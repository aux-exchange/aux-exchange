{{.WarningForManualEdit}}
module aux::quoter_{{.N}}pool {
{{$lastIndex := .LastIndex}}{{$typeList := .CoinTypeList}}    use aux::math_{{.N}}pool as pool_math;
    use aux::uint256;

    /*********************/
    /* Error Codes       */
    /*********************/

    const E_POOL_ALREADY_EXISTS: u64 = 1;
    const E_UNAUTHORIZED: u64 = 2;
    const E_AMP_ZERO: u64 = 3;
    const E_BALANCED_RESERVE_DECREASING: u64 = 4;
    const E_LP_AMOUNT_OVERFLOW: u64 = 5;
    const E_LP_AMOUNT_INCREASE_UNDERFLOW: u64 = 6;
    const E_LP_TO_MINT_OVERFLOW: u64 = 7;
    const E_LP_AMOUNT_INSUFFICIENT: u64 = 8;
    const E_WITHDRAW_AMOUNT_ALL_ZERO: u64 = 9;
    const E_WITHDRAW_BALANCED_RESERVE_UNDERFLOW: u64 = 10;
    const E_LP_BURNT_OVERFLOW: u64 = 10;
    const E_COIN_DECIMAL_TOO_LARGE: u64 = 11;
    const E_LP_TO_BURN_IS_ZERO: u64 = 12;
    const E_INVALID_OUT_COIN_INDEX: u64 = 13;
    const E_OUTPUT_COIN_UNDERFLOW: u64 = 14;
    const E_OUTPUT_COIN_INSUFFICIENT: u64 = 15;
    const E_INVALID_IN_COIN_INDEX: u64 = 16;
    const E_INPUT_COIN_UNDERFLOW: u64 = 17;
    const E_INPUT_COIN_INSUFFICIENT: u64 = 18;
    const E_AMP_TOO_LARGE: u64 = 19;

    /// Number of Coins
    const N_COINS: u128 = {{.N}};
    const N_COINS_U8: u8 = {{.N}};

    /// Fee Denominator
    const FEE_DENOMINATOR: u128 = {{.FeeDenominator}};
    /// Min fee
    const MIN_FEE_NUMERATOR: u128 = {{.MinFeeNumerator}};
    /// Max fee
    const MAX_FEE_NUMERATOR: u128 = {{.MaxFeeNumerator}};

    /// Balanced Reserve is stored with 18 decimals,
    /// while lp tokens only have 8 decimals.
    const BALANCED_RESERVED_TO_LP_SCALER: u128 = {{.BalanceScaler}};

    /// Max U64, used to check if a u128 can be safely cast into u64
    const MAX_U64: u128 = {{.MaxU64}};

    /// Lp token decimals is constant 8
    const LP_TOKEN_DECIMALS: u8 = 8;

    /// max coin decimal allowed is 8
    const MAX_COIN_DECIMAL_ALLOWED: u8 = {{.MaxDecimal}};

    /// max amp
    const MAX_AMP: u128 = {{.MaxAmp}};

    /// Quoter
    struct Quoter has copy, drop, store {
{{range .Xis}}        /// reserve of the coin {{.I}}
        reserve_{{.I}}: u64,
        /// fee for coin {{.I}}
        fee_{{.I}}: u64,
        /// scaler_{{.I}} is used to convert the coin value to 18 decimals.
        scaler_{{.I}}: u128,
{{end}}
        /// balanced reserve, or D.
        /// If the pool is in equilibrium (all coins have the save reserve),
        /// the sum of the all coins will have this value.
        balanced_reserve: u128,
        /// amp
        amp: u128,

        /// fee numertor.
        /// the denominator is the consant FEE_DENOMINATOR
        fee_numerator: u128,

        /// LP
        lp_supply: u128
    }

    /// create a new {{.N}}pool.
    public fun new_quoter(
        fee_numerator: u128,
        amp: u128,
        balanced_reserve: u128,
        {{range .Xis}}reserve_{{.I}}: u64,
        fee_{{.I}}: u64,
        scaler_{{.I}}: u128,
        {{end}}lp_supply: u128,
    ): Quoter {
        Quoter{
            fee_numerator,
            lp_supply,
            balanced_reserve,
            amp,
{{range .Xis}}            reserve_{{.I}},
            fee_{{.I}},
            scaler_{{.I}},
{{end}}        }
    }

    /// Move fee into reserve.
    /// This will be automatically called when adding/removing liquidity from the pool.
    public fun move_fee_into_reserve(pool: &mut Quoter)
    {
        // no op if there is no fee to move
        let fee_added = false;
{{range .Xis}}
        let fee_moved_{{.I}} = pool.fee_{{.I}};
        // only merge if there is fee to move
        if (fee_moved_{{.I}}> 0) {
            fee_added = true;
            pool.fee_{{.I}} = 0;
        };
{{end}}
        if (!fee_added) {
            return
        };
    }

    /// Add liquidity to the protocol.
    /// There is no fee to add liquidity.
    public fun add_liquidity(
        pool: &mut Quoter,
        {{range .Xis}}amount_{{.I}}: u64,
        {{end}}min_lp_amount: u64,
    ): u64
    {
        move_fee_into_reserve(pool);
{{range .Xis}}
        // move the coins into reserve
        pool.reserve_{{.I}} = pool.reserve_{{.I}} + amount_{{.I}};
{{end}}
        // update balanced reserve and lp token supply
        let before_balanced_reserve = pool.balanced_reserve;
        let before_lp_tokens_supply = pool.lp_supply;

        update_balanced_reserve(pool);

        let after_balanced_reserve = pool.balanced_reserve;

        assert!(
            before_balanced_reserve <= after_balanced_reserve,
            E_BALANCED_RESERVE_DECREASING,
        );

        // if lp token supply is 0, this is an empty pool.
        let after_lp_tokens_supply = if (before_lp_tokens_supply == 0) {
            after_balanced_reserve / BALANCED_RESERVED_TO_LP_SCALER
        } else {
            let new_lp_amount = uint256::divide_underlying(
                uint256::underlying_mul_to_uint256(
                    after_balanced_reserve,
                    before_lp_tokens_supply,
                ),
                before_balanced_reserve,
            );
            assert!(
                !uint256::underlying_overflow(new_lp_amount),
                E_LP_AMOUNT_OVERFLOW,
            );

            uint256::downcast(new_lp_amount)
        };

        assert!(
            after_lp_tokens_supply > before_lp_tokens_supply,
            E_LP_AMOUNT_INCREASE_UNDERFLOW,
        );

        let lp_to_mint = after_lp_tokens_supply - before_lp_tokens_supply;

        assert!(
            lp_to_mint <= MAX_U64,
            E_LP_TO_MINT_OVERFLOW,
        );

        let lp_to_mint = (lp_to_mint as u64);

        assert!(
            lp_to_mint >= min_lp_amount,
            E_LP_AMOUNT_INSUFFICIENT,
        );

        pool.lp_supply = after_lp_tokens_supply;

        lp_to_mint
    }

    /// Remove coins from the pool and burn some lp tokens.
    /// There will be a fee charged on each withdrawal. If the withdrawal amount is 0, fee is 0,
    /// otherwise the fee will be the same as swap, with a 1 minimal.
    /// Fee is charged on the output amount.
    /// For example, if 10000 is requested, and fee is 1bps, the pool will dispense 10001
    /// coins from the reserve, and deposite 1 into the fee.
    public fun remove_liquidity_for_coin(
        pool: &mut Quoter,
        {{range .Xis}}amount_{{.I}}_to_withdraw: u64,
        {{end}}lp: u64,
    ): ({{range .Xis}}u64, {{end}}u64)
    {
        assert!(
            {{range .Xis}}amount_{{.I}}_to_withdraw > 0{{if .NotLast}} || {{end}}{{end}},
            E_WITHDRAW_AMOUNT_ALL_ZERO,
        );

        move_fee_into_reserve(pool);

        let before_balanced_reserve = pool.balanced_reserve;
{{range .Xis}}
        // calculate the fee
        let coin_{{.I}} = if (amount_{{.I}}_to_withdraw > 0) {
            let fee = ((amount_{{.I}}_to_withdraw as u128) * pool.fee_numerator) / FEE_DENOMINATOR;
            if (fee * FEE_DENOMINATOR < (amount_{{.I}}_to_withdraw as u128) * pool.fee_numerator) {
                fee = fee + 1;
            };
            let fee = (fee as u64);

            pool.reserve_{{.I}} = pool.reserve_{{.I}} - fee;
            pool.fee_{{.I}} = pool.fee_{{.I}} + fee;
            pool.reserve_{{.I}} = pool.reserve_{{.I}} - amount_{{.I}}_to_withdraw;

            amount_{{.I}}_to_withdraw
        } else {
            0
        };
{{end}}
        let before_lp_tokens_supply = pool.lp_supply;

        update_balanced_reserve(pool);

        let after_balanced_reserve = pool.balanced_reserve;
        assert!(
            before_balanced_reserve > after_balanced_reserve,
            E_WITHDRAW_BALANCED_RESERVE_UNDERFLOW
        );

        let after_lp_tokens_supply = uint256::downcast(
            uint256::divide_underlying(
                uint256::underlying_mul_to_uint256(
                    after_balanced_reserve,
                    before_lp_tokens_supply,
                ),
                before_balanced_reserve,
            ),
        );

        if (after_lp_tokens_supply == before_lp_tokens_supply) {
            after_lp_tokens_supply = before_lp_tokens_supply - 1;
        };

        let lp_burnt = (before_lp_tokens_supply - after_lp_tokens_supply);
        assert!(
            lp_burnt <= MAX_U64,
            E_LP_BURNT_OVERFLOW,
        );

        pool.lp_supply = pool.lp_supply - lp_burnt;

        let lp_burnt = (lp_burnt as u64);

        lp = lp - lp_burnt;

        ({{range .Xis}}coin_{{.I}}, {{end}}lp)
    }

    /// Remove liquidity from the pool by burning lp tokens.
    /// The coins returned will follow the current ratio of the pool.
    /// There is no fee.
    public fun remove_liquidity(
        pool: &mut Quoter,
        lp: u64,
    ): ({{range .Xis}}u64{{if .NotLast}}, {{end}}{{end}})
    {
        let lp_burnt = lp;
        assert!(
            lp_burnt > 0,
            E_LP_TO_BURN_IS_ZERO,
        );

        move_fee_into_reserve(pool);

        let before_lp_tokens_supply = pool.lp_supply;
{{range .Xis}}
        // remove liquidity for coin {{.I}}
        let before_reserve_{{.I}} = pool.reserve_{{.I}};

        let withdraw_{{.I}} = (
            ((before_reserve_{{.I}} as u128) * (lp_burnt as u128))
            / before_lp_tokens_supply
             as u64);
        pool.reserve_{{.I}} = pool.reserve_{{.I}} - withdraw_{{.I}};
        let coin_{{.I}} = withdraw_{{.I}};
{{end}}
        // recalculate d
        update_balanced_reserve(pool);

        pool.lp_supply = pool.lp_supply - (lp_burnt as u128);

        ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}})
    }

    /// swap coins, where output amount is decided by the input amount.
    /// for input coins, the full amount stored in the coin will be transferred to the pool.
    /// for the output coin, the amount swapped for will be added (so the output coin can contain non-zero value).
    /// output coin is identified by the index.
    public fun swap_exact_coin_for_coin(
        pool: &mut Quoter,
        {{range .Xis}}coin_{{.I}}: u64,
        {{end}}out_coin_index: u8,
        min_quantity_out: u64,
    ): ({{range .Xis}}u64{{if .NotLast}}, {{end}}{{end}})
    {
        assert!(out_coin_index < N_COINS_U8, E_INVALID_OUT_COIN_INDEX);

        let amp = pool.amp;
        let before_balanced_reserve = pool.balanced_reserve;
{{range .Xis}}
        // calculate the amount in for coin {{.I}}
        let before_reserve_{{.I}} = pool.reserve_{{.I}};

        let is_coin_{{.I}}_out = out_coin_index == {{.I}};

        if (out_coin_index != {{.I}}) {
            pool.reserve_{{.I}} = pool.reserve_{{.I}} + coin_{{.I}};
        };

        let after_reserve_{{.I}} = pool.reserve_{{.I}};
        let after_reserve_{{.I}}_scaled = (after_reserve_{{.I}} as u128) * pool.scaler_{{.I}};
{{end}}
        // calculate the scaled output coin value
        let new_x = pool_math::calculate_x_non_decreasing_d(
{{range .Xis}}            after_reserve_{{.I}}_scaled,
{{end}}            out_coin_index,
            amp,
            before_balanced_reserve,
        );
{{range .Xis}}
        // if coin {{.I}} is the output, update it.
        if (is_coin_{{.I}}_out) {
            after_reserve_{{.I}} = ((new_x / pool.scaler_{{.I}}) as u64);
            // make sure reserve after swap is not truncated.
            if (new_x % pool.scaler_{{.I}} > 0) {
                after_reserve_{{.I}} = after_reserve_{{.I}} + 1;
            };
            assert!(before_reserve_{{.I}} > after_reserve_{{.I}}, E_OUTPUT_COIN_UNDERFLOW);

            // the value the pool will dispense
            let diff = before_reserve_{{.I}} - after_reserve_{{.I}};

            // fee is charged on the amount the user receives.
            let fee_amount = ((diff as u128) * pool.fee_numerator)/(FEE_DENOMINATOR + pool.fee_numerator);
            if (fee_amount * (FEE_DENOMINATOR + pool.fee_numerator) < (diff as u128) * pool.fee_numerator) {
                fee_amount = fee_amount + 1;
            };
            let fee_{{.I}} = (fee_amount as u64);
            // amount the user will receive
            let amount_{{.I}}_out = diff - fee_{{.I}};

            assert!(amount_{{.I}}_out > 0, E_OUTPUT_COIN_UNDERFLOW);
            assert!(amount_{{.I}}_out >= min_quantity_out, E_OUTPUT_COIN_INSUFFICIENT);

            coin_{{.I}} = coin_{{.I}} + amount_{{.I}}_out;
            pool.reserve_{{.I}} = pool.reserve_{{.I}} - amount_{{.I}}_out;
            pool.fee_{{.I}} = pool.fee_{{.I}} + fee_{{.I}};
            pool.reserve_{{.I}} = pool.reserve_{{.I}} - fee_{{.I}};
        };
{{end}}
        update_balanced_reserve(pool);
        let after_balanced_reserve = pool.balanced_reserve;
        assert!(after_balanced_reserve >= before_balanced_reserve, E_BALANCED_RESERVE_DECREASING);

        ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}})
    }

    /// swap coins, where input amount is decided by the requested output amount.
    /// for the output coins, the amount swapped for will be added (so the output coin can contain non-zero value).
    /// for the input coin, the amount necessary is deducted.
    /// input coin is identified by the index.
    public fun swap_coin_for_exact_coin(
        pool: &mut Quoter,
        {{range .Xis}}requested_quantity_{{.I}}: u64,
        {{end}}in_coin_index: u8,
        max_in_coin_amount: u64,
    ): ({{range .Xis}}u64{{if .NotLast}}, {{end}}{{end}})
    {
        assert!(in_coin_index < N_COINS_U8, E_INVALID_IN_COIN_INDEX);

        let amp = pool.amp;
        let before_balanced_reserve = pool.balanced_reserve;
{{range .Xis}}
        // process coin {{.I}}
        let before_reserve_{{.I}} = pool.reserve_{{.I}};

        let coin_{{.I}} = if (in_coin_index == {{.I}}) {
            max_in_coin_amount
        } else if (requested_quantity_{{.I}} > 0) {
            // calculate fee.
            // fee is based on the amount user receives.
            let fee = (pool.fee_numerator * (requested_quantity_{{.I}} as u128))/FEE_DENOMINATOR;
            if (fee * FEE_DENOMINATOR < pool.fee_numerator * (requested_quantity_{{.I}} as u128)) {
                fee = fee + 1;
            };
            let fee = (fee as u64);
            pool.fee_{{.I}} = pool.fee_{{.I}} + fee;
            pool.reserve_{{.I}} = pool.reserve_{{.I}} - fee;
            pool.reserve_{{.I}} = pool.reserve_{{.I}} - requested_quantity_{{.I}};
            requested_quantity_{{.I}}
        } else {
            0
        };

        let after_reserve_{{.I}} = pool.reserve_{{.I}};
        let after_reserve_{{.I}}_scaled = (after_reserve_{{.I}} as u128) * pool.scaler_{{.I}};
{{end}}

        // get the new reserve for the input coin
        let new_x = pool_math::calculate_x_non_decreasing_d(
{{range .Xis}}            after_reserve_{{.I}}_scaled,
{{end}}            in_coin_index,
            amp,
            before_balanced_reserve,
        );
{{range .Xis}}
        if (in_coin_index == {{.I}}) {
            after_reserve_{{.I}} = ((new_x / pool.scaler_{{.I}}) as u64);
            // make sure new reserve is not round down
            if (new_x % pool.scaler_{{.I}} > 0) {
                after_reserve_{{.I}} = after_reserve_{{.I}} + 1;
            };
            assert!(after_reserve_{{.I}} > before_reserve_{{.I}}, E_INPUT_COIN_UNDERFLOW);
            let amount_{{.I}}_in = after_reserve_{{.I}} - before_reserve_{{.I}};
            assert!(amount_{{.I}}_in <= coin_{{.I}}, E_INPUT_COIN_INSUFFICIENT);
            coin_{{.I}} = coin_{{.I}} - amount_{{.I}}_in;
            pool.reserve_{{.I}} = pool.reserve_{{.I}} + amount_{{.I}}_in;
        };
{{end}}
        update_balanced_reserve(pool);

        let after_balanced_reserve = pool.balanced_reserve;
        assert!(after_balanced_reserve >= before_balanced_reserve, E_BALANCED_RESERVE_DECREASING);

        ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}})
    }

    public fun calculate_required_lp_for_coin(
        pool: &Quoter,
    {{range .Xis}}    amount_{{.I}}_to_withdraw: u64,
    {{end}}): u64
    {
        let lp = (MAX_U64 as u64);
        let pool = *pool;
        let ({{range .Xis}}_, {{end}}leftover_lp) = remove_liquidity_for_coin(
            &mut pool,
            {{range .Xis}}amount_{{.I}}_to_withdraw,
            {{end}}lp
        );

        lp - leftover_lp
    }

    public fun update_balanced_reserve(
        pool: &mut Quoter,
    ) {
{{range .Xis}}
        let scaler_{{.I}} = pool.scaler_{{.I}};
        let reserve_{{.I}}_unscaled = pool.reserve_{{.I}};
        let reserve_{{.I}} = (reserve_{{.I}}_unscaled as u128) * scaler_{{.I}};
{{end}}
        pool.balanced_reserve = pool_math::calculate_d(
            {{range .Xis}}reserve_{{.I}},
            {{end}}pool.amp
        );
    }

    public fun get_fee_numerator(pool: &Quoter): u128 {
        pool.fee_numerator
    }

    public fun get_balanced_reserve(pool: &Quoter): u128 {
        pool.balanced_reserve
    }

    public fun get_amp(pool: &Quoter): u128 {
        pool.amp
    }

    public fun get_lp_supply(pool: &Quoter): u128 {
        pool.lp_supply
    }
{{range .Xis}}
    public fun get_reserve_{{.I}}(pool: &Quoter): u64 {
        pool.reserve_{{.I}}
    }

    public fun get_fee_{{.I}}(pool: &Quoter): u64 {
        pool.fee_{{.I}}
    }

    public fun get_scaler_{{.I}}(pool: &Quoter): u128 {
        pool.scaler_{{.I}}
    }
{{end}}}
