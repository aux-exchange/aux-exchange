{{$structParamName := .StructParamName}}{{$quoter := .IsQuoter}}{{$nq := false}}{{$lastIndex := .LastIndex}}{{$typeList := .CoinTypeList}}{{$structName := "Pool"}}{{$coinModule := "coin"}}{{$rewardDistributorName := "RewardDistributor"}}{{$redeemTokenName := "RedeemToken"}}{{$timestampNow := "timestamp::now_microseconds()"}}{{$rewardDistributorModule := "reward_distributor"}}{{$coinName := "Coin"}}{{.WarningForManualEdit}}
module aux::{{.ModuleName}} {
{{if not $quoter}}{{$nq = true}}    use std::option;
    use std::signer;
    use std::string::{Self, String};

    use aptos_std::event::{Self, EventHandle};
    use aptos_framework::coin::{Self, Coin};
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aux::authority;

    use aux::reward_distributor::{Self, RewardDistributor, RedeemToken};
{{else}}{{$coinModule = "quote_coin"}}{{$structName = "Quoter"}}{{$rewardDistributorName = "RewardDistributionQuoter"}}{{$redeemTokenName = "QuoterRedeemToken"}}{{$timestampNow = "0"}}{{$rewardDistributorModule = "reward_quoter"}}{{$coinName = "u64"}}    use aux::quote_coin;
    use aux::reward_quoter::{Self, RewardDistributionQuoter, QuoterRedeemToken};
{{end}}
    use aux::math_{{.N}}pool as pool_math;
{{if .UseQuoter}}    use aux::quoter_{{.N}}pool::{Self, Quoter};
{{end}}
    /*********************/
    /* Error Codes       */
    /*********************/

    const E_POOL_ALREADY_EXISTS: u64 = 1;
    const E_UNAUTHORIZED: u64 = 2;
    const E_AMP_ZERO: u64 = 3;
    const E_BALANCED_RESERVE_DECREASING: u64 = 4;
    const E_LP_AMOUNT_OVERFLOW: u64 = 5;
    const E_LP_AMOUNT_INCREASE_UNDERFLOW: u64 = 6;
    const E_LP_TO_MINT_OVERFLOW: u64 = 7;
    const E_LP_AMOUNT_INSUFFICIENT: u64 = 8;
    const E_WITHDRAW_AMOUNT_ALL_ZERO: u64 = 9;
    const E_WITHDRAW_BALANCED_RESERVE_UNDERFLOW: u64 = 10;
    const E_LP_BURNT_OVERFLOW: u64 = 10;
    const E_COIN_DECIMAL_TOO_LARGE: u64 = 11;
    const E_LP_TO_BURN_IS_ZERO: u64 = 12;
    const E_INVALID_OUT_COIN_INDEX: u64 = 13;
    const E_OUTPUT_COIN_UNDERFLOW: u64 = 14;
    const E_OUTPUT_COIN_INSUFFICIENT: u64 = 15;
    const E_INVALID_IN_COIN_INDEX: u64 = 16;
    const E_INPUT_COIN_UNDERFLOW: u64 = 17;
    const E_INPUT_COIN_INSUFFICIENT: u64 = 18;
    const E_AMP_TOO_LARGE: u64 = 19;
    const E_REWARD_TOKEN_AMOUNT_MISMATCH: u64 = 20;

    /// Number of Coins
    const N_COINS: u128 = {{.N}};
    const N_COINS_U8: u8 = {{.N}};

    /// Fee Denominator
    const FEE_DENOMINATOR: u128 = {{.FeeDenominator}};
    /// Min fee
    const MIN_FEE_NUMERATOR: u128 = {{.MinFeeNumerator}};
    /// Max fee
    const MAX_FEE_NUMERATOR: u128 = {{.MaxFeeNumerator}};

    /// Balanced Reserve is stored with 18 decimals,
    /// while lp tokens only have 8 decimals.
    const BALANCED_RESERVED_TO_LP_SCALER: u128 = {{.BalanceScaler}};

    /// Max U64, used to check if a u128 can be safely cast into u64
    const MAX_U64: u128 = {{.MaxU64}};
    const MAX_U128: u256 = (1 << 128) - 1;

    /// Lp token decimals is constant 8
    const LP_TOKEN_DECIMALS: u8 = 8;

    /// max coin decimal allowed is 8
    const MAX_COIN_DECIMAL_ALLOWED: u8 = {{.MaxDecimal}};

    /// max amp
    const MAX_AMP: u128 = {{.MaxAmp}};
{{if $nq}}
    /// LP Token for the pool
    struct LP<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> {}

    struct LPRedeemTokenStore<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has key {
    {{range .Xis}}    reward_token_{{.I}}: {{$redeemTokenName}}{{if $nq}}<Coin{{.I}}, LP{{$typeList}}>{{end}},
    {{end}}}
{{end}}

    /// LP Bundle combines LP Coins, and the RedeemTokens for the fees.
    /// The number of lp coins, and the number of RedeemTokens are equal, and they must be created or burned together.
    struct LPBundle{{if $nq}}<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}>{{end}} has store{{if .IsQuoter}}, copy, drop{{end}} {
        /// Lps for the pool.
        lps: {{$coinName}}{{if $nq}}<LP{{$typeList}}>{{end}},
    {{range .Xis}}    reward_token_{{.I}}: {{$redeemTokenName}}{{if $nq}}<Coin{{.I}}, LP{{$typeList}}>{{end}},
    {{end}}}

    /// {{$structName}} is the struct that holds the coins, fee distributor, and information about the pool.
    /// Swap fees are moved into reward_distributor, and lps can redeem those with the redeem tokens.
    struct {{$structName}}{{if $nq}}<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}>{{end}} has {{if $quoter}}store, copy, drop{{else}}key{{end}} {
{{range .Xis}}        /// reserve of the coin {{.I}}
        reserve_{{.I}}: {{.CoinName}},
        /// fee for coin {{.I}}
        fee_{{.I}}: {{.CoinName}},
        /// scaler_{{.I}} is used to convert the coin value to 18 decimals.
        scaler_{{.I}}: u128,
        /// reward distributor for the fees in {{.I}}
        reward_distributor_{{.I}}: {{$rewardDistributorName}}{{if $nq}}<Coin{{.I}}, LP{{$typeList}}>{{end}},
{{end}}
{{if $nq}}        /// mint capability of the lp tokens.
        lp_mint: {{$coinModule}}::MintCapability<LP{{$typeList}}>,
        /// burn capability of the lp tokens.
        lp_burn: {{$coinModule}}::BurnCapability<LP{{$typeList}}>,
{{else}}        // in place of of mint/burn
        lp_treasury: {{$coinModule}}::CoinTreasury,
{{end}}
        /// balanced reserve, or D.
        /// If the pool is in equilibrium (all coins have the save reserve),
        /// the sum of the all coins will have this value.
        balanced_reserve: u128,
        /// amp
        amp: u128,

        /// fee numertor.
        /// the denominator is the consant FEE_DENOMINATOR
        fee_numerator: u128,
    }
{{if $nq}}
    /// SwapEvent is emitted when a swap happens.
    struct SwapEvent<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has store, drop {
        sender: address,
        timestamp_microseconds: u64,

{{range .Xis}}
        before_reserve_{{.I}}: u64,
        after_reserve_{{.I}}: u64,
        fee_{{.I}}: u64,
        is_coin_{{.I}}_out: bool,
        amount_{{.I}}_in: u64,
        amount_{{.I}}_out: u64,
{{end}}
        before_balanced_reserve: u128,
        after_balanced_reserve: u128,
        amp: u128,
    }

    struct SwapEventHolder<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has key {
        swap_events: EventHandle<SwapEvent{{$typeList}}>,
    }

    /// AddLiquidityEvent is emitted when adding liquidity.
    struct AddLiquidityEvent<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has store, drop {
        sender: address,
        timestamp_microseconds: u64,

{{range .Xis}}        before_reserve_{{.I}}: u64,
        after_reserve_{{.I}}: u64,
        current_acc_reward_per_share_{{.I}}: u128,
{{end}}

        before_balanced_reserve: u128,
        after_balanced_reserve: u128,

        amp: u128,

        before_lp_coins_supply: u128,
        after_lp_coins_supply: u128,
    }

    struct AddLiquidityEventHolder<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has key {
        add_liquidity_events: EventHandle<AddLiquidityEvent{{$typeList}}>,
    }

    /// RemoveLiquidityEvent is emitted when the LPs unstake from the pool
    struct RemoveLiquidityEvent<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has store, drop {
        sender: address,
        timestamp_microseconds: u64,

{{range .Xis}}        before_reserve_{{.I}}: u64,
        after_reserve_{{.I}}: u64,
        fee_{{.I}}: u64,
        withdraw_{{.I}}: u64,
        reward_{{.I}}: u64,
{{end}}

        before_balanced_reserve: u128,
        after_balanced_reserve: u128,

        amp: u128,

        before_lp_coins_supply: u128,
        after_lp_coins_supply: u128,
        lp_burnt: u64,
    }

    struct RemoveLiquidityEventHolder<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has key {
        remove_liquidity_events: EventHandle<RemoveLiquidityEvent{{$typeList}}>,
    }

    /// FeeMoveEvent is emitted when fees are moved from the pool into reward distributor.
    struct FeeMoveEvent<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has store, drop {
        timestamp_microseconds: u64,
{{range .Xis}}        reserve_{{.I}}: u64,
        fee_moved_{{.I}}: u64,
        before_acc_reward_per_share_{{.I}}: u128,
        after_acc_reward_per_share_{{.I}}: u128,
{{end}}        balanced_reserve: u128,
        amp: u128,
    }

    struct FeeMoveEventHolder<{{range .Xis}}phantom Coin{{.I}}{{if .NotLast}}, {{end}}{{end}}> has key {
        fee_move_events: EventHandle<FeeMoveEvent{{$typeList}}>,
    }
{{end}}
    /**************************/
    /* Public Function        */
    /**************************/
{{if $nq}}
    /// Create a new {{.N}}pool.
    public entry fun create_pool{{$typeList}}(sender: &signer, fee_numerator: u128, amp: u128) {
        assert!(
            amp > 0,
            E_AMP_ZERO,
        );

        assert!(
            amp <= MAX_AMP,
            E_AMP_TOO_LARGE,
        );

        // check if any of the permutation already initialized.
{{range .AllPerms}}        assert!(
            !exists<Pool<{{range $index, $element := .}}Coin{{$element.I}}{{if lt $index $lastIndex}}, {{end}}{{end}}>>(@aux),
            E_POOL_ALREADY_EXISTS,
        );
{{end}}

        if (fee_numerator > MAX_FEE_NUMERATOR || fee_numerator < MIN_FEE_NUMERATOR) {
            assert!(
                signer::address_of(sender) == @aux || authority::is_signer_owner(sender),
                E_UNAUTHORIZED,
            );
        };
        let amm_signer = &authority::get_signer_self();
{{range .Xis}}
        // related to coin {{.I}}
        // register coin {{.I}} for aux
        if (!coin::is_account_registered<Coin{{.I}}>(@aux)) {
            coin::register<Coin{{.I}}>(amm_signer);
        };
        let reward_distributor_{{.I}} = reward_distributor::create_reward_distributor<Coin{{.I}}, LP{{$typeList}}>(amm_signer, 0);
        // related to coin {{.I}}
        let reserve_{{.I}} = {{$coinModule}}::zero{{if $nq}}<Coin{{.I}}>{{end}}();
        let fee_{{.I}} = {{$coinModule}}::zero{{if $nq}}<Coin{{.I}}>{{end}}();
        let scaler_{{.I}} = pool_math::get_scaler({{$coinModule}}::decimals<Coin{{.I}}>());
{{end}}
        let (lp_burn, lp_freeze, lp_mint) = coin::initialize<LP{{$typeList}}>(
            amm_signer,
            lp_name{{$typeList}}(),
            lp_symbol{{$typeList}}(),
            LP_TOKEN_DECIMALS,
            true // monitor_supply
        );
        coin::destroy_freeze_cap(lp_freeze);

        coin::register<LP{{$typeList}}>(amm_signer);

        // create the pool
        move_to(amm_signer, {{$structParamName}}{
            fee_numerator,
            lp_mint,
            lp_burn,
            balanced_reserve: 0,
            amp,
{{range .Xis}}            reserve_{{.I}},
            fee_{{.I}},
            scaler_{{.I}},
            reward_distributor_{{.I}},
{{end}}        });

        move_to(amm_signer,
            SwapEventHolder{{$typeList}} {
                swap_events: account::new_event_handle<SwapEvent{{$typeList}}>(amm_signer),
            }
        );
        move_to(amm_signer,
            AddLiquidityEventHolder{{$typeList}} {
                add_liquidity_events: account::new_event_handle<AddLiquidityEvent{{$typeList}}>(amm_signer),
            }
        );
        move_to(amm_signer,
            RemoveLiquidityEventHolder{{$typeList}} {
                remove_liquidity_events: account::new_event_handle<RemoveLiquidityEvent{{$typeList}}>(amm_signer),
            }
        );
        move_to(amm_signer,
            FeeMoveEventHolder{{$typeList}} {
                fee_move_events: account::new_event_handle<FeeMoveEvent{{$typeList}}>(amm_signer),
            }
        );
    }

    /// Get the quoter from the the pool's state.
    public fun get_quoter{{$typeList}}(): Quoter acquires {{$structName}} {
        let pool = borrow_global<{{$structParamName}}>(@aux);
        let lp_supply = std::option::destroy_some({{$coinModule}}::supply<LP{{$typeList}}>());

        quoter_{{.N}}pool::new_quoter(
            pool.fee_numerator,
            pool.amp,
            pool.balanced_reserve,
            {{range .Xis}}coin::value(&pool.reserve_{{.I}}),
            coin::value(&pool.fee_{{.I}}),
            pool.scaler_{{.I}},
            reward_distributor::get_quoter(&pool.reward_distributor_{{.I}}),
            {{end}}lp_supply,
        )
    }
{{else}}
    /// Create a new Quoter.
    public fun new_quoter(
        fee_numerator: u128,
        amp: u128,
        balanced_reserve: u128,
{{range .Xis}}        reserve_{{.I}}: u64,
        fee_{{.I}}: u64,
        scaler_{{.I}}: u128,
        reward_distributor_{{.I}}: RewardDistributionQuoter,
{{end}}        lp_supply: u128,
    ): Quoter {
        Quoter {
            fee_numerator,
            amp,
            balanced_reserve,
{{range .Xis}}            reserve_{{.I}}: quote_coin::new(reserve_{{.I}}),
            fee_{{.I}}: quote_coin::new(fee_{{.I}}),
            scaler_{{.I}},
            reward_distributor_{{.I}},
{{end}}            lp_treasury: quote_coin::new_coin_treasury(lp_supply),
        }
    }
{{end}}

    /// Update the A parameter of the stable curve.
    public{{if $nq}} entry{{end}} fun update_amp{{$typeList}}({{if $nq}}sender: &signer{{else}}pool: &mut {{$structParamName}}{{end}}, amp: u128) {{if $nq}}acquires Pool {{end}}{
        assert!(
            amp > 0,
            E_AMP_ZERO,
        );

        assert!(
            amp <= MAX_AMP,
            E_AMP_TOO_LARGE,
        );
{{if $nq}}        let pool = borrow_global_mut<{{$structParamName}}>(@aux);
        assert!(
            signer::address_of(sender) == @aux || authority::is_signer_owner(sender),
            E_UNAUTHORIZED,
        );
{{end}}        pool.amp = amp;
        // update balanced reserve
        update_balanced_reserve(pool);
    }

    /// Update fee for the pool.
    public{{if $nq}} entry{{end}} fun update_fee{{$typeList}}({{if $nq}}sender: &signer{{else}}pool: &mut {{$structParamName}}{{end}}, fee_numerator: u128) {{if $nq}}acquires Pool {{end}}{
{{if $nq}}        let pool = borrow_global_mut<{{$structParamName}}>(@aux);
        assert!(
            signer::address_of(sender) == @aux || authority::is_signer_owner(sender),
            E_UNAUTHORIZED,
        );
{{end}}        pool.fee_numerator = fee_numerator;
    }

    /// Move fee into reward distributor.
    /// This will be automatically called when adding/removing liquidity from the pool.
    public fun move_fee_into_reward_distributor{{$typeList}}({{if .IsQuoter}}pool: &mut {{$structParamName}}{{end}}){{if $nq}} acquires Pool, FeeMoveEventHolder{{end}}
    {
{{if $nq}}        let pool = borrow_global_mut<{{$structParamName}}>(@aux);
        let fee_move_event_holder = borrow_global_mut<FeeMoveEventHolder{{$typeList}}>(@aux);
{{end}}
        // no op if there is no fee to move
        let fee_added = false;
{{range .Xis}}
{{if $nq}}        let reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});

{{end}}        let fee_moved_{{.I}} = {{$coinModule}}::value(&pool.fee_{{.I}});
{{if $nq}}        let before_acc_reward_per_share_{{.I}} = {{$rewardDistributorModule}}::acc_reward_per_share(&pool.reward_distributor_{{.I}});
        let after_acc_reward_per_share_{{.I}} = before_acc_reward_per_share_{{.I}};
{{end}}        // only merge if there is fee to move
        if (fee_moved_{{.I}}> 0) {
            fee_added = true;
            {{$rewardDistributorModule}}::add_reward(&mut pool.reward_distributor_{{.I}}, {{$coinModule}}::extract_all(&mut pool.fee_{{.I}}));
{{if $nq}}            after_acc_reward_per_share_{{.I}} = {{$rewardDistributorModule}}::acc_reward_per_share(&pool.reward_distributor_{{.I}});
{{end}}        };
{{end}}
        if (!fee_added) {
            return
        };
{{if $nq}}
        let balanced_reserve = pool.balanced_reserve;

        // emit event
        let amp = pool.amp;
        event::emit_event<FeeMoveEvent{{$typeList}}>(
            &mut fee_move_event_holder.fee_move_events,
            FeeMoveEvent{{$typeList}}{
                timestamp_microseconds: {{$timestampNow}},
                {{range .Xis}}reserve_{{.I}},
                fee_moved_{{.I}},
                before_acc_reward_per_share_{{.I}},
                after_acc_reward_per_share_{{.I}},
                {{end}}balanced_reserve,
                amp,
            },
        );
{{end}}    }

    /// Add liquidity to the protocol.
    /// Unlike constant product amm, arbitrary amount of coins are allowed here.
    /// Note, however, imbalanced coins will result in less lp coins than balanced coins.
    /// There is no fee to add liquidity.{{if not $nq}} This will not underflow, so the output lp coins value may be 0.{{end}}
    public fun add_liquidity{{$typeList}}(
{{if $nq}}        sender: address{{else}}pool: &mut {{$structParamName}}{{end}},
        {{range .Xis}}amount_{{.I}}: {{.CoinName}},
        {{end}}min_lp_amount: u64
    ): LPBundle{{$typeList}}{{if $nq}} acquires Pool, FeeMoveEventHolder, AddLiquidityEventHolder{{end}}
    {
        move_fee_into_reward_distributor{{$typeList}}({{if not $nq}}pool{{end}});
{{if $nq}}        let pool = borrow_global_mut<Pool{{$typeList}}>(@aux);
        let add_liquidity_events = borrow_global_mut<AddLiquidityEventHolder{{$typeList}}>(@aux);
{{end}}
{{range .Xis}}        // move the coins into reserve
{{if $nq}}        let before_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});
{{end}}
        {{$coinModule}}::merge(&mut pool.reserve_{{.I}}, amount_{{.I}});
{{if $nq}}        let after_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});
{{end}}{{end}}
        // update balanced reserve and lp token supply
        let before_balanced_reserve = pool.balanced_reserve;
        let before_lp_coins_supply = {{if $nq}}option::destroy_some({{$coinModule}}::supply<LP{{$typeList}}>()){{else}}quote_coin::treasury_supply(&pool.lp_treasury){{end}};

        // update balanced reserve for the pool
        update_balanced_reserve(pool);

        let after_balanced_reserve = pool.balanced_reserve;
        assert!(
            before_balanced_reserve <= after_balanced_reserve,
            E_BALANCED_RESERVE_DECREASING,
        );

        // if lp token supply is 0, this is an empty pool.
        let after_lp_coins_supply = if (before_lp_coins_supply == 0) {
            after_balanced_reserve / BALANCED_RESERVED_TO_LP_SCALER
        } else {
            let new_lp_amount = ((after_balanced_reserve as u256) * (before_lp_coins_supply as u256))/(before_balanced_reserve as u256);
            assert!(
                new_lp_amount <= MAX_U128,
                E_LP_AMOUNT_OVERFLOW,
            );

            (new_lp_amount as u128)
        };

{{if $nq}}        // Need to make sure the user added enough liquidity to generate new tokens.
        assert!(
            after_lp_coins_supply > before_lp_coins_supply,
            E_LP_AMOUNT_INCREASE_UNDERFLOW,
        );
{{end}}
        // mint lp coins
        let lp_to_mint = after_lp_coins_supply - before_lp_coins_supply;

        assert!(
            lp_to_mint <= MAX_U64,
            E_LP_TO_MINT_OVERFLOW,
        );

        let lp_to_mint = (lp_to_mint as u64);

        assert!(
            lp_to_mint >= min_lp_amount,
            E_LP_AMOUNT_INSUFFICIENT,
        );

        let lps = {{$coinModule}}::mint{{if $nq}}<LP{{$typeList}}>{{end}}(
            lp_to_mint,
            &{{if $quoter}}mut pool.lp_treasury{{else}}pool.lp_mint{{end}},
        );

        // mint reward tokens
{{range .Xis}}        let reward_token_{{.I}} = {{$rewardDistributorModule}}::mint(&mut pool.reward_distributor_{{.I}}, lp_to_mint);
{{if $nq}}        let current_acc_reward_per_share_{{.I}} = {{$rewardDistributorModule}}::acc_reward_per_share(&pool.reward_distributor_{{.I}});
{{end}}{{end}}
{{if $nq}}        event::emit_event<AddLiquidityEvent{{$typeList}}>(
            &mut add_liquidity_events.add_liquidity_events,
            AddLiquidityEvent{{$typeList}} {
                sender,
                timestamp_microseconds: {{$timestampNow}},

{{range .Xis}}                before_reserve_{{.I}},
                after_reserve_{{.I}},
                current_acc_reward_per_share_{{.I}},
{{end}}
                before_balanced_reserve,
                after_balanced_reserve,

                amp: pool.amp,

                before_lp_coins_supply,
                after_lp_coins_supply,
            }
        );

{{end}}        LPBundle {
            lps,
        {{range .Xis}}    reward_token_{{.I}},
        {{end}}}
    }

    /// Remove coins from the pool and burn some lp bundles.
    /// There will be a fee charged on each withdrawal. If the withdrawal amount is 0, fee is 0,
    /// otherwise the fee will be the same as swap, with a 1 minimal.
    /// Fee is charged on the output amount.
    /// For example, if 10000 is requested, and fee is 1bps, the pool will dispense 10001
    /// coins from the reserve, and deposit 1 into the fee.
    /// Also, since fees that the lp earned will be dispensed at the same time, the actual out amount may be higher than requested amount.
    public fun remove_liquidity_for_coin{{$typeList}}(
{{if $nq}}        sender: address{{else}}pool: &mut {{$structParamName}}{{end}},
        {{range .Xis}}amount_{{.I}}_to_withdraw: u64,
        {{end}}lp_bundle: LPBundle{{$typeList}}
    ): ({{range .Xis}}{{.CoinName}}, {{end}}LPBundle{{$typeList}})
    {{if $nq}}acquires Pool, RemoveLiquidityEventHolder, FeeMoveEventHolder
    {{end}}{
        move_fee_into_reward_distributor{{$typeList}}({{if not $nq}}pool{{end}});

        assert!(
            {{range .Xis}}amount_{{.I}}_to_withdraw > 0{{if .NotLast}} || {{end}}{{end}},
            E_WITHDRAW_AMOUNT_ALL_ZERO,
        );
{{if $nq}}        let pool = borrow_global_mut<Pool{{$typeList}}>(@aux);
        let remove_liquidity_events = borrow_global_mut<RemoveLiquidityEventHolder{{$typeList}}>(@aux);
{{end}}
        let before_balanced_reserve = pool.balanced_reserve;
{{range .Xis}}
        // calculate the new reserve
{{if $nq}}        let before_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});
        let fee_{{.I}} = 0u64;
        let after_reserve_{{.I}} = before_reserve_{{.I}};
{{end}}
        let coin_{{.I}} = if (amount_{{.I}}_to_withdraw > 0) {
            // calculate the fee
            let fee = ((amount_{{.I}}_to_withdraw as u128) * pool.fee_numerator) / FEE_DENOMINATOR;
            if (fee * FEE_DENOMINATOR < (amount_{{.I}}_to_withdraw as u128) * pool.fee_numerator) {
                fee = fee + 1;
            };
            let fee = (fee as u64);

            let fee_coin_{{.I}} = {{$coinModule}}::extract(&mut pool.reserve_{{.I}}, fee);
            {{$coinModule}}::merge(&mut pool.fee_{{.I}}, fee_coin_{{.I}});
{{if $nq}}
            after_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});
            fee_{{.I}} = fee;
{{end}}
            {{$coinModule}}::extract(&mut pool.reserve_{{.I}}, amount_{{.I}}_to_withdraw)
        } else {
            {{$coinModule}}::zero{{if $nq}}<Coin{{.I}}>{{end}}()
        };
{{end}}
        let before_lp_coins_supply = {{if $nq}}option::destroy_some({{$coinModule}}::supply<LP{{$typeList}}>()){{else}}quote_coin::treasury_supply(&pool.lp_treasury){{end}};

        update_balanced_reserve(pool);

        let after_balanced_reserve = pool.balanced_reserve;
        assert!(
            before_balanced_reserve > after_balanced_reserve,
            E_WITHDRAW_BALANCED_RESERVE_UNDERFLOW
        );

        let after_lp_coins_supply = (((after_balanced_reserve as u256)*(before_lp_coins_supply as u256) / (before_balanced_reserve as u256)) as u128);

        // make sure at least 1 lp coin is burned
        if (after_lp_coins_supply == before_lp_coins_supply) {
            after_lp_coins_supply = before_lp_coins_supply - 1;
        };

        let lp_burnt = (before_lp_coins_supply - after_lp_coins_supply);
        assert!(
            lp_burnt <= MAX_U64,
            E_LP_BURNT_OVERFLOW,
        );

        let lp_burnt = (lp_burnt as u64);

        let LPBundle {
            lps: lps_to_burn,
        {{range .Xis}}    reward_token_{{.I}},
        {{end}}} = bundle_extract(&mut lp_bundle, lp_burnt);

        {{$coinModule}}::burn(lps_to_burn, &{{if $quoter}}mut pool.lp_treasury{{else}}pool.lp_burn{{end}});
{{range .Xis}}        // burn the reward {{.I}}
        let reward_coin_{{.I}} = {{$rewardDistributorModule}}::burn(&mut pool.reward_distributor_{{.I}}, reward_token_{{.I}});
        {{if $nq}}let reward_{{.I}} = {{$coinModule}}::value(&reward_coin_{{.I}});
        {{end}}{{$coinModule}}::merge(&mut coin_{{.I}}, reward_coin_{{.I}});
{{end}}{{if $nq}}
        event::emit_event<RemoveLiquidityEvent{{$typeList}}>(
            &mut remove_liquidity_events.remove_liquidity_events,
            RemoveLiquidityEvent{{$typeList}} {
                sender,
                timestamp_microseconds: {{$timestampNow}},

                lp_burnt,
                before_balanced_reserve,
                after_balanced_reserve,
                before_lp_coins_supply,
                after_lp_coins_supply,
                amp: pool.amp,
{{range .Xis}}
                before_reserve_{{.I}},
                after_reserve_{{.I}},
                fee_{{.I}},
                withdraw_{{.I}}: amount_{{.I}}_to_withdraw,
                reward_{{.I}},
{{end}}            }
        );
{{end}}
        ({{range .Xis}}coin_{{.I}}, {{end}}lp_bundle)
    }

    /// Remove liquidity from the pool by burning lp bundles.
    /// The coins returned will follow the current ratio of the pool.
    /// There is no fee.
    public fun remove_liquidity{{$typeList}}(
{{if $nq}}        sender: address{{else}}pool: &mut {{$structParamName}}{{end}},
        lp_bundle: LPBundle{{$typeList}},
    ): ({{range .Xis}}{{.CoinName}}{{if .NotLast}}, {{end}}{{end}})
    {{if $nq}}acquires Pool, RemoveLiquidityEventHolder, FeeMoveEventHolder
    {{end}}{
        move_fee_into_reward_distributor{{$typeList}}({{if not $nq}}pool{{end}});

        let LPBundle {
            {{range .Xis}}reward_token_{{.I}},
            {{end}}lps: lp,
        } = lp_bundle;
        let lp_burnt = {{$coinModule}}::value(&lp);
        assert!(
            lp_burnt > 0,
            E_LP_TO_BURN_IS_ZERO,
        );
{{if $nq}}        let pool = borrow_global_mut<Pool{{$typeList}}>(@aux);
        let remove_liquidity_events = borrow_global_mut<RemoveLiquidityEventHolder{{$typeList}}>(@aux);
{{end}}
        let before_lp_coins_supply = {{if $nq}}option::destroy_some({{$coinModule}}::supply<LP{{$typeList}}>()){{else}}quote_coin::treasury_supply(&pool.lp_treasury){{end}};
{{if $nq}}        let before_balanced_reserve = pool.balanced_reserve;
{{end}}{{range .Xis}}
        // remove liquidity for coin {{.I}}
        let before_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});

        let withdraw_{{.I}} = (
            ((before_reserve_{{.I}} as u128) * (lp_burnt as u128))
            / before_lp_coins_supply
             as u64);
        let coin_{{.I}} = {{$coinModule}}::extract(&mut pool.reserve_{{.I}}, withdraw_{{.I}});
        let reward_coin_{{.I}} = {{$rewardDistributorModule}}::burn(&mut pool.reward_distributor_{{.I}}, reward_token_{{.I}});
{{if $nq}}        let reward_{{.I}} = {{$coinModule}}::value(&reward_coin_{{.I}});
{{end}}        {{$coinModule}}::merge(&mut coin_{{.I}}, reward_coin_{{.I}});
{{if $nq}}
        let after_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});
        let fee_{{.I}}: u64 = 0;
{{end}}{{end}}
        // recalculate d
        update_balanced_reserve(pool);

        {{$coinModule}}::burn(lp, &{{if $quoter}}mut pool.lp_treasury{{else}}pool.lp_burn{{end}});
{{if $nq}}
        let after_balanced_reserve = pool.balanced_reserve;
        let after_lp_coins_supply = {{if $nq}}option::destroy_some({{$coinModule}}::supply<LP{{$typeList}}>()){{else}}quote_coin::treasury_supply(&pool.lp_treasury){{end}};

        event::emit_event<RemoveLiquidityEvent{{$typeList}}>(
            &mut remove_liquidity_events.remove_liquidity_events,
            RemoveLiquidityEvent{{$typeList}} {
                sender,
                timestamp_microseconds: {{$timestampNow}},

                lp_burnt,
                before_balanced_reserve,
                after_balanced_reserve,
                before_lp_coins_supply,
                after_lp_coins_supply,
                amp: pool.amp,
{{range .Xis}}
                before_reserve_{{.I}},
                after_reserve_{{.I}},
                fee_{{.I}},
                withdraw_{{.I}},
                reward_{{.I}},
{{end}}            }
        );
{{end}}
        ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}})
    }

    /// swap coins, where output amount is decided by the input amount.
    /// for input coins, the full amount stored in the coin will be transferred to the pool.
    /// for the output coin, the amount swapped for will be added (so the output coin can contain non-zero value).
    /// output coin is identified by the index.
    public fun swap_exact_coin_for_coin{{$typeList}}(
{{if $nq}}        sender: address{{else}}pool: &mut {{$structParamName}}{{end}},
        {{range .Xis}}coin_{{.I}}: {{.CoinName}},
        {{end}}out_coin_index: u8,
        min_quantity_out: u64,
    ): ({{range .Xis}}{{.CoinName}}{{if .NotLast}}, {{end}}{{end}})
    {{if $nq}}acquires Pool, SwapEventHolder
    {{end}}{
        assert!(out_coin_index < N_COINS_U8, E_INVALID_OUT_COIN_INDEX);
{{if $nq}}        let pool = borrow_global_mut<Pool{{$typeList}}>(@aux);
        let swap_events = borrow_global_mut<SwapEventHolder{{$typeList}}>(@aux);

{{end}}        let amp = pool.amp;
        let before_balanced_reserve = pool.balanced_reserve;
{{range .Xis}}
        // calculate the amount in for coin {{.I}}
        let before_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});

        let is_coin_{{.I}}_out = out_coin_index == {{.I}};

{{if $nq}}        let amount_{{.I}}_in = 0u64;
        let amount_{{.I}}_out = 0u64;
        let fee_{{.I}} = 0u64;
{{end}}
        if (out_coin_index != {{.I}}) {
{{if $nq}}            amount_{{.I}}_in = {{$coinModule}}::value(&coin_{{.I}});
{{end}}            {{$coinModule}}::merge(&mut pool.reserve_{{.I}}, {{$coinModule}}::extract_all(&mut coin_{{.I}}));
        };

        let after_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});
        let after_reserve_{{.I}}_scaled = (after_reserve_{{.I}} as u128) * pool.scaler_{{.I}};
{{end}}
        // calculate the scaled output coin value
        let new_x = pool_math::calculate_x(
{{range .Xis}}            after_reserve_{{.I}}_scaled,
{{end}}            out_coin_index,
            amp,
            before_balanced_reserve,
        ) + 1;
{{range .Xis}}
        // if coin {{.I}} is the output, update it.
        if (is_coin_{{.I}}_out) {
            after_reserve_{{.I}} = ((new_x / pool.scaler_{{.I}}) as u64);
            // make sure reserve after swap is not truncated.
            if (new_x % pool.scaler_{{.I}} > 0) {
                after_reserve_{{.I}} = after_reserve_{{.I}} + 1;
            };
            assert!(before_reserve_{{.I}} > after_reserve_{{.I}}, E_OUTPUT_COIN_UNDERFLOW);

            // the value the pool will dispense
            let diff = before_reserve_{{.I}} - after_reserve_{{.I}};

            // fee is charged on the amount the user receives.
            let fee_amount = ((diff as u128) * pool.fee_numerator)/(FEE_DENOMINATOR + pool.fee_numerator);
            if (fee_amount * (FEE_DENOMINATOR + pool.fee_numerator) < (diff as u128) * pool.fee_numerator) {
                fee_amount = fee_amount + 1;
            };
            {{if not $nq}}let {{end}}fee_{{.I}} = (fee_amount as u64);
            // amount the user will receive
            {{if not $nq}}let {{end}}amount_{{.I}}_out = diff - fee_{{.I}};

            assert!(amount_{{.I}}_out > 0, E_OUTPUT_COIN_UNDERFLOW);
            assert!(amount_{{.I}}_out >= min_quantity_out, E_OUTPUT_COIN_INSUFFICIENT);

            let out_coin = {{$coinModule}}::extract(&mut pool.reserve_{{.I}}, amount_{{.I}}_out);
            {{$coinModule}}::merge(&mut coin_{{.I}}, out_coin);
            let fee_coin = {{$coinModule}}::extract(&mut pool.reserve_{{.I}}, fee_{{.I}});
            {{$coinModule}}::merge(&mut pool.fee_{{.I}}, fee_coin);
        };
{{end}}
        update_balanced_reserve(pool);
        let after_balanced_reserve = pool.balanced_reserve;
        assert!(after_balanced_reserve >= before_balanced_reserve, E_BALANCED_RESERVE_DECREASING);
{{if $nq}}
        event::emit_event<SwapEvent{{$typeList}}>(
            &mut swap_events.swap_events,
            SwapEvent{{$typeList}}{
                sender,
                timestamp_microseconds: {{$timestampNow}},
{{range .Xis}}
                before_reserve_{{.I}},
                after_reserve_{{.I}},
                fee_{{.I}},
                is_coin_{{.I}}_out,
                amount_{{.I}}_in,
                amount_{{.I}}_out,
{{end}}
                before_balanced_reserve,
                after_balanced_reserve,
                amp,
            },
        );
{{end}}
        ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}})
    }

    /// swap coins, where input amount is decided by the requested output amount.
    /// for the output coins, the amount swapped for will be added (so the output coin can contain non-zero value).
    /// for the input coin, the amount necessary is deducted.
    /// input coin is identified by the index.
    public fun swap_coin_for_exact_coin{{$typeList}}(
{{if $nq}}        sender: address{{else}}pool: &mut {{$structParamName}}{{end}},
        {{range .Xis}}coin_{{.I}}: {{.CoinName}},
        requested_quantity_{{.I}}: u64,
        {{end}}in_coin_index: u8,
    ): ({{range .Xis}}{{.CoinName}}{{if .NotLast}}, {{end}}{{end}})
    {{if $nq}}acquires Pool, SwapEventHolder
    {{end}}{
        assert!(in_coin_index < N_COINS_U8, E_INVALID_IN_COIN_INDEX);
{{if $nq}}        let pool = borrow_global_mut<Pool{{$typeList}}>(@aux);
        let swap_events = borrow_global_mut<SwapEventHolder{{$typeList}}>(@aux);

{{end}}        let amp = pool.amp;
        let before_balanced_reserve = pool.balanced_reserve;
{{range .Xis}}
        // process coin {{.I}}
        let before_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});

        let is_coin_{{.I}}_out = in_coin_index != {{.I}};
{{if $nq}}
        let amount_{{.I}}_in = 0u64;
        let amount_{{.I}}_out = 0u64;
        let fee_{{.I}} = 0u64;
{{end}}
        if (is_coin_{{.I}}_out && requested_quantity_{{.I}} > 0) {
            // calculate fee.
            // fee is based on the amount user receives.
            let fee = (pool.fee_numerator * (requested_quantity_{{.I}} as u128))/FEE_DENOMINATOR;
            if (fee * FEE_DENOMINATOR < pool.fee_numerator * (requested_quantity_{{.I}} as u128)) {
                fee = fee + 1;
            };
            let fee = (fee as u64);
            let fee_coin = {{$coinModule}}::extract(&mut pool.reserve_{{.I}}, fee);
            {{$coinModule}}::merge(&mut pool.fee_{{.I}}, fee_coin);
            {{$coinModule}}::merge(&mut coin_{{.I}}, {{$coinModule}}::extract(&mut pool.reserve_{{.I}}, requested_quantity_{{.I}}));
{{if $nq}}            amount_{{.I}}_out = requested_quantity_{{.I}};
            fee_{{.I}} = fee;
{{end}}        };

        let after_reserve_{{.I}} = {{$coinModule}}::value(&pool.reserve_{{.I}});
        let after_reserve_{{.I}}_scaled = (after_reserve_{{.I}} as u128) * pool.scaler_{{.I}};
{{end}}
        // get the new reserve for the input coin
        let new_x = pool_math::calculate_x(
{{range .Xis}}            after_reserve_{{.I}}_scaled,
{{end}}            in_coin_index,
            amp,
            before_balanced_reserve,
        ) + 1;
{{range .Xis}}
        if (in_coin_index == {{.I}}) {
            after_reserve_{{.I}} = ((new_x / pool.scaler_{{.I}}) as u64);
            // make sure new reserve is not round down
            if (new_x % pool.scaler_{{.I}} > 0) {
                after_reserve_{{.I}} = after_reserve_{{.I}} + 1;
            };
            assert!(after_reserve_{{.I}} > before_reserve_{{.I}}, E_INPUT_COIN_UNDERFLOW);
            {{if not $nq}}let {{end}}amount_{{.I}}_in = after_reserve_{{.I}} - before_reserve_{{.I}};
            assert!(amount_{{.I}}_in <= {{$coinModule}}::value(&coin_{{.I}}), E_INPUT_COIN_INSUFFICIENT);
            {{$coinModule}}::merge(&mut pool.reserve_{{.I}}, {{$coinModule}}::extract(&mut coin_{{.I}}, amount_{{.I}}_in));
        };
{{end}}
        update_balanced_reserve(pool);

        let after_balanced_reserve = pool.balanced_reserve;
        assert!(after_balanced_reserve >= before_balanced_reserve, E_BALANCED_RESERVE_DECREASING);
{{if $nq}}
        event::emit_event<SwapEvent{{$typeList}}>(
            &mut swap_events.swap_events,
            SwapEvent{{$typeList}}{
                sender,
                timestamp_microseconds: {{$timestampNow}},
{{range .Xis}}
                before_reserve_{{.I}},
                after_reserve_{{.I}},
                fee_{{.I}},
                is_coin_{{.I}}_out,
                amount_{{.I}}_in,
                amount_{{.I}}_out,
{{end}}
                before_balanced_reserve,
                after_balanced_reserve,
                amp,
            },
        );
{{end}}
        ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}})
    }
{{if $nq}}
    #[test_only]
    /// during test it may be desired to reset the pool - for example, a pool with coin X, Y is created,
    /// but need to do something with coin Y, X. This will destroy the pool, but the LP token will still
    /// exists.
    public fun delete_pool_in_test{{$typeList}}() acquires Pool {
        let {{$structName}} {
            amp: _,
            balanced_reserve: _,
            fee_numerator: _,
            lp_burn,
            lp_mint,
{{range .Xis}}
            scaler_{{.I}}: _,
            reserve_{{.I}},
            fee_{{.I}},
            reward_distributor_{{.I}},
{{end}}        } = move_from<{{$structParamName}}>(@aux);
{{range .Xis}}
        {{$coinModule}}::deposit(@aux, reserve_{{.I}});
        {{$coinModule}}::deposit(@aux, fee_{{.I}});
        {{$coinModule}}::deposit(@aux, {{$rewardDistributorModule}}::destroy_for_test(reward_distributor_{{.I}}));
{{end}}
        {{$coinModule}}::destroy_mint_cap(lp_mint);
        {{$coinModule}}::destroy_burn_cap(lp_burn);
    }
{{end}}
    /*********************/
    /* LPBundle          */
    /*********************/

    /// extract amount from the bundle.
    public fun bundle_extract{{$typeList}}(lp: &mut LPBundle{{$typeList}}, amount: u64): LPBundle{{$typeList}} {
        LPBundle {
            {{range .Xis}}reward_token_{{.I}}: {{$rewardDistributorModule}}::token_extract(&mut lp.reward_token_{{.I}}, amount),
            {{end}}lps: {{$coinModule}}::extract(&mut lp.lps, amount),
        }
    }

    /// detach reward tokens from lp coins.
    /// **note**: to redeem lp coins from the pool, reward tokens must be reattached to the lp coins.
    public fun bundle_detach_reward{{$typeList}}(
        lp: LPBundle{{$typeList}},
    ): (
        {{$coinName}}{{if $nq}}<LP{{$typeList}}>{{end}},
    {{range .Xis}}    {{$redeemTokenName}}{{if $nq}}<Coin{{.I}}, LP{{$typeList}}>{{end}},
    {{end}}) {
        let LPBundle {
            {{range .Xis}}reward_token_{{.I}},
            {{end}}lps,
        } = lp;
        (lps, {{range .Xis}}reward_token_{{.I}}{{if .NotLast}}, {{end}}{{end}})
    }

    /// attach reward token to lp coins so they can be redeemed from the pool.
    /// the value contained in the reward token must exactly match the value
    /// contained in the lp coins.
    public fun bundle_attach_reward{{$typeList}}(
        lps: {{$coinName}}{{if $nq}}<LP{{$typeList}}>{{end}},
    {{range .Xis}}    reward_token_{{.I}}: {{$redeemTokenName}}{{if $nq}}<Coin{{.I}}, LP{{$typeList}}>{{end}},
    {{end}}): LPBundle{{$typeList}} {
{{range .Xis}}        assert!(
            {{$coinModule}}::value(&lps) == {{$rewardDistributorModule}}::token_value(&reward_token_{{.I}}),
            E_REWARD_TOKEN_AMOUNT_MISMATCH
        );
{{end}}
        LPBundle {
            lps,
        {{range .Xis}}    reward_token_{{.I}},
        {{end}}}
    }

    /// check if the reward token is fungible.
    public fun bundle_is_fungible{{$typeList}}(
        l: &LPBundle{{$typeList}},
        r: &LPBundle{{$typeList}},
    ): bool {
{{range .Xis}}        if (!{{$rewardDistributorModule}}::is_fungible(&l.reward_token_{{.I}}, &r.reward_token_{{.I}})) {
            return false
        };
{{end}}
        true
    }

    /// merge lp token bundle into another bundle.
    /// the reward tokens must be fungile.
    public fun bundle_merge{{$typeList}}(
        l: &mut LPBundle{{$typeList}},
        r: LPBundle{{$typeList}},
    ) {
        let LPBundle {
            lps,
        {{range .Xis}}    reward_token_{{.I}},
        {{end}}} = r;

        {{$coinModule}}::merge(&mut l.lps, lps);

{{range .Xis}}        {{$rewardDistributorModule}}::token_merge(&mut l.reward_token_{{.I}}, reward_token_{{.I}});
{{end}}    }

    /// melt lp token bundle into another bundle
    public fun bundle_melt{{$typeList}}(
        l: &mut LPBundle{{$typeList}},
        r: LPBundle{{$typeList}},
    ) {
        let LPBundle {
            lps,
        {{range .Xis}}    reward_token_{{.I}},
        {{end}}} = r;

        {{$coinModule}}::merge(&mut l.lps, lps);

{{range .Xis}}        {{$rewardDistributorModule}}::token_melt(&mut l.reward_token_{{.I}}, reward_token_{{.I}});
{{end}}    }

    public fun bundle_value{{$typeList}}(lp_bundle: &LPBundle{{$typeList}}): u64 {
        {{$coinModule}}::value(&lp_bundle.lps)
    }

    public fun update_balanced_reserve{{$typeList}}(pool: &mut {{$structParamName}}) {
{{range .Xis}}        let scaler_{{.I}} = pool.scaler_{{.I}};
        let reserve_{{.I}}_unscaled = {{$coinModule}}::value(&pool.reserve_{{.I}});
        let reserve_{{.I}} = (reserve_{{.I}}_unscaled as u128) * scaler_{{.I}};

{{end}}        pool.balanced_reserve = pool_math::calculate_d(
            {{range .Xis}}reserve_{{.I}},
            {{end}}pool.amp
        );
    }
{{if $nq}}
    fun lp_name{{$typeList}}(): String {
        let name = string::utf8(b"");
{{$nameTake := .NameTake}}{{range .Xis}}
        let coin_name_{{.I}} = coin::name<Coin{{.I}}>();
        let end_{{.I}} = min_u64(string::length(&coin_name_{{.I}}), {{$nameTake}});
        string::append(&mut name, string::sub_string(&coin_name_{{.I}}, 0, end_{{.I}}));
{{if .NotLast}}        string::append(&mut name, string::utf8(b"/"));
{{end}}{{end}}
        string::sub_string(&name, 0, min_u64(string::length(&name), 10))
    }

    fun lp_symbol{{$typeList}}(): String {
        let symbol = string::utf8(b"");
{{range .Xis}}
        let coin_symbol_{{.I}} = coin::symbol<Coin{{.I}}>();
        let end_{{.I}} = min_u64(string::length(&coin_symbol_{{.I}}), 3);
        string::append(&mut symbol, string::sub_string(&coin_symbol_{{.I}}, 0, end_{{.I}}));
{{if .NotLast}}        string::append(&mut symbol, string::utf8(b"/"));
{{end}}{{end}}
        string::sub_string(&symbol, 0, min_u64(string::length(&symbol), 10))
    }

    fun min_u64(l: u64, r: u64): u64 {
        if (l>r) {
            r
        } else {
            l
        }
    }

    public fun pool_exists{{$typeList}}(): bool {
        exists<Pool{{$typeList}}>(@aux)
    }

    #[test_only]
    public fun print_pool{{$typeList}}() acquires Pool {
        std::debug::print(borrow_global<Pool{{$typeList}}>(@aux));
    }
{{else}}
    public fun get_balanced_reserve(pool: &Quoter): u128 {
        pool.balanced_reserve
    }

    public fun get_lp_supply(pool: &Quoter): u128 {
       quote_coin::treasury_supply(&pool.lp_treasury)
    }
{{range .Xis}}
    public fun get_reserve_{{.I}}(pool: &Quoter): u64 {
        quote_coin::value(&pool.reserve_{{.I}})
    }

    public fun get_fee_{{.I}}(pool: &Quoter): u64 {
        quote_coin::value(&pool.fee_{{.I}})
    }
{{end}}{{end}}}
