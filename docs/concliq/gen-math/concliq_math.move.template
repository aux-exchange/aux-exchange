// Autogenerated from ./docs/concliq/gen-math -p {{.Precision}}
// Manual edit with caution.
//
// Tick math for concentrated liquidity.
// square price is an u128 used as a fixed point number.
// Precision indicates how many bits are after decimal point.
// There are three optiosn for precision:
// - 64: only lower 96 bits of the u128 is used, decimal point is at index 64 of the u128 from the most significant bit.
// - 96: all the bits of the u128 is used, decimal point is at index 32 of the u128 from the most significant bit.
module aux::concliq_math {
    use aux::int32::{Self, Int32};
    use aux::int128::{Self, Int128};
    use aux::more_math_u256;
    use aux::more_math_u128;

    /**********************/
    /* Errors             */
    /**********************/

    const E_TICK_TOO_BIG: u64 = 1001;
    const E_TICK_TOO_SMALL: u64 = 1002;
    const E_Y_OUTSIDE_1_2: u64 = 1003;
    const E_ZERO_FOR_LOG_2: u64 = 1004;
    const E_Y_LESS_THAN_ONE: u64 = 1004;

    /**********************/
    /* constants          */
    /**********************/

    /// Precision used in the operation.
    const PRECISION: u8 = {{.Precision}};

    // ONE_X is 1 in fixed point number with {{.Precision}} digits after decimal point.
    const ONE_X: u128 = 1 << {{.Precision}};
    // TWO_X is 2 in fixed point number with {{.Precision}} digits after decimal point.
    const TWO_X: u128 = 1 << ({{.Precision}} + 1);
    // ONE_X_256 is 1 in fixed point number with {{.Precision}} digits after decimal point.
    const ONE_X_256: u256 = 1 << {{.Precision}};
    // TWO_X_256 is 2 in fixed point number with {{.Precision}} digits after decimal point.
    const TWO_X_256: u256 = 1 << ({{.Precision}} + 1);
    // ONE_X_TWICE_SHIFTED_256 is 1 in fixed point number with 2*{{.Precision}} digits after decimal point. It is generally acting as numerator for division.
    const ONE_X_TWICE_SHIFTED_256: u256 = (1 << {{.Precision}}) << {{.Precision}};
    // ONE_32 is 1 << 32;
    const ONE_32: u256 = 1 << 32;

    /// sqrt(1.0001) in fixed point {{.Precision}}
    const SQUARE_PRICE: u128 = {{.SquarePrice1}};
    /// log_2 sqrt(1.0001) in fixed point {{.Precision}}
    const SQUARE_PRICE_LOG_2: u128 = {{.SquarePrice1Log2}};
    /// 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG: u128 = {{.SquarePriceNeg1}};
    /// log_2 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG_LOG_2_ABS: u128 = {{.SquarePriceNeg1Log2}};

    /// get sqrt(1.0001)^i
    public fun get_square_price_from_tick(i: Int32): u128 {
        if (int32::is_negative(i)) {
            get_square_price_from_tick_negative(int32::abs(i))
        } else {
            get_square_price_from_tick_positive(int32::raw_value(i))
        }
    }

    /// get sqrt(1.0001)^i, where i >= 0
    public fun get_square_price_from_tick_positive(i: u32): u128 {
        assert!(i <= {{.MaxPositiveIndex}}, E_TICK_TOO_BIG);
        let r = ONE_X_256;
{{range .PositiveIndices}}
        // check for 2^{{.I}}
        if (i & {{.TwoP}} > 0) {
            r = r * {{.StringV}};
            r = r >> PRECISION;
        };
{{end}}
        (r as u128)
    }

    /// get sqrt(1.0001)^(-i), where i >= 0
    public fun get_square_price_from_tick_negative(i: u32): u128 {
        assert!(i <= {{.MinNegativeIndex}}, E_TICK_TOO_BIG);
        let r = (ONE_X as u256);
{{range .NegativeIndices}}        if (i & {{.TwoP}} > 0) {
            r = r * {{.StringV}};
            r = r >> PRECISION;
        };
{{end}}
        (r as u128)
    }

    /// log_2 for log_{sqrt{1.0001}} y
    public fun log_2(y: u128): Int128 {
        assert!(y != 0, E_ZERO_FOR_LOG_2);
        let leading_zeros = more_math_u128::leading_zeros(y);
        if (y == ONE_X) {
            int128::zero()
        } else if (y > ONE_X) {
            let n_0: u8 = 128 - PRECISION - leading_zeros - 1;
            let r = (n_0 as u128) << PRECISION;
            let d = (more_math_u256::log_2((y as u256) >> n_0, PRECISION) as u128);
            int128::new(r + d, false)
        } else {
            let n_0: u8 = leading_zeros - (128 - PRECISION - 1);
            let r = (n_0 as u128) << PRECISION;
            let intpart = int128::new(r, true);
            let d = (more_math_u256::log_2((y as u256) << n_0, PRECISION) as u128);
            int128::add(int128::new(d, false), intpart)
        }
    }

    /// get the tick from sqrt price
    public fun get_tick(sqrt_p: u128): Int32 {
        let log_2_y = log_2(sqrt_p);
        let is_neg = int128::is_negative(log_2_y);
        let log_2_y = int128::abs(log_2_y);
        let ratio = if (is_neg) {
            let r = log_2_y / SQUARE_PRICE_NEG_LOG_2_ABS;
            if (r * SQUARE_PRICE_NEG_LOG_2_ABS < log_2_y) {
                r + 1
            } else {
                r
            }
        } else {
            log_2_y / SQUARE_PRICE_LOG_2
        };
        int32::new((ratio as u32), is_neg)
    }

    /// price
    public fun get_price(x: u64, y: u64): u256 {
        let x = (x as u256) << PRECISION;
        let y = (y as u256);
        x / y
    }

    /// get the sqrt price sqrt(x/y)
    public fun get_sqrt_price(x: u64, y: u64): u128 {
        let x = ((x as u256) << PRECISION) << PRECISION;
        let y = (y as u256);
        (more_math_u256::sqrt(x / y) as u128)
    }

    /// get sqrt price for a fixed point price with the same precision.
    public fun get_sqrt_price_from_price(price: u128): u128 {
        let price = (price as u256);
        price = price << PRECISION;
        let sqrt_price = more_math_u256::sqrt(price);
        (sqrt_price as u128)
    }

    /// check if this is a valid tick
    public fun is_valid_tick(tick: Int32, spacing: u32): bool {
        let abs_tick = int32::abs(tick);
        (abs_tick % spacing) == 0
    }

    /// making sure the tick spacing is between 1 and 256 inclusive.
    public fun is_valid_tick_spacing(tick_spacing: u32): bool {
        tick_spacing > 0 && tick_spacing <= 256
    }

    /// inverse returns 1/x
    public fun inverse(x: u128, round_up: bool): u128 {
        let x = (x as u256);
        let r = ONE_X_TWICE_SHIFTED_256 / x;
        if (round_up && (r * x < ONE_X_TWICE_SHIFTED_256)) {
            ((r + 1) as u128)
        } else {
            (r as u128)
        }
    }

    /// divide the fixed point number.
    public fun divide(numerator: u128, denominator: u128, round_up: bool): u128 {
        let numerator = (numerator as u256) << PRECISION;
        let denominator = (denominator as u256);
        let r = numerator / denominator;
        if (round_up && (r * denominator < numerator)) {
            ((r + 1) as u128)
        } else {
            (r as u128)
        }
    }

    #[test_only]
    public fun get_square_price_from_2_n_positive(i: u8): u128 {
{{range .PositiveIndices}}        {{if ne .I 0}}} else {{end}}if (i == {{.I}}) {
            {{.StringV}}
{{end}}        } else {
            abort((i as u64))
        }
    }

    #[test_only]
    public fun get_square_price_from_2_n_negative(i: u8): u128 {
{{range .NegativeIndices}}        {{if ne .I 0}}} else {{end}}if (i == {{.I}}) {
            {{.StringV}}
{{end}}        } else {
            abort((i as u64))
        }
    }

    #[test]
    fun test_log_2_y() {
        assert!(int128::is_zero(log_2(ONE_X)), 1);
{{range .PositiveIndices}}
        // check positive side
        let square_price_{{.I}} = {{.StringV}}u128;
        let ratio_{{.I}} = get_tick(square_price_{{.I}});
        let abs_ratio_{{.I}} = int32::abs(ratio_{{.I}});
        assert!(abs_ratio_{{.I}} == {{.TwoP}}, (abs_ratio_{{.I}} as u64)); // positive
{{end}}{{range .NegativeIndices}}
        // check negative side
        let square_price_{{.I}} = {{.StringV}}u128;
        let ratio_{{.I}} = get_tick(square_price_{{.I}});
        let abs_ratio_{{.I}} = int32::abs(ratio_{{.I}});
        assert!(abs_ratio_{{.I}} == {{.TwoP}}, (abs_ratio_{{.I}} as u64)); // negative
{{end}}    }

    #[test]
    fun test_inverse() {
        // check if the inverse can match back
{{range .PositiveIndices}}
        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_{{.I}} = get_square_price_from_2_n_positive({{.I}});
        let p_neg_{{.I}} = get_square_price_from_2_n_negative({{.I}});
        let p_{{.I}}_inverse = inverse(p_{{.I}}, false);
        let diff_{{.I}} = int128::unsigned_subtract(p_{{.I}}_inverse, p_neg_{{.I}});
        if (!int128::is_zero(diff_{{.I}})) {
            std::debug::print(&{{.I}});
            std::debug::print(&p_neg_{{.I}});
            std::debug::print(&p_{{.I}}_inverse);
            std::debug::print(&diff_{{.I}});
        };
        let diff_{{.I}} = int128::abs(diff_{{.I}});
        assert!(diff_{{.I}} <= 1, (diff_{{.I}} as u64)); // positive index inverse

        let p_neg_{{.I}}_inverse = inverse(p_neg_{{.I}}, false);
        let diff_{{.I}} = int128::unsigned_subtract(p_neg_{{.I}}_inverse, p_{{.I}});
        if (!int128::is_zero(diff_{{.I}})) {
            std::debug::print(&{{.I}});
            std::debug::print(&p_{{.I}});
            std::debug::print(&p_neg_{{.I}}_inverse);
            std::debug::print(&diff_{{.I}});
        };
        let diff_{{.I}} = int128::abs(diff_{{.I}});
        assert!(diff_{{.I}} <= 1, (diff_{{.I}} as u64)); // negative index inverse
{{end}}    }
}
