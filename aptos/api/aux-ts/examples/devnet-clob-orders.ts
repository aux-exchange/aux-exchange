/**
 * Demo of the supported CLOB order types.
 */
import { AptosAccount, AptosClient } from "aptos";
import { assert } from "console";
import { AU, DU, Market, Vault } from "../src";
import { AuxClient } from "../src/client";
import { OrderType, STPActionType } from "../src/clob/core/mutation";
import { FakeCoin } from "../src/coin";

async function main() {
  const auxClient = new AuxClient(
    "devnet",
    new AptosClient("https://fullnode.devnet.aptoslabs.com/v1")
  );

  // Create a new trader for the demo and provide a bit of native token and fake
  // currency to play with.
  //
  // AU is a shortcut for AtomicUnits, the native u64 on-chain quantity. DU is a
  // shortcut for DecimalUnits, the fixed-precision representation that will be
  // converted to AU in API calls.
  const trader = new AptosAccount();
  auxClient.sender = trader;
  await auxClient.fundAccount({
    account: trader.address(),
    quantity: AU(500_000_000),
  });

  // We support several fake coins that can be used for test trading. You can
  // mint and burn any quantities.
  await auxClient.registerAndMintFakeCoin(FakeCoin.BTC, DU(1000));
  await auxClient.registerAndMintFakeCoin(FakeCoin.USDC, DU(1_000_000));

  // The full type names for the fake coins. For real trading.
  const btcCoin = auxClient.getWrappedFakeCoinType(FakeCoin.BTC);
  const usdcCoin = auxClient.getWrappedFakeCoinType(FakeCoin.USDC);

  // CLOB trades credit to and debit from a user-specific vault.
  const vault = new Vault(auxClient);
  await vault.createAuxAccount();
  await vault.deposit(trader, btcCoin, DU(1000));
  await vault.deposit(trader, usdcCoin, DU(1_000_000));

  // Read the initial market state.
  const maybeMarket = await Market.read(auxClient, {
    baseCoinType: btcCoin,
    quoteCoinType: usdcCoin,
  });
  assert(
    maybeMarket !== undefined,
    "Fake market should have been created during deploy"
  );
  const market = maybeMarket as Market;
  await market.update();

  // Demo some orders around midpoint.
  const maybeBid = market.l2.bids[0]?.price.toNumber();
  const maybeAsk = market.l2.asks[0]?.price.toNumber();

  const midpoint =
    maybeBid !== undefined && maybeAsk !== undefined
      ? (maybeBid + maybeAsk) / 2
      : 20_000;

  // Match as much of the order as possible. Cancel the remaining unmatched
  // portion immediately.
  const immediateOrCancel = await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint + 10), // Midpoint + $10
    quantity: DU(0.1), // Fractional BTC. The API will roundlot the quantity.
    orderType: OrderType.IMMEDIATE_OR_CANCEL_ORDER,
  });

  // On tx success, these are the PlaceOrderEvent[] generated by your order.
  // Same is true for all of the placeOrder examples below but we will omit the
  // print for brevity.
  console.log("immediateOrCancel.result:", immediateOrCancel.result);

  // We specify isBid: false to indicate a sell order.
  await market.placeOrder({
    sender: trader,
    isBid: false,
    limitPrice: DU(midpoint + 10),
    quantity: DU(0.1),
    orderType: OrderType.IMMEDIATE_OR_CANCEL_ORDER,
  });

  // If you attach a client order ID to the initial order, all events will echo
  // back the client order ID.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint + 10),
    quantity: DU(0.1),
    orderType: OrderType.IMMEDIATE_OR_CANCEL_ORDER,
    clientOrderId: "123",
  });

  // Self trades are currently prohibited and default to cancelling the passive
  // side. You can change this behavior via the stpActionType parameter.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint + 10),
    quantity: DU(0.1),
    orderType: OrderType.IMMEDIATE_OR_CANCEL_ORDER,
    stpActionType: STPActionType.CANCEL_AGGRESSIVE,
  });

  // Match as much of the order as possible. Place the remaining unmatched
  // portion in the orderbook.
  const limit = await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint - 100), // Midpoint - $100
    quantity: DU(0.1), // Note that you can also use AU() here to specify an exact atomic quantity.
    orderType: OrderType.LIMIT_ORDER,
  });
  for (const event of limit.result ?? []) {
    switch (event.type) {
      case "OrderPlacedEvent":
        // The event contains your client order ID echoed back. You can use this
        // to map to global order ID when tracking positions.
        console.log("event.clientOrderId:", event.clientOrderId);

        // Cancel it. You probably wouldn't normally do this.
        await market.cancelOrder({
          sender: trader,

          // Note that cancellation uses the global order ID. You can map the
          // client order ID to global order ID using the returned events.
          orderId: event.orderId.toString(),
        });
        break;
      // These don't result in liquidity placed on the orderbook.
      case "OrderCancelEvent":
      case "OrderFillEvent":
      case "UnknownEvent":
        console.log("event:", event);
    }
  }

  // When placing in the orderbook, expire the order at the specified timeout.
  // The order will no longer match after the specified timestamp in epoch
  // microseconds.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint - 100),
    quantity: DU(0.1),
    orderType: OrderType.LIMIT_ORDER,
    timeoutTimestamp: ((Date.now() + 60_000) * 1000).toFixed(0),
  });

  // Match all of the order immediately or cancel the entire order.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint + 100),
    quantity: DU(0.1),
    orderType: OrderType.FILL_OR_KILL_ORDER,
  });

  // Ensure that the order places passively into the orderbook. If any portion
  // of the order would match, cancel the entire order.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint),
    quantity: DU(0.1),
    orderType: OrderType.POST_ONLY_ORDER,
  });

  // Ensure that the order places passively into the orderbook. If any portion
  // of the order would match, slide the specified ticks back to become passive.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint),
    quantity: DU(0.1),
    orderType: OrderType.POST_ONLY_ORDER,
    ticksToSlide: "5", // Place 5 ticks deep if the specified price is aggressive.
  });

  // Join the best bid if isBid is true, or best ask if isBid is false, up to
  // the specified limit price. Cancel if the BBO is inside the limit price.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint),
    quantity: DU(0.1),
    orderType: OrderType.PASSIVE_JOIN_ORDER,
  });

  // Join the best bid if isBid is true, or best ask if isBid is false. Make the
  // price up to one tick more aggressive while staying passive, up to the
  // specified limit price. Cancel if the resulting order is inside the limit
  // price.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint),
    quantity: DU(0.1),
    orderType: OrderType.PASSIVE_JOIN_ORDER,
    directionAggressive: true,
    ticksToSlide: "1",
  });

  // Join the best bid if isBid is true, or best ask if isBid is false. Make the
  // price two ticks less aggressive. Cancel if the resulting order is inside
  // the limit price.
  await market.placeOrder({
    sender: trader,
    isBid: true,
    limitPrice: DU(midpoint),
    quantity: DU(0.1),
    orderType: OrderType.PASSIVE_JOIN_ORDER,
    directionAggressive: false,
    ticksToSlide: "2",
  });

  const book = await market.orderbook();
  console.dir(book, { depth: null });

  // Withdraw all money from the vault. We won't be able to trade the CLOB until
  // we deposit again.
  await vault.withdrawAll(trader, btcCoin);
  await vault.withdrawAll(trader, usdcCoin);
}

main();
