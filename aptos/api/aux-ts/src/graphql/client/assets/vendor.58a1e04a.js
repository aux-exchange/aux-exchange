var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { g as getDefaultExportFromCjs, c as commonjsGlobal, a as getAugmentedNamespace } from "./__commonjsHelpers__.4516dc8a.js";
function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e3 = m2[i2];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k2 in e3) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e3, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e3[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$8 = Symbol.for("react.element"), n$7 = Symbol.for("react.portal"), p$a = Symbol.for("react.fragment"), q$6 = Symbol.for("react.strict_mode"), r$7 = Symbol.for("react.profiler"), t$3 = Symbol.for("react.provider"), u$8 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$6 = Symbol.for("react.suspense"), x$5 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$2(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$3 && a2[z$3] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$4 = Object.assign, D$4 = {};
function E$2(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e3 || B$2;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$7() {
}
F$7.prototype = E$2.prototype;
function G$2(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e3 || B$2;
}
var H$3 = G$2.prototype = new F$7();
H$3.constructor = G$2;
C$4(H$3, E$2.prototype);
H$3.isPureReactComponent = true;
var I$5 = Array.isArray, J$3 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$3 = { key: true, ref: true, __self: true, __source: true };
function M$7(a2, b2, e3) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$3.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g = arguments.length - 2;
  if (1 === g)
    c2.children = e3;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g = a2.defaultProps, g)
      void 0 === c2[d2] && (c2[d2] = g[d2]);
  return { $$typeof: l$8, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$4(a2, b2) {
  return { $$typeof: l$8, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$8;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$5(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e3, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$8:
          case n$7:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$5(h2, 0) : d2, I$5(c2) ? (e3 = "", null != a2 && (e3 = a2.replace(P$2, "$&/") + "/"), R$1(c2, b2, e3, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$4(c2, e3 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$5(a2))
    for (var g = 0; g < a2.length; g++) {
      k2 = a2[g];
      var f2 = d2 + Q$5(k2, g);
      h2 += R$1(k2, b2, e3, f2, c2);
    }
  else if (f2 = A$2(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$5(k2, g++), h2 += R$1(k2, b2, e3, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$4(a2, b2, e3) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e3, a3, c2++);
  });
  return d2;
}
function T$5(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$3 = { current: null }, V$5 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$5, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$4, forEach: function(a2, b2, e3) {
  S$4(a2, function() {
    b2.apply(this, arguments);
  }, e3);
}, count: function(a2) {
  var b2 = 0;
  S$4(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$4(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$2(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$a;
react_production_min.Profiler = r$7;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$6;
react_production_min.Suspense = w$6;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e3) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$4({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g = a2.type.defaultProps;
    for (f2 in b2)
      J$3.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g ? g[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e3;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g[m2] = arguments[m2 + 2];
    d2.children = g;
  }
  return { $$typeof: l$8, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$8, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$3, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$7;
react_production_min.createFactory = function(a2) {
  var b2 = M$7.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$4, render: a2 };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a2 }, _init: T$5 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$5, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$5.transition;
  V$5.transition = {};
  try {
    a2();
  } finally {
    V$5.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$3.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$3.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$3.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$3.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e3) {
  return U$3.current.useImperativeHandle(a2, b2, e3);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$3.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$3.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$3.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e3) {
  return U$3.current.useReducer(a2, b2, e3);
};
react_production_min.useRef = function(a2) {
  return U$3.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$3.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e3) {
  return U$3.current.useSyncExternalStore(a2, b2, e3);
};
react_production_min.useTransition = function() {
  return U$3.current.useTransition();
};
react_production_min.version = "18.2.0";
(function(module2) {
  {
    module2.exports = react_production_min;
  }
})(react);
const React = /* @__PURE__ */ getDefaultExportFromCjs(react.exports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [react.exports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e3 = a2[d2];
        if (0 < g(e3, b2))
          a2[d2] = b2, a2[c2] = e3, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e3 = a2.length, w2 = e3 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g(C2, c2))
            n2 < e3 && 0 > g(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e3 && 0 > g(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e3 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c2 + e3;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e3, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e3, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
(function(module2) {
  {
    module2.exports = scheduler_production_min;
  }
})(scheduler);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, ca$1 = scheduler.exports;
function p$9(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$3(a2, b2, c2, d2, e3, f2, g) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e3;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g;
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$2[a2] = new v$3(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$2[b2] = new v$3(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$2[a2] = new v$3(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$2[b2] = new v$3(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$2.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$2[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e3 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  if (null !== e3 ? 0 !== e3.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e3, d2) && (c2 = null), d2 || null === e3 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e3.mustUseProperty ? a2[e3.propertyName] = null === c2 ? 3 === e3.type ? false : "" : c2 : (b2 = e3.attributeName, d2 = e3.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e3 = e3.type, c2 = 3 === e3 || 4 === e3 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$1 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g = e3.length - 1, h2 = f2.length - 1; 1 <= g && 0 <= h2 && e3[g] !== f2[h2]; )
        h2--;
      for (; 1 <= g && 0 <= h2; g--, h2--)
        if (e3[g] !== f2[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e3[g] !== f2[h2]) {
                var k2 = "\n" + e3[g].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e3 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb$1(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb$1(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb$1(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e3 = 0; e3 < c2.length; e3++)
      b2["$" + c2[e3]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e3 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e3 && (a2[c2].selected = e3), e3 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e3 = 0; e3 < a2.length; e3++) {
      if (a2[e3].value === c2) {
        a2[e3].selected = true;
        d2 && (a2[e3].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e3].disabled || (b2 = a2[e3]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$9(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$9(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$9(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e3);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e3 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e3) : a2[c2] = e3;
    }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$9(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$9(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$9(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$9(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$9(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$9(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e3, f2, g, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e3, f2, g, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e3, f2, g, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$9(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$9(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$9(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e3 = c2.return;
    if (null === e3)
      break;
    var f2 = e3.alternate;
    if (null === f2) {
      d2 = e3.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c2)
          return Xb(e3), a2;
        if (f2 === d2)
          return Xb(e3), b2;
        f2 = f2.sibling;
      }
      throw Error(p$9(188));
    }
    if (c2.return !== d2.return)
      c2 = e3, d2 = f2;
    else {
      for (var g = false, h2 = e3.child; h2; ) {
        if (h2 === c2) {
          g = true;
          c2 = e3;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g = true;
          d2 = e3;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g = true;
            c2 = f2;
            d2 = e3;
            break;
          }
          if (h2 === d2) {
            g = true;
            d2 = f2;
            c2 = e3;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g)
          throw Error(p$9(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$9(190));
  }
  if (3 !== c2.tag)
    throw Error(p$9(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca$1.unstable_scheduleCallback, bc = ca$1.unstable_cancelCallback, cc$1 = ca$1.unstable_shouldYield, dc = ca$1.unstable_requestPaint, B$1 = ca$1.unstable_now, ec = ca$1.unstable_getCurrentPriorityLevel, fc = ca$1.unstable_ImmediatePriority, gc = ca$1.unstable_UserBlockingPriority, hc = ca$1.unstable_NormalPriority, ic = ca$1.unstable_LowPriority, jc = ca$1.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e3 = a2.suspendedLanes, f2 = a2.pingedLanes, g = c2 & 268435455;
  if (0 !== g) {
    var h2 = g & ~e3;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g, 0 !== f2 && (d2 = tc(f2)));
  } else
    g = c2 & ~e3, 0 !== g ? d2 = tc(g) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e3) && (e3 = d2 & -d2, f2 = b2 & -b2, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e3 = 1 << c2, d2 |= a2[c2], b2 &= ~e3;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e3 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g = 31 - oc(f2), h2 = 1 << g, k2 = e3[g];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e3[g] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e3 = 31 - oc(c2), f2 = 1 << e3;
    b2[e3] = 0;
    d2[e3] = -1;
    a2[e3] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e3 = 1 << d2;
    e3 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e3;
  }
}
var C$3 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e3, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
  return a2;
}
function Uc(a2, b2, c2, d2, e3) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e3)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e3 = C$3, f2 = cd.transition;
  cd.transition = null;
  try {
    C$3 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$3 = e3, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e3 = C$3, f2 = cd.transition;
  cd.transition = null;
  try {
    C$3 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$3 = e3, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e3 = Yc(a2, b2, c2, d2);
    if (null === e3)
      hd(a2, b2, d2, id$1, c2), Sc(a2, d2);
    else if (Uc(e3, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$1, c2);
        if (f2 === e3)
          break;
        e3 = f2;
      }
      null !== e3 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id$1 = null;
function Yc(a2, b2, c2, d2) {
  id$1 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$1 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e3[a2]; a2++)
    ;
  var g = c2 - a2;
  for (d2 = 1; d2 <= g && b2[c2 - d2] === e3[f2 - d2]; d2++)
    ;
  return md = e3.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e3, f2, g) {
    this._reactName = b3;
    this._targetInst = e3;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be$4 = null;
ia && "documentMode" in document && (be$4 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$4, de$2 = ia && (!ae || be$4 && 8 < be$4 && 11 >= be$4), ee$2 = String.fromCharCode(32), fe$3 = false;
function ge$4(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$3(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$3(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$3 = true;
      return ee$2;
    case "textInput":
      return a2 = b2.data, a2 === ee$2 && fe$3 ? null : a2;
    default:
      return null;
  }
}
function ke$3(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge$4(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$2 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$3 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$3(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$3[a2.type] : "textarea" === b2 ? true : false;
}
function ne$3(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$2(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$2 = null, qe$2 = null;
function re$4(a2) {
  se$2(a2, 0);
}
function te$3(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
function ve$3(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$3 = false;
if (ia) {
  var xe$5;
  if (ia) {
    var ye$3 = "oninput" in document;
    if (!ye$3) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye$3 = "function" === typeof ze.oninput;
    }
    xe$5 = ye$3;
  } else
    xe$5 = false;
  we$3 = xe$5 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$4() {
  pe$2 && (pe$2.detachEvent("onpropertychange", Be$2), qe$2 = pe$2 = null);
}
function Be$2(a2) {
  if ("value" === a2.propertyName && te$3(qe$2)) {
    var b2 = [];
    ne$3(b2, qe$2, a2, xb(a2));
    Jb(re$4, b2);
  }
}
function Ce$4(a2, b2, c2) {
  "focusin" === a2 ? (Ae$4(), pe$2 = b2, qe$2 = c2, pe$2.attachEvent("onpropertychange", Be$2)) : "focusout" === a2 && Ae$4();
}
function De$3(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$3(qe$2);
}
function Ee$4(a2, b2) {
  if ("click" === a2)
    return te$3(b2);
}
function Fe$3(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$3(b2);
}
function Ge$2(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$2 = "function" === typeof Object.is ? Object.is : Ge$2;
function Ie$4(a2, b2) {
  if (He$2(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e3 = c2[d2];
    if (!ja.call(b2, e3) || !He$2(a2[e3], b2[e3]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke$1(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$4(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$4(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$5() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$4(a2) {
  var b2 = Me$5(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$4(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$1(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e3 = c2.textContent.length, f2 = Math.min(d2.start, e3);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e3);
        !a2.extend && f2 > d2 && (e3 = d2, d2 = f2, f2 = e3);
        e3 = Ke$1(c2, f2);
        var g = Ke$1(
          c2,
          d2
        );
        e3 && g && (1 !== a2.rangeCount || a2.anchorNode !== e3.node || a2.anchorOffset !== e3.offset || a2.focusNode !== g.node || a2.focusOffset !== g.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g.node, g.offset)) : (b2.setEnd(g.node, g.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$3 = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$5 = null, Se$4 = null, Te$2 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$2 || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$4 && Ie$4(Se$4, d2) || (Se$4 = d2, d2 = oe$2(Re$5, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$2 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We$2.animationend.animation, delete We$2.animationiteration.animation, delete We$2.animationstart.animation), "TransitionEvent" in window || delete We$2.transitionend.transition);
function Ze(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$2[a2])
    return a2;
  var b2 = We$2[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe$1[a2] = b2[c2];
  return a2;
}
var $e$1 = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$2(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e3 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g = d2.length - 1; 0 <= g; g--) {
          var h2 = d2[g], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
      else
        for (g = 0; g < d2.length; g++) {
          h2 = d2[g];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$3(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c2 = e3.bind(null, b2, c2, a2);
  e3 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
  d2 ? void 0 !== e3 ? a2.addEventListener(b2, c2, { capture: true, passive: e3 }) : a2.addEventListener(b2, c2, true) : void 0 !== e3 ? a2.addEventListener(b2, c2, { passive: e3 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e3) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g = d2.tag;
        if (3 === g || 4 === g) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e3 || 8 === h2.nodeType && h2.parentNode === e3)
            break;
          if (4 === g)
            for (g = d2.return; null !== g; ) {
              var k2 = g.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g.stateNode.containerInfo, k2 === e3 || 8 === k2.nodeType && k2.parentNode === e3)
                  return;
              }
              g = g.return;
            }
          for (; null !== h2; ) {
            g = Wc(h2);
            if (null === g)
              return;
            k2 = g.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e4 = xb(c2), g2 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e4), g2.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e4.window === e4 ? e4 : (h3 = e4.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e4);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e4) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e4), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g2, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$3;
        else if (me$3(h3))
          if (we$3)
            na = Fe$3;
          else {
            na = De$3;
            var xa = Ce$4;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$4);
        if (na && (na = na(a2, d3))) {
          ne$3(g2, na, c2, e4);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb$1(h3, "number", h3.value);
      }
      xa = d3 ? ue$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$3(xa) || "true" === xa.contentEditable)
            Qe = xa, Re$5 = d3, Se$4 = null;
          break;
        case "focusout":
          Se$4 = Re$5 = Qe = null;
          break;
        case "mousedown":
          Te$2 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$2 = false;
          Ue$1(g2, c2, e4);
          break;
        case "selectionchange":
          if (Pe$3)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g2, c2, e4);
      }
      var $a;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge$4(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$2 && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e4), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$3(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$2 ? je$1(a2, c2) : ke$3(a2, c2))
        d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c2, e4), g2.push({ event: e4, listeners: d3 }), e4.data = $a);
    }
    se$2(g2, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$2(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e3 = a2, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e3)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e3)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e3) {
  for (var f2 = b2._reactName, g = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e3 ? (k2 = Kb(c2, f2), null != k2 && g.unshift(tf(c2, k2, h2))) : e3 || (k2 = Kb(c2, f2), null != k2 && g.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g.length && a2.push({ event: b2, listeners: g });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$9(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e3 = c2.nextSibling;
    a2.removeChild(c2);
    if (e3 && 8 === e3.nodeType)
      if (c2 = e3.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e3);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e3;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$9(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c2)
    e3[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$1(Wf);
  E$1(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$9(168));
  G$1(H$2, b2);
  G$1(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e3 in d2)
    if (!(e3 in b2))
      throw Error(p$9(108, Ra(a2) || "Unknown", e3));
  return A$1({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$1(H$2, a2);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$9(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$2), G$1(H$2, a2)) : E$1(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$3;
    try {
      var c2 = eg;
      for (C$3 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e3;
    } finally {
      C$3 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e3 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e3);
  c2 += 1;
  var f2 = 32 - oc(b2) + e3;
  if (30 < f2) {
    var g = e3 - e3 % 5;
    f2 = (d2 & (1 << g) - 1).toString(32);
    d2 >>= g;
    e3 -= g;
    rg = 1 << 32 - oc(b2) + e3 | c2 << e3 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e3 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$4 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$4) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$9(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$4 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$9(418));
      a2.flags = a2.flags & -4097 | 2;
      I$4 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$4)
    return Fg(a2), I$4 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$9(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$9(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$4 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$1({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$1(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$9(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e3 = b2.interleaved;
  null === e3 ? (c2.next = c2, Xg(b2)) : (c2.next = e3.next, e3.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e3 = d2.pending;
    null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e3 = d2.interleaved;
  null === e3 ? (b2.next = b2, Xg(d2)) : (b2.next = e3.next, e3.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e3 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e3 = f2 = g : f2 = f2.next = g;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e3 = f2 = b2 : f2 = f2.next = b2;
    } else
      e3 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e3 = a2.updateQueue;
  $g = false;
  var f2 = e3.firstBaseUpdate, g = e3.lastBaseUpdate, h2 = e3.shared.pending;
  if (null !== h2) {
    e3.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g ? f2 = l2 : g.next = l2;
    g = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e3.baseState;
    g = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e3.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e3.baseState = k2;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m2;
    b2 = e3.shared.interleaved;
    if (null !== b2) {
      e3 = b2;
      do
        g |= e3.lane, e3 = e3.next;
      while (e3 !== b2);
    } else
      null === f2 && (e3.shared.lanes = 0);
    hh |= g;
    a2.lanes = g;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e3 = d2.callback;
      if (null !== e3) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e3)
          throw Error(p$9(191, e3));
        e3.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e3 = ch(c2, d2);
  e3.tag = 2;
  void 0 !== b2 && null !== b2 && (e3.callback = b2);
  b2 = dh(a2, e3, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e3, f2, g) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$4(c2, d2) || !Ie$4(e3, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e3 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e3 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e3) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e3, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e3 = a2.stateNode;
  e3.props = c2;
  e3.state = a2.memoizedState;
  e3.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e3.context = Yf(a2, f2));
  e3.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e3.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && nh.enqueueReplaceState(e3, e3.state, null), gh(a2, c2, e3, d2), e3.state = a2.memoizedState);
  "function" === typeof e3.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$9(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$9(147, a2));
      var e3 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e3.refs;
        b3 === jh && (b3 = e3.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$9(284));
    if (!c2._owner)
      throw Error(p$9(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$9(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh$1(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e3(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e3(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e4 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e4 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e4 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e4 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e4 = c3._init, r2(
            a3,
            b3,
            e4(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e4 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e4) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e4);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e4);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e4);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e4);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e4, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e4, g2, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e4, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e4, u2);
      g2 = f2(n3, g2, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e4, u2), I$4 && tg(e4, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e4, h3[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$4 && tg(e4, w2);
      return l3;
    }
    for (u2 = d2(e4, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e4, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$4 && tg(e4, w2);
    return l3;
  }
  function t2(e4, g2, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$9(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$9(151));
    for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e4, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e4, m3);
      g2 = f2(t3, g2, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e4,
        m3
      ), I$4 && tg(e4, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e4, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$4 && tg(e4, w2);
      return l3;
    }
    for (m3 = d2(e4, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e4, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$4 && tg(e4, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e3(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e3(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e3(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e3(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$9(174));
  return a2;
}
function Ih(a2, b2) {
  G$1(Gh, b2);
  G$1(Fh, a2);
  G$1(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E$1(Eh);
  E$1(Fh);
  E$1(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$1(Eh), E$1(Fh));
}
var M$6 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$3 = null, O$1 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$4() {
  throw Error(p$9(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$2(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e3, f2) {
  Rh = f2;
  N$3 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e3);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$9(301));
      f2 += 1;
      P$1 = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e3);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$1 = O$1 = N$3 = null;
  Sh = false;
  if (b2)
    throw Error(p$9(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N$3.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di() {
  if (null === O$1) {
    var a2 = N$3.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$1.next;
  var b2 = null === P$1 ? N$3.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$1 = a2;
  else {
    if (null === a2)
      throw Error(p$9(310));
    O$1 = a2;
    a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$1 ? N$3.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$9(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$1, e3 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g = e3.next;
      e3.next = f2.next;
      f2.next = g;
    }
    d2.baseQueue = e3 = f2;
    c2.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d2 = d2.baseState;
    var h2 = g = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g = d2) : k2 = k2.next = q2;
        N$3.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g = d2 : k2.next = h2;
    He$2(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e3 = a2;
    do
      f2 = e3.lane, N$3.lanes |= f2, hh |= f2, e3 = e3.next;
    while (e3 !== a2);
  } else
    null === e3 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$9(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e3 = c2.pending, f2 = b2.memoizedState;
  if (null !== e3) {
    c2.pending = null;
    var g = e3 = e3.next;
    do
      f2 = a2(f2, g.action), g = g.next;
    while (g !== e3);
    He$2(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$3, d2 = di(), e3 = b2(), f2 = !He$2(d2.memoizedState, e3);
  f2 && (d2.memoizedState = e3, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e3, b2), void 0, null);
    if (null === R)
      throw Error(p$9(349));
    0 !== (Rh & 30) || ni(c2, b2, e3);
  }
  return e3;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$3.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$2(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$3, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$3.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e3 = ci();
  N$3.flags |= a2;
  e3.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e3 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$1) {
    var g = O$1.memoizedState;
    f2 = g.destroy;
    if (null !== d2 && Wh(d2, g.deps)) {
      e3.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$3.flags |= a2;
  e3.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$2(c2, b2) || (c2 = yc(), N$3.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$3;
  C$3 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$3 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e3 = L$2();
    mh(c2, a2, d2, e3);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e3 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e3);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g = b2.lastRenderedState, h2 = f2(g, c2);
        e3.hasEagerState = true;
        e3.eagerState = h2;
        if (He$2(h2, g)) {
          var k2 = b2.interleaved;
          null === k2 ? (e3.next = e3, Xg(b2)) : (e3.next = k2.next, k2.next = e3);
          b2.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e3, d2);
    null !== c2 && (e3 = L$2(), mh(c2, a2, d2, e3), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$3 || null !== b2 && b2 === N$3;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$4, useContext: Q$4, useEffect: Q$4, useImperativeHandle: Q$4, useInsertionEffect: Q$4, useLayoutEffect: Q$4, useMemo: Q$4, useReducer: Q$4, useRef: Q$4, useState: Q$4, useDebugValue: Q$4, useDeferredValue: Q$4, useTransition: Q$4, useMutableSource: Q$4, useSyncExternalStore: Q$4, useId: Q$4, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$3, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$3, e3 = ci();
  if (I$4) {
    if (void 0 === c2)
      throw Error(p$9(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R)
      throw Error(p$9(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e3.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e3.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R.identifierPrefix;
  if (I$4) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$1 ? b2.memoizedState = a2 : Di(b2, O$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e3 = c2;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e3, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e3 = b2.value;
    c2.payload = function() {
      return d2(e3);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e3 = /* @__PURE__ */ new Set();
    d2.set(b2, e3);
  } else
    e3 = d2.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d2.set(b2, e3));
  e3.has(c2) || (e3.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e3) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e3;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e3) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e3);
  d2 = Xh(a2, b2, c2, d2, f2, e3);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i(a2, b2, e3);
  I$4 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e3);
  return b2.child;
}
function aj(a2, b2, c2, d2, e3) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e3);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e3);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e3)) {
    var g = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$4;
    if (c2(g, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e3);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e3) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$4(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e3))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e3);
  }
  return dj(a2, b2, c2, d2, e3);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a2, b2, e3, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e3) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e3);
  c2 = Xh(a2, b2, c2, d2, f2, e3);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i(a2, b2, e3);
  I$4 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e3);
  return b2.child;
}
function ij(a2, b2, c2, d2, e3) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e3);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e3), d2 = true;
  else if (null === a2) {
    var g = b2.stateNode, h2 = b2.memoizedProps;
    g.props = h2;
    var k2 = g.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g.state = r2;
    gh(b2, d2, g, e3);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g.props = d2, g.state = k2, g.context = l2, d2 = h2) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g.props = l2;
    q2 = b2.pendingProps;
    r2 = g.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g.state = r2;
    gh(b2, d2, g, e3);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d2, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g.componentDidUpdate && (b2.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g.props = d2, g.state = n2, g.context = k2, d2 = l2) : ("function" !== typeof g.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e3);
}
function kj(a2, b2, c2, d2, e3, f2) {
  hj(a2, b2);
  var g = 0 !== (b2.flags & 128);
  if (!d2 && !g)
    return e3 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e3 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e3) {
  Ig();
  Jg(e3);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = M$6.current, f2 = false, g = 0 !== (b2.flags & 128), h2;
  (h2 = g) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e3 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e3 |= 1;
  G$1(M$6, e3 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g = { mode: "hidden", children: g }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = qj(g, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g);
  }
  e3 = a2.memoizedState;
  if (null !== e3 && (h2 = e3.dehydrated, null !== h2))
    return sj(a2, b2, g, d2, h2, e3, c2);
  if (f2) {
    f2 = d2.fallback;
    g = b2.mode;
    e3 = a2.child;
    h2 = e3.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g & 1) && b2.child !== e3 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e3, k2), d2.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g = a2.child.memoizedState;
    g = null === g ? oj(c2) : { baseLanes: g.baseLanes | c2, cachePool: null, transitions: g.transitions };
    f2.memoizedState = g;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e3, f2, g) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$9(422))), tj(a2, b2, g, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e3 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e3, 0, null);
    f2 = Ah(f2, e3, g, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g);
    b2.child.memoizedState = oj(g);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g, null);
  if ("$!" === e3.data) {
    d2 = e3.nextSibling && e3.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$9(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g, d2);
  }
  h2 = 0 !== (g & a2.childLanes);
  if (Ug || h2) {
    d2 = R;
    if (null !== d2) {
      switch (g & -g) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d2.suspendedLanes | g)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, Zg(a2, e3), mh(d2, a2, e3, -1));
    }
    uj();
    d2 = Li(Error(p$9(421)));
    return tj(a2, b2, g, d2);
  }
  if ("$?" === e3.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e3._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b2;
  I$4 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e3) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e3 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e3);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$6.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$1(M$6, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c2 = b2.child;
        for (e3 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e3 = c2), c2 = c2.sibling;
        c2 = e3;
        null === c2 ? (e3 = b2.child, b2.child = null) : (e3 = c2.sibling, c2.sibling = null);
        xj(b2, false, e3, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e3 = b2.child;
        for (b2.child = null; null !== e3; ) {
          a2 = e3.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e3;
            break;
          }
          a2 = e3.sibling;
          e3.sibling = c2;
          c2 = e3;
          e3 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$9(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e3 = b2.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e3;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$6, M$6.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$1(M$6, M$6.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$1(M$6, M$6.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e3 = b2.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G$1(M$6, M$6.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e3 = a2.memoizedProps;
  if (e3 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e3 = Ya(a2, e3);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e3 = A$1({}, e3, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a2, e3);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g;
    c2 = null;
    for (l2 in e3)
      if (!d2.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2])
        if ("style" === l2) {
          var h2 = e3[l2];
          for (g in h2)
            h2.hasOwnProperty(g) && (c2 || (c2 = {}), c2[g] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e3 ? e3[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g in h2)
              !h2.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c2 || (c2 = {}), c2[g] = "");
            for (g in k2)
              k2.hasOwnProperty(g) && h2[g] !== k2[g] && (c2 || (c2 = {}), c2[g] = k2[g]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$3("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$4)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$3(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags & 14680064, d2 |= e3.flags & 14680064, e3.return = a2, e3 = e3.sibling;
  else
    for (e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags, d2 |= e3.flags, e3.return = a2, e3 = e3.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$3(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$3(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$1(Wf);
      E$1(H$2);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$3(b2);
      return null;
    case 5:
      Lh(b2);
      var e3 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e3), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$9(166));
          S$3(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$3("cancel", d2);
              D$3("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$3("load", d2);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++)
                D$3(lf[e3], d2);
              break;
            case "source":
              D$3("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$3(
                "error",
                d2
              );
              D$3("load", d2);
              break;
            case "details":
              D$3("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$3("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$3("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$3("invalid", d2);
          }
          ub(c2, f2);
          e3 = null;
          for (var g in f2)
            if (f2.hasOwnProperty(g)) {
              var h2 = f2[g];
              "children" === g ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e3 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e3 = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D$3("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e3;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g.createElement(c2, { is: d2.is }) : (a2 = g.createElement(c2), "select" === c2 && (g = a2, d2.multiple ? g.multiple = true : d2.size && (g.size = d2.size))) : a2 = g.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$3("cancel", a2);
                D$3("close", a2);
                e3 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$3("load", a2);
                e3 = d2;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++)
                  D$3(lf[e3], a2);
                e3 = d2;
                break;
              case "source":
                D$3("error", a2);
                e3 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$3(
                  "error",
                  a2
                );
                D$3("load", a2);
                e3 = d2;
                break;
              case "details":
                D$3("toggle", a2);
                e3 = d2;
                break;
              case "input":
                Za(a2, d2);
                e3 = Ya(a2, d2);
                D$3("invalid", a2);
                break;
              case "option":
                e3 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e3 = A$1({}, d2, { value: void 0 });
                D$3("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e3 = gb(a2, d2);
                D$3("invalid", a2);
                break;
              default:
                e3 = d2;
            }
            ub(c2, e3);
            h2 = e3;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$3("scroll", a2) : null != k2 && ta(a2, f2, k2, g));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$3(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$9(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$3(b2);
      return null;
    case 13:
      E$1(M$6);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$4 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$9(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$9(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$3(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$6.current & 1) ? 0 === T$4 && (T$4 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$3(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$3(b2), null;
    case 10:
      return Rg(b2.type._context), S$3(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$3(b2), null;
    case 19:
      E$1(M$6);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$3(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g = f2.rendering;
      if (null === g)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$4 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g = Mh(a2);
              if (null !== g) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a2 = g.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$1(M$6, M$6.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$1() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I$4)
              return S$3(b2), null;
          } else
            2 * B$1() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g.sibling = b2.child, b2.child = g) : (c2 = f2.last, null !== c2 ? c2.sibling = g : b2.child = g, f2.last = g);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$1(), b2.sibling = null, c2 = M$6.current, G$1(M$6, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$3(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$3(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$3(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$9(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$1(M$6);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$9(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(M$6), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$2 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$4 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$5();
  if (Ne$1(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e3 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e3 && 3 !== q2.nodeType || (h2 = g + e3);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g + d2);
                3 === q2.nodeType && (g += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e3 && (h2 = g);
                r2 === f2 && ++m2 === d2 && (k2 = g);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$4 = b2; null !== V$4; )
    if (b2 = V$4, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$4 = a2;
    else
      for (; null !== V$4; ) {
        b2 = V$4;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$9(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$4 = a2;
          break;
        }
        V$4 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e3 = d2 = d2.next;
    do {
      if ((e3.tag & a2) === a2) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e3 = e3.next;
    } while (e3 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$2 || Mj(c2, b2);
    case 6:
      var d2 = X$1, e3 = Yj;
      X$1 = null;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e3;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e3 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$2 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e3 = d2 = d2.next;
        do {
          var f2 = e3, g = f2.destroy;
          f2 = f2.tag;
          void 0 !== g && (0 !== (f2 & 2) ? Nj(c2, b2, g) : 0 !== (f2 & 4) && Nj(c2, b2, g));
          e3 = e3.next;
        } while (e3 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$2 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$2 = (d2 = U$2) || null !== c2.memoizedState, Zj(a2, b2, c2), U$2 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e3 = c2[d2];
      try {
        var f2 = a2, g = b2, h2 = g;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$9(160));
        ak(f2, g, e3);
        X$1 = null;
        Yj = false;
        var k2 = e3.alternate;
        null !== k2 && (k2.return = null);
        e3.return = null;
      } catch (l2) {
        W$1(e3, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e3 = a2.stateNode;
        try {
          ob(e3, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e3 = a2.stateNode, null != e3)) {
        var f2 = a2.memoizedProps, g = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h2, g);
            var l2 = vb(h2, f2);
            for (g = 0; g < k2.length; g += 2) {
              var m2 = k2[g], q2 = k2[g + 1];
              "style" === m2 ? sb(e3, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e3, q2) : "children" === m2 ? ob(e3, q2) : ta(e3, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r2 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e3, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$9(162));
        e3 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e3 = a2.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (gk = B$1()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$2 = (l2 = U$2) || m2, dk(b2, a2), U$2 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$4 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$4 = m2; null !== V$4; ) {
              r2 = V$4;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$4 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e3 = q2.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$9(160));
      }
      switch (d2.tag) {
        case 5:
          var e3 = d2.stateNode;
          d2.flags & 32 && (ob(e3, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e3);
          break;
        case 3:
        case 4:
          var g = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g);
          break;
        default:
          throw Error(p$9(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$4 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$4; ) {
    var e3 = V$4, f2 = e3.child;
    if (22 === e3.tag && d2) {
      var g = null !== e3.memoizedState || Kj;
      if (!g) {
        var h2 = e3.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$2;
        h2 = Kj;
        var l2 = U$2;
        Kj = g;
        if ((U$2 = k2) && !l2)
          for (V$4 = e3; null !== V$4; )
            g = V$4, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e3) : null !== k2 ? (k2.return = g, V$4 = k2) : kk(e3);
        for (; null !== f2; )
          V$4 = f2, jk(f2), f2 = f2.sibling;
        V$4 = e3;
        Kj = h2;
        U$2 = l2;
      }
      lk(a2);
    } else
      0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V$4 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$2 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$2)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e3 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e3, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g = b2.updateQueue;
              if (null !== g) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$9(163));
          }
        U$2 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e3 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e3, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$4 = h2;
      break;
    }
    V$4 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$4 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return 0 !== (K$1 & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$3;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$9(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R)
    a2 === R && (0 === (K$1 & 2) && (rk |= c2), 4 === T$4 && Dk(a2, Z$1)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$1() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R ? Z$1 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$9(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R ? Z$1 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e3 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R !== a2 || Z$1 !== b2)
      vk = null, Hj = B$1() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e3;
    null !== Y$1 ? b2 = 0 : (R = null, Z$1 = 0, b2 = T$4);
  }
  if (0 !== b2) {
    2 === b2 && (e3 = xc(a2), 0 !== e3 && (d2 = e3, b2 = Ok(a2, e3)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e3 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e3) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
      a2.finishedWork = e3;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$9(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$1(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e3 = a2.suspendedLanes;
            if ((e3 & d2) !== d2) {
              L$2();
              a2.pingedLanes |= a2.suspendedLanes & e3;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e3 = -1; 0 < d2; ) {
            var g = 31 - oc(d2);
            f2 = 1 << g;
            g = b2[g];
            g > e3 && (e3 = g);
            d2 &= ~f2;
          }
          d2 = e3;
          d2 = B$1() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$9(329));
      }
    }
  }
  Ek(a2, B$1());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e3 = c2[d2], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He$2(f2(), e3))
              return false;
          } catch (g) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$9(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$1()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$1()), c2;
  if (6 === c2)
    throw Error(p$9(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$1());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$1() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$3;
  try {
    if (pk.transition = null, C$3 = 1, a2)
      return a2();
  } finally {
    C$3 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$1(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$1(Wf);
          E$1(H$2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$6);
          break;
        case 19:
          E$1(M$6);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$1 = gj = b2;
  T$4 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e3 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g = f2.next;
          f2.next = e3;
          d2.next = g;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$3.memoizedState; null !== d2; ) {
          var e3 = d2.queue;
          null !== e3 && (e3.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$1 = N$3 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$4 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$9(426));
          }
        } else if (I$4 && h2.mode & 1) {
          var J2 = Vi(g);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$4 && (T$4 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$4 || 3 === T$4 || 2 === T$4)
    T$4 = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z$1);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R !== a2 || Z$1 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e3) {
      Nk(a2, e3);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$9(261));
  R = null;
  Z$1 = 0;
  return T$4;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc$1(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$4 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$4 && (T$4 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$3, e3 = pk.transition;
  try {
    pk.transition = null, C$3 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e3, C$3 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$9(327));
  c2 = a2.finishedWork;
  var e3 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$9(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R && (Y$1 = R = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g = C$3;
    C$3 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$4(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$3 = g;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e3);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$1());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e3 = b2[c2], d2(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$3;
    try {
      pk.transition = null;
      C$3 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$9(331));
        var e3 = K$1;
        K$1 |= 4;
        for (V$4 = a2.current; null !== V$4; ) {
          var f2 = V$4, g = f2.child;
          if (0 !== (V$4.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$4 = l2; null !== V$4; ) {
                  var m2 = V$4;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$4 = q2;
                  else
                    for (; null !== V$4; ) {
                      m2 = V$4;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$4 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$4 = r2;
                        break;
                      }
                      V$4 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$4 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g)
            g.return = f2, V$4 = g;
          else
            b:
              for (; null !== V$4; ) {
                f2 = V$4;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$4 = x2;
                  break b;
                }
                V$4 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$4 = w2; null !== V$4; ) {
          g = V$4;
          var u2 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u2)
            u2.return = g, V$4 = u2;
          else
            b:
              for (g = w2; null !== V$4; ) {
                h2 = V$4;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g) {
                  V$4 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$4 = F2;
                  break b;
                }
                V$4 = h2.return;
              }
        }
        K$1 = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$3 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$2();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$2();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R === a2 && (Z$1 & c2) === c2 && (4 === T$4 || 3 === T$4 && (Z$1 & 130023424) === Z$1 && 500 > B$1() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$2();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e3 = a2.memoizedState;
      null !== e3 && (c2 = e3.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$9(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$4 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e3 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e3 = Xh(null, b2, d2, a2, e3, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, ah(b2), e3.updater = nh, b2.stateNode = e3, e3._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$4 && f2 && vg(b2), Yi(null, b2, e3, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e3 = d2._init;
        d2 = e3(d2._payload);
        b2.type = d2;
        e3 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e3) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$9(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), dj(a2, b2, d2, e3, c2);
    case 1:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), ij(a2, b2, d2, e3, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$9(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e3 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g = b2.memoizedState;
        d2 = g.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e3 = Ki(Error(p$9(423)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else if (d2 !== e3) {
            e3 = Ki(Error(p$9(424)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$4 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e3) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e3 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g = e3.children, Ef(d2, e3) ? g = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), Zi(a2, b2, d2, e3, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e3 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g = e3.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g;
        if (null !== f2)
          if (He$2(f2.value, g)) {
            if (f2.children === e3.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g = f2.return;
                if (null === g)
                  throw Error(p$9(341));
                g.lanes |= c2;
                h2 = g.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g, c2, b2);
                g = f2.sibling;
              } else
                g = f2.child;
              if (null !== g)
                g.return = f2;
              else
                for (g = f2; null !== g; ) {
                  if (g === b2) {
                    g = null;
                    break;
                  }
                  f2 = g.sibling;
                  if (null !== f2) {
                    f2.return = g.return;
                    g = f2;
                    break;
                  }
                  g = g.return;
                }
              f2 = g;
            }
        Yi(a2, b2, e3.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e3 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e3 = Vg(e3), d2 = d2(e3), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e3 = Lg(d2, b2.pendingProps), e3 = Lg(d2.type, e3), aj(a2, b2, d2, e3, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e3), rh(b2, d2, e3, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$9(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e3, f2) {
  var g = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g = 1);
  else if ("string" === typeof a2)
    g = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e3, f2, b2);
        case za:
          g = 8;
          e3 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e3 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e3), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e3), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e3, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d2 = null;
                break a;
            }
          throw Error(p$9(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g, c2, b2, e3);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e3) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e3, f2, g, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$9(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$9(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e3, f2, g, h2, k2) {
  a2 = cl(c2, d2, true, a2, e3, f2, g, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$2();
  e3 = lh(c2);
  f2 = ch(d2, e3);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e3);
  a2.current.lanes = e3;
  Ac(a2, e3, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e3 = b2.current, f2 = L$2(), g = lh(e3);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e3, b2, g);
  null !== a2 && (mh(a2, e3, g, f2), eh(a2, e3, g));
  return g;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$9(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e3) {
  if (e3) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g);
        f2.call(a3);
      };
    }
    var g = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g;
    a2[uf] = g.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g;
  }
  for (; e3 = a2.lastChild; )
    a2.removeChild(e3);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e3) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g = f2;
    if ("function" === typeof e3) {
      var h2 = e3;
      e3 = function() {
        var a3 = hl(g);
        h2.call(a3);
      };
    }
    gl(b2, g, a2, e3);
  } else
    g = rl(c2, b2, a2, e3, d2);
  return hl(g);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$1()), 0 === (K$1 & 6) && (Hj = B$1() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$3;
};
Ic = function(a2, b2) {
  var c2 = C$3;
  try {
    return C$3 = a2, b2();
  } finally {
    C$3 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e3 = Db(d2);
            if (!e3)
              throw Error(p$9(90));
            Wa(d2);
            bb(d2, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$9(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$9(299));
  var c2 = false, d2 = "", e3 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e3);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$9(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$9(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$9(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$9(405));
  var d2 = null != c2 && c2.hydratedSources || null, e3 = false, f2 = "", g = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e3 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e3, false, f2, g);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e3 = c2._getVersion, e3 = e3(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e3] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e3
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$9(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$9(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$9(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$9(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
(function(module2) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module2.exports = reactDom_production_min;
  }
})(reactDom);
var m$6 = reactDom.exports;
{
  client.createRoot = m$6.createRoot;
  client.hydrateRoot = m$6.hydrateRoot;
}
/**
 * @remix-run/router v1.0.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$1({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  function handlePop() {
    action = Action.Pop;
    if (listener) {
      listener({
        action,
        location: history.location
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location
      });
    }
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(branches[i2], pathname);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route, index2) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$2(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$2(
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? a2[a2.length - 1] - b2[b2.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo2, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo2[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning$1(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning$1(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant$2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e3) {
    }
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$1({}, toArg);
    invariant$2(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant$2(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant$2(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
class ErrorResponse {
  constructor(status, statusText, data2) {
    this.status = status;
    this.statusText = statusText || "";
    this.data = data2;
  }
}
function isRouteErrorResponse(e3) {
  return e3 instanceof ErrorResponse;
}
var jsxRuntime$1 = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$4 = react.exports, k$3 = Symbol.for("react.element"), l$7 = Symbol.for("react.fragment"), m$5 = Object.prototype.hasOwnProperty, n$6 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$8 = { key: true, ref: true, __self: true, __source: true };
function q$5(c2, a2, g) {
  var b2, d2 = {}, e3 = null, h2 = null;
  void 0 !== g && (e3 = "" + g);
  void 0 !== a2.key && (e3 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$5.call(a2, b2) && !p$8.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$3, type: c2, key: e3, ref: h2, props: d2, _owner: n$6.current };
}
reactJsxRuntime_production_min.Fragment = l$7;
reactJsxRuntime_production_min.jsx = q$5;
reactJsxRuntime_production_min.jsxs = q$5;
(function(module2) {
  {
    module2.exports = reactJsxRuntime_production_min;
  }
})(jsxRuntime$1);
const Fragment = jsxRuntime$1.exports.Fragment;
const jsx = jsxRuntime$1.exports.jsx;
const jsxs = jsxRuntime$1.exports.jsxs;
const jsxRuntime = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Fragment,
  jsx,
  jsxs
}, Symbol.toStringTag, { value: "Module" }));
/**
 * React Router v6.4.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
const is = typeof Object.is === "function" ? Object.is : isPolyfill;
const {
  useState,
  useEffect,
  useLayoutEffect: useLayoutEffect$1,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe, getSnapshot, getServerSnapshot) {
  const value = getSnapshot();
  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  });
  useLayoutEffect$1(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged$1(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    if (checkIfSnapshotChanged$1(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged$1(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe(handleStoreChange);
  }, [subscribe]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged$1(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM$1;
const shim$1 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 ? ((module2) => module2.useSyncExternalStore)(React$1) : shim$1;
const DataStaticRouterContext = /* @__PURE__ */ react.exports.createContext(null);
const DataRouterContext = /* @__PURE__ */ react.exports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ react.exports.createContext(null);
const NavigationContext = /* @__PURE__ */ react.exports.createContext(null);
const LocationContext = /* @__PURE__ */ react.exports.createContext(null);
const RouteContext = /* @__PURE__ */ react.exports.createContext({
  outlet: null,
  matches: []
});
const RouteErrorContext = /* @__PURE__ */ react.exports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant$2(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return react.exports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$2(false) : void 0;
  return react.exports.useContext(LocationContext).location;
}
function useMatch(pattern) {
  !useInRouterContext() ? invariant$2(false) : void 0;
  let {
    pathname
  } = useLocation();
  return react.exports.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || !match2.route.index && match2.pathnameBase !== matches[index2 - 1].pathnameBase);
}
function useNavigate() {
  !useInRouterContext() ? invariant$2(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.exports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return react.exports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant$2(false) : void 0;
  let dataRouterStateContext = react.exports.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = react.exports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$2(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([parentPathnameBase, match2.pathname]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
  })), parentMatches, dataRouterStateContext || void 0);
  if (locationArg) {
    return /* @__PURE__ */ jsx(LocationContext.Provider, {
      value: {
        location: _extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      },
      children: renderedMatches
    });
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("h2", {
      children: "Unhandled Thrown Error!"
    }), /* @__PURE__ */ jsx("h3", {
      style: {
        fontStyle: "italic"
      },
      children: message
    }), stack ? /* @__PURE__ */ jsx("pre", {
      style: preStyles,
      children: stack
    }) : null, /* @__PURE__ */ jsx("p", {
      children: "\u{1F4BF} Hey developer \u{1F44B}"
    }), /* @__PURE__ */ jsxs("p", {
      children: ["You can provide a way better UX than this when your app throws errors by providing your own\xA0", /* @__PURE__ */ jsx("code", {
        style: codeStyles,
        children: "errorElement"
      }), " props on\xA0", /* @__PURE__ */ jsx("code", {
        style: codeStyles,
        children: "<Route>"
      })]
    })]
  });
}
class RenderErrorBoundary extends react.exports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ jsx(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataStaticRouterContext = react.exports.useContext(DataStaticRouterContext);
  if (dataStaticRouterContext && match2.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ jsx(RouteContext.Provider, {
    value: routeContext,
    children
  });
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors2 = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors2 != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors2 == null ? void 0 : errors2[m2.route.id]));
    !(errorIndex >= 0) ? invariant$2(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error = match2.route.id ? errors2 == null ? void 0 : errors2[match2.route.id] : null;
    let errorElement = dataRouterState ? match2.route.errorElement || /* @__PURE__ */ jsx(DefaultErrorElement, {}) : null;
    let getChildren = () => /* @__PURE__ */ jsx(RenderedRoute, {
      match: match2,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index2 + 1))
      },
      children: error ? errorElement : match2.route.element !== void 0 ? match2.route.element : outlet
    });
    return dataRouterState && (match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ jsx(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error,
      children: getChildren()
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = react.exports.useContext(DataRouterStateContext);
  !state ? invariant$2(false) : void 0;
  return state;
}
function useRouteError() {
  var _state$errors;
  let error = react.exports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let route = react.exports.useContext(RouteContext);
  let thisRoute = route.matches[route.matches.length - 1];
  if (error) {
    return error;
  }
  !route ? invariant$2(false) : void 0;
  !thisRoute.route.id ? invariant$2(false) : void 0;
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
}
function Route(_props) {
  invariant$2(false);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? invariant$2(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react.exports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = react.exports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash: hash2,
      state,
      key
    };
  }, [basename, pathname, search, hash2, state, key]);
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ jsx(NavigationContext.Provider, {
    value: navigationContext,
    children: /* @__PURE__ */ jsx(LocationContext.Provider, {
      children,
      value: {
        location,
        navigationType
      }
    })
  });
}
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = react.exports.useContext(DataRouterContext);
  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  react.exports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ react.exports.isValidElement(element)) {
      return;
    }
    if (element.type === react.exports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ? invariant$2(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$2(false) : void 0;
    let treePath = [...parentPath, index2];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.4.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event);
}
const _excluded$2 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window: window2
  } = _ref;
  let historyRef = react.exports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react.exports.useState({
    action: history.action,
    location: history.location
  });
  react.exports.useLayoutEffect(() => history.listen(setState), [history]);
  return /* @__PURE__ */ jsx(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
const Link = /* @__PURE__ */ react.exports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose$1(_ref4, _excluded$2);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ jsx("a", {
    ...rest,
    href,
    onClick: reloadDocument ? onClick : handleClick,
    ref,
    target
  });
});
const NavLink = /* @__PURE__ */ react.exports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose$1(_ref5, _excluded2);
  let path = useResolvedPath(to);
  let match2 = useMatch({
    path: path.pathname,
    end,
    caseSensitive
  });
  let routerState = react.exports.useContext(DataRouterStateContext);
  let nextLocation = routerState == null ? void 0 : routerState.navigation.location;
  let nextPath = useResolvedPath(nextLocation || "");
  let nextMatch = react.exports.useMemo(() => nextLocation ? matchPath({
    path: path.pathname,
    end,
    caseSensitive
  }, nextPath.pathname) : null, [nextLocation, path.pathname, caseSensitive, end, nextPath.pathname]);
  let isPending = nextMatch != null;
  let isActive = match2 != null;
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ jsx(Link, {
    ...rest,
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to,
    children: typeof children === "function" ? children({
      isActive,
      isPending
    }) : children
  });
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return react.exports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
function ArrowLongRightIcon$4({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M17.25 8.25L21 12m0 0l-3.75 3.75M21 12H3"
    })]
  });
}
const ForwardRef$i = react.exports.forwardRef(ArrowLongRightIcon$4);
const ArrowLongRightIcon$5 = ForwardRef$i;
function Bars3Icon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
    })]
  });
}
const ForwardRef$h = react.exports.forwardRef(Bars3Icon);
const Bars3Icon$1 = ForwardRef$h;
function CheckCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
    })]
  });
}
const ForwardRef$g = react.exports.forwardRef(CheckCircleIcon);
const CheckCircleIcon$1 = ForwardRef$g;
function CogIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M4.5 12a7.5 7.5 0 0015 0m-15 0a7.5 7.5 0 1115 0m-15 0H3m16.5 0H21m-1.5 0H12m-8.457 3.077l1.41-.513m14.095-5.13l1.41-.513M5.106 17.785l1.15-.964m11.49-9.642l1.149-.964M7.501 19.795l.75-1.3m7.5-12.99l.75-1.3m-6.063 16.658l.26-1.477m2.605-14.772l.26-1.477m0 17.726l-.26-1.477M10.698 4.614l-.26-1.477M16.5 19.794l-.75-1.299M7.5 4.205L12 12m6.894 5.785l-1.149-.964M6.256 7.178l-1.15-.964m15.352 8.864l-1.41-.513M4.954 9.435l-1.41-.514M12.002 12l-3.75 6.495"
    })]
  });
}
const ForwardRef$f = react.exports.forwardRef(CogIcon);
const CogIcon$1 = ForwardRef$f;
function EllipsisVerticalIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M12 6.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 12.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 18.75a.75.75 0 110-1.5.75.75 0 010 1.5z"
    })]
  });
}
const ForwardRef$e = react.exports.forwardRef(EllipsisVerticalIcon);
const EllipsisVerticalIcon$1 = ForwardRef$e;
function LockClosedIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z"
    })]
  });
}
const ForwardRef$d = react.exports.forwardRef(LockClosedIcon);
const LockClosedIcon$1 = ForwardRef$d;
function XMarkIcon$2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M6 18L18 6M6 6l12 12"
    })]
  });
}
const ForwardRef$c = react.exports.forwardRef(XMarkIcon$2);
const XMarkIcon$3 = ForwardRef$c;
const e$4 = typeof window == "undefined" || typeof document == "undefined";
let s$a = e$4 ? react.exports.useEffect : react.exports.useLayoutEffect;
function s$9(e3) {
  let r2 = react.exports.useRef(e3);
  return s$a(() => {
    r2.current = e3;
  }, [e3]), r2;
}
function i$4(e3, o2) {
  let [u2, t2] = react.exports.useState(e3), r2 = s$9(e3);
  return s$a(() => t2(r2.current), [r2, t2, ...o2]), u2;
}
function t$2(e3) {
  typeof queueMicrotask == "function" ? queueMicrotask(e3) : Promise.resolve().then(e3).catch((o2) => setTimeout(() => {
    throw o2;
  }));
}
function m$4() {
  let n2 = [], i2 = [], r2 = { enqueue(e3) {
    i2.push(e3);
  }, addEventListener(e3, t2, a2, o2) {
    return e3.addEventListener(t2, a2, o2), r2.add(() => e3.removeEventListener(t2, a2, o2));
  }, requestAnimationFrame(...e3) {
    let t2 = requestAnimationFrame(...e3);
    return r2.add(() => cancelAnimationFrame(t2));
  }, nextFrame(...e3) {
    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e3));
  }, setTimeout(...e3) {
    let t2 = setTimeout(...e3);
    return r2.add(() => clearTimeout(t2));
  }, microTask(...e3) {
    let t2 = { current: true };
    return t$2(() => {
      t2.current && e3[0]();
    }), r2.add(() => {
      t2.current = false;
    });
  }, add(e3) {
    return n2.push(e3), () => {
      let t2 = n2.indexOf(e3);
      if (t2 >= 0) {
        let [a2] = n2.splice(t2, 1);
        a2();
      }
    };
  }, dispose() {
    for (let e3 of n2.splice(0))
      e3();
  }, async workQueue() {
    for (let e3 of i2.splice(0))
      await e3();
  } };
  return r2;
}
function p$7() {
  let [e3] = react.exports.useState(m$4);
  return react.exports.useEffect(() => () => e3.dispose(), [e3]), e3;
}
let o$4 = function(t2) {
  let e3 = s$9(t2);
  return React.useCallback((...r2) => e3.current(...r2), [e3]);
};
let r$6 = { serverHandoffComplete: false };
function a$5() {
  let [e3, f2] = react.exports.useState(r$6.serverHandoffComplete);
  return react.exports.useEffect(() => {
    e3 !== true && f2(true);
  }, [e3]), react.exports.useEffect(() => {
    r$6.serverHandoffComplete === false && (r$6.serverHandoffComplete = true);
  }, []), e3;
}
var u$7;
let l$6 = 0;
function r$5() {
  return ++l$6;
}
let I$3 = (u$7 = React.useId) != null ? u$7 : function() {
  let n2 = a$5(), [e3, o2] = React.useState(n2 ? r$5 : null);
  return s$a(() => {
    e3 === null && o2(r$5());
  }, [e3]), e3 != null ? "" + e3 : void 0;
};
function u$6(r2, n2, ...a2) {
  if (r2 in n2) {
    let e3 = n2[r2];
    return typeof e3 == "function" ? e3(...a2) : e3;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e3) => `"${e3}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$6), t2;
}
function e$3(r2) {
  return e$4 ? null : r2 instanceof Node ? r2.ownerDocument : r2 != null && r2.hasOwnProperty("current") && r2.current instanceof Node ? r2.current.ownerDocument : document;
}
let m$3 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e3) => `${e3}:not([tabindex='-1'])`).join(",");
var T$3 = ((n2) => (n2[n2.First = 1] = "First", n2[n2.Previous = 2] = "Previous", n2[n2.Next = 4] = "Next", n2[n2.Last = 8] = "Last", n2[n2.WrapAround = 16] = "WrapAround", n2[n2.NoScroll = 32] = "NoScroll", n2))(T$3 || {}), M$5 = ((o2) => (o2[o2.Error = 0] = "Error", o2[o2.Overflow = 1] = "Overflow", o2[o2.Success = 2] = "Success", o2[o2.Underflow = 3] = "Underflow", o2))(M$5 || {}), b$1 = ((r2) => (r2[r2.Previous = -1] = "Previous", r2[r2.Next = 1] = "Next", r2))(b$1 || {});
function d$2(e3 = document.body) {
  return e3 == null ? [] : Array.from(e3.querySelectorAll(m$3));
}
var N$2 = ((r2) => (r2[r2.Strict = 0] = "Strict", r2[r2.Loose = 1] = "Loose", r2))(N$2 || {});
function F$6(e3, t2 = 0) {
  var r2;
  return e3 === ((r2 = e$3(e3)) == null ? void 0 : r2.body) ? false : u$6(t2, { [0]() {
    return e3.matches(m$3);
  }, [1]() {
    let l2 = e3;
    for (; l2 !== null; ) {
      if (l2.matches(m$3))
        return true;
      l2 = l2.parentElement;
    }
    return false;
  } });
}
function I$2(e3) {
  let t2 = e$3(e3);
  m$4().nextFrame(() => {
    t2 && !F$6(t2.activeElement, 0) && h$6(e3);
  });
}
function h$6(e3) {
  e3 == null || e3.focus({ preventScroll: true });
}
let w$5 = ["textarea", "input"].join(",");
function H$1(e3) {
  var t2, r2;
  return (r2 = (t2 = e3 == null ? void 0 : e3.matches) == null ? void 0 : t2.call(e3, w$5)) != null ? r2 : false;
}
function S$2(e3, t2 = (r2) => r2) {
  return e3.slice().sort((r2, l2) => {
    let o2 = t2(r2), s2 = t2(l2);
    if (o2 === null || s2 === null)
      return 0;
    let n2 = o2.compareDocumentPosition(s2);
    return n2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function D$2(e3, t2) {
  return O(d$2(), t2, true, e3);
}
function O(e3, t2, r2 = true, l2 = null) {
  let o2 = Array.isArray(e3) ? e3.length > 0 ? e3[0].ownerDocument : document : e3.ownerDocument, s2 = Array.isArray(e3) ? r2 ? S$2(e3) : e3 : d$2(e3);
  l2 = l2 != null ? l2 : o2.activeElement;
  let n2 = (() => {
    if (t2 & 5)
      return 1;
    if (t2 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), E2 = (() => {
    if (t2 & 1)
      return 0;
    if (t2 & 2)
      return Math.max(0, s2.indexOf(l2)) - 1;
    if (t2 & 4)
      return Math.max(0, s2.indexOf(l2)) + 1;
    if (t2 & 8)
      return s2.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x2 = t2 & 32 ? { preventScroll: true } : {}, f2 = 0, i2 = s2.length, u2;
  do {
    if (f2 >= i2 || f2 + i2 <= 0)
      return 0;
    let a2 = E2 + f2;
    if (t2 & 16)
      a2 = (a2 + i2) % i2;
    else {
      if (a2 < 0)
        return 3;
      if (a2 >= i2)
        return 1;
    }
    u2 = s2[a2], u2 == null || u2.focus(x2), f2 += n2;
  } while (u2 !== o2.activeElement);
  return t2 & 6 && H$1(u2) && u2.select(), u2.hasAttribute("tabindex") || u2.setAttribute("tabindex", "0"), 2;
}
function d$1(e3, r2, n2) {
  let o2 = s$9(r2);
  react.exports.useEffect(() => {
    function t2(u2) {
      o2.current(u2);
    }
    return document.addEventListener(e3, t2, n2), () => document.removeEventListener(e3, t2, n2);
  }, [e3, n2]);
}
function L$1(s2, E2, a2 = true) {
  let i2 = react.exports.useRef(false);
  react.exports.useEffect(() => {
    requestAnimationFrame(() => {
      i2.current = a2;
    });
  }, [a2]);
  function f2(e3, l2) {
    if (!i2.current || e3.defaultPrevented)
      return;
    let o2 = function r2(t2) {
      return typeof t2 == "function" ? r2(t2()) : Array.isArray(t2) || t2 instanceof Set ? t2 : [t2];
    }(s2), n2 = l2(e3);
    if (n2 !== null && !!n2.ownerDocument.documentElement.contains(n2)) {
      for (let r2 of o2) {
        if (r2 === null)
          continue;
        let t2 = r2 instanceof HTMLElement ? r2 : r2.current;
        if (t2 != null && t2.contains(n2))
          return;
      }
      return !F$6(n2, N$2.Loose) && n2.tabIndex !== -1 && e3.preventDefault(), E2(e3, n2);
    }
  }
  let u2 = react.exports.useRef(null);
  d$1("mousedown", (e3) => {
    var l2, o2;
    i2.current && (u2.current = ((o2 = (l2 = e3.composedPath) == null ? void 0 : l2.call(e3)) == null ? void 0 : o2[0]) || e3.target);
  }, true), d$1("click", (e3) => {
    !u2.current || (f2(e3, () => u2.current), u2.current = null);
  }, true), d$1("blur", (e3) => f2(e3, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
function i$3(t2) {
  var n2;
  if (t2.type)
    return t2.type;
  let e3 = (n2 = t2.as) != null ? n2 : "button";
  if (typeof e3 == "string" && e3.toLowerCase() === "button")
    return "button";
}
function s$8(t2, e3) {
  let [n2, u2] = react.exports.useState(() => i$3(t2));
  return s$a(() => {
    u2(i$3(t2));
  }, [t2.type, t2.as]), s$a(() => {
    n2 || !e3.current || e3.current instanceof HTMLButtonElement && !e3.current.hasAttribute("type") && u2("button");
  }, [n2, e3]), n2;
}
let u$5 = Symbol();
function T$2(t2, n2 = true) {
  return Object.assign(t2, { [u$5]: n2 });
}
function y(...t2) {
  let n2 = react.exports.useRef(t2);
  react.exports.useEffect(() => {
    n2.current = t2;
  }, [t2]);
  let c2 = o$4((e3) => {
    for (let o2 of n2.current)
      o2 != null && (typeof o2 == "function" ? o2(e3) : o2.current = e3);
  });
  return t2.every((e3) => e3 == null || (e3 == null ? void 0 : e3[u$5])) ? void 0 : c2;
}
function F$5({ container: e3, accept: t2, walk: r2, enabled: c2 = true }) {
  let o2 = react.exports.useRef(t2), l2 = react.exports.useRef(r2);
  react.exports.useEffect(() => {
    o2.current = t2, l2.current = r2;
  }, [t2, r2]), s$a(() => {
    if (!e3 || !c2)
      return;
    let n2 = e$3(e3);
    if (!n2)
      return;
    let f2 = o2.current, p2 = l2.current, d2 = Object.assign((i2) => f2(i2), { acceptNode: f2 }), u2 = n2.createTreeWalker(e3, NodeFilter.SHOW_ELEMENT, d2, false);
    for (; u2.nextNode(); )
      p2(u2.currentNode);
  }, [e3, c2, o2, l2]);
}
function f$3(r2) {
  throw new Error("Unexpected object: " + r2);
}
var a$4 = ((e3) => (e3[e3.First = 0] = "First", e3[e3.Previous = 1] = "Previous", e3[e3.Next = 2] = "Next", e3[e3.Last = 3] = "Last", e3[e3.Specific = 4] = "Specific", e3[e3.Nothing = 5] = "Nothing", e3))(a$4 || {});
function x$4(r2, n2) {
  let t2 = n2.resolveItems();
  if (t2.length <= 0)
    return null;
  let l2 = n2.resolveActiveIndex(), s2 = l2 != null ? l2 : -1, d2 = (() => {
    switch (r2.focus) {
      case 0:
        return t2.findIndex((e3) => !n2.resolveDisabled(e3));
      case 1: {
        let e3 = t2.slice().reverse().findIndex((i2, c2, u2) => s2 !== -1 && u2.length - c2 - 1 >= s2 ? false : !n2.resolveDisabled(i2));
        return e3 === -1 ? e3 : t2.length - 1 - e3;
      }
      case 2:
        return t2.findIndex((e3, i2) => i2 <= s2 ? false : !n2.resolveDisabled(e3));
      case 3: {
        let e3 = t2.slice().reverse().findIndex((i2) => !n2.resolveDisabled(i2));
        return e3 === -1 ? e3 : t2.length - 1 - e3;
      }
      case 4:
        return t2.findIndex((e3) => n2.resolveId(e3) === r2.id);
      case 5:
        return null;
      default:
        f$3(r2);
    }
  })();
  return d2 === -1 ? l2 : d2;
}
var S$1 = ((a2) => (a2[a2.None = 0] = "None", a2[a2.RenderStrategy = 1] = "RenderStrategy", a2[a2.Static = 2] = "Static", a2))(S$1 || {}), j$3 = ((e3) => (e3[e3.Unmount = 0] = "Unmount", e3[e3.Hidden = 1] = "Hidden", e3))(j$3 || {});
function $$2({ ourProps: r2, theirProps: t2, slot: e3, defaultTag: a2, features: o2, visible: n2 = true, name: l2 }) {
  let s2 = T$1(t2, r2);
  if (n2)
    return p$6(s2, e3, a2, l2);
  let u2 = o2 != null ? o2 : 0;
  if (u2 & 2) {
    let { static: i2 = false, ...d2 } = s2;
    if (i2)
      return p$6(d2, e3, a2, l2);
  }
  if (u2 & 1) {
    let { unmount: i2 = true, ...d2 } = s2;
    return u$6(i2 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return p$6({ ...d2, hidden: true, style: { display: "none" } }, e3, a2, l2);
    } });
  }
  return p$6(s2, e3, a2, l2);
}
function p$6(r2, t2 = {}, e3, a2) {
  let { as: o2 = e3, children: n2, refName: l2 = "ref", ...s2 } = m$2(r2, ["unmount", "static"]), u2 = r2.ref !== void 0 ? { [l2]: r2.ref } : {}, i2 = typeof n2 == "function" ? n2(t2) : n2;
  s2.className && typeof s2.className == "function" && (s2.className = s2.className(t2));
  let d2 = {};
  if (t2) {
    let f2 = false, y2 = [];
    for (let [h2, g] of Object.entries(t2))
      typeof g == "boolean" && (f2 = true), g === true && y2.push(h2);
    f2 && (d2["data-headlessui-state"] = y2.join(" "));
  }
  if (o2 === react.exports.Fragment && Object.keys(F$4(s2)).length > 0) {
    if (!react.exports.isValidElement(i2) || Array.isArray(i2) && i2.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${a2} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(s2).map((f2) => `  - ${f2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((f2) => `  - ${f2}`).join(`
`)].join(`
`));
    return react.exports.cloneElement(i2, Object.assign({}, T$1(i2.props, F$4(m$2(s2, ["ref"]))), d2, u2, w$4(i2.ref, u2.ref)));
  }
  return react.exports.createElement(o2, Object.assign({}, m$2(s2, ["ref"]), o2 !== react.exports.Fragment && u2, o2 !== react.exports.Fragment && d2), i2);
}
function w$4(...r2) {
  return { ref: r2.every((t2) => t2 == null) ? void 0 : (t2) => {
    for (let e3 of r2)
      e3 != null && (typeof e3 == "function" ? e3(t2) : e3.current = t2);
  } };
}
function T$1(...r2) {
  if (r2.length === 0)
    return {};
  if (r2.length === 1)
    return r2[0];
  let t2 = {}, e3 = {};
  for (let o2 of r2)
    for (let n2 in o2)
      n2.startsWith("on") && typeof o2[n2] == "function" ? (e3[n2] != null || (e3[n2] = []), e3[n2].push(o2[n2])) : t2[n2] = o2[n2];
  if (t2.disabled || t2["aria-disabled"])
    return Object.assign(t2, Object.fromEntries(Object.keys(e3).map((o2) => [o2, void 0])));
  for (let o2 in e3)
    Object.assign(t2, { [o2](n2, ...l2) {
      let s2 = e3[o2];
      for (let u2 of s2) {
        if ((n2 instanceof Event || (n2 == null ? void 0 : n2.nativeEvent) instanceof Event) && n2.defaultPrevented)
          return;
        u2(n2, ...l2);
      }
    } });
  return t2;
}
function C$2(r2) {
  var t2;
  return Object.assign(react.exports.forwardRef(r2), { displayName: (t2 = r2.displayName) != null ? t2 : r2.name });
}
function F$4(r2) {
  let t2 = Object.assign({}, r2);
  for (let e3 in t2)
    t2[e3] === void 0 && delete t2[e3];
  return t2;
}
function m$2(r2, t2 = []) {
  let e3 = Object.assign({}, r2);
  for (let a2 of t2)
    a2 in e3 && delete e3[a2];
  return e3;
}
function r$4(n2) {
  let e3 = n2.parentElement, l2 = null;
  for (; e3 && !(e3 instanceof HTMLFieldSetElement); )
    e3 instanceof HTMLLegendElement && (l2 = e3), e3 = e3.parentElement;
  let t2 = (e3 == null ? void 0 : e3.getAttribute("disabled")) === "";
  return t2 && i$2(l2) ? false : t2;
}
function i$2(n2) {
  if (!n2)
    return false;
  let e3 = n2.previousElementSibling;
  for (; e3 !== null; ) {
    if (e3 instanceof HTMLLegendElement)
      return false;
    e3 = e3.previousElementSibling;
  }
  return true;
}
function e$2(n2 = {}, r2 = null, t2 = []) {
  for (let [i2, o2] of Object.entries(n2))
    f$2(t2, s$7(r2, i2), o2);
  return t2;
}
function s$7(n2, r2) {
  return n2 ? n2 + "[" + r2 + "]" : r2;
}
function f$2(n2, r2, t2) {
  if (Array.isArray(t2))
    for (let [i2, o2] of t2.entries())
      f$2(n2, s$7(r2, i2.toString()), o2);
  else
    t2 instanceof Date ? n2.push([r2, t2.toISOString()]) : typeof t2 == "boolean" ? n2.push([r2, t2 ? "1" : "0"]) : typeof t2 == "string" ? n2.push([r2, t2]) : typeof t2 == "number" ? n2.push([r2, `${t2}`]) : t2 == null ? n2.push([r2, ""]) : e$2(t2, r2, n2);
}
function p$5(n2) {
  var t2;
  let r2 = (t2 = n2 == null ? void 0 : n2.form) != null ? t2 : n2.closest("form");
  if (!!r2) {
    for (let i2 of r2.elements)
      if (i2.tagName === "INPUT" && i2.type === "submit" || i2.tagName === "BUTTON" && i2.type === "submit" || i2.nodeName === "INPUT" && i2.type === "image") {
        i2.click();
        return;
      }
  }
}
let a$3 = "div";
var s$6 = ((e3) => (e3[e3.None = 1] = "None", e3[e3.Focusable = 2] = "Focusable", e3[e3.Hidden = 4] = "Hidden", e3))(s$6 || {});
let h$5 = C$2(function(t2, o2) {
  let { features: e3 = 1, ...r2 } = t2, d2 = { ref: o2, "aria-hidden": (e3 & 2) === 2 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(e3 & 4) === 4 && (e3 & 2) !== 2 && { display: "none" } } };
  return $$2({ ourProps: d2, theirProps: r2, slot: {}, defaultTag: a$3, name: "Hidden" });
});
let o$3 = react.exports.createContext(null);
o$3.displayName = "OpenClosedContext";
var p$4 = ((e3) => (e3[e3.Open = 0] = "Open", e3[e3.Closed = 1] = "Closed", e3))(p$4 || {});
function s$5() {
  return react.exports.useContext(o$3);
}
function C$1({
  value: t2,
  children: n2
}) {
  return React.createElement(o$3.Provider, {
    value: t2
  }, n2);
}
var o$2 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$2 || {});
function p$3(e3, t2, u2) {
  let [l2, s2] = react.exports.useState(u2), i2 = e3 !== void 0;
  return [i2 ? e3 : l2, o$4((r2) => (i2 || s2(r2), t2 == null ? void 0 : t2(r2)))];
}
function m$1(u2, t2) {
  let e3 = react.exports.useRef([]), r2 = o$4(u2);
  react.exports.useEffect(() => {
    let o2 = [...e3.current];
    for (let [n2, a2] of t2.entries())
      if (e3.current[n2] !== a2) {
        let l2 = r2(t2, o2);
        return e3.current = t2, l2;
      }
  }, [r2, ...t2]);
}
var De$2 = ((n2) => (n2[n2.Open = 0] = "Open", n2[n2.Closed = 1] = "Closed", n2))(De$2 || {}), Le$3 = ((n2) => (n2[n2.Single = 0] = "Single", n2[n2.Multi = 1] = "Multi", n2))(Le$3 || {}), Ve = ((n2) => (n2[n2.Pointer = 0] = "Pointer", n2[n2.Other = 1] = "Other", n2))(Ve || {}), Me$4 = ((a2) => (a2[a2.OpenCombobox = 0] = "OpenCombobox", a2[a2.CloseCombobox = 1] = "CloseCombobox", a2[a2.GoToOption = 2] = "GoToOption", a2[a2.RegisterOption = 3] = "RegisterOption", a2[a2.UnregisterOption = 4] = "UnregisterOption", a2[a2.RegisterLabel = 5] = "RegisterLabel", a2))(Me$4 || {});
function $$1(t2, l2 = (n2) => n2) {
  let n2 = t2.activeOptionIndex !== null ? t2.options[t2.activeOptionIndex] : null, e3 = S$2(l2(t2.options.slice()), (r2) => r2.dataRef.current.domRef.current), i2 = n2 ? e3.indexOf(n2) : null;
  return i2 === -1 && (i2 = null), {
    options: e3,
    activeOptionIndex: i2
  };
}
let he$2 = {
  [1](t2) {
    return t2.dataRef.current.disabled || t2.comboboxState === 1 ? t2 : {
      ...t2,
      activeOptionIndex: null,
      comboboxState: 1
    };
  },
  [0](t2) {
    if (t2.dataRef.current.disabled || t2.comboboxState === 0)
      return t2;
    let l2 = t2.activeOptionIndex, {
      isSelected: n2
    } = t2.dataRef.current, e3 = t2.options.findIndex((i2) => n2(i2.dataRef.current.value));
    return e3 !== -1 && (l2 = e3), {
      ...t2,
      comboboxState: 0,
      activeOptionIndex: l2
    };
  },
  [2](t2, l2) {
    var i2;
    if (t2.dataRef.current.disabled || t2.dataRef.current.optionsRef.current && !t2.dataRef.current.optionsPropsRef.current.static && t2.comboboxState === 1)
      return t2;
    let n2 = $$1(t2);
    if (n2.activeOptionIndex === null) {
      let r2 = n2.options.findIndex((a2) => !a2.dataRef.current.disabled);
      r2 !== -1 && (n2.activeOptionIndex = r2);
    }
    let e3 = x$4(l2, {
      resolveItems: () => n2.options,
      resolveActiveIndex: () => n2.activeOptionIndex,
      resolveId: (r2) => r2.id,
      resolveDisabled: (r2) => r2.dataRef.current.disabled
    });
    return {
      ...t2,
      ...n2,
      activeOptionIndex: e3,
      activationTrigger: (i2 = l2.trigger) != null ? i2 : 1
    };
  },
  [3]: (t2, l2) => {
    let n2 = {
      id: l2.id,
      dataRef: l2.dataRef
    }, e3 = $$1(t2, (r2) => [...r2, n2]);
    t2.activeOptionIndex === null && t2.dataRef.current.isSelected(l2.dataRef.current.value) && (e3.activeOptionIndex = e3.options.indexOf(n2));
    let i2 = {
      ...t2,
      ...e3,
      activationTrigger: 1
    };
    return t2.dataRef.current.__demoMode && t2.dataRef.current.value === void 0 && (i2.activeOptionIndex = 0), i2;
  },
  [4]: (t2, l2) => {
    let n2 = $$1(t2, (e3) => {
      let i2 = e3.findIndex((r2) => r2.id === l2.id);
      return i2 !== -1 && e3.splice(i2, 1), e3;
    });
    return {
      ...t2,
      ...n2,
      activationTrigger: 1
    };
  },
  [5]: (t2, l2) => ({
    ...t2,
    labelId: l2.id
  })
}, J$2 = react.exports.createContext(null);
J$2.displayName = "ComboboxActionsContext";
function N$1(t2) {
  let l2 = react.exports.useContext(J$2);
  if (l2 === null) {
    let n2 = new Error(`<${t2} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n2, N$1), n2;
  }
  return l2;
}
let q$4 = react.exports.createContext(null);
q$4.displayName = "ComboboxDataContext";
function w$3(t2) {
  let l2 = react.exports.useContext(q$4);
  if (l2 === null) {
    let n2 = new Error(`<${t2} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n2, w$3), n2;
  }
  return l2;
}
function Fe$2(t2, l2) {
  return u$6(l2.type, he$2, t2, l2);
}
let _e$2 = react.exports.Fragment;
function ke$2(t2, l2) {
  let {
    value: n2,
    defaultValue: e3,
    onChange: i2,
    name: r2,
    by: a2 = (b2, f2) => b2 === f2,
    disabled: m2 = false,
    __demoMode: o2 = false,
    nullable: u2 = false,
    multiple: y2 = false,
    ...O2
  } = t2, [x2, C2] = p$3(n2, i2, e3), [c2, s2] = react.exports.useReducer(Fe$2, {
    dataRef: react.exports.createRef(),
    comboboxState: o2 ? 0 : 1,
    options: [],
    activeOptionIndex: null,
    activationTrigger: 1,
    labelId: null
  }), T2 = react.exports.useRef(false), B2 = react.exports.useRef({
    static: false,
    hold: false
  }), L2 = react.exports.useRef(null), I2 = react.exports.useRef(null), V2 = react.exports.useRef(null), d2 = react.exports.useRef(null), A2 = o$4(typeof a2 == "string" ? (b2, f2) => {
    let S2 = a2;
    return (b2 == null ? void 0 : b2[S2]) === (f2 == null ? void 0 : f2[S2]);
  } : a2), M2 = react.exports.useCallback((b2) => u$6(p2.mode, {
    [1]: () => x2.some((f2) => A2(f2, b2)),
    [0]: () => A2(x2, b2)
  }), [x2]), p2 = react.exports.useMemo(() => ({
    ...c2,
    optionsPropsRef: B2,
    labelRef: L2,
    inputRef: I2,
    buttonRef: V2,
    optionsRef: d2,
    value: x2,
    disabled: m2,
    mode: y2 ? 1 : 0,
    get activeOptionIndex() {
      if (T2.current && c2.activeOptionIndex === null && c2.options.length > 0) {
        let b2 = c2.options.findIndex((f2) => !f2.dataRef.current.disabled);
        if (b2 !== -1)
          return b2;
      }
      return c2.activeOptionIndex;
    },
    compare: A2,
    isSelected: M2,
    nullable: u2,
    __demoMode: o2
  }), [x2, m2, y2, u2, o2, c2]);
  s$a(() => {
    c2.dataRef.current = p2;
  }, [p2]), L$1([p2.buttonRef, p2.inputRef, p2.optionsRef], () => s2({
    type: 1
  }), p2.comboboxState === 0);
  let h2 = react.exports.useMemo(() => ({
    open: p2.comboboxState === 0,
    disabled: m2,
    activeIndex: p2.activeOptionIndex,
    activeOption: p2.activeOptionIndex === null ? null : p2.options[p2.activeOptionIndex].dataRef.current.value,
    value: x2
  }), [p2, m2, x2]), H2 = o$4((b2) => {
    let f2 = p2.options.find((S2) => S2.id === b2);
    !f2 || K2(f2.dataRef.current.value);
  }), oe2 = o$4(() => {
    if (p2.activeOptionIndex !== null) {
      let {
        dataRef: b2,
        id: f2
      } = p2.options[p2.activeOptionIndex];
      K2(b2.current.value), s2({
        type: 2,
        focus: a$4.Specific,
        id: f2
      });
    }
  }), te2 = o$4(() => {
    s2({
      type: 0
    }), T2.current = true;
  }), ne2 = o$4(() => {
    s2({
      type: 1
    }), T2.current = false;
  }), re2 = o$4((b2, f2, S2) => (T2.current = false, b2 === a$4.Specific ? s2({
    type: 2,
    focus: a$4.Specific,
    id: f2,
    trigger: S2
  }) : s2({
    type: 2,
    focus: b2,
    trigger: S2
  }))), ae2 = o$4((b2, f2) => (s2({
    type: 3,
    id: b2,
    dataRef: f2
  }), () => s2({
    type: 4,
    id: b2
  }))), le2 = o$4((b2) => (s2({
    type: 5,
    id: b2
  }), () => s2({
    type: 5,
    id: null
  }))), K2 = o$4((b2) => u$6(p2.mode, {
    [0]() {
      return C2 == null ? void 0 : C2(b2);
    },
    [1]() {
      let f2 = p2.value.slice(), S2 = f2.findIndex((pe2) => A2(pe2, b2));
      return S2 === -1 ? f2.push(b2) : f2.splice(S2, 1), C2 == null ? void 0 : C2(f2);
    }
  })), ie2 = react.exports.useMemo(() => ({
    onChange: K2,
    registerOption: ae2,
    registerLabel: le2,
    goToOption: re2,
    closeCombobox: ne2,
    openCombobox: te2,
    selectActiveOption: oe2,
    selectOption: H2
  }), []), ue2 = l2 === null ? {} : {
    ref: l2
  };
  return React.createElement(J$2.Provider, {
    value: ie2
  }, React.createElement(q$4.Provider, {
    value: p2
  }, /* @__PURE__ */ jsxs(C$1, {
    value: u$6(p2.comboboxState, {
      [0]: p$4.Open,
      [1]: p$4.Closed
    }),
    children: [r2 != null && x2 != null && e$2({
      [r2]: x2
    }).map(([b2, f2]) => React.createElement(h$5, {
      features: s$6.Hidden,
      ...F$4({
        key: b2,
        as: "input",
        type: "hidden",
        hidden: true,
        readOnly: true,
        name: b2,
        value: f2
      })
    })), $$2({
      ourProps: ue2,
      theirProps: O2,
      slot: h2,
      defaultTag: _e$2,
      name: "Combobox"
    })]
  })));
}
let we$2 = C$2(ke$2), Be$1 = "input", Ue = C$2(function(l2, n2) {
  var I2, V2;
  let {
    value: e3,
    onChange: i2,
    displayValue: r2,
    type: a2 = "text",
    ...m2
  } = l2, o2 = w$3("Combobox.Input"), u2 = N$1("Combobox.Input"), y$12 = y(o2.inputRef, n2), O2 = `headlessui-combobox-input-${I$3()}`, x2 = p$7(), C2 = react.exports.useMemo(() => {
    var d2;
    return typeof r2 == "function" ? (d2 = r2(o2.value)) != null ? d2 : "" : typeof o2.value == "string" ? o2.value : "";
  }, [o2.value]);
  m$1(([d2, A2], [M2, p2]) => {
    !o2.inputRef.current || (p2 === 0 && A2 === 1 || d2 !== M2) && (o2.inputRef.current.value = d2);
  }, [C2, o2.comboboxState]);
  let c2 = o$4((d2) => {
    switch (d2.key) {
      case o$2.Backspace:
      case o$2.Delete:
        if (o2.mode !== 0 || !o2.nullable)
          return;
        let A2 = d2.currentTarget;
        x2.requestAnimationFrame(() => {
          A2.value === "" && (u2.onChange(null), o2.optionsRef.current && (o2.optionsRef.current.scrollTop = 0), u2.goToOption(a$4.Nothing));
        });
        break;
      case o$2.Enter:
        if (o2.comboboxState !== 0 || d2.nativeEvent.isComposing)
          return;
        if (d2.preventDefault(), d2.stopPropagation(), o2.activeOptionIndex === null) {
          u2.closeCombobox();
          return;
        }
        u2.selectActiveOption(), o2.mode === 0 && u2.closeCombobox();
        break;
      case o$2.ArrowDown:
        return d2.preventDefault(), d2.stopPropagation(), u$6(o2.comboboxState, {
          [0]: () => {
            u2.goToOption(a$4.Next);
          },
          [1]: () => {
            u2.openCombobox();
          }
        });
      case o$2.ArrowUp:
        return d2.preventDefault(), d2.stopPropagation(), u$6(o2.comboboxState, {
          [0]: () => {
            u2.goToOption(a$4.Previous);
          },
          [1]: () => {
            u2.openCombobox(), x2.nextFrame(() => {
              o2.value || u2.goToOption(a$4.Last);
            });
          }
        });
      case o$2.Home:
      case o$2.PageUp:
        return d2.preventDefault(), d2.stopPropagation(), u2.goToOption(a$4.First);
      case o$2.End:
      case o$2.PageDown:
        return d2.preventDefault(), d2.stopPropagation(), u2.goToOption(a$4.Last);
      case o$2.Escape:
        return o2.comboboxState !== 0 ? void 0 : (d2.preventDefault(), o2.optionsRef.current && !o2.optionsPropsRef.current.static && d2.stopPropagation(), u2.closeCombobox());
      case o$2.Tab:
        if (o2.comboboxState !== 0)
          return;
        o2.mode === 0 && u2.selectActiveOption(), u2.closeCombobox();
        break;
    }
  }), s2 = o$4((d2) => {
    u2.openCombobox(), i2 == null || i2(d2);
  }), T2 = i$4(() => {
    if (!!o2.labelId)
      return [o2.labelId].join(" ");
  }, [o2.labelId]), B2 = react.exports.useMemo(() => ({
    open: o2.comboboxState === 0,
    disabled: o2.disabled
  }), [o2]), L2 = {
    ref: y$12,
    id: O2,
    role: "combobox",
    type: a2,
    "aria-controls": (I2 = o2.optionsRef.current) == null ? void 0 : I2.id,
    "aria-expanded": o2.disabled ? void 0 : o2.comboboxState === 0,
    "aria-activedescendant": o2.activeOptionIndex === null || (V2 = o2.options[o2.activeOptionIndex]) == null ? void 0 : V2.id,
    "aria-multiselectable": o2.mode === 1 ? true : void 0,
    "aria-labelledby": T2,
    disabled: o2.disabled,
    onKeyDown: c2,
    onChange: s2
  };
  return $$2({
    ourProps: L2,
    theirProps: m2,
    slot: B2,
    defaultTag: Be$1,
    name: "Combobox.Input"
  });
}), Ge$1 = "button", Ne = C$2(function(l2, n2) {
  var c2;
  let e3 = w$3("Combobox.Button"), i2 = N$1("Combobox.Button"), r2 = y(e3.buttonRef, n2), a2 = `headlessui-combobox-button-${I$3()}`, m2 = p$7(), o2 = o$4((s2) => {
    switch (s2.key) {
      case o$2.ArrowDown:
        return s2.preventDefault(), s2.stopPropagation(), e3.comboboxState === 1 && i2.openCombobox(), m2.nextFrame(() => {
          var T2;
          return (T2 = e3.inputRef.current) == null ? void 0 : T2.focus({
            preventScroll: true
          });
        });
      case o$2.ArrowUp:
        return s2.preventDefault(), s2.stopPropagation(), e3.comboboxState === 1 && (i2.openCombobox(), m2.nextFrame(() => {
          e3.value || i2.goToOption(a$4.Last);
        })), m2.nextFrame(() => {
          var T2;
          return (T2 = e3.inputRef.current) == null ? void 0 : T2.focus({
            preventScroll: true
          });
        });
      case o$2.Escape:
        return e3.comboboxState !== 0 ? void 0 : (s2.preventDefault(), e3.optionsRef.current && !e3.optionsPropsRef.current.static && s2.stopPropagation(), i2.closeCombobox(), m2.nextFrame(() => {
          var T2;
          return (T2 = e3.inputRef.current) == null ? void 0 : T2.focus({
            preventScroll: true
          });
        }));
      default:
        return;
    }
  }), u2 = o$4((s2) => {
    if (r$4(s2.currentTarget))
      return s2.preventDefault();
    e3.comboboxState === 0 ? i2.closeCombobox() : (s2.preventDefault(), i2.openCombobox()), m2.nextFrame(() => {
      var T2;
      return (T2 = e3.inputRef.current) == null ? void 0 : T2.focus({
        preventScroll: true
      });
    });
  }), y$12 = i$4(() => {
    if (!!e3.labelId)
      return [e3.labelId, a2].join(" ");
  }, [e3.labelId, a2]), O2 = react.exports.useMemo(() => ({
    open: e3.comboboxState === 0,
    disabled: e3.disabled,
    value: e3.value
  }), [e3]), x2 = l2, C2 = {
    ref: r2,
    id: a2,
    type: s$8(l2, e3.buttonRef),
    tabIndex: -1,
    "aria-haspopup": true,
    "aria-controls": (c2 = e3.optionsRef.current) == null ? void 0 : c2.id,
    "aria-expanded": e3.disabled ? void 0 : e3.comboboxState === 0,
    "aria-labelledby": y$12,
    disabled: e3.disabled,
    onClick: u2,
    onKeyDown: o2
  };
  return $$2({
    ourProps: C2,
    theirProps: x2,
    slot: O2,
    defaultTag: Ge$1,
    name: "Combobox.Button"
  });
}), He$1 = "label", je = C$2(function(l2, n2) {
  let e3 = w$3("Combobox.Label"), i2 = `headlessui-combobox-label-${I$3()}`, r2 = N$1("Combobox.Label"), a2 = y(e3.labelRef, n2);
  s$a(() => r2.registerLabel(i2), [i2]);
  let m2 = o$4(() => {
    var O2;
    return (O2 = e3.inputRef.current) == null ? void 0 : O2.focus({
      preventScroll: true
    });
  }), o2 = react.exports.useMemo(() => ({
    open: e3.comboboxState === 0,
    disabled: e3.disabled
  }), [e3]);
  return $$2({
    ourProps: {
      ref: a2,
      id: i2,
      onClick: m2
    },
    theirProps: l2,
    slot: o2,
    defaultTag: He$1,
    name: "Combobox.Label"
  });
}), Ke = "ul", We$1 = S$1.RenderStrategy | S$1.Static, Xe = C$2(function(l2, n2) {
  var C2;
  let {
    hold: e3 = false,
    ...i2
  } = l2, r2 = w$3("Combobox.Options"), a2 = y(r2.optionsRef, n2), m2 = `headlessui-combobox-options-${I$3()}`, o2 = s$5(), u2 = (() => o2 !== null ? o2 === p$4.Open : r2.comboboxState === 0)();
  s$a(() => {
    var c2;
    r2.optionsPropsRef.current.static = (c2 = l2.static) != null ? c2 : false;
  }, [r2.optionsPropsRef, l2.static]), s$a(() => {
    r2.optionsPropsRef.current.hold = e3;
  }, [r2.optionsPropsRef, e3]), F$5({
    container: r2.optionsRef.current,
    enabled: r2.comboboxState === 0,
    accept(c2) {
      return c2.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : c2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    },
    walk(c2) {
      c2.setAttribute("role", "none");
    }
  });
  let y$12 = i$4(() => {
    var c2, s2;
    return (s2 = r2.labelId) != null ? s2 : (c2 = r2.buttonRef.current) == null ? void 0 : c2.id;
  }, [r2.labelId, r2.buttonRef.current]), O2 = react.exports.useMemo(() => ({
    open: r2.comboboxState === 0
  }), [r2]), x2 = {
    "aria-activedescendant": r2.activeOptionIndex === null || (C2 = r2.options[r2.activeOptionIndex]) == null ? void 0 : C2.id,
    "aria-labelledby": y$12,
    role: "listbox",
    id: m2,
    ref: a2
  };
  return $$2({
    ourProps: x2,
    theirProps: i2,
    slot: O2,
    defaultTag: Ke,
    features: We$1,
    visible: u2,
    name: "Combobox.Options"
  });
}), $e = "li", Je = C$2(function(l2, n2) {
  var A2, M2;
  let {
    disabled: e3 = false,
    value: i2,
    ...r2
  } = l2, a2 = w$3("Combobox.Option"), m2 = N$1("Combobox.Option"), o2 = `headlessui-combobox-option-${I$3()}`, u2 = a2.activeOptionIndex !== null ? a2.options[a2.activeOptionIndex].id === o2 : false, y$12 = a2.isSelected(i2), O2 = react.exports.useRef(null), x2 = s$9({
    disabled: e3,
    value: i2,
    domRef: O2,
    textValue: (M2 = (A2 = O2.current) == null ? void 0 : A2.textContent) == null ? void 0 : M2.toLowerCase()
  }), C2 = y(n2, O2), c2 = o$4(() => m2.selectOption(o2));
  s$a(() => m2.registerOption(o2, x2), [x2, o2]);
  let s2 = react.exports.useRef(!a2.__demoMode);
  s$a(() => {
    if (!a2.__demoMode)
      return;
    let p2 = m$4();
    return p2.requestAnimationFrame(() => {
      s2.current = true;
    }), p2.dispose;
  }, []), s$a(() => {
    if (a2.comboboxState !== 0 || !u2 || !s2.current || a2.activationTrigger === 0)
      return;
    let p2 = m$4();
    return p2.requestAnimationFrame(() => {
      var h2, H2;
      (H2 = (h2 = O2.current) == null ? void 0 : h2.scrollIntoView) == null || H2.call(h2, {
        block: "nearest"
      });
    }), p2.dispose;
  }, [O2, u2, a2.comboboxState, a2.activationTrigger, a2.activeOptionIndex]);
  let T2 = o$4((p2) => {
    if (e3)
      return p2.preventDefault();
    c2(), a2.mode === 0 && m2.closeCombobox();
  }), B2 = o$4(() => {
    if (e3)
      return m2.goToOption(a$4.Nothing);
    m2.goToOption(a$4.Specific, o2);
  }), L2 = o$4(() => {
    e3 || u2 || m2.goToOption(a$4.Specific, o2, 0);
  }), I2 = o$4(() => {
    e3 || !u2 || a2.optionsPropsRef.current.hold || m2.goToOption(a$4.Nothing);
  }), V2 = react.exports.useMemo(() => ({
    active: u2,
    selected: y$12,
    disabled: e3
  }), [u2, y$12, e3]);
  return $$2({
    ourProps: {
      id: o2,
      ref: C2,
      role: "option",
      tabIndex: e3 === true ? void 0 : -1,
      "aria-disabled": e3 === true ? true : void 0,
      "aria-selected": y$12,
      disabled: void 0,
      onClick: T2,
      onFocus: B2,
      onPointerMove: L2,
      onMouseMove: L2,
      onPointerLeave: I2,
      onMouseLeave: I2
    },
    theirProps: r2,
    slot: V2,
    defaultTag: $e,
    name: "Combobox.Option"
  });
}), Lo = Object.assign(we$2, {
  Input: Ue,
  Button: Ne,
  Label: je,
  Options: Xe,
  Option: Je
});
function s$4(e3, r2, n2) {
  let o2 = s$9(r2);
  react.exports.useEffect(() => {
    function t2(i2) {
      o2.current(i2);
    }
    return window.addEventListener(e3, t2, n2), () => window.removeEventListener(e3, t2, n2);
  }, [e3, n2]);
}
var s$3 = ((r2) => (r2[r2.Forwards = 0] = "Forwards", r2[r2.Backwards = 1] = "Backwards", r2))(s$3 || {});
function n$5() {
  let e3 = react.exports.useRef(0);
  return s$4("keydown", (o2) => {
    o2.key === "Tab" && (e3.current = o2.shiftKey ? 1 : 0);
  }, true), e3;
}
function f$1() {
  let e3 = react.exports.useRef(false);
  return s$a(() => (e3.current = true, () => {
    e3.current = false;
  }), []), e3;
}
function n$4(...e3) {
  return react.exports.useMemo(() => e$3(...e3), [...e3]);
}
function E(n2, e3, a2, t2) {
  let i2 = s$9(a2);
  react.exports.useEffect(() => {
    n2 = n2 != null ? n2 : window;
    function r2(o2) {
      i2.current(o2);
    }
    return n2.addEventListener(e3, r2, t2), () => n2.removeEventListener(e3, r2, t2);
  }, [n2, e3, t2]);
}
let N = "div";
var v$2 = ((r2) => (r2[r2.None = 1] = "None", r2[r2.InitialFocus = 2] = "InitialFocus", r2[r2.TabLock = 4] = "TabLock", r2[r2.FocusLock = 8] = "FocusLock", r2[r2.RestoreFocus = 16] = "RestoreFocus", r2[r2.All = 30] = "All", r2))(v$2 || {});
let fe$2 = Object.assign(C$2(function(u2, e3) {
  let l2 = react.exports.useRef(null), o2 = y(l2, e3), {
    initialFocus: a2,
    containers: r2,
    features: n2 = 30,
    ...c2
  } = u2;
  a$5() || (n2 = 1);
  let s2 = n$4(l2);
  V$3({
    ownerDocument: s2
  }, Boolean(n2 & 16));
  let j2 = x$3({
    ownerDocument: s2,
    container: l2,
    initialFocus: a2
  }, Boolean(n2 & 2));
  G({
    ownerDocument: s2,
    container: l2,
    containers: r2,
    previousActiveElement: j2
  }, Boolean(n2 & 8));
  let k2 = n$5(), p2 = o$4(() => {
    let T2 = l2.current;
    !T2 || u$6(k2.current, {
      [s$3.Forwards]: () => O(T2, T$3.First),
      [s$3.Backwards]: () => O(T2, T$3.Last)
    });
  }), A2 = {
    ref: o2
  };
  return React.createElement(React.Fragment, null, Boolean(n2 & 4) && /* @__PURE__ */ jsx(h$5, {
    as: "button",
    type: "button",
    onFocus: p2,
    features: s$6.Focusable
  }), $$2({
    ourProps: A2,
    theirProps: c2,
    defaultTag: N,
    name: "FocusTrap"
  }), Boolean(n2 & 4) && /* @__PURE__ */ jsx(h$5, {
    as: "button",
    type: "button",
    onFocus: p2,
    features: s$6.Focusable
  }));
}), {
  features: v$2
});
function V$3({
  ownerDocument: t2
}, u2) {
  let e3 = react.exports.useRef(null);
  E(t2 == null ? void 0 : t2.defaultView, "focusout", (o2) => {
    !u2 || e3.current || (e3.current = o2.target);
  }, true), m$1(() => {
    u2 || ((t2 == null ? void 0 : t2.activeElement) === (t2 == null ? void 0 : t2.body) && h$6(e3.current), e3.current = null);
  }, [u2]);
  let l2 = react.exports.useRef(false);
  react.exports.useEffect(() => (l2.current = false, () => {
    l2.current = true, t$2(() => {
      !l2.current || (h$6(e3.current), e3.current = null);
    });
  }), []);
}
function x$3({
  ownerDocument: t2,
  container: u2,
  initialFocus: e3
}, l2) {
  let o2 = react.exports.useRef(null), a2 = f$1();
  return m$1(() => {
    if (!l2)
      return;
    let r2 = u2.current;
    !r2 || t$2(() => {
      if (!a2.current)
        return;
      let n2 = t2 == null ? void 0 : t2.activeElement;
      if (e3 != null && e3.current) {
        if ((e3 == null ? void 0 : e3.current) === n2) {
          o2.current = n2;
          return;
        }
      } else if (r2.contains(n2)) {
        o2.current = n2;
        return;
      }
      e3 != null && e3.current ? h$6(e3.current) : O(r2, T$3.First) === M$5.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), o2.current = t2 == null ? void 0 : t2.activeElement;
    });
  }, [l2]), o2;
}
function G({
  ownerDocument: t2,
  container: u2,
  containers: e3,
  previousActiveElement: l2
}, o2) {
  let a2 = f$1();
  E(t2 == null ? void 0 : t2.defaultView, "focus", (r2) => {
    if (!o2 || !a2.current)
      return;
    let n2 = new Set(e3 == null ? void 0 : e3.current);
    n2.add(u2);
    let c2 = l2.current;
    if (!c2)
      return;
    let s2 = r2.target;
    s2 && s2 instanceof HTMLElement ? W(n2, s2) ? (l2.current = s2, h$6(s2)) : (r2.preventDefault(), r2.stopPropagation(), h$6(c2)) : h$6(l2.current);
  }, true);
}
function W(t2, u2) {
  var e3;
  for (let l2 of t2)
    if ((e3 = l2.current) != null && e3.contains(u2))
      return true;
  return false;
}
let i$1 = /* @__PURE__ */ new Set(), r$3 = /* @__PURE__ */ new Map();
function u$4(t2) {
  t2.setAttribute("aria-hidden", "true"), t2.inert = true;
}
function l$5(t2) {
  let n2 = r$3.get(t2);
  !n2 || (n2["aria-hidden"] === null ? t2.removeAttribute("aria-hidden") : t2.setAttribute("aria-hidden", n2["aria-hidden"]), t2.inert = n2.inert);
}
function M$4(t2, n2 = true) {
  s$a(() => {
    if (!n2 || !t2.current)
      return;
    let o2 = t2.current, a2 = e$3(o2);
    if (!!a2) {
      i$1.add(o2);
      for (let e3 of r$3.keys())
        e3.contains(o2) && (l$5(e3), r$3.delete(e3));
      return a2.querySelectorAll("body > *").forEach((e3) => {
        if (e3 instanceof HTMLElement) {
          for (let f2 of i$1)
            if (e3.contains(f2))
              return;
          i$1.size === 1 && (r$3.set(e3, { "aria-hidden": e3.getAttribute("aria-hidden"), inert: e3.inert }), u$4(e3));
        }
      }), () => {
        if (i$1.delete(o2), i$1.size > 0)
          a2.querySelectorAll("body > *").forEach((e3) => {
            if (e3 instanceof HTMLElement && !r$3.has(e3)) {
              for (let f2 of i$1)
                if (e3.contains(f2))
                  return;
              r$3.set(e3, { "aria-hidden": e3.getAttribute("aria-hidden"), inert: e3.inert }), u$4(e3);
            }
          });
        else
          for (let e3 of r$3.keys())
            l$5(e3), r$3.delete(e3);
      };
    }
  }, [n2]);
}
let e$1 = react.exports.createContext(false);
function l$4() {
  return react.exports.useContext(e$1);
}
function P(o2) {
  return React.createElement(e$1.Provider, {
    value: o2.force
  }, o2.children);
}
function x$2(i2) {
  let u2 = l$4(), o2 = react.exports.useContext(A), e3 = n$4(i2), [r2, f2] = react.exports.useState(() => {
    if (!u2 && o2 !== null || e$4)
      return null;
    let n2 = e3 == null ? void 0 : e3.getElementById("headlessui-portal-root");
    if (n2)
      return n2;
    if (e3 === null)
      return null;
    let t2 = e3.createElement("div");
    return t2.setAttribute("id", "headlessui-portal-root"), e3.body.appendChild(t2);
  });
  return react.exports.useEffect(() => {
    r2 !== null && (e3 != null && e3.body.contains(r2) || e3 == null || e3.body.appendChild(r2));
  }, [r2, e3]), react.exports.useEffect(() => {
    u2 || o2 !== null && f2(o2.current);
  }, [o2, f2, u2]), r2;
}
let _ = react.exports.Fragment, U$1 = C$2(function(u2, o2) {
  let e3 = u2, r2 = react.exports.useRef(null), f2 = y(T$2((a2) => {
    r2.current = a2;
  }), o2), n2 = n$4(r2), t2 = x$2(r2), [l2] = react.exports.useState(() => {
    var a2;
    return e$4 ? null : (a2 = n2 == null ? void 0 : n2.createElement("div")) != null ? a2 : null;
  }), b2 = a$5(), p2 = react.exports.useRef(false);
  return s$a(() => {
    if (p2.current = false, !(!t2 || !l2))
      return t2.contains(l2) || (l2.setAttribute("data-headlessui-portal", ""), t2.appendChild(l2)), () => {
        p2.current = true, t$2(() => {
          var a2;
          !p2.current || !t2 || !l2 || (t2.removeChild(l2), t2.childNodes.length <= 0 && ((a2 = t2.parentElement) == null || a2.removeChild(t2)));
        });
      };
  }, [t2, l2]), b2 ? !t2 || !l2 ? null : reactDom.exports.createPortal($$2({
    ourProps: {
      ref: f2
    },
    theirProps: e3,
    defaultTag: _,
    name: "Portal"
  }), l2) : null;
}), j$2 = react.exports.Fragment, A = react.exports.createContext(null), F$3 = C$2(function(u2, o2) {
  let {
    target: e3,
    ...r2
  } = u2, n2 = {
    ref: y(o2)
  };
  return /* @__PURE__ */ jsx(A.Provider, {
    value: e3,
    children: $$2({
      ourProps: n2,
      theirProps: r2,
      defaultTag: j$2,
      name: "Popover.Group"
    })
  });
}), $ = Object.assign(U$1, {
  Group: F$3
});
let d = react.exports.createContext(null);
function u$3() {
  let r2 = react.exports.useContext(d);
  if (r2 === null) {
    let t2 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t2, u$3), t2;
  }
  return r2;
}
function k$2() {
  let [r2, t2] = react.exports.useState([]);
  return [r2.length > 0 ? r2.join(" ") : void 0, react.exports.useMemo(() => function(e3) {
    let i2 = o$4((n2) => (t2((o2) => [...o2, n2]), () => t2((o2) => {
      let c2 = o2.slice(), p2 = c2.indexOf(n2);
      return p2 !== -1 && c2.splice(p2, 1), c2;
    }))), s2 = react.exports.useMemo(() => ({
      register: i2,
      slot: e3.slot,
      name: e3.name,
      props: e3.props
    }), [i2, e3.slot, e3.name, e3.props]);
    return React.createElement(d.Provider, {
      value: s2
    }, e3.children);
  }, [t2])];
}
let S = "p", F$2 = C$2(function(t2, a2) {
  let e3 = u$3(), i2 = `headlessui-description-${I$3()}`, s2 = y(a2);
  s$a(() => e3.register(i2), [i2, e3.register]);
  let n2 = t2, o2 = {
    ref: s2,
    ...e3.props,
    id: i2
  };
  return $$2({
    ourProps: o2,
    theirProps: n2,
    slot: e3.slot || {},
    defaultTag: S,
    name: e3.name || "Description"
  });
});
let a$2 = react.exports.createContext(() => {
});
a$2.displayName = "StackContext";
var s$2 = ((e3) => (e3[e3.Add = 0] = "Add", e3[e3.Remove = 1] = "Remove", e3))(s$2 || {});
function x$1() {
  return react.exports.useContext(a$2);
}
function M$3({
  children: i2,
  onUpdate: r2,
  type: e3,
  element: n2,
  enabled: u2
}) {
  let l2 = x$1(), o2 = o$4((...t2) => {
    r2 == null || r2(...t2), l2(...t2);
  });
  return s$a(() => {
    let t2 = u2 === void 0 || u2 === true;
    return t2 && o2(0, e3, n2), () => {
      t2 && o2(1, e3, n2);
    };
  }, [o2, e3, n2, u2]), React.createElement(a$2.Provider, {
    value: o2
  }, i2);
}
function o$1() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
var Re$4 = ((r2) => (r2[r2.Open = 0] = "Open", r2[r2.Closed = 1] = "Closed", r2))(Re$4 || {}), be$3 = ((e3) => (e3[e3.SetTitleId = 0] = "SetTitleId", e3))(be$3 || {});
let Ae$3 = {
  [0](l2, e3) {
    return l2.titleId === e3.id ? l2 : {
      ...l2,
      titleId: e3.id
    };
  }
}, M$2 = react.exports.createContext(null);
M$2.displayName = "DialogContext";
function L(l2) {
  let e3 = react.exports.useContext(M$2);
  if (e3 === null) {
    let r2 = new Error(`<${l2} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r2, L), r2;
  }
  return e3;
}
function Ee$3(l2, e3) {
  react.exports.useEffect(() => {
    var p2;
    if (!e3 || !l2)
      return;
    let r2 = m$4();
    function t2(n2, d2, m2) {
      let i2 = n2.style.getPropertyValue(d2);
      return Object.assign(n2.style, {
        [d2]: m2
      }), r2.add(() => {
        Object.assign(n2.style, {
          [d2]: i2
        });
      });
    }
    let o2 = l2.documentElement, s2 = ((p2 = l2.defaultView) != null ? p2 : window).innerWidth - o2.clientWidth;
    if (t2(o2, "overflow", "hidden"), s2 > 0) {
      let n2 = o2.clientWidth - o2.offsetWidth, d2 = s2 - n2;
      t2(o2, "paddingRight", `${d2}px`);
    }
    if (o$1()) {
      let n2 = window.pageYOffset;
      t2(o2, "position", "fixed"), t2(o2, "marginTop", `-${n2}px`), t2(o2, "width", "100%"), r2.add(() => window.scrollTo(0, n2));
    }
    return r2.dispose;
  }, [l2, e3]);
}
function ve$2(l2, e3) {
  return u$6(e3.type, Ae$3, l2, e3);
}
let Oe$3 = "div", Ce$3 = S$1.RenderStrategy | S$1.Static, Se$3 = C$2(function(e3, r2) {
  let {
    open: t2,
    onClose: o2,
    initialFocus: a2,
    __demoMode: s2 = false,
    ...p2
  } = e3, [n2, d2] = react.exports.useState(0), m2 = s$5();
  t2 === void 0 && m2 !== null && (t2 = u$6(m2, {
    [p$4.Open]: true,
    [p$4.Closed]: false
  }));
  let i2 = react.exports.useRef(/* @__PURE__ */ new Set()), T2 = react.exports.useRef(null), K2 = y(T2, r2), W2 = react.exports.useRef(null), P$12 = n$4(T2), B2 = e3.hasOwnProperty("open") || m2 !== null, G2 = e3.hasOwnProperty("onClose");
  if (!B2 && !G2)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!B2)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!G2)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof t2 != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${t2}`);
  if (typeof o2 != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${o2}`);
  let u2 = t2 ? 0 : 1, [y$12, q2] = react.exports.useReducer(ve$2, {
    titleId: null,
    descriptionId: null,
    panelRef: react.exports.createRef()
  }), h2 = o$4(() => o2(false)), U2 = o$4((f2) => q2({
    type: 0,
    id: f2
  })), _2 = a$5() ? s2 ? false : u2 === 0 : false, w2 = n2 > 1, z2 = react.exports.useContext(M$2) !== null, J2 = w2 ? "parent" : "leaf";
  M$4(T2, w2 ? _2 : false), L$1(() => {
    var R2, g;
    return [...Array.from((R2 = P$12 == null ? void 0 : P$12.querySelectorAll("body > *, [data-headlessui-portal]")) != null ? R2 : []).filter((D2) => !(!(D2 instanceof HTMLElement) || D2.contains(W2.current) || y$12.panelRef.current && D2.contains(y$12.panelRef.current))), (g = y$12.panelRef.current) != null ? g : T2.current];
  }, h2, _2 && !w2), E(P$12 == null ? void 0 : P$12.defaultView, "keydown", (f2) => {
    f2.defaultPrevented || f2.key === o$2.Escape && u2 === 0 && (w2 || (f2.preventDefault(), f2.stopPropagation(), h2()));
  }), Ee$3(P$12, u2 === 0 && !z2), react.exports.useEffect(() => {
    if (u2 !== 0 || !T2.current)
      return;
    let f2 = new IntersectionObserver((R2) => {
      for (let g of R2)
        g.boundingClientRect.x === 0 && g.boundingClientRect.y === 0 && g.boundingClientRect.width === 0 && g.boundingClientRect.height === 0 && h2();
    });
    return f2.observe(T2.current), () => f2.disconnect();
  }, [u2, T2, h2]);
  let [Q2, X2] = k$2(), Z2 = `headlessui-dialog-${I$3()}`, ee2 = react.exports.useMemo(() => [{
    dialogState: u2,
    close: h2,
    setTitleId: U2
  }, y$12], [u2, y$12, h2, U2]), $$12 = react.exports.useMemo(() => ({
    open: u2 === 0
  }), [u2]), te2 = {
    ref: K2,
    id: Z2,
    role: "dialog",
    "aria-modal": u2 === 0 ? true : void 0,
    "aria-labelledby": y$12.titleId,
    "aria-describedby": Q2
  };
  return React.createElement(M$3, {
    type: "Dialog",
    enabled: u2 === 0,
    element: T2,
    onUpdate: o$4((f2, R2, g) => {
      R2 === "Dialog" && u$6(f2, {
        [s$2.Add]() {
          i2.current.add(g), d2((D2) => D2 + 1);
        },
        [s$2.Remove]() {
          i2.current.add(g), d2((D2) => D2 - 1);
        }
      });
    })
  }, /* @__PURE__ */ jsx(P, {
    force: true,
    children: /* @__PURE__ */ jsx($, {
      children: /* @__PURE__ */ jsx(M$2.Provider, {
        value: ee2,
        children: /* @__PURE__ */ jsx($.Group, {
          target: T2,
          children: /* @__PURE__ */ jsx(P, {
            force: false,
            children: /* @__PURE__ */ jsx(X2, {
              slot: $$12,
              name: "Dialog.Description",
              children: /* @__PURE__ */ jsx(fe$2, {
                initialFocus: a2,
                containers: i2,
                features: _2 ? u$6(J2, {
                  parent: fe$2.features.RestoreFocus,
                  leaf: fe$2.features.All & ~fe$2.features.FocusLock
                }) : fe$2.features.None,
                children: $$2({
                  ourProps: te2,
                  theirProps: p2,
                  slot: $$12,
                  defaultTag: Oe$3,
                  features: Ce$3,
                  visible: u2 === 0,
                  name: "Dialog"
                })
              })
            })
          })
        })
      })
    })
  }), /* @__PURE__ */ jsx(h$5, {
    features: s$6.Hidden,
    ref: W2
  }));
}), Le$2 = "div", we$1 = C$2(function(e3, r2) {
  let [{
    dialogState: t2,
    close: o2
  }] = L("Dialog.Overlay"), a2 = y(r2), s2 = `headlessui-dialog-overlay-${I$3()}`, p2 = o$4((i2) => {
    if (i2.target === i2.currentTarget) {
      if (r$4(i2.currentTarget))
        return i2.preventDefault();
      i2.preventDefault(), i2.stopPropagation(), o2();
    }
  }), n2 = react.exports.useMemo(() => ({
    open: t2 === 0
  }), [t2]);
  return $$2({
    ourProps: {
      ref: a2,
      id: s2,
      "aria-hidden": true,
      onClick: p2
    },
    theirProps: e3,
    slot: n2,
    defaultTag: Le$2,
    name: "Dialog.Overlay"
  });
}), Fe$1 = "div", ke$1 = C$2(function(e3, r2) {
  let [{
    dialogState: t2
  }, o2] = L("Dialog.Backdrop"), a2 = y(r2), s2 = `headlessui-dialog-backdrop-${I$3()}`;
  react.exports.useEffect(() => {
    if (o2.panelRef.current === null)
      throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [o2.panelRef]);
  let p2 = react.exports.useMemo(() => ({
    open: t2 === 0
  }), [t2]);
  return /* @__PURE__ */ jsx(P, {
    force: true,
    children: /* @__PURE__ */ jsx($, {
      children: $$2({
        ourProps: {
          ref: a2,
          id: s2,
          "aria-hidden": true
        },
        theirProps: e3,
        slot: p2,
        defaultTag: Fe$1,
        name: "Dialog.Backdrop"
      })
    })
  });
}), Me$3 = "div", _e$1 = C$2(function(e3, r2) {
  let [{
    dialogState: t2
  }, o2] = L("Dialog.Panel"), a2 = y(r2, o2.panelRef), s2 = `headlessui-dialog-panel-${I$3()}`, p2 = react.exports.useMemo(() => ({
    open: t2 === 0
  }), [t2]), n2 = o$4((i2) => {
    i2.stopPropagation();
  });
  return $$2({
    ourProps: {
      ref: a2,
      id: s2,
      onClick: n2
    },
    theirProps: e3,
    slot: p2,
    defaultTag: Me$3,
    name: "Dialog.Panel"
  });
}), xe$4 = "h2", Ie$3 = C$2(function(e3, r2) {
  let [{
    dialogState: t2,
    setTitleId: o2
  }] = L("Dialog.Title"), a2 = `headlessui-dialog-title-${I$3()}`, s2 = y(r2);
  react.exports.useEffect(() => (o2(a2), () => o2(null)), [a2, o2]);
  let p2 = react.exports.useMemo(() => ({
    open: t2 === 0
  }), [t2]);
  return $$2({
    ourProps: {
      ref: s2,
      id: a2
    },
    theirProps: e3,
    slot: p2,
    defaultTag: xe$4,
    name: "Dialog.Title"
  });
}), gt = Object.assign(Se$3, {
  Backdrop: ke$1,
  Panel: _e$1,
  Overlay: we$1,
  Title: Ie$3,
  Description: F$2
});
var Q$3 = ((o2) => (o2[o2.Open = 0] = "Open", o2[o2.Closed = 1] = "Closed", o2))(Q$3 || {}), V$2 = ((n2) => (n2[n2.ToggleDisclosure = 0] = "ToggleDisclosure", n2[n2.CloseDisclosure = 1] = "CloseDisclosure", n2[n2.SetButtonId = 2] = "SetButtonId", n2[n2.SetPanelId = 3] = "SetPanelId", n2[n2.LinkPanel = 4] = "LinkPanel", n2[n2.UnlinkPanel = 5] = "UnlinkPanel", n2))(V$2 || {});
let X = {
  [0]: (e3) => ({
    ...e3,
    disclosureState: u$6(e3.disclosureState, {
      [0]: 1,
      [1]: 0
    })
  }),
  [1]: (e3) => e3.disclosureState === 1 ? e3 : {
    ...e3,
    disclosureState: 1
  },
  [4](e3) {
    return e3.linkedPanel === true ? e3 : {
      ...e3,
      linkedPanel: true
    };
  },
  [5](e3) {
    return e3.linkedPanel === false ? e3 : {
      ...e3,
      linkedPanel: false
    };
  },
  [2](e3, t2) {
    return e3.buttonId === t2.buttonId ? e3 : {
      ...e3,
      buttonId: t2.buttonId
    };
  },
  [3](e3, t2) {
    return e3.panelId === t2.panelId ? e3 : {
      ...e3,
      panelId: t2.panelId
    };
  }
}, B = react.exports.createContext(null);
B.displayName = "DisclosureContext";
function h$4(e3) {
  let t2 = react.exports.useContext(B);
  if (t2 === null) {
    let o2 = new Error(`<${e3} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o2, h$4), o2;
  }
  return t2;
}
let H = react.exports.createContext(null);
H.displayName = "DisclosureAPIContext";
function j$1(e3) {
  let t2 = react.exports.useContext(H);
  if (t2 === null) {
    let o2 = new Error(`<${e3} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o2, j$1), o2;
  }
  return t2;
}
let U = react.exports.createContext(null);
U.displayName = "DisclosurePanelContext";
function Y() {
  return react.exports.useContext(U);
}
function Z(e3, t2) {
  return u$6(t2.type, X, e3, t2);
}
let ee$1 = react.exports.Fragment, te$2 = C$2(function(t2, o2) {
  let {
    defaultOpen: l2 = false,
    ...i2
  } = t2, s2 = `headlessui-disclosure-button-${I$3()}`, n2 = `headlessui-disclosure-panel-${I$3()}`, u2 = react.exports.useRef(null), D2 = y(o2, T$2((f2) => {
    u2.current = f2;
  }, t2.as === void 0 || t2.as === react.exports.Fragment)), T2 = react.exports.useRef(null), m2 = react.exports.useRef(null), c2 = react.exports.useReducer(Z, {
    disclosureState: l2 ? 0 : 1,
    linkedPanel: false,
    buttonRef: m2,
    panelRef: T2,
    buttonId: s2,
    panelId: n2
  }), [{
    disclosureState: p2
  }, a2] = c2;
  react.exports.useEffect(() => a2({
    type: 2,
    buttonId: s2
  }), [s2, a2]), react.exports.useEffect(() => a2({
    type: 3,
    panelId: n2
  }), [n2, a2]);
  let P2 = o$4((f2) => {
    a2({
      type: 1
    });
    let C2 = e$3(u2);
    if (!C2)
      return;
    let A2 = (() => f2 ? f2 instanceof HTMLElement ? f2 : f2.current instanceof HTMLElement ? f2.current : C2.getElementById(s2) : C2.getElementById(s2))();
    A2 == null || A2.focus();
  }), b2 = react.exports.useMemo(() => ({
    close: P2
  }), [P2]), r2 = react.exports.useMemo(() => ({
    open: p2 === 0,
    close: P2
  }), [p2, P2]), d2 = {
    ref: D2
  };
  return React.createElement(B.Provider, {
    value: c2
  }, React.createElement(H.Provider, {
    value: b2
  }, React.createElement(C$1, {
    value: u$6(p2, {
      [0]: p$4.Open,
      [1]: p$4.Closed
    })
  }, $$2({
    ourProps: d2,
    theirProps: i2,
    slot: r2,
    defaultTag: ee$1,
    name: "Disclosure"
  }))));
}), ne$2 = "button", le$2 = C$2(function(t2, o2) {
  let [l2, i2] = h$4("Disclosure.Button"), s2 = Y(), n2 = s2 === null ? false : s2 === l2.panelId, u2 = react.exports.useRef(null), D2 = y(u2, o2, n2 ? null : l2.buttonRef), T2 = o$4((r2) => {
    var d2;
    if (n2) {
      if (l2.disclosureState === 1)
        return;
      switch (r2.key) {
        case o$2.Space:
        case o$2.Enter:
          r2.preventDefault(), r2.stopPropagation(), i2({
            type: 0
          }), (d2 = l2.buttonRef.current) == null || d2.focus();
          break;
      }
    } else
      switch (r2.key) {
        case o$2.Space:
        case o$2.Enter:
          r2.preventDefault(), r2.stopPropagation(), i2({
            type: 0
          });
          break;
      }
  }), m2 = o$4((r2) => {
    switch (r2.key) {
      case o$2.Space:
        r2.preventDefault();
        break;
    }
  }), c2 = o$4((r2) => {
    var d2;
    r$4(r2.currentTarget) || t2.disabled || (n2 ? (i2({
      type: 0
    }), (d2 = l2.buttonRef.current) == null || d2.focus()) : i2({
      type: 0
    }));
  }), p2 = react.exports.useMemo(() => ({
    open: l2.disclosureState === 0
  }), [l2]), a2 = s$8(t2, u2), P2 = t2, b2 = n2 ? {
    ref: D2,
    type: a2,
    onKeyDown: T2,
    onClick: c2
  } : {
    ref: D2,
    id: l2.buttonId,
    type: a2,
    "aria-expanded": t2.disabled ? void 0 : l2.disclosureState === 0,
    "aria-controls": l2.linkedPanel ? l2.panelId : void 0,
    onKeyDown: T2,
    onKeyUp: m2,
    onClick: c2
  };
  return $$2({
    ourProps: b2,
    theirProps: P2,
    slot: p2,
    defaultTag: ne$2,
    name: "Disclosure.Button"
  });
}), oe$1 = "div", re$3 = S$1.RenderStrategy | S$1.Static, se$1 = C$2(function(t2, o2) {
  let [l2, i2] = h$4("Disclosure.Panel"), {
    close: s2
  } = j$1("Disclosure.Panel"), n2 = y(o2, l2.panelRef, (p2) => {
    i2({
      type: p2 ? 4 : 5
    });
  }), u2 = s$5(), D2 = (() => u2 !== null ? u2 === p$4.Open : l2.disclosureState === 0)(), T2 = react.exports.useMemo(() => ({
    open: l2.disclosureState === 0,
    close: s2
  }), [l2, s2]), m2 = t2, c2 = {
    ref: n2,
    id: l2.panelId
  };
  return /* @__PURE__ */ jsx(U.Provider, {
    value: l2.panelId,
    children: $$2({
      ourProps: c2,
      theirProps: m2,
      slot: T2,
      defaultTag: oe$1,
      features: re$3,
      visible: D2,
      name: "Disclosure.Panel"
    })
  });
}), Oe$2 = Object.assign(te$2, {
  Button: le$2,
  Panel: se$1
});
var ye$2 = ((n2) => (n2[n2.Open = 0] = "Open", n2[n2.Closed = 1] = "Closed", n2))(ye$2 || {}), xe$3 = ((n2) => (n2[n2.Single = 0] = "Single", n2[n2.Multi = 1] = "Multi", n2))(xe$3 || {}), Oe$1 = ((n2) => (n2[n2.Pointer = 0] = "Pointer", n2[n2.Other = 1] = "Other", n2))(Oe$1 || {}), me$2 = ((r2) => (r2[r2.OpenListbox = 0] = "OpenListbox", r2[r2.CloseListbox = 1] = "CloseListbox", r2[r2.SetDisabled = 2] = "SetDisabled", r2[r2.SetOrientation = 3] = "SetOrientation", r2[r2.GoToOption = 4] = "GoToOption", r2[r2.Search = 5] = "Search", r2[r2.ClearSearch = 6] = "ClearSearch", r2[r2.RegisterOption = 7] = "RegisterOption", r2[r2.UnregisterOption = 8] = "UnregisterOption", r2))(me$2 || {});
function j(t2, i2 = (n2) => n2) {
  let n2 = t2.activeOptionIndex !== null ? t2.options[t2.activeOptionIndex] : null, e3 = S$2(i2(t2.options.slice()), (u2) => u2.dataRef.current.domRef.current), o2 = n2 ? e3.indexOf(n2) : null;
  return o2 === -1 && (o2 = null), {
    options: e3,
    activeOptionIndex: o2
  };
}
let ge$3 = {
  [1](t2) {
    return t2.disabled || t2.listboxState === 1 ? t2 : {
      ...t2,
      activeOptionIndex: null,
      listboxState: 1
    };
  },
  [0](t2) {
    if (t2.disabled || t2.listboxState === 0)
      return t2;
    let i2 = t2.activeOptionIndex, {
      value: n2,
      mode: e3,
      compare: o2
    } = t2.propsRef.current, u2 = t2.options.findIndex((l2) => {
      let s2 = l2.dataRef.current.value;
      return u$6(e3, {
        [1]: () => n2.some((r2) => o2(r2, s2)),
        [0]: () => o2(n2, s2)
      });
    });
    return u2 !== -1 && (i2 = u2), {
      ...t2,
      listboxState: 0,
      activeOptionIndex: i2
    };
  },
  [2](t2, i2) {
    return t2.disabled === i2.disabled ? t2 : {
      ...t2,
      disabled: i2.disabled
    };
  },
  [3](t2, i2) {
    return t2.orientation === i2.orientation ? t2 : {
      ...t2,
      orientation: i2.orientation
    };
  },
  [4](t2, i2) {
    var o2;
    if (t2.disabled || t2.listboxState === 1)
      return t2;
    let n2 = j(t2), e3 = x$4(i2, {
      resolveItems: () => n2.options,
      resolveActiveIndex: () => n2.activeOptionIndex,
      resolveId: (u2) => u2.id,
      resolveDisabled: (u2) => u2.dataRef.current.disabled
    });
    return {
      ...t2,
      ...n2,
      searchQuery: "",
      activeOptionIndex: e3,
      activationTrigger: (o2 = i2.trigger) != null ? o2 : 1
    };
  },
  [5]: (t2, i2) => {
    if (t2.disabled || t2.listboxState === 1)
      return t2;
    let e3 = t2.searchQuery !== "" ? 0 : 1, o2 = t2.searchQuery + i2.value.toLowerCase(), l2 = (t2.activeOptionIndex !== null ? t2.options.slice(t2.activeOptionIndex + e3).concat(t2.options.slice(0, t2.activeOptionIndex + e3)) : t2.options).find((d2) => {
      var r2;
      return !d2.dataRef.current.disabled && ((r2 = d2.dataRef.current.textValue) == null ? void 0 : r2.startsWith(o2));
    }), s2 = l2 ? t2.options.indexOf(l2) : -1;
    return s2 === -1 || s2 === t2.activeOptionIndex ? {
      ...t2,
      searchQuery: o2
    } : {
      ...t2,
      searchQuery: o2,
      activeOptionIndex: s2,
      activationTrigger: 1
    };
  },
  [6](t2) {
    return t2.disabled || t2.listboxState === 1 || t2.searchQuery === "" ? t2 : {
      ...t2,
      searchQuery: ""
    };
  },
  [7]: (t2, i2) => {
    let n2 = {
      id: i2.id,
      dataRef: i2.dataRef
    }, e3 = j(t2, (o2) => [...o2, n2]);
    if (t2.activeOptionIndex === null) {
      let {
        value: o2,
        mode: u2,
        compare: l2
      } = t2.propsRef.current, s2 = i2.dataRef.current.value;
      u$6(u2, {
        [1]: () => o2.some((r2) => l2(r2, s2)),
        [0]: () => l2(o2, s2)
      }) && (e3.activeOptionIndex = e3.options.indexOf(n2));
    }
    return {
      ...t2,
      ...e3
    };
  },
  [8]: (t2, i2) => {
    let n2 = j(t2, (e3) => {
      let o2 = e3.findIndex((u2) => u2.id === i2.id);
      return o2 !== -1 && e3.splice(o2, 1), e3;
    });
    return {
      ...t2,
      ...n2,
      activationTrigger: 1
    };
  }
}, K = react.exports.createContext(null);
K.displayName = "ListboxContext";
function w$2(t2) {
  let i2 = react.exports.useContext(K);
  if (i2 === null) {
    let n2 = new Error(`<${t2} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n2, w$2), n2;
  }
  return i2;
}
function Re$3(t2, i2) {
  return u$6(i2.type, ge$3, t2, i2);
}
let ve$1 = react.exports.Fragment, Le$1 = C$2(function(i2, n2) {
  let {
    value: e3,
    defaultValue: o2,
    name: u2,
    onChange: l2,
    by: s2 = (p2, T2) => p2 === T2,
    disabled: d2 = false,
    horizontal: r2 = false,
    multiple: x2 = false,
    ...S2
  } = i2;
  const g = r2 ? "horizontal" : "vertical";
  let O2 = y(n2), [m2, f2] = p$3(e3, l2, o2), b2 = react.exports.useReducer(Re$3, {
    listboxState: 1,
    propsRef: {
      current: {
        value: m2,
        onChange: f2,
        mode: x2 ? 1 : 0,
        compare: o$4(typeof s2 == "string" ? (p2, T2) => {
          let C2 = s2;
          return (p2 == null ? void 0 : p2[C2]) === (T2 == null ? void 0 : T2[C2]);
        } : s2)
      }
    },
    labelRef: react.exports.createRef(),
    buttonRef: react.exports.createRef(),
    optionsRef: react.exports.createRef(),
    disabled: d2,
    orientation: g,
    options: [],
    searchQuery: "",
    activeOptionIndex: null,
    activationTrigger: 1
  }), [{
    listboxState: a2,
    propsRef: c2,
    optionsRef: P2,
    buttonRef: D2
  }, M2] = b2;
  c2.current.value = m2, c2.current.mode = x2 ? 1 : 0, s$a(() => {
    c2.current.onChange = (p2) => u$6(c2.current.mode, {
      [0]() {
        return f2(p2);
      },
      [1]() {
        let T2 = c2.current.value.slice(), {
          compare: C2
        } = c2.current, W2 = T2.findIndex((X2) => C2(X2, p2));
        return W2 === -1 ? T2.push(p2) : T2.splice(W2, 1), f2(T2);
      }
    });
  }, [f2, c2]), s$a(() => M2({
    type: 2,
    disabled: d2
  }), [d2]), s$a(() => M2({
    type: 3,
    orientation: g
  }), [g]), L$1([D2, P2], (p2, T2) => {
    var C2;
    M2({
      type: 1
    }), F$6(T2, N$2.Loose) || (p2.preventDefault(), (C2 = D2.current) == null || C2.focus());
  }, a2 === 0);
  let N2 = react.exports.useMemo(() => ({
    open: a2 === 0,
    disabled: d2,
    value: m2
  }), [a2, d2, m2]), R2 = {
    ref: O2
  };
  return React.createElement(K.Provider, {
    value: b2
  }, React.createElement(C$1, {
    value: u$6(a2, {
      [0]: p$4.Open,
      [1]: p$4.Closed
    })
  }, u2 != null && m2 != null && e$2({
    [u2]: m2
  }).map(([p2, T2]) => React.createElement(h$5, {
    features: s$6.Hidden,
    ...F$4({
      key: p2,
      as: "input",
      type: "hidden",
      hidden: true,
      readOnly: true,
      name: p2,
      value: T2
    })
  })), $$2({
    ourProps: R2,
    theirProps: S2,
    slot: N2,
    defaultTag: ve$1,
    name: "Listbox"
  })));
}), Se$2 = "button", Ae$2 = C$2(function(i2, n2) {
  var f2;
  let [e3, o2] = w$2("Listbox.Button"), u2 = y(e3.buttonRef, n2), l2 = `headlessui-listbox-button-${I$3()}`, s2 = p$7(), d2 = o$4((b2) => {
    switch (b2.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        b2.preventDefault(), o2({
          type: 0
        }), s2.nextFrame(() => {
          e3.propsRef.current.value || o2({
            type: 4,
            focus: a$4.First
          });
        });
        break;
      case o$2.ArrowUp:
        b2.preventDefault(), o2({
          type: 0
        }), s2.nextFrame(() => {
          e3.propsRef.current.value || o2({
            type: 4,
            focus: a$4.Last
          });
        });
        break;
    }
  }), r2 = o$4((b2) => {
    switch (b2.key) {
      case o$2.Space:
        b2.preventDefault();
        break;
    }
  }), x2 = o$4((b2) => {
    if (r$4(b2.currentTarget))
      return b2.preventDefault();
    e3.listboxState === 0 ? (o2({
      type: 1
    }), s2.nextFrame(() => {
      var a2;
      return (a2 = e3.buttonRef.current) == null ? void 0 : a2.focus({
        preventScroll: true
      });
    })) : (b2.preventDefault(), o2({
      type: 0
    }));
  }), S2 = i$4(() => {
    if (!!e3.labelRef.current)
      return [e3.labelRef.current.id, l2].join(" ");
  }, [e3.labelRef.current, l2]), g = react.exports.useMemo(() => ({
    open: e3.listboxState === 0,
    disabled: e3.disabled,
    value: e3.propsRef.current.value
  }), [e3]), O2 = i2, m2 = {
    ref: u2,
    id: l2,
    type: s$8(i2, e3.buttonRef),
    "aria-haspopup": true,
    "aria-controls": (f2 = e3.optionsRef.current) == null ? void 0 : f2.id,
    "aria-expanded": e3.disabled ? void 0 : e3.listboxState === 0,
    "aria-labelledby": S2,
    disabled: e3.disabled,
    onKeyDown: d2,
    onKeyUp: r2,
    onClick: x2
  };
  return $$2({
    ourProps: m2,
    theirProps: O2,
    slot: g,
    defaultTag: Se$2,
    name: "Listbox.Button"
  });
}), he$1 = "label", Pe$2 = C$2(function(i2, n2) {
  let [e3] = w$2("Listbox.Label"), o2 = `headlessui-listbox-label-${I$3()}`, u2 = y(e3.labelRef, n2), l2 = o$4(() => {
    var x2;
    return (x2 = e3.buttonRef.current) == null ? void 0 : x2.focus({
      preventScroll: true
    });
  }), s2 = react.exports.useMemo(() => ({
    open: e3.listboxState === 0,
    disabled: e3.disabled
  }), [e3]);
  return $$2({
    ourProps: {
      ref: u2,
      id: o2,
      onClick: l2
    },
    theirProps: i2,
    slot: s2,
    defaultTag: he$1,
    name: "Listbox.Label"
  });
}), Ce$2 = "ul", De$1 = S$1.RenderStrategy | S$1.Static, Me$2 = C$2(function(i2, n2) {
  var b2;
  let [e3, o2] = w$2("Listbox.Options"), u2 = y(e3.optionsRef, n2), l2 = `headlessui-listbox-options-${I$3()}`, s2 = p$7(), d2 = p$7(), r2 = s$5(), x2 = (() => r2 !== null ? r2 === p$4.Open : e3.listboxState === 0)();
  react.exports.useEffect(() => {
    var c2;
    let a2 = e3.optionsRef.current;
    !a2 || e3.listboxState === 0 && a2 !== ((c2 = e$3(a2)) == null ? void 0 : c2.activeElement) && a2.focus({
      preventScroll: true
    });
  }, [e3.listboxState, e3.optionsRef]);
  let S2 = o$4((a2) => {
    switch (d2.dispose(), a2.key) {
      case o$2.Space:
        if (e3.searchQuery !== "")
          return a2.preventDefault(), a2.stopPropagation(), o2({
            type: 5,
            value: a2.key
          });
      case o$2.Enter:
        if (a2.preventDefault(), a2.stopPropagation(), e3.activeOptionIndex !== null) {
          let {
            dataRef: c2
          } = e3.options[e3.activeOptionIndex];
          e3.propsRef.current.onChange(c2.current.value);
        }
        e3.propsRef.current.mode === 0 && (o2({
          type: 1
        }), m$4().nextFrame(() => {
          var c2;
          return (c2 = e3.buttonRef.current) == null ? void 0 : c2.focus({
            preventScroll: true
          });
        }));
        break;
      case u$6(e3.orientation, {
        vertical: o$2.ArrowDown,
        horizontal: o$2.ArrowRight
      }):
        return a2.preventDefault(), a2.stopPropagation(), o2({
          type: 4,
          focus: a$4.Next
        });
      case u$6(e3.orientation, {
        vertical: o$2.ArrowUp,
        horizontal: o$2.ArrowLeft
      }):
        return a2.preventDefault(), a2.stopPropagation(), o2({
          type: 4,
          focus: a$4.Previous
        });
      case o$2.Home:
      case o$2.PageUp:
        return a2.preventDefault(), a2.stopPropagation(), o2({
          type: 4,
          focus: a$4.First
        });
      case o$2.End:
      case o$2.PageDown:
        return a2.preventDefault(), a2.stopPropagation(), o2({
          type: 4,
          focus: a$4.Last
        });
      case o$2.Escape:
        return a2.preventDefault(), a2.stopPropagation(), o2({
          type: 1
        }), s2.nextFrame(() => {
          var c2;
          return (c2 = e3.buttonRef.current) == null ? void 0 : c2.focus({
            preventScroll: true
          });
        });
      case o$2.Tab:
        a2.preventDefault(), a2.stopPropagation();
        break;
      default:
        a2.key.length === 1 && (o2({
          type: 5,
          value: a2.key
        }), d2.setTimeout(() => o2({
          type: 6
        }), 350));
        break;
    }
  }), g = i$4(() => {
    var a2, c2, P2;
    return (P2 = (a2 = e3.labelRef.current) == null ? void 0 : a2.id) != null ? P2 : (c2 = e3.buttonRef.current) == null ? void 0 : c2.id;
  }, [e3.labelRef.current, e3.buttonRef.current]), O2 = react.exports.useMemo(() => ({
    open: e3.listboxState === 0
  }), [e3]), m2 = i2, f2 = {
    "aria-activedescendant": e3.activeOptionIndex === null || (b2 = e3.options[e3.activeOptionIndex]) == null ? void 0 : b2.id,
    "aria-multiselectable": e3.propsRef.current.mode === 1 ? true : void 0,
    "aria-labelledby": g,
    "aria-orientation": e3.orientation,
    id: l2,
    onKeyDown: S2,
    role: "listbox",
    tabIndex: 0,
    ref: u2
  };
  return $$2({
    ourProps: f2,
    theirProps: m2,
    slot: O2,
    defaultTag: Ce$2,
    features: De$1,
    visible: x2,
    name: "Listbox.Options"
  });
}), Ee$2 = "li", Ie$2 = C$2(function(i2, n2) {
  let {
    disabled: e3 = false,
    value: o2,
    ...u2
  } = i2, [l2, s2] = w$2("Listbox.Option"), d2 = `headlessui-listbox-option-${I$3()}`, r2 = l2.activeOptionIndex !== null ? l2.options[l2.activeOptionIndex].id === d2 : false, {
    value: x2,
    compare: S2
  } = l2.propsRef.current, g = u$6(l2.propsRef.current.mode, {
    [1]: () => x2.some((R2) => S2(R2, o2)),
    [0]: () => S2(x2, o2)
  }), O2 = react.exports.useRef(null), m2 = y(n2, O2);
  s$a(() => {
    if (l2.listboxState !== 0 || !r2 || l2.activationTrigger === 0)
      return;
    let R2 = m$4();
    return R2.requestAnimationFrame(() => {
      var p2, T2;
      (T2 = (p2 = O2.current) == null ? void 0 : p2.scrollIntoView) == null || T2.call(p2, {
        block: "nearest"
      });
    }), R2.dispose;
  }, [O2, r2, l2.listboxState, l2.activationTrigger, l2.activeOptionIndex]);
  let f2 = react.exports.useRef({
    disabled: e3,
    value: o2,
    domRef: O2
  });
  s$a(() => {
    f2.current.disabled = e3;
  }, [f2, e3]), s$a(() => {
    f2.current.value = o2;
  }, [f2, o2]), s$a(() => {
    var R2, p2;
    f2.current.textValue = (p2 = (R2 = O2.current) == null ? void 0 : R2.textContent) == null ? void 0 : p2.toLowerCase();
  }, [f2, O2]);
  let b2 = o$4(() => l2.propsRef.current.onChange(o2));
  s$a(() => (s2({
    type: 7,
    id: d2,
    dataRef: f2
  }), () => s2({
    type: 8,
    id: d2
  })), [f2, d2]);
  let a2 = o$4((R2) => {
    if (e3)
      return R2.preventDefault();
    b2(), l2.propsRef.current.mode === 0 && (s2({
      type: 1
    }), m$4().nextFrame(() => {
      var p2;
      return (p2 = l2.buttonRef.current) == null ? void 0 : p2.focus({
        preventScroll: true
      });
    }));
  }), c2 = o$4(() => {
    if (e3)
      return s2({
        type: 4,
        focus: a$4.Nothing
      });
    s2({
      type: 4,
      focus: a$4.Specific,
      id: d2
    });
  }), P2 = o$4(() => {
    e3 || r2 || s2({
      type: 4,
      focus: a$4.Specific,
      id: d2,
      trigger: 0
    });
  }), D2 = o$4(() => {
    e3 || !r2 || s2({
      type: 4,
      focus: a$4.Nothing
    });
  }), M2 = react.exports.useMemo(() => ({
    active: r2,
    selected: g,
    disabled: e3
  }), [r2, g, e3]);
  return $$2({
    ourProps: {
      id: d2,
      ref: m2,
      role: "option",
      tabIndex: e3 === true ? void 0 : -1,
      "aria-disabled": e3 === true ? true : void 0,
      "aria-selected": g,
      disabled: void 0,
      onClick: a2,
      onFocus: c2,
      onPointerMove: P2,
      onMouseMove: P2,
      onPointerLeave: D2,
      onMouseLeave: D2
    },
    theirProps: u2,
    slot: M2,
    defaultTag: Ee$2,
    name: "Listbox.Option"
  });
}), pt = Object.assign(Le$1, {
  Button: Ae$2,
  Label: Pe$2,
  Options: Me$2,
  Option: Ie$2
});
var ue = ((o2) => (o2[o2.Open = 0] = "Open", o2[o2.Closed = 1] = "Closed", o2))(ue || {}), se = ((o2) => (o2[o2.Pointer = 0] = "Pointer", o2[o2.Other = 1] = "Other", o2))(se || {}), le$1 = ((a2) => (a2[a2.OpenMenu = 0] = "OpenMenu", a2[a2.CloseMenu = 1] = "CloseMenu", a2[a2.GoToItem = 2] = "GoToItem", a2[a2.Search = 3] = "Search", a2[a2.ClearSearch = 4] = "ClearSearch", a2[a2.RegisterItem = 5] = "RegisterItem", a2[a2.UnregisterItem = 6] = "UnregisterItem", a2))(le$1 || {});
function k$1(t2, i2 = (o2) => o2) {
  let o2 = t2.activeItemIndex !== null ? t2.items[t2.activeItemIndex] : null, e3 = S$2(i2(t2.items.slice()), (u2) => u2.dataRef.current.domRef.current), n2 = o2 ? e3.indexOf(o2) : null;
  return n2 === -1 && (n2 = null), {
    items: e3,
    activeItemIndex: n2
  };
}
let ce$1 = {
  [1](t2) {
    return t2.menuState === 1 ? t2 : {
      ...t2,
      activeItemIndex: null,
      menuState: 1
    };
  },
  [0](t2) {
    return t2.menuState === 0 ? t2 : {
      ...t2,
      menuState: 0
    };
  },
  [2]: (t2, i2) => {
    var n2;
    let o2 = k$1(t2), e3 = x$4(i2, {
      resolveItems: () => o2.items,
      resolveActiveIndex: () => o2.activeItemIndex,
      resolveId: (u2) => u2.id,
      resolveDisabled: (u2) => u2.dataRef.current.disabled
    });
    return {
      ...t2,
      ...o2,
      searchQuery: "",
      activeItemIndex: e3,
      activationTrigger: (n2 = i2.trigger) != null ? n2 : 1
    };
  },
  [3]: (t2, i2) => {
    let e3 = t2.searchQuery !== "" ? 0 : 1, n2 = t2.searchQuery + i2.value.toLowerCase(), s2 = (t2.activeItemIndex !== null ? t2.items.slice(t2.activeItemIndex + e3).concat(t2.items.slice(0, t2.activeItemIndex + e3)) : t2.items).find((c2) => {
      var p2;
      return ((p2 = c2.dataRef.current.textValue) == null ? void 0 : p2.startsWith(n2)) && !c2.dataRef.current.disabled;
    }), a2 = s2 ? t2.items.indexOf(s2) : -1;
    return a2 === -1 || a2 === t2.activeItemIndex ? {
      ...t2,
      searchQuery: n2
    } : {
      ...t2,
      searchQuery: n2,
      activeItemIndex: a2,
      activationTrigger: 1
    };
  },
  [4](t2) {
    return t2.searchQuery === "" ? t2 : {
      ...t2,
      searchQuery: "",
      searchActiveItemIndex: null
    };
  },
  [5]: (t2, i2) => {
    let o2 = k$1(t2, (e3) => [...e3, {
      id: i2.id,
      dataRef: i2.dataRef
    }]);
    return {
      ...t2,
      ...o2
    };
  },
  [6]: (t2, i2) => {
    let o2 = k$1(t2, (e3) => {
      let n2 = e3.findIndex((u2) => u2.id === i2.id);
      return n2 !== -1 && e3.splice(n2, 1), e3;
    });
    return {
      ...t2,
      ...o2,
      activationTrigger: 1
    };
  }
}, w$1 = react.exports.createContext(null);
w$1.displayName = "MenuContext";
function D$1(t2) {
  let i2 = react.exports.useContext(w$1);
  if (i2 === null) {
    let o2 = new Error(`<${t2} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o2, D$1), o2;
  }
  return i2;
}
function pe$1(t2, i2) {
  return u$6(i2.type, ce$1, t2, i2);
}
let me$1 = react.exports.Fragment, de$1 = C$2(function(i2, o2) {
  let e3 = react.exports.useReducer(pe$1, {
    menuState: 1,
    buttonRef: react.exports.createRef(),
    itemsRef: react.exports.createRef(),
    items: [],
    searchQuery: "",
    activeItemIndex: null,
    activationTrigger: 1
  }), [{
    menuState: n2,
    itemsRef: u2,
    buttonRef: s2
  }, a2] = e3, c2 = y(o2);
  L$1([s2, u2], (M2, R2) => {
    var f2;
    a2({
      type: 1
    }), F$6(R2, N$2.Loose) || (M2.preventDefault(), (f2 = s2.current) == null || f2.focus());
  }, n2 === 0);
  let p2 = react.exports.useMemo(() => ({
    open: n2 === 0
  }), [n2]), g = i2, d2 = {
    ref: c2
  };
  return React.createElement(w$1.Provider, {
    value: e3
  }, React.createElement(C$1, {
    value: u$6(n2, {
      [0]: p$4.Open,
      [1]: p$4.Closed
    })
  }, $$2({
    ourProps: d2,
    theirProps: g,
    slot: p2,
    defaultTag: me$1,
    name: "Menu"
  })));
}), fe$1 = "button", Te$1 = C$2(function(i2, o2) {
  var f2;
  let [e3, n2] = D$1("Menu.Button"), u2 = y(e3.buttonRef, o2), s2 = `headlessui-menu-button-${I$3()}`, a2 = p$7(), c2 = o$4((l2) => {
    switch (l2.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        l2.preventDefault(), l2.stopPropagation(), n2({
          type: 0
        }), a2.nextFrame(() => n2({
          type: 2,
          focus: a$4.First
        }));
        break;
      case o$2.ArrowUp:
        l2.preventDefault(), l2.stopPropagation(), n2({
          type: 0
        }), a2.nextFrame(() => n2({
          type: 2,
          focus: a$4.Last
        }));
        break;
    }
  }), p2 = o$4((l2) => {
    switch (l2.key) {
      case o$2.Space:
        l2.preventDefault();
        break;
    }
  }), g = o$4((l2) => {
    if (r$4(l2.currentTarget))
      return l2.preventDefault();
    i2.disabled || (e3.menuState === 0 ? (n2({
      type: 1
    }), a2.nextFrame(() => {
      var b2;
      return (b2 = e3.buttonRef.current) == null ? void 0 : b2.focus({
        preventScroll: true
      });
    })) : (l2.preventDefault(), n2({
      type: 0
    })));
  }), d2 = react.exports.useMemo(() => ({
    open: e3.menuState === 0
  }), [e3]), M2 = i2, R2 = {
    ref: u2,
    id: s2,
    type: s$8(i2, e3.buttonRef),
    "aria-haspopup": true,
    "aria-controls": (f2 = e3.itemsRef.current) == null ? void 0 : f2.id,
    "aria-expanded": i2.disabled ? void 0 : e3.menuState === 0,
    onKeyDown: c2,
    onKeyUp: p2,
    onClick: g
  };
  return $$2({
    ourProps: R2,
    theirProps: M2,
    slot: d2,
    defaultTag: fe$1,
    name: "Menu.Button"
  });
}), ye$1 = "div", Ie$1 = S$1.RenderStrategy | S$1.Static, ge$2 = C$2(function(i2, o2) {
  var b2, C2;
  let [e3, n2] = D$1("Menu.Items"), u2 = y(e3.itemsRef, o2), s2 = n$4(e3.itemsRef), a2 = `headlessui-menu-items-${I$3()}`, c2 = p$7(), p2 = s$5(), g = (() => p2 !== null ? p2 === p$4.Open : e3.menuState === 0)();
  react.exports.useEffect(() => {
    let r2 = e3.itemsRef.current;
    !r2 || e3.menuState === 0 && r2 !== (s2 == null ? void 0 : s2.activeElement) && r2.focus({
      preventScroll: true
    });
  }, [e3.menuState, e3.itemsRef, s2]), F$5({
    container: e3.itemsRef.current,
    enabled: e3.menuState === 0,
    accept(r2) {
      return r2.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : r2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    },
    walk(r2) {
      r2.setAttribute("role", "none");
    }
  });
  let d2 = o$4((r2) => {
    var T2, A2;
    switch (c2.dispose(), r2.key) {
      case o$2.Space:
        if (e3.searchQuery !== "")
          return r2.preventDefault(), r2.stopPropagation(), n2({
            type: 3,
            value: r2.key
          });
      case o$2.Enter:
        if (r2.preventDefault(), r2.stopPropagation(), n2({
          type: 1
        }), e3.activeItemIndex !== null) {
          let {
            dataRef: v2
          } = e3.items[e3.activeItemIndex];
          (A2 = (T2 = v2.current) == null ? void 0 : T2.domRef.current) == null || A2.click();
        }
        I$2(e3.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return r2.preventDefault(), r2.stopPropagation(), n2({
          type: 2,
          focus: a$4.Next
        });
      case o$2.ArrowUp:
        return r2.preventDefault(), r2.stopPropagation(), n2({
          type: 2,
          focus: a$4.Previous
        });
      case o$2.Home:
      case o$2.PageUp:
        return r2.preventDefault(), r2.stopPropagation(), n2({
          type: 2,
          focus: a$4.First
        });
      case o$2.End:
      case o$2.PageDown:
        return r2.preventDefault(), r2.stopPropagation(), n2({
          type: 2,
          focus: a$4.Last
        });
      case o$2.Escape:
        r2.preventDefault(), r2.stopPropagation(), n2({
          type: 1
        }), m$4().nextFrame(() => {
          var v2;
          return (v2 = e3.buttonRef.current) == null ? void 0 : v2.focus({
            preventScroll: true
          });
        });
        break;
      case o$2.Tab:
        r2.preventDefault(), r2.stopPropagation(), n2({
          type: 1
        }), m$4().nextFrame(() => {
          D$2(e3.buttonRef.current, r2.shiftKey ? T$3.Previous : T$3.Next);
        });
        break;
      default:
        r2.key.length === 1 && (n2({
          type: 3,
          value: r2.key
        }), c2.setTimeout(() => n2({
          type: 4
        }), 350));
        break;
    }
  }), M2 = o$4((r2) => {
    switch (r2.key) {
      case o$2.Space:
        r2.preventDefault();
        break;
    }
  }), R2 = react.exports.useMemo(() => ({
    open: e3.menuState === 0
  }), [e3]), f2 = i2, l2 = {
    "aria-activedescendant": e3.activeItemIndex === null || (b2 = e3.items[e3.activeItemIndex]) == null ? void 0 : b2.id,
    "aria-labelledby": (C2 = e3.buttonRef.current) == null ? void 0 : C2.id,
    id: a2,
    onKeyDown: d2,
    onKeyUp: M2,
    role: "menu",
    tabIndex: 0,
    ref: u2
  };
  return $$2({
    ourProps: l2,
    theirProps: f2,
    slot: R2,
    defaultTag: ye$1,
    features: Ie$1,
    visible: g,
    name: "Menu.Items"
  });
}), Me$1 = react.exports.Fragment, Re$2 = C$2(function(i2, o2) {
  let {
    disabled: e3 = false,
    ...n2
  } = i2, [u2, s2] = D$1("Menu.Item"), a2 = `headlessui-menu-item-${I$3()}`, c2 = u2.activeItemIndex !== null ? u2.items[u2.activeItemIndex].id === a2 : false, p2 = react.exports.useRef(null), g = y(o2, p2);
  s$a(() => {
    if (u2.menuState !== 0 || !c2 || u2.activationTrigger === 0)
      return;
    let r2 = m$4();
    return r2.requestAnimationFrame(() => {
      var T2, A2;
      (A2 = (T2 = p2.current) == null ? void 0 : T2.scrollIntoView) == null || A2.call(T2, {
        block: "nearest"
      });
    }), r2.dispose;
  }, [p2, c2, u2.menuState, u2.activationTrigger, u2.activeItemIndex]);
  let d2 = react.exports.useRef({
    disabled: e3,
    domRef: p2
  });
  s$a(() => {
    d2.current.disabled = e3;
  }, [d2, e3]), s$a(() => {
    var r2, T2;
    d2.current.textValue = (T2 = (r2 = p2.current) == null ? void 0 : r2.textContent) == null ? void 0 : T2.toLowerCase();
  }, [d2, p2]), s$a(() => (s2({
    type: 5,
    id: a2,
    dataRef: d2
  }), () => s2({
    type: 6,
    id: a2
  })), [d2, a2]);
  let M2 = o$4((r2) => {
    if (e3)
      return r2.preventDefault();
    s2({
      type: 1
    }), I$2(u2.buttonRef.current);
  }), R2 = o$4(() => {
    if (e3)
      return s2({
        type: 2,
        focus: a$4.Nothing
      });
    s2({
      type: 2,
      focus: a$4.Specific,
      id: a2
    });
  }), f2 = o$4(() => {
    e3 || c2 || s2({
      type: 2,
      focus: a$4.Specific,
      id: a2,
      trigger: 0
    });
  }), l2 = o$4(() => {
    e3 || !c2 || s2({
      type: 2,
      focus: a$4.Nothing
    });
  }), b2 = react.exports.useMemo(() => ({
    active: c2,
    disabled: e3
  }), [c2, e3]);
  return $$2({
    ourProps: {
      id: a2,
      ref: g,
      role: "menuitem",
      tabIndex: e3 === true ? void 0 : -1,
      "aria-disabled": e3 === true ? true : void 0,
      disabled: void 0,
      onClick: M2,
      onFocus: R2,
      onPointerMove: f2,
      onMouseMove: f2,
      onPointerLeave: l2,
      onMouseLeave: l2
    },
    theirProps: n2,
    slot: b2,
    defaultTag: Me$1,
    name: "Menu.Item"
  });
}), qe$1 = Object.assign(de$1, {
  Button: Te$1,
  Items: ge$2,
  Item: Re$2
});
var Ae$1 = ((f2) => (f2[f2.Open = 0] = "Open", f2[f2.Closed = 1] = "Closed", f2))(Ae$1 || {}), Ce$1 = ((n2) => (n2[n2.TogglePopover = 0] = "TogglePopover", n2[n2.ClosePopover = 1] = "ClosePopover", n2[n2.SetButton = 2] = "SetButton", n2[n2.SetButtonId = 3] = "SetButtonId", n2[n2.SetPanel = 4] = "SetPanel", n2[n2.SetPanelId = 5] = "SetPanelId", n2))(Ce$1 || {});
let Re$1 = {
  [0]: (r2) => ({
    ...r2,
    popoverState: u$6(r2.popoverState, {
      [0]: 1,
      [1]: 0
    })
  }),
  [1](r2) {
    return r2.popoverState === 1 ? r2 : {
      ...r2,
      popoverState: 1
    };
  },
  [2](r2, t2) {
    return r2.button === t2.button ? r2 : {
      ...r2,
      button: t2.button
    };
  },
  [3](r2, t2) {
    return r2.buttonId === t2.buttonId ? r2 : {
      ...r2,
      buttonId: t2.buttonId
    };
  },
  [4](r2, t2) {
    return r2.panel === t2.panel ? r2 : {
      ...r2,
      panel: t2.panel
    };
  },
  [5](r2, t2) {
    return r2.panelId === t2.panelId ? r2 : {
      ...r2,
      panelId: t2.panelId
    };
  }
}, te$1 = react.exports.createContext(null);
te$1.displayName = "PopoverContext";
function Q$2(r2) {
  let t2 = react.exports.useContext(te$1);
  if (t2 === null) {
    let f2 = new Error(`<${r2} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(f2, Q$2), f2;
  }
  return t2;
}
let oe = react.exports.createContext(null);
oe.displayName = "PopoverAPIContext";
function re$2(r2) {
  let t2 = react.exports.useContext(oe);
  if (t2 === null) {
    let f2 = new Error(`<${r2} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(f2, re$2), f2;
  }
  return t2;
}
let ne$1 = react.exports.createContext(null);
ne$1.displayName = "PopoverGroupContext";
function ce() {
  return react.exports.useContext(ne$1);
}
let le = react.exports.createContext(null);
le.displayName = "PopoverPanelContext";
function Oe() {
  return react.exports.useContext(le);
}
function Me(r2, t2) {
  return u$6(t2.type, Re$1, r2, t2);
}
let Le = "div", Ie = C$2(function(t2, f2) {
  var O2;
  let o2 = `headlessui-popover-button-${I$3()}`, v2 = `headlessui-popover-panel-${I$3()}`, a2 = react.exports.useRef(null), n2 = y(f2, T$2((e3) => {
    a2.current = e3;
  })), g = react.exports.useReducer(Me, {
    popoverState: 1,
    button: null,
    buttonId: o2,
    panel: null,
    panelId: v2,
    beforePanelSentinel: react.exports.createRef(),
    afterPanelSentinel: react.exports.createRef()
  }), [{
    popoverState: y$12,
    button: l2,
    panel: P2,
    beforePanelSentinel: s2,
    afterPanelSentinel: B2
  }, i2] = g, T2 = n$4((O2 = a2.current) != null ? O2 : l2);
  react.exports.useEffect(() => i2({
    type: 3,
    buttonId: o2
  }), [o2, i2]), react.exports.useEffect(() => i2({
    type: 5,
    panelId: v2
  }), [v2, i2]);
  let c2 = react.exports.useMemo(() => {
    if (!l2 || !P2)
      return false;
    for (let M2 of document.querySelectorAll("body > *"))
      if (Number(M2 == null ? void 0 : M2.contains(l2)) ^ Number(M2 == null ? void 0 : M2.contains(P2)))
        return true;
    let e3 = d$2(), p2 = e3.indexOf(l2), m2 = (p2 + e3.length - 1) % e3.length, C2 = (p2 + 1) % e3.length, D2 = e3[m2], V2 = e3[C2];
    return !P2.contains(D2) && !P2.contains(V2);
  }, [l2, P2]), d2 = react.exports.useMemo(() => ({
    buttonId: o2,
    panelId: v2,
    close: () => i2({
      type: 1
    })
  }), [o2, v2, i2]), E$12 = ce(), A2 = E$12 == null ? void 0 : E$12.registerPopover, L2 = o$4(() => {
    var e3;
    return (e3 = E$12 == null ? void 0 : E$12.isFocusWithinPopoverGroup()) != null ? e3 : (T2 == null ? void 0 : T2.activeElement) && ((l2 == null ? void 0 : l2.contains(T2.activeElement)) || (P2 == null ? void 0 : P2.contains(T2.activeElement)));
  });
  react.exports.useEffect(() => A2 == null ? void 0 : A2(d2), [A2, d2]), E(T2 == null ? void 0 : T2.defaultView, "focus", (e3) => {
    var p2, m2, C2, D2;
    y$12 === 0 && (L2() || !l2 || !P2 || (m2 = (p2 = s2.current) == null ? void 0 : p2.contains) != null && m2.call(p2, e3.target) || (D2 = (C2 = B2.current) == null ? void 0 : C2.contains) != null && D2.call(C2, e3.target) || i2({
      type: 1
    }));
  }, true), L$1([l2, P2], (e3, p2) => {
    i2({
      type: 1
    }), F$6(p2, N$2.Loose) || (e3.preventDefault(), l2 == null || l2.focus());
  }, y$12 === 0);
  let I2 = o$4((e3) => {
    i2({
      type: 1
    });
    let p2 = (() => e3 ? e3 instanceof HTMLElement ? e3 : "current" in e3 && e3.current instanceof HTMLElement ? e3.current : l2 : l2)();
    p2 == null || p2.focus();
  }), H2 = react.exports.useMemo(() => ({
    close: I2,
    isPortalled: c2
  }), [I2, c2]), u2 = react.exports.useMemo(() => ({
    open: y$12 === 0,
    close: I2
  }), [y$12, I2]), S2 = t2, R2 = {
    ref: n2
  };
  return React.createElement(te$1.Provider, {
    value: g
  }, React.createElement(oe.Provider, {
    value: H2
  }, React.createElement(C$1, {
    value: u$6(y$12, {
      [0]: p$4.Open,
      [1]: p$4.Closed
    })
  }, $$2({
    ourProps: R2,
    theirProps: S2,
    slot: u2,
    defaultTag: Le,
    name: "Popover"
  }))));
}), Fe = "button", he = C$2(function(t2, f2) {
  let [o2, v2] = Q$2("Popover.Button"), {
    isPortalled: a2
  } = re$2("Popover.Button"), n2 = react.exports.useRef(null), g = `headlessui-focus-sentinel-${I$3()}`, y$12 = ce(), l2 = y$12 == null ? void 0 : y$12.closeOthers, P2 = Oe(), s2 = P2 === null ? false : P2 === o2.panelId, B2 = y(n2, f2, s2 ? null : (e3) => v2({
    type: 2,
    button: e3
  })), i2 = y(n2, f2), T2 = n$4(n2), c2 = o$4((e3) => {
    var p2, m2, C2;
    if (s2) {
      if (o2.popoverState === 1)
        return;
      switch (e3.key) {
        case o$2.Space:
        case o$2.Enter:
          e3.preventDefault(), (m2 = (p2 = e3.target).click) == null || m2.call(p2), v2({
            type: 1
          }), (C2 = o2.button) == null || C2.focus();
          break;
      }
    } else
      switch (e3.key) {
        case o$2.Space:
        case o$2.Enter:
          e3.preventDefault(), e3.stopPropagation(), o2.popoverState === 1 && (l2 == null || l2(o2.buttonId)), v2({
            type: 0
          });
          break;
        case o$2.Escape:
          if (o2.popoverState !== 0)
            return l2 == null ? void 0 : l2(o2.buttonId);
          if (!n2.current || (T2 == null ? void 0 : T2.activeElement) && !n2.current.contains(T2.activeElement))
            return;
          e3.preventDefault(), e3.stopPropagation(), v2({
            type: 1
          });
          break;
      }
  }), d2 = o$4((e3) => {
    s2 || e3.key === o$2.Space && e3.preventDefault();
  }), E2 = o$4((e3) => {
    var p2, m2;
    r$4(e3.currentTarget) || t2.disabled || (s2 ? (v2({
      type: 1
    }), (p2 = o2.button) == null || p2.focus()) : (e3.preventDefault(), e3.stopPropagation(), o2.popoverState === 1 && (l2 == null || l2(o2.buttonId)), v2({
      type: 0
    }), (m2 = o2.button) == null || m2.focus()));
  }), A2 = o$4((e3) => {
    e3.preventDefault(), e3.stopPropagation();
  }), L2 = o2.popoverState === 0, I2 = react.exports.useMemo(() => ({
    open: L2
  }), [L2]), H2 = s$8(t2, n2), u2 = t2, S2 = s2 ? {
    ref: i2,
    type: H2,
    onKeyDown: c2,
    onClick: E2
  } : {
    ref: B2,
    id: o2.buttonId,
    type: H2,
    "aria-expanded": t2.disabled ? void 0 : o2.popoverState === 0,
    "aria-controls": o2.panel ? o2.panelId : void 0,
    onKeyDown: c2,
    onKeyUp: d2,
    onClick: E2,
    onMouseDown: A2
  }, R2 = n$5(), O$12 = o$4(() => {
    let e3 = o2.panel;
    if (!e3)
      return;
    function p2() {
      u$6(R2.current, {
        [s$3.Forwards]: () => O(e3, T$3.First),
        [s$3.Backwards]: () => O(e3, T$3.Last)
      });
    }
    p2();
  });
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [$$2({
      ourProps: S2,
      theirProps: u2,
      slot: I2,
      defaultTag: Fe,
      name: "Popover.Button"
    }), L2 && !s2 && a2 && /* @__PURE__ */ jsx(h$5, {
      id: g,
      features: s$6.Focusable,
      as: "button",
      type: "button",
      onFocus: O$12
    })]
  });
}), Be = "div", De = S$1.RenderStrategy | S$1.Static, xe$2 = C$2(function(t2, f2) {
  let [{
    popoverState: o2
  }, v2] = Q$2("Popover.Overlay"), a2 = y(f2), n2 = `headlessui-popover-overlay-${I$3()}`, g = s$5(), y$12 = (() => g !== null ? g === p$4.Open : o2 === 0)(), l2 = o$4((i2) => {
    if (r$4(i2.currentTarget))
      return i2.preventDefault();
    v2({
      type: 1
    });
  }), P2 = react.exports.useMemo(() => ({
    open: o2 === 0
  }), [o2]);
  return $$2({
    ourProps: {
      ref: a2,
      id: n2,
      "aria-hidden": true,
      onClick: l2
    },
    theirProps: t2,
    slot: P2,
    defaultTag: Be,
    features: De,
    visible: y$12,
    name: "Popover.Overlay"
  });
}), He = "div", Ge = S$1.RenderStrategy | S$1.Static, ke = C$2(function(t2, f2) {
  let {
    focus: o2 = false,
    ...v2
  } = t2, [a2, n2] = Q$2("Popover.Panel"), {
    close: g,
    isPortalled: y$12
  } = re$2("Popover.Panel"), l2 = `headlessui-focus-sentinel-before-${I$3()}`, P2 = `headlessui-focus-sentinel-after-${I$3()}`, s2 = react.exports.useRef(null), B2 = y(s2, f2, (u2) => {
    n2({
      type: 4,
      panel: u2
    });
  }), i2 = n$4(s2), T2 = s$5(), c2 = (() => T2 !== null ? T2 === p$4.Open : a2.popoverState === 0)(), d2 = o$4((u2) => {
    var S2;
    switch (u2.key) {
      case o$2.Escape:
        if (a2.popoverState !== 0 || !s2.current || (i2 == null ? void 0 : i2.activeElement) && !s2.current.contains(i2.activeElement))
          return;
        u2.preventDefault(), u2.stopPropagation(), n2({
          type: 1
        }), (S2 = a2.button) == null || S2.focus();
        break;
    }
  });
  react.exports.useEffect(() => {
    var u2;
    t2.static || a2.popoverState === 1 && ((u2 = t2.unmount) != null ? u2 : true) && n2({
      type: 4,
      panel: null
    });
  }, [a2.popoverState, t2.unmount, t2.static, n2]), react.exports.useEffect(() => {
    if (!o2 || a2.popoverState !== 0 || !s2.current)
      return;
    let u2 = i2 == null ? void 0 : i2.activeElement;
    s2.current.contains(u2) || O(s2.current, T$3.First);
  }, [o2, s2, a2.popoverState]);
  let E2 = react.exports.useMemo(() => ({
    open: a2.popoverState === 0,
    close: g
  }), [a2, g]), A2 = {
    ref: B2,
    id: a2.panelId,
    onKeyDown: d2,
    onBlur: o2 && a2.popoverState === 0 ? (u2) => {
      var R2, O2, e3, p2, m2;
      let S2 = u2.relatedTarget;
      !S2 || !s2.current || (R2 = s2.current) != null && R2.contains(S2) || (n2({
        type: 1
      }), (((e3 = (O2 = a2.beforePanelSentinel.current) == null ? void 0 : O2.contains) == null ? void 0 : e3.call(O2, S2)) || ((m2 = (p2 = a2.afterPanelSentinel.current) == null ? void 0 : p2.contains) == null ? void 0 : m2.call(p2, S2))) && S2.focus({
        preventScroll: true
      }));
    } : void 0,
    tabIndex: -1
  }, L2 = n$5(), I2 = o$4(() => {
    let u2 = s2.current;
    if (!u2)
      return;
    function S2() {
      u$6(L2.current, {
        [s$3.Forwards]: () => {
          O(u2, T$3.First);
        },
        [s$3.Backwards]: () => {
          var R2;
          (R2 = a2.button) == null || R2.focus({
            preventScroll: true
          });
        }
      });
    }
    S2();
  }), H2 = o$4(() => {
    let u2 = s2.current;
    if (!u2)
      return;
    function S2() {
      u$6(L2.current, {
        [s$3.Forwards]: () => {
          var C2, D2, V2;
          if (!a2.button)
            return;
          let R2 = d$2(), O$12 = R2.indexOf(a2.button), e3 = R2.slice(0, O$12 + 1), m2 = [...R2.slice(O$12 + 1), ...e3];
          for (let M2 of m2.slice())
            if (((D2 = (C2 = M2 == null ? void 0 : M2.id) == null ? void 0 : C2.startsWith) == null ? void 0 : D2.call(C2, "headlessui-focus-sentinel-")) || ((V2 = a2.panel) == null ? void 0 : V2.contains(M2))) {
              let ae2 = m2.indexOf(M2);
              ae2 !== -1 && m2.splice(ae2, 1);
            }
          O(m2, T$3.First, false);
        },
        [s$3.Backwards]: () => O(u2, T$3.Last)
      });
    }
    S2();
  });
  return React.createElement(le.Provider, {
    value: a2.panelId
  }, c2 && y$12 && /* @__PURE__ */ jsx(h$5, {
    id: l2,
    ref: a2.beforePanelSentinel,
    features: s$6.Focusable,
    as: "button",
    type: "button",
    onFocus: I2
  }), $$2({
    ourProps: A2,
    theirProps: v2,
    slot: E2,
    defaultTag: He,
    features: Ge,
    visible: c2,
    name: "Popover.Panel"
  }), c2 && y$12 && /* @__PURE__ */ jsx(h$5, {
    id: P2,
    ref: a2.afterPanelSentinel,
    features: s$6.Focusable,
    as: "button",
    type: "button",
    onFocus: H2
  }));
}), _e = "div", we = C$2(function(t2, f2) {
  let o2 = react.exports.useRef(null), v2 = y(o2, f2), [a2, n2] = react.exports.useState([]), g = o$4((c2) => {
    n2((d2) => {
      let E2 = d2.indexOf(c2);
      if (E2 !== -1) {
        let A2 = d2.slice();
        return A2.splice(E2, 1), A2;
      }
      return d2;
    });
  }), y$12 = o$4((c2) => (n2((d2) => [...d2, c2]), () => g(c2))), l2 = o$4(() => {
    var E2;
    let c2 = e$3(o2);
    if (!c2)
      return false;
    let d2 = c2.activeElement;
    return (E2 = o2.current) != null && E2.contains(d2) ? true : a2.some((A2) => {
      var L2, I2;
      return ((L2 = c2.getElementById(A2.buttonId)) == null ? void 0 : L2.contains(d2)) || ((I2 = c2.getElementById(A2.panelId)) == null ? void 0 : I2.contains(d2));
    });
  }), P2 = o$4((c2) => {
    for (let d2 of a2)
      d2.buttonId !== c2 && d2.close();
  }), s2 = react.exports.useMemo(() => ({
    registerPopover: y$12,
    unregisterPopover: g,
    isFocusWithinPopoverGroup: l2,
    closeOthers: P2
  }), [y$12, g, l2, P2]), B2 = react.exports.useMemo(() => ({}), []), i2 = t2, T2 = {
    ref: v2
  };
  return React.createElement(ne$1.Provider, {
    value: s2
  }, $$2({
    ourProps: T2,
    theirProps: i2,
    slot: B2,
    defaultTag: _e,
    name: "Popover.Group"
  }));
}), mt = Object.assign(Ie, {
  Button: he,
  Overlay: xe$2,
  Panel: ke,
  Group: we
});
let u$2 = react.exports.createContext(null);
function c$3() {
  let o2 = react.exports.useContext(u$2);
  if (o2 === null) {
    let t2 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t2, c$3), t2;
  }
  return o2;
}
function M$1() {
  let [o2, t2] = react.exports.useState([]);
  return [o2.length > 0 ? o2.join(" ") : void 0, react.exports.useMemo(() => function(e3) {
    let l2 = o$4((a2) => (t2((i2) => [...i2, a2]), () => t2((i2) => {
      let n2 = i2.slice(), d2 = n2.indexOf(a2);
      return d2 !== -1 && n2.splice(d2, 1), n2;
    }))), r2 = react.exports.useMemo(() => ({
      register: l2,
      slot: e3.slot,
      name: e3.name,
      props: e3.props
    }), [l2, e3.slot, e3.name, e3.props]);
    return React.createElement(u$2.Provider, {
      value: r2
    }, e3.children);
  }, [t2])];
}
let h$3 = "label", F$1 = C$2(function(t2, s2) {
  let {
    passive: e3 = false,
    ...l2
  } = t2, r2 = c$3(), a2 = `headlessui-label-${I$3()}`, i2 = y(s2);
  s$a(() => r2.register(a2), [a2, r2.register]);
  let n2 = {
    ref: i2,
    ...r2.props,
    id: a2
  };
  return e3 && ("onClick" in n2 && delete n2.onClick, "onClick" in l2 && delete l2.onClick), $$2({
    ourProps: n2,
    theirProps: l2,
    slot: r2.slot || {},
    defaultTag: h$3,
    name: r2.name || "Label"
  });
});
let h$2 = react.exports.createContext(null);
h$2.displayName = "GroupContext";
let z$1 = react.exports.Fragment;
function J$1(b2) {
  let [t2, o2] = react.exports.useState(null), [i2, d2] = M$1(), [a2, s2] = k$2(), u2 = react.exports.useMemo(() => ({
    switch: t2,
    setSwitch: o2,
    labelledby: i2,
    describedby: a2
  }), [t2, o2, i2, a2]), p2 = {}, m2 = b2;
  return React.createElement(s2, {
    name: "Switch.Description"
  }, React.createElement(d2, {
    name: "Switch.Label",
    props: {
      onClick() {
        !t2 || (t2.click(), t2.focus({
          preventScroll: true
        }));
      }
    }
  }, React.createElement(h$2.Provider, {
    value: u2
  }, $$2({
    ourProps: p2,
    theirProps: m2,
    defaultTag: z$1,
    name: "Switch.Group"
  }))));
}
let Q$1 = "button", V$1 = C$2(function(t2, o2) {
  let {
    checked: i2,
    defaultChecked: d2 = false,
    onChange: a2,
    name: s2,
    value: u2,
    ...p2
  } = t2, m2 = `headlessui-switch-${I$3()}`, r2 = react.exports.useContext(h$2), y$12 = react.exports.useRef(null), P2 = y(y$12, o2, r2 === null ? null : r2.setSwitch), [n2, f2] = p$3(i2, a2, d2), T2 = o$4(() => f2 == null ? void 0 : f2(!n2)), v2 = o$4((e3) => {
    if (r$4(e3.currentTarget))
      return e3.preventDefault();
    e3.preventDefault(), T2();
  }), k2 = o$4((e3) => {
    e3.key === o$2.Space ? (e3.preventDefault(), T2()) : e3.key === o$2.Enter && p$5(e3.currentTarget);
  }), g = o$4((e3) => e3.preventDefault()), C2 = react.exports.useMemo(() => ({
    checked: n2
  }), [n2]), D2 = {
    id: m2,
    ref: P2,
    role: "switch",
    type: s$8(t2, y$12),
    tabIndex: 0,
    "aria-checked": n2,
    "aria-labelledby": r2 == null ? void 0 : r2.labelledby,
    "aria-describedby": r2 == null ? void 0 : r2.describedby,
    onClick: v2,
    onKeyUp: k2,
    onKeyPress: g
  };
  return React.createElement(React.Fragment, null, s2 != null && n2 && React.createElement(h$5, {
    features: s$6.Hidden,
    ...F$4({
      as: "input",
      type: "checkbox",
      hidden: true,
      readOnly: true,
      checked: n2,
      name: s2,
      value: u2
    })
  }), $$2({
    ourProps: D2,
    theirProps: p2,
    slot: C2,
    defaultTag: Q$1,
    name: "Switch"
  }));
}), be$2 = Object.assign(V$1, {
  Group: J$1,
  Label: F$1,
  Description: F$2
});
function p$2({
  onFocus: n2
}) {
  let [r2, o2] = react.exports.useState(true);
  return r2 ? React.createElement(h$5, {
    as: "button",
    type: "button",
    features: s$6.Focusable,
    onFocus: (a2) => {
      a2.preventDefault();
      let e3, u2 = 50;
      function t2() {
        if (u2-- <= 0) {
          e3 && cancelAnimationFrame(e3);
          return;
        }
        if (n2()) {
          o2(false), cancelAnimationFrame(e3);
          return;
        }
        e3 = requestAnimationFrame(t2);
      }
      e3 = requestAnimationFrame(t2);
    }
  }) : null;
}
var de = ((n2) => (n2[n2.SetSelectedIndex = 0] = "SetSelectedIndex", n2[n2.RegisterTab = 1] = "RegisterTab", n2[n2.UnregisterTab = 2] = "UnregisterTab", n2[n2.RegisterPanel = 3] = "RegisterPanel", n2[n2.UnregisterPanel = 4] = "UnregisterPanel", n2))(de || {});
let pe = {
  [0](e3, t2) {
    let r2 = e3.tabs.filter((i2) => {
      var l2;
      return !((l2 = i2.current) != null && l2.hasAttribute("disabled"));
    });
    if (t2.index < 0)
      return {
        ...e3,
        selectedIndex: e3.tabs.indexOf(r2[0])
      };
    if (t2.index > e3.tabs.length)
      return {
        ...e3,
        selectedIndex: e3.tabs.indexOf(r2[r2.length - 1])
      };
    let o2 = e3.tabs.slice(0, t2.index), n2 = [...e3.tabs.slice(t2.index), ...o2].find((i2) => r2.includes(i2));
    return n2 ? {
      ...e3,
      selectedIndex: e3.tabs.indexOf(n2)
    } : e3;
  },
  [1](e3, t2) {
    var n2;
    if (e3.tabs.includes(t2.tab))
      return e3;
    let r2 = e3.tabs[e3.selectedIndex], o2 = S$2([...e3.tabs, t2.tab], (i2) => i2.current), s2 = (n2 = o2.indexOf(r2)) != null ? n2 : e3.selectedIndex;
    return s2 === -1 && (s2 = e3.selectedIndex), {
      ...e3,
      tabs: o2,
      selectedIndex: s2
    };
  },
  [2](e3, t2) {
    return {
      ...e3,
      tabs: e3.tabs.filter((r2) => r2 !== t2.tab)
    };
  },
  [3](e3, t2) {
    return e3.panels.includes(t2.panel) ? e3 : {
      ...e3,
      panels: S$2([...e3.panels, t2.panel], (r2) => r2.current)
    };
  },
  [4](e3, t2) {
    return {
      ...e3,
      panels: e3.panels.filter((r2) => r2 !== t2.panel)
    };
  }
}, z = react.exports.createContext(null);
z.displayName = "TabsSSRContext";
function V(e3) {
  let t2 = react.exports.useContext(z);
  if (t2 === null) {
    let r2 = new Error(`<${e3} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r2, V), r2;
  }
  return t2;
}
let q$3 = react.exports.createContext(null);
q$3.displayName = "TabsDataContext";
function D(e3) {
  let t2 = react.exports.useContext(q$3);
  if (t2 === null) {
    let r2 = new Error(`<${e3} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r2, D), r2;
  }
  return t2;
}
let J = react.exports.createContext(null);
J.displayName = "TabsActionsContext";
function Q(e3) {
  let t2 = react.exports.useContext(J);
  if (t2 === null) {
    let r2 = new Error(`<${e3} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r2, Q), r2;
  }
  return t2;
}
function fe(e3, t2) {
  return u$6(t2.type, pe, e3, t2);
}
let be$1 = react.exports.Fragment, Te = C$2(function(t2, r2) {
  let {
    defaultIndex: o2 = 0,
    vertical: s2 = false,
    manual: n2 = false,
    onChange: i2,
    selectedIndex: l2 = null,
    ...y$12
  } = t2;
  const p2 = s2 ? "vertical" : "horizontal", S2 = n2 ? "manual" : "auto";
  let b2 = l2 !== null, u2 = y(r2), [c2, f2] = react.exports.useReducer(fe, {
    selectedIndex: l2 != null ? l2 : o2,
    tabs: [],
    panels: []
  }), T2 = react.exports.useMemo(() => ({
    selectedIndex: c2.selectedIndex
  }), [c2.selectedIndex]), x2 = s$9(i2 || (() => {
  })), R2 = s$9(c2.tabs), E2 = react.exports.useMemo(() => ({
    orientation: p2,
    activation: S2,
    ...c2
  }), [p2, S2, c2]), A2 = s$9(b2 ? t2.selectedIndex : c2.selectedIndex), L2 = react.exports.useMemo(() => ({
    registerTab(d2) {
      return f2({
        type: 1,
        tab: d2
      }), () => f2({
        type: 2,
        tab: d2
      });
    },
    registerPanel(d2) {
      return f2({
        type: 3,
        panel: d2
      }), () => f2({
        type: 4,
        panel: d2
      });
    },
    change(d2) {
      A2.current !== d2 && x2.current(d2), b2 || f2({
        type: 0,
        index: d2
      });
    }
  }), [f2, b2]);
  s$a(() => {
    f2({
      type: 0,
      index: l2 != null ? l2 : o2
    });
  }, [l2]);
  let k2 = react.exports.useRef({
    tabs: [],
    panels: []
  }), G2 = {
    ref: u2
  };
  return React.createElement(z.Provider, {
    value: k2
  }, React.createElement(J.Provider, {
    value: L2
  }, React.createElement(q$3.Provider, {
    value: E2
  }, E2.tabs.length <= 0 && React.createElement(p$2, {
    onFocus: () => {
      var d2, U2;
      for (let M2 of R2.current)
        if (((d2 = M2.current) == null ? void 0 : d2.tabIndex) === 0)
          return (U2 = M2.current) == null || U2.focus(), true;
      return false;
    }
  }), $$2({
    ourProps: G2,
    theirProps: y$12,
    slot: T2,
    defaultTag: be$1,
    name: "Tabs"
  }))));
}), me = "div", Pe$1 = C$2(function(t2, r2) {
  let {
    orientation: o2,
    selectedIndex: s2
  } = D("Tab.List"), n2 = y(r2);
  return $$2({
    ourProps: {
      ref: n2,
      role: "tablist",
      "aria-orientation": o2
    },
    theirProps: t2,
    slot: {
      selectedIndex: s2
    },
    defaultTag: me,
    name: "Tabs.List"
  });
}), xe$1 = "button", ge$1 = C$2(function(t2, r2) {
  var M2, X2;
  let o2 = `headlessui-tabs-tab-${I$3()}`, {
    orientation: s2,
    activation: n2,
    selectedIndex: i2,
    tabs: l2,
    panels: y$12
  } = D("Tab"), p2 = Q("Tab"), S2 = D("Tab"), b2 = V("Tab"), u2 = react.exports.useRef(null), c2 = y(u2, r2);
  s$a(() => p2.registerTab(u2), [p2, u2]);
  let f2 = b2.current.tabs.indexOf(o2);
  f2 === -1 && (f2 = b2.current.tabs.push(o2) - 1);
  let T2 = l2.indexOf(u2);
  T2 === -1 && (T2 = f2);
  let x2 = T2 === i2, R2 = o$4((a2) => {
    var j2;
    let g = a2();
    if (g === M$5.Success && n2 === "auto") {
      let W2 = (j2 = e$3(u2)) == null ? void 0 : j2.activeElement, Y2 = S2.tabs.findIndex((ne2) => ne2.current === W2);
      Y2 !== -1 && p2.change(Y2);
    }
    return g;
  }), E2 = o$4((a2) => {
    let g = l2.map((W2) => W2.current).filter(Boolean);
    if (a2.key === o$2.Space || a2.key === o$2.Enter) {
      a2.preventDefault(), a2.stopPropagation(), p2.change(T2);
      return;
    }
    switch (a2.key) {
      case o$2.Home:
      case o$2.PageUp:
        return a2.preventDefault(), a2.stopPropagation(), R2(() => O(g, T$3.First));
      case o$2.End:
      case o$2.PageDown:
        return a2.preventDefault(), a2.stopPropagation(), R2(() => O(g, T$3.Last));
    }
    if (R2(() => u$6(s2, {
      vertical() {
        return a2.key === o$2.ArrowUp ? O(g, T$3.Previous | T$3.WrapAround) : a2.key === o$2.ArrowDown ? O(g, T$3.Next | T$3.WrapAround) : M$5.Error;
      },
      horizontal() {
        return a2.key === o$2.ArrowLeft ? O(g, T$3.Previous | T$3.WrapAround) : a2.key === o$2.ArrowRight ? O(g, T$3.Next | T$3.WrapAround) : M$5.Error;
      }
    })) === M$5.Success)
      return a2.preventDefault();
  }), A2 = react.exports.useRef(false), L2 = o$4(() => {
    var a2;
    A2.current || (A2.current = true, (a2 = u2.current) == null || a2.focus(), p2.change(T2), t$2(() => {
      A2.current = false;
    }));
  }), k2 = o$4((a2) => {
    a2.preventDefault();
  }), G2 = react.exports.useMemo(() => ({
    selected: x2
  }), [x2]), d2 = t2, U2 = {
    ref: c2,
    onKeyDown: E2,
    onMouseDown: k2,
    onClick: L2,
    id: o2,
    role: "tab",
    type: s$8(t2, u2),
    "aria-controls": (X2 = (M2 = y$12[T2]) == null ? void 0 : M2.current) == null ? void 0 : X2.id,
    "aria-selected": x2,
    tabIndex: x2 ? 0 : -1
  };
  return $$2({
    ourProps: U2,
    theirProps: d2,
    slot: G2,
    defaultTag: xe$1,
    name: "Tabs.Tab"
  });
}), ye = "div", Re = C$2(function(t2, r2) {
  let {
    selectedIndex: o2
  } = D("Tab.Panels"), s2 = y(r2), n2 = react.exports.useMemo(() => ({
    selectedIndex: o2
  }), [o2]);
  return $$2({
    ourProps: {
      ref: s2
    },
    theirProps: t2,
    slot: n2,
    defaultTag: ye,
    name: "Tabs.Panels"
  });
}), Ae = "div", Ee$1 = S$1.RenderStrategy | S$1.Static, Se$1 = C$2(function(t2, r2) {
  var R2, E2, A2, L2;
  let {
    selectedIndex: o2,
    tabs: s2,
    panels: n2
  } = D("Tab.Panel"), i2 = Q("Tab.Panel"), l2 = V("Tab.Panel"), y$12 = `headlessui-tabs-panel-${I$3()}`, p2 = react.exports.useRef(null), S2 = y(p2, r2);
  s$a(() => i2.registerPanel(p2), [i2, p2]);
  let b2 = l2.current.panels.indexOf(y$12);
  b2 === -1 && (b2 = l2.current.panels.push(y$12) - 1);
  let u2 = n2.indexOf(p2);
  u2 === -1 && (u2 = b2);
  let c2 = u2 === o2, f2 = react.exports.useMemo(() => ({
    selected: c2
  }), [c2]), T2 = t2, x2 = {
    ref: S2,
    id: y$12,
    role: "tabpanel",
    "aria-labelledby": (E2 = (R2 = s2[u2]) == null ? void 0 : R2.current) == null ? void 0 : E2.id,
    tabIndex: c2 ? 0 : -1
  };
  return !c2 && ((A2 = t2.unmount) != null ? A2 : true) && !((L2 = t2.static) != null && L2) ? React.createElement(h$5, {
    as: "span",
    ...x2
  }) : $$2({
    ourProps: x2,
    theirProps: T2,
    slot: f2,
    defaultTag: Ae,
    features: Ee$1,
    visible: c2,
    name: "Tabs.Panel"
  });
}), qe = Object.assign(ge$1, {
  Group: Te,
  List: Pe$1,
  Panels: Re,
  Panel: Se$1
});
function l$3(r2) {
  let e3 = { called: false };
  return (...t2) => {
    if (!e3.called)
      return e3.called = true, r2(...t2);
  };
}
function f(t2, ...e3) {
  t2 && e3.length > 0 && t2.classList.add(...e3);
}
function v$1(t2, ...e3) {
  t2 && e3.length > 0 && t2.classList.remove(...e3);
}
var T = ((n2) => (n2.Ended = "ended", n2.Cancelled = "cancelled", n2))(T || {});
function c$2(t2, e3) {
  let n2 = m$4();
  if (!t2)
    return n2.dispose;
  let { transitionDuration: d2, transitionDelay: o2 } = getComputedStyle(t2), [s2, u2] = [d2, o2].map((i2) => {
    let [a2 = 0] = i2.split(",").filter(Boolean).map((r2) => r2.includes("ms") ? parseFloat(r2) : parseFloat(r2) * 1e3).sort((r2, l2) => l2 - r2);
    return a2;
  });
  if (s2 + u2 !== 0) {
    let i2 = [];
    i2.push(n2.addEventListener(t2, "transitionrun", (a2) => {
      a2.target === a2.currentTarget && (i2.splice(0).forEach((r2) => r2()), i2.push(n2.addEventListener(t2, "transitionend", (r2) => {
        r2.target === r2.currentTarget && (e3("ended"), i2.splice(0).forEach((l2) => l2()));
      }), n2.addEventListener(t2, "transitioncancel", (r2) => {
        r2.target === r2.currentTarget && (e3("cancelled"), i2.splice(0).forEach((l2) => l2()));
      })));
    }));
  } else
    e3("ended");
  return n2.add(() => e3("cancelled")), n2.dispose;
}
function C(t2, e3, n2, d2) {
  let o2 = n2 ? "enter" : "leave", s2 = m$4(), u2 = d2 !== void 0 ? l$3(d2) : () => {
  };
  o2 === "enter" && (t2.removeAttribute("hidden"), t2.style.display = "");
  let m2 = u$6(o2, { enter: () => e3.enter, leave: () => e3.leave }), i2 = u$6(o2, { enter: () => e3.enterTo, leave: () => e3.leaveTo }), a2 = u$6(o2, { enter: () => e3.enterFrom, leave: () => e3.leaveFrom });
  return v$1(t2, ...e3.enter, ...e3.enterTo, ...e3.enterFrom, ...e3.leave, ...e3.leaveFrom, ...e3.leaveTo, ...e3.entered), f(t2, ...m2, ...a2), s2.nextFrame(() => {
    v$1(t2, ...a2), f(t2, ...i2), c$2(t2, (r2) => (r2 === "ended" && (v$1(t2, ...m2), f(t2, ...e3.entered)), u2(r2)));
  }), s2.dispose;
}
function I$1({ container: o2, direction: t2, classes: s2, onStart: a2, onStop: u2 }) {
  let c2 = f$1(), d2 = p$7(), r2 = s$9(t2);
  s$a(() => {
    let e3 = m$4();
    d2.add(e3.dispose);
    let n2 = o2.current;
    if (!!n2 && r2.current !== "idle" && !!c2.current)
      return e3.dispose(), a2.current(r2.current), e3.add(C(n2, s2.current, r2.current === "enter", (l2) => {
        e3.dispose(), u$6(l2, { [T.Ended]() {
          u2.current(r2.current);
        }, [T.Cancelled]: () => {
        } });
      })), e3.dispose;
  }, [t2]);
}
function x(r2 = "") {
  return r2.split(" ").filter((e3) => e3.trim().length > 1);
}
let F = react.exports.createContext(null);
F.displayName = "TransitionContext";
var ve = ((s2) => (s2.Visible = "visible", s2.Hidden = "hidden", s2))(ve || {});
function Ce() {
  let r2 = react.exports.useContext(F);
  if (r2 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return r2;
}
function ge() {
  let r2 = react.exports.useContext(M);
  if (r2 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return r2;
}
let M = react.exports.createContext(null);
M.displayName = "NestingContext";
function I(r2) {
  return "children" in r2 ? I(r2.children) : r2.current.filter(({
    el: e3
  }) => e3.current !== null).filter(({
    state: e3
  }) => e3 === "visible").length > 0;
}
function ee(r2, e3) {
  let s2 = s$9(r2), n2 = react.exports.useRef([]), m2 = f$1(), D2 = p$7(), b2 = o$4((l2, i2 = j$3.Hidden) => {
    let t2 = n2.current.findIndex(({
      el: o2
    }) => o2 === l2);
    t2 !== -1 && (u$6(i2, {
      [j$3.Unmount]() {
        n2.current.splice(t2, 1);
      },
      [j$3.Hidden]() {
        n2.current[t2].state = "hidden";
      }
    }), D2.microTask(() => {
      var o2;
      !I(n2) && m2.current && ((o2 = s2.current) == null || o2.call(s2));
    }));
  }), E2 = o$4((l2) => {
    let i2 = n2.current.find(({
      el: t2
    }) => t2 === l2);
    return i2 ? i2.state !== "visible" && (i2.state = "visible") : n2.current.push({
      el: l2,
      state: "visible"
    }), () => b2(l2, j$3.Unmount);
  }), S2 = react.exports.useRef([]), u2 = react.exports.useRef(Promise.resolve()), p2 = react.exports.useRef({
    enter: [],
    leave: [],
    idle: []
  }), d2 = o$4((l2, i2, t2) => {
    S2.current.splice(0), e3 && (e3.chains.current[i2] = e3.chains.current[i2].filter(([o2]) => o2 !== l2)), e3 == null || e3.chains.current[i2].push([l2, new Promise((o2) => {
      S2.current.push(o2);
    })]), e3 == null || e3.chains.current[i2].push([l2, new Promise((o2) => {
      Promise.all(p2.current[i2].map(([f2, a2]) => a2)).then(() => o2());
    })]), i2 === "enter" ? u2.current = u2.current.then(() => e3 == null ? void 0 : e3.wait.current).then(() => t2(i2)) : t2(i2);
  }), h2 = o$4((l2, i2, t2) => {
    Promise.all(p2.current[i2].splice(0).map(([o2, f2]) => f2)).then(() => {
      var o2;
      (o2 = S2.current.shift()) == null || o2();
    }).then(() => t2(i2));
  });
  return react.exports.useMemo(() => ({
    children: n2,
    register: E2,
    unregister: b2,
    onStart: d2,
    onStop: h2,
    wait: u2,
    chains: p2
  }), [E2, b2, n2, d2, h2, p2, u2]);
}
function be() {
}
let Ee = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function te(r2) {
  var s2;
  let e3 = {};
  for (let n2 of Ee)
    e3[n2] = (s2 = r2[n2]) != null ? s2 : be;
  return e3;
}
function Se(r2) {
  let e3 = react.exports.useRef(te(r2));
  return react.exports.useEffect(() => {
    e3.current = te(r2);
  }, [r2]), e3;
}
let xe = "div", ne = S$1.RenderStrategy, re$1 = C$2(function(e3, s2) {
  let {
    beforeEnter: n2,
    afterEnter: m2,
    beforeLeave: D2,
    afterLeave: b2,
    enter: E2,
    enterFrom: S2,
    enterTo: u2,
    entered: p2,
    leave: d2,
    leaveFrom: h2,
    leaveTo: l2,
    ...i2
  } = e3, t2 = react.exports.useRef(null), o2 = y(t2, s2), f2 = i2.unmount ? j$3.Unmount : j$3.Hidden, {
    show: a2,
    appear: P2,
    initial: ie2
  } = Ce(), [v2, _2] = react.exports.useState(a2 ? "visible" : "hidden"), z2 = ge(), {
    register: N2,
    unregister: V2
  } = z2, j2 = react.exports.useRef(null);
  react.exports.useEffect(() => N2(t2), [N2, t2]), react.exports.useEffect(() => {
    if (f2 === j$3.Hidden && !!t2.current) {
      if (a2 && v2 !== "visible") {
        _2("visible");
        return;
      }
      return u$6(v2, {
        ["hidden"]: () => V2(t2),
        ["visible"]: () => N2(t2)
      });
    }
  }, [v2, t2, N2, V2, a2, f2]);
  let oe2 = s$9({
    enter: x(E2),
    enterFrom: x(S2),
    enterTo: x(u2),
    entered: x(p2),
    leave: x(d2),
    leaveFrom: x(h2),
    leaveTo: x(l2)
  }), L2 = Se({
    beforeEnter: n2,
    afterEnter: m2,
    beforeLeave: D2,
    afterLeave: b2
  }), U2 = a$5();
  react.exports.useEffect(() => {
    if (U2 && v2 === "visible" && t2.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [t2, v2, U2]);
  let k2 = ie2 && !P2, se2 = (() => !U2 || k2 || j2.current === a2 ? "idle" : a2 ? "enter" : "leave")(), le2 = o$4((C2) => u$6(C2, {
    enter: () => L2.current.beforeEnter(),
    leave: () => L2.current.beforeLeave(),
    idle: () => {
    }
  })), ae2 = o$4((C2) => u$6(C2, {
    enter: () => L2.current.afterEnter(),
    leave: () => L2.current.afterLeave(),
    idle: () => {
    }
  })), w2 = ee(() => {
    _2("hidden"), V2(t2);
  }, z2);
  I$1({
    container: t2,
    classes: oe2,
    direction: se2,
    onStart: s$9((C2) => {
      w2.onStart(t2, C2, le2);
    }),
    onStop: s$9((C2) => {
      w2.onStop(t2, C2, ae2), C2 === "leave" && !I(w2) && (_2("hidden"), V2(t2));
    })
  }), react.exports.useEffect(() => {
    !k2 || (f2 === j$3.Hidden ? j2.current = null : j2.current = a2);
  }, [a2, k2, v2]);
  let ue2 = i2, de2 = {
    ref: o2
  };
  return /* @__PURE__ */ jsx(M.Provider, {
    value: w2,
    children: /* @__PURE__ */ jsx(C$1, {
      value: u$6(v2, {
        ["visible"]: p$4.Open,
        ["hidden"]: p$4.Closed
      }),
      children: $$2({
        ourProps: de2,
        theirProps: ue2,
        defaultTag: xe,
        features: ne,
        visible: v2 === "visible",
        name: "Transition.Child"
      })
    })
  });
}), q$2 = C$2(function(e3, s2) {
  let {
    show: n2,
    appear: m2 = false,
    unmount: D2,
    ...b2
  } = e3, E2 = react.exports.useRef(null), S2 = y(E2, s2);
  a$5();
  let u2 = s$5();
  if (n2 === void 0 && u2 !== null && (n2 = u$6(u2, {
    [p$4.Open]: true,
    [p$4.Closed]: false
  })), ![true, false].includes(n2))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [p2, d2] = react.exports.useState(n2 ? "visible" : "hidden"), h2 = ee(() => {
    d2("hidden");
  }), [l2, i2] = react.exports.useState(true), t2 = react.exports.useRef([n2]);
  s$a(() => {
    l2 !== false && t2.current[t2.current.length - 1] !== n2 && (t2.current.push(n2), i2(false));
  }, [t2, n2]);
  let o2 = react.exports.useMemo(() => ({
    show: n2,
    appear: m2,
    initial: l2
  }), [n2, m2, l2]);
  react.exports.useEffect(() => {
    if (n2)
      d2("visible");
    else if (!I(h2))
      d2("hidden");
    else {
      let a2 = E2.current;
      if (!a2)
        return;
      let P2 = a2.getBoundingClientRect();
      P2.x === 0 && P2.y === 0 && P2.width === 0 && P2.height === 0 && d2("hidden");
    }
  }, [n2, h2]);
  let f2 = {
    unmount: D2
  };
  return /* @__PURE__ */ jsx(M.Provider, {
    value: h2,
    children: /* @__PURE__ */ jsx(F.Provider, {
      value: o2,
      children: $$2({
        ourProps: {
          ...f2,
          as: react.exports.Fragment,
          children: React.createElement(re$1, {
            ref: S2,
            ...f2,
            ...b2
          })
        },
        theirProps: {},
        defaultTag: react.exports.Fragment,
        features: ne,
        visible: p2 === "visible",
        name: "Transition"
      })
    })
  });
}), Pe = C$2(function(e3, s2) {
  let n2 = react.exports.useContext(F) !== null, m2 = s$5() !== null;
  return /* @__PURE__ */ jsx(Fragment, {
    children: !n2 && m2 ? React.createElement(q$2, {
      ref: s2,
      ...e3
    }) : React.createElement(re$1, {
      ref: s2,
      ...e3
    })
  });
}), We = Object.assign(q$2, {
  Child: Pe,
  Root: q$2
});
function ascending(a2, b2) {
  return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function descending(a2, b2) {
  return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
}
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d2, x2) => ascending(f2(d2), x2);
    delta = (d2, x2) => f2(d2) - x2;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero$2;
    compare2 = f2;
    delta = f2;
  }
  function left(a2, x2, lo = 0, hi2 = a2.length) {
    if (lo < hi2) {
      if (compare1(x2, x2) !== 0)
        return hi2;
      do {
        const mid = lo + hi2 >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi2 = mid;
      } while (lo < hi2);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi2 = a2.length) {
    if (lo < hi2) {
      if (compare1(x2, x2) !== 0)
        return hi2;
      do {
        const mid = lo + hi2 >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi2 = mid;
      } while (lo < hi2);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi2 = a2.length) {
    const i2 = left(a2, x2, lo, hi2 - 1);
    return i2 > lo && delta(a2[i2 - 1], x2) > -delta(a2[i2], x2) ? i2 - 1 : i2;
  }
  return { left, center, right };
}
function zero$2() {
  return 0;
}
function number$3(x2) {
  return x2 === null ? NaN : +x2;
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$3).center;
const bisect = bisectRight;
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function ticks(start, stop, count2) {
  var reverse, i2 = -1, n2, ticks2, step;
  stop = +stop, start = +start, count2 = +count2;
  if (start === stop && count2 > 0)
    return [start];
  if (reverse = stop < start)
    n2 = start, start = stop, stop = n2;
  if ((step = tickIncrement(start, stop, count2)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start)
      ++r0;
    if (r1 * step > stop)
      --r1;
    ticks2 = new Array(n2 = r1 - r0 + 1);
    while (++i2 < n2)
      ticks2[i2] = (r0 + i2) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start)
      ++r0;
    if (r1 / step > stop)
      --r1;
    ticks2 = new Array(n2 = r1 - r0 + 1);
    while (++i2 < n2)
      ticks2[i2] = (r0 + i2) / step;
  }
  if (reverse)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  var step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count2) {
  var step0 = Math.abs(stop - start) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10)
    step1 *= 10;
  else if (error >= e5)
    step1 *= 5;
  else if (error >= e2)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}
function define(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend(parent, definition) {
  var prototype2 = Object.create(parent.prototype);
  for (var key in definition)
    prototype2[key] = definition[key];
  return prototype2;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color$1, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba$1(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba$1(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba$1(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba$1(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba$1(r2, g, b2, a2) {
  if (a2 <= 0)
    r2 = g = b2 = NaN;
  return new Rgb(r2, g, b2, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color))
    o2 = color$1(o2);
  if (!o2)
    return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b2, opacity == null ? 1 : opacity);
}
function Rgb(r2, g, b2, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex$1(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h2, s2, l2, a2) {
  if (a2 <= 0)
    h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl)
    return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color))
    o2 = color$1(o2);
  if (!o2)
    return new Hsl();
  if (o2 instanceof Hsl)
    return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r2, g, b2), max2 = Math.max(r2, g, b2), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r2 === max2)
      h2 = (g - b2) / s2 + (g < b2) * 6;
    else if (g === max2)
      h2 = (b2 - r2) / s2 + 2;
    else
      h2 = (r2 - g) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant = (x2) => () => x2;
function linear$2(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear$2(a2, d2) : constant(isNaN(a2) ? b2 : a2);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start, end) {
    var r2 = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b2 = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t2) {
      start.r = r2(t2);
      start.g = g(t2);
      start.b = b2(t2);
      start.opacity = opacity(t2);
      return start + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function numberArray(a2, b2) {
  if (!b2)
    b2 = [];
  var n2 = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n2; ++i2)
      c2[i2] = a2[i2] * (1 - t2) + b2[i2] * t2;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b2) {
  var nb2 = b2 ? b2.length : 0, na = a2 ? Math.min(nb2, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb2), i2;
  for (i2 = 0; i2 < na; ++i2)
    x2[i2] = interpolate$1(a2[i2], b2[i2]);
  for (; i2 < nb2; ++i2)
    c2[i2] = b2[i2];
  return function(t2) {
    for (i2 = 0; i2 < na; ++i2)
      c2[i2] = x2[i2](t2);
    return c2;
  };
}
function date(a2, b2) {
  var d2 = new Date();
  return a2 = +a2, b2 = +b2, function(t2) {
    return d2.setTime(a2 * (1 - t2) + b2 * t2), d2;
  };
}
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
function object(a2, b2) {
  var i2 = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k2 in b2) {
    if (k2 in a2) {
      i2[k2] = interpolate$1(a2[k2], b2[k2]);
    } else {
      c2[k2] = b2[k2];
    }
  }
  return function(t2) {
    for (k2 in i2)
      c2[k2] = i2[k2](t2);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero$1(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function interpolateString(a2, b2) {
  var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi2) {
      bs = b2.slice(bi2, bs);
      if (s2[i2])
        s2[i2] += bs;
      else
        s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2])
        s2[i2] += bm;
      else
        s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: interpolateNumber(am, bm) });
    }
    bi2 = reB.lastIndex;
  }
  if (bi2 < b2.length) {
    bs = b2.slice(bi2);
    if (s2[i2])
      s2[i2] += bs;
    else
      s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero$1(b2) : (b2 = q2.length, function(t2) {
    for (var i3 = 0, o2; i3 < b2; ++i3)
      s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}
function interpolate$1(a2, b2) {
  var t2 = typeof b2, c2;
  return b2 == null || t2 === "boolean" ? constant(b2) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c2 = color$1(b2)) ? (b2 = c2, interpolateRgb) : interpolateString : b2 instanceof color$1 ? interpolateRgb : b2 instanceof Date ? date : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object : interpolateNumber)(a2, b2);
}
function interpolateRound(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return Math.round(a2 * (1 - t2) + b2 * t2);
  };
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p2) {
  if ((i2 = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i2, coefficient = x2.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i2 + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i2 = value.length, t2 = [], j2 = 0, g = grouping[0], length = 0;
    while (i2 > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t2.push(value.substring(i2 -= g, i2 + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out:
    for (var n2 = s2.length, i2 = 1, i0 = -1, i1; i2 < n2; ++i2) {
      switch (s2[i2]) {
        case ".":
          i0 = i1 = i2;
          break;
        case "0":
          if (i0 === 0)
            i0 = i2;
          i1 = i2;
          break;
        default:
          if (!+s2[i2])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2)
    return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1], i2 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i2 - 1))[0];
}
function formatRounded(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2)
    return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x2, p2) => (x2 * 100).toFixed(p2),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p2) => x2.toExponential(p2),
  "f": (x2, p2) => x2.toFixed(p2),
  "g": (x2, p2) => x2.toPrecision(p2),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p2) => formatRounded(x2 * 100, p2),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$1(x2) {
  return x2;
}
var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$1 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$1 : formatNumerals(map.call(locale2.numerals, String)), percent2 = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent2 : "";
    var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n2, c2;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n2 = value.length;
          while (++i2 < n2) {
            if (c2 = value.charCodeAt(i2), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i2 + 1) : value.slice(i2)) + valueSuffix;
              value = value.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f2(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$1(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$2(x2) {
  return +x2;
}
var unit = [0, 1];
function identity(x2) {
  return x2;
}
function normalize$2(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t2;
  if (a2 > b2)
    t2 = a2, a2 = b2, b2 = t2;
  return function(x2) {
    return Math.max(a2, Math.min(b2, x2));
  };
}
function bimap(domain, range, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0)
    d0 = normalize$2(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize$2(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range, interpolate2) {
  var j2 = Math.min(domain.length, range.length) - 1, d2 = new Array(j2), r2 = new Array(j2), i2 = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i2 < j2) {
    d2[i2] = normalize$2(domain[i2], domain[i2 + 1]);
    r2[i2] = interpolate2(range[i2], range[i2 + 1]);
  }
  return function(x2) {
    var i3 = bisect(domain, x2, 1, j2) - 1;
    return r2[i3](d2[i3](x2));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate2 = interpolate$1, transform, untransform, unknown, clamp2 = identity, piecewise, output2, input;
  function rescale() {
    var n2 = Math.min(domain.length, range.length);
    if (clamp2 !== identity)
      clamp2 = clamper(domain[0], domain[n2 - 1]);
    piecewise = n2 > 2 ? polymap : bimap;
    output2 = input = null;
    return scale2;
  }
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output2 || (output2 = piecewise(domain.map(transform), range, interpolate2)))(transform(clamp2(x2)));
  }
  scale2.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y2)));
  };
  scale2.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number$2), rescale()) : domain.slice();
  };
  scale2.range = function(_2) {
    return arguments.length ? (range = Array.from(_2), rescale()) : range.slice();
  };
  scale2.rangeRound = function(_2) {
    return range = Array.from(_2), interpolate2 = interpolateRound, rescale();
  };
  scale2.clamp = function(_2) {
    return arguments.length ? (clamp2 = _2 ? true : identity, rescale()) : clamp2 !== identity;
  };
  scale2.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, rescale()) : interpolate2;
  };
  scale2.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale2) : unknown;
  };
  return function(t2, u2) {
    transform = t2, untransform = u2;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity, identity);
}
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count2) {
    var d2 = domain();
    return ticks(d2[0], d2[d2.length - 1], count2 == null ? 10 : count2);
  };
  scale2.tickFormat = function(count2, specifier) {
    var d2 = domain();
    return tickFormat(d2[0], d2[d2.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale2.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d2 = domain();
    var i0 = 0;
    var i1 = d2.length - 1;
    var start = d2[i0];
    var stop = d2[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d2[i0] = start;
        d2[i1] = stop;
        return domain(d2);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear$1() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear$1());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
function Transform(k2, x2, y2) {
  this.k = k2;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
new Transform(1, 0, 0);
Transform.prototype;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal || freeSelf || Function("return this")();
var _root = root$2;
var root$1 = _root;
var Symbol$3 = root$1.Symbol;
var _Symbol = Symbol$3;
var Symbol$2 = _Symbol;
Symbol$2 ? Symbol$2.toStringTag : void 0;
var Symbol$1 = _Symbol;
Symbol$1 ? Symbol$1.toStringTag : void 0;
const createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState2(setState, getState, api);
  return api;
};
const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e = react.exports;
function h$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k = "function" === typeof Object.is ? Object.is : h$1, l$2 = e.useState, m = e.useEffect, n$3 = e.useLayoutEffect, p$1 = e.useDebugValue;
function q$1(a2, b2) {
  var d2 = b2(), f2 = l$2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g = f2[1];
  n$3(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$2(c2) && g({ inst: c2 });
  }, [a2, d2, b2]);
  m(function() {
    r$2(c2) && g({ inst: c2 });
    return a2(function() {
      r$2(c2) && g({ inst: c2 });
    });
  }, [a2]);
  p$1(d2);
  return d2;
}
function r$2(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$1(a2, b2) {
  return b2();
}
var u$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$1 : q$1;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u$1;
(function(module2) {
  {
    module2.exports = useSyncExternalStoreShim_production_min;
  }
})(shim);
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h = react.exports, n$2 = shim.exports;
function p(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q = "function" === typeof Object.is ? Object.is : p, r$1 = n$2.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e3, l2, g) {
  var c2 = t(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g && f2.hasValue) {
          var b3 = f2.value;
          if (g(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q(d3, a4))
        return b3;
      var e4 = l2(a4);
      if (void 0 !== g && g(b3, e4))
        return b3;
      d3 = a4;
      return k2 = e4;
    }
    var c3 = false, d3, k2, m2 = void 0 === e3 ? null : e3;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e3, l2, g]);
  var d2 = r$1(a2, c2[0], c2[1]);
  u(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w(d2);
  return d2;
};
(function(module2) {
  {
    module2.exports = withSelector_production_min;
  }
})(withSelector);
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelector.exports);
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
function useStore(api, selector = api.getState, equalityFn) {
  const slice2 = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  react.exports.useDebugValue(slice2);
  return slice2;
}
const createImpl = (createState2) => {
  const api = typeof createState2 === "function" ? createStore(createState2) : createState2;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState2) => createState2 ? createImpl(createState2) : createImpl;
const MotionConfigContext = react.exports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = react.exports.createContext({});
function useVisualElementContext() {
  return react.exports.useContext(MotionContext).visualElement;
}
const PresenceContext = react.exports.createContext(null);
const isBrowser = typeof document !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? react.exports.useLayoutEffect : react.exports.useEffect;
const LazyContext = react.exports.createContext({ strict: false });
function useVisualElement(Component, visualState, props, createVisualElement) {
  const parent = useVisualElementContext();
  const lazyContext = react.exports.useContext(LazyContext);
  const presenceContext = react.exports.useContext(PresenceContext);
  const reducedMotionConfig = react.exports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = react.exports.useRef(void 0);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceId: presenceContext ? presenceContext.id : void 0,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement2 = visualElementRef.current;
  useIsomorphicLayoutEffect(() => {
    visualElement2 && visualElement2.syncRender();
  });
  react.exports.useEffect(() => {
    if (visualElement2 && visualElement2.animationState) {
      visualElement2.animationState.animateChanges();
    }
  });
  useIsomorphicLayoutEffect(() => () => visualElement2 && visualElement2.notifyUnmount(), []);
  return visualElement2;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement2, externalRef) {
  return react.exports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement2) {
        instance ? visualElement2.mount(instance) : visualElement2.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    [visualElement2]
  );
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}
const variantProps$1 = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps$1.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, react.exports.useContext(MotionContext));
  return react.exports.useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const createDefinition = (propNames) => ({
  isEnabled: (props) => propNames.some((name) => !!props[name])
});
const featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features2) {
  for (const key in features2) {
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features2[key];
    } else {
      featureDefinitions[key].Component = features2[key];
    }
  }
}
function useConstant(init) {
  const ref = react.exports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const globalProjectionState = {
  hasAnimatedSinceResize: true,
  hasEverUpdated: false
};
let id = 1;
function useProjectionId() {
  return useConstant(() => {
    if (globalProjectionState.hasEverUpdated) {
      return id++;
    }
  });
}
const LayoutGroupContext = react.exports.createContext({});
class VisualElementHandler extends React.Component {
  getSnapshotBeforeUpdate() {
    const { visualElement: visualElement2, props } = this.props;
    if (visualElement2)
      visualElement2.setProps(props);
    return null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
const SwitchLayoutGroupContext = react.exports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({
  preloadedFeatures,
  createVisualElement,
  projectionNodeConstructor,
  useRender,
  useVisualState,
  Component
}) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    const configAndProps = {
      ...react.exports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const {
      isStatic
    } = configAndProps;
    let features2 = null;
    const context = useCreateMotionContext(props);
    const projectionId = isStatic ? void 0 : useProjectionId();
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
      const lazyStrictMode = react.exports.useContext(LazyContext).strict;
      const initialLayoutGroupConfig = react.exports.useContext(SwitchLayoutGroupContext);
      if (context.visualElement) {
        features2 = context.visualElement.loadFeatures(
          configAndProps,
          lazyStrictMode,
          preloadedFeatures,
          projectionId,
          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,
          initialLayoutGroupConfig
        );
      }
    }
    return /* @__PURE__ */ jsxs(VisualElementHandler, {
      visualElement: context.visualElement,
      props: configAndProps,
      children: [features2, /* @__PURE__ */ jsx(MotionContext.Provider, {
        value: context,
        children: useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
      })]
    });
  }
  const ForwardRefComponent = react.exports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component;
  return ForwardRefComponent;
}
function useLayoutId({
  layoutId
}) {
  const layoutGroupId = react.exports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (typeof Component !== "string" || Component.includes("-")) {
    return false;
  } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/.test(Component)) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key, { layout, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const sortTransformProps = (a2, b2) => transformPropOrder.indexOf(a2) - transformPropOrder.indexOf(b2);
function buildTransform({ transform, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  transformKeys2.sort(sortTransformProps);
  for (const key of transformKeys2) {
    transformString += `${translateAlias[key] || key}(${transform[key]}) `;
  }
  if (enableHardwareAcceleration && !transform.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function isCSSVariable$1(key) {
  return key.startsWith("--");
}
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp$1 = (min2, max2) => (v2) => Math.max(Math.min(v2, max2), min2);
const sanitize = (v2) => v2 % 1 ? Number(v2.toFixed(5)) : v2;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$2(v2) {
  return typeof v2 === "string";
}
const number$1 = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = Object.assign(Object.assign({}, number$1), { transform: clamp$1(0, 1) });
const scale = Object.assign(Object.assign({}, number$1), { default: 1 });
const createUnitType = (unit2) => ({
  test: (v2) => isString$2(v2) && v2.endsWith(unit2) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit2}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v2) => percent.parse(v2) / 100, transform: (v2) => percent.transform(v2 * 100) });
const isColorString = (type, testProp) => (v2) => {
  return Boolean(isString$2(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString$2(v2))
    return v2;
  const [a2, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const clampRgbUnit = clamp$1(0, 255);
const rgbUnit = Object.assign(Object.assign({}, number$1), { transform: (v2) => Math.round(clampRgbUnit(v2)) });
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substr(1, 2);
    g = v2.substr(3, 2);
    b2 = v2.substr(5, 2);
    a2 = v2.substr(7, 2);
  } else {
    r2 = v2.substr(1, 1);
    g = v2.substr(2, 1);
    b2 = v2.substr(3, 1);
    a2 = v2.substr(4, 1);
    r2 += r2;
    g += g;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString$2(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const colorToken = "${c}";
const numberToken = "${n}";
function test(v2) {
  var _a2, _b, _c, _d;
  return isNaN(v2) && isString$2(v2) && ((_b = (_a2 = v2.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v2.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse$1(v2) {
  if (typeof v2 === "number")
    v2 = `${v2}`;
  const values = [];
  let numColors = 0;
  const colors = v2.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v2 = v2.replace(colorRegex, colorToken);
    values.push(...colors.map(color.parse));
  }
  const numbers = v2.match(floatRegex);
  if (numbers) {
    v2 = v2.replace(floatRegex, numberToken);
    values.push(...numbers.map(number$1.parse));
  }
  return { values, numColors, tokenised: v2 };
}
function parse$1(v2) {
  return analyse$1(v2).values;
}
function createTransformer(v2) {
  const { values, numColors, tokenised } = analyse$1(v2);
  const numValues = values.length;
  return (v3) => {
    let output2 = tokenised;
    for (let i2 = 0; i2 < numValues; i2++) {
      output2 = output2.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v3[i2]) : sanitize(v3[i2]));
    }
    return output2;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parse$1(v2);
  const transformer2 = createTransformer(v2);
  return transformer2(parsed.map(convertNumbersToZero));
}
const complex = { test, parse: parse$1, createTransformer, getAnimatableNone: getAnimatableNone$1 };
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  let [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit2 = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit2 + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v2) => {
  const functions = v2.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
} });
const int$1 = {
  ...number$1,
  transform: Math.round
};
const numberValueTypes = {
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  zIndex: int$1,
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int$1
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style, vars, transform, transformKeys: transformKeys2, transformOrigin } = state;
  transformKeys2.length = 0;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (isCSSVariable$1(key)) {
      vars[key] = value;
      continue;
    }
    const valueType = numberValueTypes[key];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key)) {
      hasTransform2 = true;
      transform[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin[key] = valueAsType;
    } else {
      style[key] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return react.exports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  htmlProps.style = style;
  return htmlProps;
}
const animationProps = [
  "animate",
  "exit",
  "variants",
  "whileHover",
  "whileTap",
  "whileFocus",
  "whileDrag",
  "whileInView"
];
const tapProps = ["whileTap", "onTap", "onTapStart", "onTapCancel"];
const panProps = ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"];
const inViewProps = [
  "whileInView",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
];
const validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "layoutDependency",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "dragSnapToOrigin",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "onHoverStart",
  "onHoverEnd",
  "layoutScroll",
  ...inViewProps,
  ...tapProps,
  ...animationProps,
  ...panProps
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a2) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset2, size) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset2);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  ...latest
}, options, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
function useSVGProps(props, visualState) {
  const visualProps = react.exports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, projectionId, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return react.exports.createElement(Component, elementProps);
  };
  return useRender;
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps$1(props) {
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props) {
  const newValues = scrapeMotionValuesFromProps$1(props);
  for (const key in props) {
    if (isMotionValue(props[key])) {
      const targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
const isCustomValue = (v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
const resolveFinalValueInKeyframes = (v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = react.exports.useContext(MotionContext);
  const presenceContext = react.exports.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props);
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate2 === void 0)
      animate2 = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values[key] = valueTarget;
        }
      }
      for (const key in transitionEnd)
        values[key] = transitionEnd[key];
    });
  }
  return values;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e3) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    projectionNodeConstructor,
    Component
  };
}
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function useDomEvent(ref, eventName, handler, options) {
  react.exports.useEffect(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
function useFocusGesture({ whileFocus, visualElement: visualElement2 }) {
  const { animationState } = visualElement2;
  const onFocus = () => {
    animationState && animationState.setActive(AnimationType.Focus, true);
  };
  const onBlur = () => {
    animationState && animationState.setActive(AnimationType.Focus, false);
  };
  useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
}
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  const hasTouches = !!event.touches;
  return hasTouches;
}
function filterPrimaryPointer(eventHandler) {
  return (event) => {
    const isMouseEvent2 = event instanceof MouseEvent;
    const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
const defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e3, pointType = "page") {
  const primaryTouch = e3.touches[0] || e3.changedTouches[0];
  const point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType = "page") {
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType = "page") {
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
const wrapHandler = (handler, shouldFilterPrimaryPointer = false) => {
  const listener = (event) => handler(event, extractEventInfo(event));
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};
const supportsPointerEvents = () => isBrowser && window.onpointerdown === null;
const supportsTouchEvents = () => isBrowser && window.ontouchstart === null;
const supportsMouseEvents = () => isBrowser && window.onmousedown === null;
const mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
const touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
}
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
function createHoverEvent(visualElement2, isActive, callback) {
  return (event, info) => {
    if (!isMouseEvent(event) || isDragActive())
      return;
    if (visualElement2.animationState) {
      visualElement2.animationState.setActive(AnimationType.Hover, isActive);
    }
    callback && callback(event, info);
  };
}
function useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement: visualElement2 }) {
  usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0, { passive: !onHoverStart });
  usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0, { passive: !onHoverEnd });
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
function useUnmountEffect(callback) {
  return react.exports.useEffect(() => () => callback(), []);
}
function __rest$2(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
var warning = function() {
};
var invariant$1 = function() {
};
const clamp = (min2, max2, v2) => Math.min(Math.max(v2, min2), max2);
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3);
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e3 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e3) * f2) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a2) {
  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a2, options = __rest$2(_a2, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
      resolveVelocity = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t2)) - envelope * (Math.cos(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => to - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t2) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from, to] = [to, from];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a2, b2) => typeof a2 === "string" || typeof b2 === "string";
const zero = (_t) => 0;
const progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
const mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from, to, v2) => {
  const fromExpo = from * from;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v2 * (toExpo - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
const mixColor = (from, to) => {
  let fromColorType = getColorType(from);
  let toColorType = getColorType(to);
  let fromColor = fromColorType.parse(from);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v2) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v2);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v2);
    return fromColorType.transform(blended);
  };
};
const isNum = (v2) => typeof v2 === "number";
const combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v2) => mix(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
const mixArray = (from, to) => {
  const output2 = [...from];
  const numValues = output2.length;
  const blendValue = from.map((fromThis, i2) => getMixer(fromThis, to[i2]));
  return (v2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output2[i2] = blendValue[i2](v2);
    }
    return output2;
  };
};
const mixObject = (origin, target) => {
  const output2 = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output2) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output2[key] = blendValue[key](v2);
    }
    return output2;
  };
};
function analyse(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i2 = 0; i2 < numValues; i2++) {
    if (numNumbers || typeof parsed[i2] === "number") {
      numNumbers++;
    } else {
      if (parsed[i2].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse(origin);
  const targetStats = analyse(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    return (p2) => `${p2 > 0 ? target : origin}`;
  }
};
const mixNumber = (from, to) => (p2) => mix(from, to, p2);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    if (color.test(v2)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
}
function createMixers(output2, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output2[0]);
  const numMixers = output2.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output2[i2], output2[i2 + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from, to], [mixer]) {
  return (v2) => mixer(progress(from, to, v2));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v2) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v2 <= input[0]) {
      foundMixerIndex = true;
    } else if (v2 >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i2 = 1;
      for (; i2 < inputLength; i2++) {
        if (input[i2] > v2 || i2 === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i2 - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v2);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output2, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant$1(inputLength === output2.length);
  invariant$1(!ease || !Array.isArray(ease) || ease.length === inputLength - 1);
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output2 = [].concat(output2);
    input.reverse();
    output2.reverse();
  }
  const mixers = createMixers(output2, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const createExpoIn = (power) => (p2) => Math.pow(p2, power);
const createBackIn = (power) => (p2) => p2 * p2 * ((power + 1) * p2 - power);
const createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p2) => (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
};
const DEFAULT_OVERSHOOT_STRENGTH = 1.525;
const BOUNCE_FIRST_THRESHOLD = 4 / 11;
const BOUNCE_SECOND_THRESHOLD = 8 / 11;
const BOUNCE_THIRD_THRESHOLD = 9 / 10;
const linear = (p2) => p2;
const easeIn = createExpoIn(2);
const easeOut = reverseEasing(easeIn);
const easeInOut = mirrorEasing(easeIn);
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
const backOut = reverseEasing(backIn);
const backInOut = mirrorEasing(backIn);
const anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
const ca = 4356 / 361;
const cb = 35442 / 1805;
const cc = 16061 / 1805;
const bounceOut = (p2) => {
  if (p2 === 1 || p2 === 0)
    return p2;
  const p22 = p2 * p2;
  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;
};
const bounceIn = reverseEasing(bounceOut);
const bounceInOut = (p2) => p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o2) => o2 * duration);
}
function keyframes$1({ from = 0, to = 1, ease, offset: offset2, duration = 300 }) {
  const state = { done: false, value: from };
  const values = Array.isArray(to) ? to : [from, to];
  const times = convertOffsetToTimes(offset2 && offset2.length === values.length ? offset2 : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state.value = interpolator(t2);
      state.done = t2 >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}
function decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from };
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}
const types$1 = { keyframes: keyframes$1, spring, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes$1;
  } else if (types$1[config.type]) {
    return types$1[config.type];
  }
  const keys = new Set(Object.keys(config));
  if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
    return keyframes$1;
  } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
    return spring;
  }
  return keyframes$1;
}
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i2 = 0; i2 < numToRun; i2++) {
          const callback = toRun[i2];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const frame = {
  delta: 0,
  timestamp: 0
};
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
const flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frame);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
const getFrameData = () => frame;
function loopElapsed(elapsed, duration, delay2 = 0) {
  return elapsed - duration - delay2;
}
function reverseElapsed(elapsed, duration, delay2 = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;
}
function hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;
}
const framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => sync.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate$1(_a2) {
  var _b, _c;
  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a2, options = __rest$2(_a2, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = interpolate([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
function inertia({ from = 0, velocity = 0, min: min2, max: max2, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  let currentAnimation;
  function isOutOfBounds(v2) {
    return min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
  }
  function boundaryNearest(v2) {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  }
  function startAnimation2(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate$1(Object.assign(Object.assign({}, options), {
      driver,
      onUpdate: (v2) => {
        var _a2;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v2);
        (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v2);
      },
      onComplete,
      onStop
    }));
  }
  function startSpring(options) {
    startAnimation2(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
  }
  if (isOutOfBounds(from)) {
    startSpring({ from, velocity, to: boundaryNearest(from) });
  } else {
    let target = power * velocity + from;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = boundaryNearest(target);
    const heading = boundary === min2 ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = (v2) => {
      prev = current;
      current = v2;
      velocity = velocityPerSecond(v2 - prev, getFrameData().delta);
      if (heading === 1 && v2 > boundary || heading === -1 && v2 < boundary) {
        startSpring({ from: v2, to: boundary, velocity });
      }
    };
    startAnimation2({
      type: "decay",
      from,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}
const isPoint = (point) => point.hasOwnProperty("x") && point.hasOwnProperty("y");
const isPoint3D = (point) => isPoint(point) && point.hasOwnProperty("z");
const distance1D = (a2, b2) => Math.abs(a2 - b2);
function distance(a2, b2) {
  if (isNum(a2) && isNum(b2)) {
    return distance1D(a2, b2);
  } else if (isPoint(a2) && isPoint(b2)) {
    const xDelta = distance1D(a2.x, b2.x);
    const yDelta = distance1D(a2.y, b2.y);
    const zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}
const a$1 = (a1, a2) => 1 - 3 * a2 + 3 * a1;
const b = (a1, a2) => 3 * a2 - 6 * a1;
const c$1 = (a1) => 3 * a1;
const calcBezier = (t2, a1, a2) => ((a$1(a1, a2) * t2 + b(a1, a2)) * t2 + c$1(a1)) * t2;
const getSlope = (t2, a1, a2) => 3 * a$1(a1, a2) * t2 * t2 + 2 * b(a1, a2) * t2 + c$1(a1);
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
const newtonIterations = 8;
const newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i2 = 0; i2 < newtonIterations; ++i2) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
const kSplineTableSize = 11;
const kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i2 = 0; i2 < kSplineTableSize; ++i2) {
    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist2 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist2 * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
function useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement: visualElement2 }) {
  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  const isPressing = react.exports.useRef(false);
  const cancelPointerEndListeners = react.exports.useRef(null);
  const eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)
  };
  function removePointerEndListener() {
    cancelPointerEndListeners.current && cancelPointerEndListeners.current();
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    removePointerEndListener();
    isPressing.current = false;
    visualElement2.animationState && visualElement2.animationState.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel && onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    visualElement2.animationState && visualElement2.animationState.setActive(AnimationType.Tap, true);
    onTapStart && onTapStart(event, info);
  }
  usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}
const defaultEnvironment = "production";
const env = typeof process === "undefined" || process.env === void 0 ? defaultEnvironment : "production";
const warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
function useViewport({ visualElement: visualElement2, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {
  const state = react.exports.useRef({
    hasEnteredView: false,
    isInView: false
  });
  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state.current.hasEnteredView)
    shouldObserve = false;
  const useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state.current, visualElement2, viewport);
}
const thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state, visualElement2, { root: root2, margin: rootMargin, amount = "some", once }) {
  react.exports.useEffect(() => {
    if (!shouldObserve)
      return;
    const options = {
      root: root2 === null || root2 === void 0 ? void 0 : root2.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const intersectionCallback = (entry) => {
      const { isIntersecting } = entry;
      if (state.isInView === isIntersecting)
        return;
      state.isInView = isIntersecting;
      if (once && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      if (visualElement2.animationState) {
        visualElement2.animationState.setActive(AnimationType.InView, isIntersecting);
      }
      const props = visualElement2.getProps();
      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(visualElement2.getInstance(), options, intersectionCallback);
  }, [shouldObserve, root2, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state, visualElement2, { fallback = true }) {
  react.exports.useEffect(() => {
    if (!shouldObserve || !fallback)
      return;
    if (env !== "production") {
      warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
    }
    requestAnimationFrame(() => {
      state.hasEnteredView = true;
      const { onViewportEnter } = visualElement2.getProps();
      onViewportEnter && onViewportEnter(null);
      if (visualElement2.animationState) {
        visualElement2.animationState.setActive(AnimationType.InView, true);
      }
    });
  }, [shouldObserve]);
}
const makeRenderlessComponent = (hook) => (props) => {
  hook(props);
  return null;
};
const gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};
function usePresence() {
  const context = react.exports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = react.exports.useId();
  react.exports.useEffect(() => register(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev[i2] !== next[i2])
      return false;
  }
  return true;
}
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant$1(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
const isEasingArray = (ease) => {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
const isAnimatable = (key, value) => {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && complex.test(value) && !value.startsWith("url(")) {
    return true;
  }
  return false;
};
const underDampedSpring = () => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
});
const criticallyDampedSpring = (to) => ({
  type: "spring",
  stiffness: 550,
  damping: to === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const linearTween = () => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
});
const keyframes = (values) => ({
  type: "keyframes",
  duration: 0.8,
  values
});
const defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
const getDefaultTransition = (valueKey, to) => {
  let transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return { to, ...transitionFactory(to) };
};
const defaultValueTypes = {
  ...numberValueTypes,
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  var _a2;
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a2 = defaultValueType.getAnimatableNone) === null || _a2 === void 0 ? void 0 : _a2.call(defaultValueType, value);
}
const instantAnimationState = {
  current: false
};
function delay(callback, timeout) {
  const start = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelSync.read(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  sync.read(checkElapsed, true);
  return () => cancelSync.read(checkElapsed);
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, ...transition }) {
  return !!Object.keys(transition).length;
}
function convertTransitionToAnimationOptions({ ease, times, yoyo, flip: flip2, loop, ...transition }) {
  const options = { ...transition };
  if (times)
    options["offset"] = times;
  if (transition.duration)
    options["duration"] = secondsToMilliseconds(transition.duration);
  if (transition.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop || flip2) {
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip2) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip2 || transition.repeat;
  }
  if (transition.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition, key) {
  var _a2, _b;
  const valueTransition = getValueTransition(transition, key) || {};
  return (_b = (_a2 = valueTransition.delay) !== null && _a2 !== void 0 ? _a2 : transition.delay) !== null && _b !== void 0 ? _b : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = [...options.to];
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition, options, key) {
  if (Array.isArray(options.to) && transition.duration === void 0) {
    transition.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition)) {
    transition = {
      ...transition,
      ...getDefaultTransition(key, options.to)
    };
  }
  return {
    ...options,
    ...convertTransitionToAnimationOptions(transition)
  };
}
function getAnimation(key, value, target, transition, onComplete) {
  const valueTransition = getValueTransition(transition, key) || {};
  let origin = valueTransition.from !== void 0 ? valueTransition.from : value.get();
  const isTargetAnimatable = isAnimatable(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  const isOriginAnimatable = isAnimatable(key, origin);
  function start() {
    const options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: (v2) => value.set(v2)
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia({ ...options, ...valueTransition }) : animate$1({
      ...getPopmotionAnimationOptions(valueTransition, options, key),
      onUpdate: (v2) => {
        options.onUpdate(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        options.onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    });
  }
  function set() {
    const finalTarget = resolveFinalValueInKeyframes(target);
    value.set(finalTarget);
    onComplete();
    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);
    valueTransition.onComplete && valueTransition.onComplete();
    return { stop: () => {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone("", potentialUnitType);
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
function startAnimation(key, value, target, transition = {}) {
  if (instantAnimationState.current) {
    transition = { type: false };
  }
  return value.start((onComplete) => {
    let controls;
    const animation = getAnimation(key, value, target, transition, onComplete);
    const delayBy = getDelayFromTransition(transition, key);
    const start = () => controls = animation();
    let cancelDelay;
    if (delayBy) {
      cancelDelay = delay(start, secondsToMilliseconds(delayBy));
    } else {
      start();
    }
    return () => {
      cancelDelay && cancelDelay();
      controls && controls.stop();
    };
  });
}
const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a2, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  constructor(init) {
    this.version = "7.6.2";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.updateSubscribers = new SubscriptionManager();
    this.velocityUpdateSubscribers = new SubscriptionManager();
    this.renderSubscribers = new SubscriptionManager();
    this.canTrackVelocity = false;
    this.updateAndNotify = (v2, render = true) => {
      this.prev = this.current;
      this.current = v2;
      const { delta, timestamp } = getFrameData();
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        sync.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current) {
        this.updateSubscribers.notify(this.current);
      }
      if (this.velocityUpdateSubscribers.getSize()) {
        this.velocityUpdateSubscribers.notify(this.getVelocity());
      }
      if (render) {
        this.renderSubscribers.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => sync.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        this.velocityUpdateSubscribers.notify(this.getVelocity());
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat(this.current);
  }
  onChange(subscription) {
    return this.updateSubscribers.add(subscription);
  }
  clearListeners() {
    this.updateSubscribers.clear();
  }
  onRenderRequest(subscription) {
    subscription(this.get());
    return this.renderSubscribers.add(subscription);
  }
  attach(passiveEffect) {
    this.passiveEffect = passiveEffect;
  }
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
  }
  start(animation) {
    this.stop();
    return new Promise((resolve2) => {
      this.hasAnimated = true;
      this.stopAnimation = animation(resolve2);
    }).then(() => this.clearAnimation());
  }
  stop() {
    if (this.stopAnimation)
      this.stopAnimation();
    this.clearAnimation();
  }
  isAnimating() {
    return !!this.stopAnimation;
  }
  clearAnimation() {
    this.stopAnimation = null;
  }
  destroy() {
    this.updateSubscribers.clear();
    this.renderSubscribers.clear();
    this.stop();
  }
}
function motionValue(init) {
  return new MotionValue(init);
}
const testValueType = (v2) => (type) => type.test(v2);
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number$1, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
function getCurrent(visualElement2) {
  const current = {};
  visualElement2.forEachValue((value, key) => current[key] = value.get());
  return current;
}
function getVelocity$1(visualElement2) {
  const velocity = {};
  visualElement2.forEachValue((value, key) => velocity[key] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement2, definition, custom) {
  const props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity$1(visualElement2));
}
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  const resolved = resolveVariant(visualElement2, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function setVariants(visualElement2, variantLabels) {
  const reversedLabels = [...variantLabels].reverse();
  reversedLabels.forEach((key) => {
    var _a2;
    const variant = visualElement2.getVariant(key);
    variant && setTarget(visualElement2, variant);
    (_a2 = visualElement2.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach((child) => {
      setVariants(child, variantLabels);
    });
  });
}
function setValues(visualElement2, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement2, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement2, [definition]);
  } else {
    setTarget(visualElement2, definition);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a2, _b;
  const newValueKeys = Object.keys(target).filter((key) => !visualElement2.hasValue(key));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i2 = 0; i2 < numNewValues; i2++) {
    const key = newValueKeys[i2];
    const targetValue = target[key];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a2 = origin[key]) !== null && _a2 !== void 0 ? _a2 : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    if (origin[key] === void 0) {
      origin[key] = value;
    }
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  const valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement2) {
  var _a2;
  const origin = {};
  for (const key in target) {
    const transitionOrigin = getOriginFromTransition(key, transition);
    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a2 = visualElement2.getValue(key)) === null || _a2 === void 0 ? void 0 : _a2.get();
  }
  return origin;
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function animateVisualElement(visualElement2, definition, options = {}) {
  visualElement2.notifyAnimationStart(definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement2, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(() => visualElement2.notifyAnimationComplete(definition));
}
function animateVariant(visualElement2, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(visualElement2, variant, options.custom);
  let { transition = visualElement2.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation2 = resolved ? () => animateTarget(visualElement2, resolved, options) : () => Promise.resolve();
  const getChildAnimations = ((_a2 = visualElement2.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.size) ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a2;
  let { transition = visualElement2.getDefaultTransition(), transitionEnd, ...target } = visualElement2.makeTargetAnimatable(definition);
  const willChange = visualElement2.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && ((_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.getState()[type]);
  for (const key in target) {
    const value = visualElement2.getValue(key);
    const valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    let valueTransition = { delay: delay2, ...transition };
    if (visualElement2.shouldReduceMotion && transformProps.has(key)) {
      valueTransition = {
        ...valueTransition,
        type: false,
        delay: 0
      };
    }
    let animation = startAnimation(key, value, valueTarget, valueTransition);
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key);
      animation = animation.then(() => willChange.remove(key));
    }
    animations2.push(animation);
  }
  return Promise.all(animations2).then(() => {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notifyAnimationComplete(variant)));
  });
  return Promise.all(animations2);
}
function stopAnimation(visualElement2) {
  visualElement2.forEachValue((value) => value.stop());
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
const variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement2, animation, options)));
}
function createAnimationState(visualElement2) {
  let animate2 = animateList(visualElement2);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a2;
    const props = visualElement2.getProps();
    const context = visualElement2.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2];
      const typeState = state[type];
      const prop = (_a2 = props[type]) !== null && _a2 !== void 0 ? _a2 : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === "boolean") {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        removedKeys.delete(key);
        typeState.needsAnimating[key] = true;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a2;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement2.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach((child) => {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    [AnimationType.Animate]: createTypeState(true),
    [AnimationType.InView]: createTypeState(),
    [AnimationType.Hover]: createTypeState(),
    [AnimationType.Tap]: createTypeState(),
    [AnimationType.Drag]: createTypeState(),
    [AnimationType.Focus]: createTypeState(),
    [AnimationType.Exit]: createTypeState()
  };
}
const animations = {
  animation: makeRenderlessComponent(({ visualElement: visualElement2, animate: animate2 }) => {
    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
    if (isAnimationControls(animate2)) {
      react.exports.useEffect(() => animate2.subscribe(visualElement2), [animate2]);
    }
  }),
  exit: makeRenderlessComponent((props) => {
    const { custom, visualElement: visualElement2 } = props;
    const [isPresent, safeToRemove] = usePresence();
    const presenceContext = react.exports.useContext(PresenceContext);
    react.exports.useEffect(() => {
      visualElement2.isPresent = isPresent;
      const animation = visualElement2.animationState && visualElement2.animationState.setActive(AnimationType.Exit, !isPresent, {
        custom: presenceContext && presenceContext.custom || custom
      });
      if (animation && !isPresent) {
        animation.then(safeToRemove);
      }
    }, [isPresent]);
  })
};
class PanSession {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = getFrameData();
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      if (isMouseEvent(event2) && event2.buttons === 0) {
        this.handlePointerUp(event2, info2);
        return;
      }
      sync.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (isTouchEvent(event) && event.touches.length > 1)
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = getFrameData();
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return distance(value, target) < maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mix(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mix(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a2;
  return typeof dragElastic === "number" ? dragElastic : (_a2 = dragElastic[label]) !== null && _a2 !== void 0 ? _a2 : 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  var _a2, _b;
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node = treePath[i2];
    delta = node.projectionDelta;
    if (((_b = (_a2 = node.instance) === null || _a2 === void 0 ? void 0 : _a2.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")
      continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys$1);
  transformAxis(box.y, transform, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.x);
    translateAxis(viewportBox.y, scroll.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement2) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement2;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    if (this.visualElement.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      var _a2;
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        var _a3, _b;
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const measuredAxis = (_b = (_a3 = this.visualElement.projection) === null || _a3 === void 0 ? void 0 : _a3.layout) === null || _b === void 0 ? void 0 : _b.actual[axis];
          if (measuredAxis) {
            const length = calcLength(measuredAxis);
            current = length * (parseFloat(current) / 100);
          }
        }
        this.originPoint[axis] = current;
      });
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
      (_a2 = this.visualElement.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Drag, true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.syncRender();
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  }
  cancel() {
    var _a2, _b;
    this.isDragging = false;
    if (this.visualElement.projection) {
      this.visualElement.projection.isAnimationBlocked = false;
    }
    (_a2 = this.panSession) === null || _a2 === void 0 ? void 0 : _a2.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      var _a2;
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = (_a2 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a2 !== void 0 ? _a2 : {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return startAnimation(axis, axisValue, 0, transition);
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  getAxisMotionValue(axis) {
    var _a2, _b;
    const dragKey = "_drag" + axis.toUpperCase();
    const externalMotionValue = this.visualElement.getProps()[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a2 = this.visualElement.getProps().initial) === null || _a2 === void 0 ? void 0 : _a2[axis]) !== null && _b !== void 0 ? _b : 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.actual[axis];
        axisValue.set(point[axis] - mix(min2, max2, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    var _a2;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mix(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    var _a2;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.getInstance();
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.syncRender();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
function useDrag$1(props) {
  const { dragControls: groupDragControls, visualElement: visualElement2 } = props;
  const dragControls = useConstant(() => new VisualElementDragControls(visualElement2));
  react.exports.useEffect(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);
  react.exports.useEffect(() => dragControls.addListeners(), [dragControls]);
}
function usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement: visualElement2 }) {
  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  const panSession = react.exports.useRef(null);
  const { transformPagePoint } = react.exports.useContext(MotionConfigContext);
  const handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: (event, info) => {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  react.exports.useEffect(() => {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(() => panSession.current && panSession.current.end());
}
const drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag$1)
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "LayoutAnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  const managers = names.map(() => new SubscriptionManager());
  const propSubscriptions = {};
  const lifecycles = {
    clearAllListeners: () => managers.forEach((manager) => manager.clear()),
    updatePropListeners: (props) => {
      names.forEach((name) => {
        var _a2;
        const on = "on" + name;
        const propListener = props[on];
        (_a2 = propSubscriptions[name]) === null || _a2 === void 0 ? void 0 : _a2.call(propSubscriptions);
        if (propListener) {
          propSubscriptions[name] = lifecycles[on](propListener);
        }
      });
    }
  };
  managers.forEach((manager, i2) => {
    lifecycles["on" + names[i2]] = (handler) => manager.add(handler);
    lifecycles["notify" + names[i2]] = (...args) => manager.notify(...args);
  });
  return lifecycles;
}
function updateMotionValuesFromProps(element, next, prev) {
  const { willChange } = next;
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const visualElement = ({ treeType = "", build: build2, getBaseTarget, makeTargetAnimatable, measureViewportBox: measureViewportBox2, render: renderInstance, readValueFromInstance, removeValueFromRenderState, sortNodePosition, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2 }) => ({ parent, props, presenceId, blockInitialAnimation, visualState, reducedMotionConfig }, options = {}) => {
  let isMounted = false;
  const { latestValues, renderState } = visualState;
  let instance;
  const lifecycles = createLifecycles();
  const values = /* @__PURE__ */ new Map();
  const valueSubscriptions = /* @__PURE__ */ new Map();
  let prevMotionValues = {};
  const baseTarget = {
    ...latestValues
  };
  const initialValues = props.initial ? { ...latestValues } : {};
  let removeFromVariantTree;
  function render() {
    if (!instance || !isMounted)
      return;
    triggerBuild();
    renderInstance(instance, renderState, props.style, element.projection);
  }
  function triggerBuild() {
    build2(element, renderState, latestValues, options, props);
  }
  function update() {
    lifecycles.notifyUpdate(latestValues);
  }
  function bindToMotionValue(key, value) {
    const removeOnChange = value.onChange((latestValue) => {
      latestValues[key] = latestValue;
      props.onUpdate && sync.update(update, false, true);
    });
    const removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);
    valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  const { willChange, ...initialMotionValues } = scrapeMotionValuesFromProps2(props);
  for (const key in initialMotionValues) {
    const value = initialMotionValues[key];
    if (latestValues[key] !== void 0 && isMotionValue(value)) {
      value.set(latestValues[key], false);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    }
  }
  if (props.values) {
    for (const key in props.values) {
      const value = props.values[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key]);
      }
    }
  }
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  const element = {
    treeType,
    current: null,
    depth: parent ? parent.depth + 1 : 0,
    parent,
    children: /* @__PURE__ */ new Set(),
    presenceId,
    shouldReduceMotion: null,
    variantChildren: isVariantNode$1 ? /* @__PURE__ */ new Set() : void 0,
    isVisible: void 0,
    manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
    blockInitialAnimation,
    isMounted: () => Boolean(instance),
    mount(newInstance) {
      isMounted = true;
      instance = element.current = newInstance;
      if (element.projection) {
        element.projection.mount(newInstance);
      }
      if (isVariantNode$1 && parent && !isControllingVariants$1) {
        removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
      }
      values.forEach((value, key) => bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      element.shouldReduceMotion = reducedMotionConfig === "never" ? false : reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      parent === null || parent === void 0 ? void 0 : parent.children.add(element);
      element.setProps(props);
    },
    unmount() {
      var _a2;
      (_a2 = element.projection) === null || _a2 === void 0 ? void 0 : _a2.unmount();
      cancelSync.update(update);
      cancelSync.render(render);
      valueSubscriptions.forEach((remove2) => remove2());
      removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
      parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
      lifecycles.clearAllListeners();
      instance = void 0;
      isMounted = false;
    },
    loadFeatures(renderedProps, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {
      const features2 = [];
      for (let i2 = 0; i2 < numFeatures; i2++) {
        const name = featureNames[i2];
        const { isEnabled, Component } = featureDefinitions[name];
        if (isEnabled(renderedProps) && Component) {
          features2.push(react.exports.createElement(Component, {
            key: name,
            ...renderedProps,
            visualElement: element
          }));
        }
      }
      if (!element.projection && ProjectionNodeConstructor) {
        element.projection = new ProjectionNodeConstructor(projectionId, element.getLatestValues(), parent && parent.projection);
        const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll } = renderedProps;
        element.projection.setOptions({
          layoutId,
          layout,
          alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
          visualElement: element,
          scheduleRender: () => element.scheduleRender(),
          animationType: typeof layout === "string" ? layout : "both",
          initialPromotionConfig: initialLayoutGroupConfig,
          layoutScroll
        });
      }
      return features2;
    },
    addVariantChild(child) {
      var _a2;
      const closestVariantNode = element.getClosestVariantNode();
      if (closestVariantNode) {
        (_a2 = closestVariantNode.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    },
    sortNodePosition(other) {
      if (!sortNodePosition || treeType !== other.treeType)
        return 0;
      return sortNodePosition(element.getInstance(), other.getInstance());
    },
    getClosestVariantNode: () => isVariantNode$1 ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode(),
    getLayoutId: () => props.layoutId,
    getInstance: () => instance,
    getStaticValue: (key) => latestValues[key],
    setStaticValue: (key, value) => latestValues[key] = value,
    getLatestValues: () => latestValues,
    setVisibility(visibility) {
      if (element.isVisible === visibility)
        return;
      element.isVisible = visibility;
      element.scheduleRender();
    },
    makeTargetAnimatable(target, canMutate = true) {
      return makeTargetAnimatable(element, target, props, canMutate);
    },
    measureViewportBox() {
      return measureViewportBox2(instance, props);
    },
    addValue(key, value) {
      if (element.hasValue(key))
        element.removeValue(key);
      values.set(key, value);
      latestValues[key] = value.get();
      bindToMotionValue(key, value);
    },
    removeValue(key) {
      var _a2;
      values.delete(key);
      (_a2 = valueSubscriptions.get(key)) === null || _a2 === void 0 ? void 0 : _a2();
      valueSubscriptions.delete(key);
      delete latestValues[key];
      removeValueFromRenderState(key, renderState);
    },
    hasValue: (key) => values.has(key),
    getValue(key, defaultValue) {
      if (props.values && props.values[key]) {
        return props.values[key];
      }
      let value = values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue);
        element.addValue(key, value);
      }
      return value;
    },
    forEachValue: (callback) => values.forEach(callback),
    readValue: (key) => latestValues[key] !== void 0 ? latestValues[key] : readValueFromInstance(instance, key, options),
    setBaseTarget(key, value) {
      baseTarget[key] = value;
    },
    getBaseTarget(key) {
      var _a2;
      const { initial } = props;
      const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a2 = resolveVariantFromProps(props, initial)) === null || _a2 === void 0 ? void 0 : _a2[key] : void 0;
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      if (getBaseTarget) {
        const target = getBaseTarget(props, key);
        if (target !== void 0 && !isMotionValue(target))
          return target;
      }
      return initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : baseTarget[key];
    },
    ...lifecycles,
    build() {
      triggerBuild();
      return renderState;
    },
    scheduleRender() {
      sync.render(render, false, true);
    },
    syncRender: render,
    setProps(newProps) {
      if (newProps.transformTemplate || props.transformTemplate) {
        element.scheduleRender();
      }
      props = newProps;
      lifecycles.updatePropListeners(newProps);
      prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps2(props), prevMotionValues);
    },
    getProps: () => props,
    getVariant: (name) => {
      var _a2;
      return (_a2 = props.variants) === null || _a2 === void 0 ? void 0 : _a2[name];
    },
    getDefaultTransition: () => props.transition,
    getTransformPagePoint: () => {
      return props.transformPagePoint;
    },
    getVariantContext(startAtParent = false) {
      if (startAtParent)
        return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
      if (!isControllingVariants$1) {
        const context2 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
        if (props.initial !== void 0) {
          context2.initial = props.initial;
        }
        return context2;
      }
      const context = {};
      for (let i2 = 0; i2 < numVariantProps; i2++) {
        const name = variantProps[i2];
        const prop = props[name];
        if (isVariantLabel(prop) || prop === false) {
          context[name] = prop;
        }
      }
      return context;
    }
  };
  return element;
};
const variantProps = ["initial", ...variantPriorityOrder];
const numVariantProps = variantProps.length;
function isCSSVariable(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match2 = cssVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token, fallback] = match2;
  return [token, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement2, { ...target }, transitionEnd) {
  const element = visualElement2.getInstance();
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement2.forEachValue((value) => {
    const current = value.get();
    if (!isCSSVariable(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key in target) {
    const current = target[key];
    if (!isCSSVariable(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd && transitionEnd[key] === void 0) {
      transitionEnd[key] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
const isPositionalKey = (key) => positionalKeys.has(key);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const setAndResetVelocity = (value, to) => {
  value.set(to, false);
  value.set(to);
};
const isNumOrPxType = (v2) => v2 === number$1 || v2 === px;
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement2) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
const positionalValues = {
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
const convertChangedValueTypes = (target, visualElement2, changedKeys) => {
  const originBbox = visualElement2.measureViewportBox();
  const element = visualElement2.getInstance();
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key) => {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement2.syncRender();
  const targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach((key) => {
    const value = visualElement2.getValue(key);
    setAndResetVelocity(value, origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement2, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key) => {
    const value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    let from = origin[key];
    let fromType = findDimensionValueType(from);
    const to = target[key];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = findDimensionValueType(from);
      for (let i2 = fromIndex; i2 < numKeyframes; i2++) {
        if (!toType) {
          toType = findDimensionValueType(to[i2]);
        } else {
          invariant$1(findDimensionValueType(to[i2]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key, value]) => {
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement2, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
const htmlConfig = {
  treeType: "dom",
  readValueFromInstance(domElement, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$2(domElement);
      const value = (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  },
  sortNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  },
  getBaseTarget(props, key) {
    var _a2;
    return (_a2 = props.style) === null || _a2 === void 0 ? void 0 : _a2[key];
  },
  measureViewportBox(element, { transformPagePoint }) {
    return measureViewportBox(element, transformPagePoint);
  },
  resetTransform(element, domElement, props) {
    const { transformTemplate } = props;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  },
  makeTargetAnimatable(element, { transition, transitionEnd, ...target }, { transformValues }, isMounted = true) {
    let origin = getOrigin(target, transition || {}, element);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin);
      const parsed = parseDomVariant(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target
    };
  },
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
  build(element, renderState, latestValues, options, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  },
  render: renderHTML
};
const htmlVisualElement = visualElement(htmlConfig);
const svgVisualElement = visualElement({
  ...htmlConfig,
  getBaseTarget(props, key) {
    return props[key];
  },
  readValueFromInstance(domElement, key) {
    var _a2;
    if (transformProps.has(key)) {
      return ((_a2 = getDefaultValueType(key)) === null || _a2 === void 0 ? void 0 : _a2.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return domElement.getAttribute(key);
  },
  scrapeMotionValuesFromProps,
  build(_element, renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);
  },
  render: renderSVG
});
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node.target.x);
    const y2 = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y2}%`;
  }
};
const varToken = "_$css";
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const containsCSSVariables = latest.includes("var(");
    const cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, (match2) => {
        cssVariables.push(match2);
        return varToken;
      });
    }
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    let output2 = template(shadow);
    if (containsCSSVariables) {
      let i2 = 0;
      output2 = output2.replace(varToken, () => {
        const cssVariable = cssVariables[i2];
        i2++;
        return cssVariable;
      });
    }
    return output2;
  }
};
class MeasureLayoutWithContext extends React.Component {
  componentDidMount() {
    const {
      visualElement: visualElement2,
      layoutGroup,
      switchLayoutGroup,
      layoutId
    } = this.props;
    const {
      projection
    } = visualElement2;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const {
      layoutDependency,
      visualElement: visualElement2,
      drag: drag2,
      isPresent
    } = this.props;
    const projection = visualElement2.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        sync.postRender(() => {
          var _a2;
          if (!((_a2 = projection.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length)) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const {
      projection
    } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      if (!projection.currentAnimation && projection.isLead()) {
        this.safeToRemove();
      }
    }
  }
  componentWillUnmount() {
    const {
      visualElement: visualElement2,
      layoutGroup,
      switchLayoutGroup: promoteContext
    } = this.props;
    const {
      projection
    } = visualElement2;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const {
      safeToRemove
    } = this.props;
    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = react.exports.useContext(LayoutGroupContext);
  return /* @__PURE__ */ jsx(MeasureLayoutWithContext, {
    ...props,
    layoutGroup,
    switchLayoutGroup: react.exports.useContext(SwitchLayoutGroupContext),
    isPresent,
    safeToRemove
  });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const layoutFeatures = {
  measureLayout: MeasureLayout
};
function animate(from, to, transition = {}) {
  const value = isMotionValue(from) ? from : motionValue(from);
  startAnimation("", value, to, transition);
  return {
    stop: () => value.stop(),
    isAnimating: () => value.isAnimating()
  };
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber$1 = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  var _a2, _b, _c, _d;
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      (_a2 = lead.opacity) !== null && _a2 !== void 0 ? _a2 : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber$1(followRadius), asNumber$1(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  var _a2;
  return (_a2 = values[radiusName]) !== null && _a2 !== void 0 ? _a2 : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(progress(min2, max2, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function isCloseTo(a2, b2, max2 = 0.1) {
  return distance(a2, b2) <= max2;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    var _a2;
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        node.snapshot.isShared = true;
      }
      if ((_a2 = node.root) === null || _a2 === void 0 ? void 0 : _a2.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      var _a2, _b, _c, _d, _e2;
      (_b = (_a2 = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_e2 = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d);
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
const identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
function buildProjectionTransform(delta, treeScale, latestTransform) {
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  let transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  transform += `scale(${elementScaleX}, ${elementScaleY})`;
  return transform === identityProjection ? "none" : transform;
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(id2, latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.potentialNodes = /* @__PURE__ */ new Map();
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.id = id2;
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      id2 && this.root.registerPotentialNode(id2, this);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    registerPotentialNode(id2, node) {
      this.potentialNodes.set(id2, node);
    }
    mount(instance, isLayoutDirty = false) {
      var _a2;
      if (this.instance)
        return;
      this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
      this.instance = instance;
      const { layoutId, layout, visualElement: visualElement2 } = this.options;
      if (visualElement2 && !visualElement2.getInstance()) {
        visualElement2.mount(instance);
      }
      this.root.nodes.add(this);
      (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.children.add(this);
      this.id && this.root.potentialNodes.delete(this.id);
      if (isLayoutDirty && (layout || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement2 && (layoutId || layout)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          var _a3, _b, _c, _d, _e2;
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = (_b = (_a3 = this.options.transition) !== null && _a3 !== void 0 ? _a3 : visualElement2.getDefaultTransition()) !== null && _b !== void 0 ? _b : defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement2.getProps();
          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (((_c = this.resumeFrom) === null || _c === void 0 ? void 0 : _c.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement2.shouldReduceMotion) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged && this.animationProgress === 0) {
              finishAnimation(this);
            }
            this.isLead() && ((_e2 = (_d = this.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d));
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      var _a2, _b;
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.remove(this);
      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
      this.instance = void 0;
      cancelSync.preRender(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var _a2;
      return this.isAnimationBlocked || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimationBlocked()) || false;
    }
    startUpdate() {
      var _a2;
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      (_a2 = this.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach(resetRotation);
    }
    willUpdate(shouldNotifyListeners = true) {
      var _a2, _b, _c;
      if (this.root.isUpdateBlocked()) {
        (_b = (_a2 = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a2);
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        node.shouldResetTransform = true;
        node.updateScroll();
      }
      const { layoutId, layout } = this.options;
      if (layoutId === void 0 && !layout)
        return;
      const transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;
      this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    didUpdate() {
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating)
        return;
      this.isUpdating = false;
      if (this.potentialNodes.size) {
        this.potentialNodes.forEach(mountNodeEarly);
        this.potentialNodes.clear();
      }
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      flushSync.update();
      flushSync.preRender();
      flushSync.render();
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      sync.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      sync.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      const measured = this.measure();
      const layout = this.removeTransform(this.removeElementScroll(measured));
      roundBox(layout);
      this.snapshot = {
        measured,
        layout,
        latestValues: {}
      };
    }
    updateLayout() {
      var _a2;
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          node.updateScroll();
        }
      }
      const measured = this.measure();
      roundBox(measured);
      const prevLayout = this.layout;
      this.layout = {
        measured,
        actual: this.removeElementScroll(measured)
      };
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.actual);
      (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
    }
    updateScroll() {
      if (this.options.layoutScroll && this.instance) {
        this.isScrollRoot = checkIsScrollRoot(this.instance);
        this.scroll = measureScroll(this.instance);
      }
    }
    resetTransform() {
      var _a2;
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
      const transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure() {
      const { visualElement: visualElement2 } = this.options;
      if (!visualElement2)
        return createBox();
      const box = visualElement2.measureViewportBox();
      const { scroll } = this.root;
      if (scroll) {
        translateAxis(box.x, scroll.x);
        translateAxis(box.y, scroll.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        const { scroll, options, isScrollRoot } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (isScrollRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll.x);
          translateAxis(boxWithoutScroll.y, scroll.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.x,
            y: -node.scroll.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      var _a2;
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measure();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a2 = node.snapshot) === null || _a2 === void 0 ? void 0 : _a2.layout, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    resolveTargetDelta() {
      var _a2;
      const { layout, layoutId } = this.options;
      if (!this.layout || !(layout || layoutId))
        return;
      if (!this.targetDelta && !this.relativeTarget) {
        this.relativeParent = this.getClosestProjectingParent();
        if (this.relativeParent && this.relativeParent.layout) {
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.target)) {
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.actual);
        } else {
          copyBoxInto(this.target, this.layout.actual);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.actual);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        this.relativeParent = this.getClosestProjectingParent();
        if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))
        return void 0;
      if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    calcProjection() {
      var _a2;
      const { layout, layoutId } = this.options;
      this.isTreeAnimating = Boolean(((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout || layoutId))
        return;
      const lead = this.getLead();
      copyBoxInto(this.layoutCorrected, this.layout.actual);
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
      const { target } = lead;
      if (!target)
        return;
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a2, _b, _c;
      (_b = (_a2 = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a2);
      notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      var _a2;
      const snapshot = this.snapshot;
      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      this.relativeTarget = this.relativeTargetOrigin = void 0;
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;
      const isOnlyMember = (((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length) || 0) <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      this.mixTargetDelta = (latest) => {
        var _a3;
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a3 = this.relativeParent) === null || _a3 === void 0 ? void 0 : _a3.layout)) {
          calcRelativePosition(relativeLayout, this.layout.actual, this.relativeParent.layout.actual);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(0);
    }
    startAnimation(options) {
      var _a2, _b;
      this.notifyListeners("animationStart");
      (_a2 = this.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      if (this.resumingFrom) {
        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
      }
      if (this.pendingAnimation) {
        cancelSync.update(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = sync.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animate(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            var _a3;
            this.mixTargetDelta(latest);
            (_a3 = options.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(options, latest);
          },
          onComplete: () => {
            var _a3;
            (_a3 = options.onComplete) === null || _a3 === void 0 ? void 0 : _a3.call(options);
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var _a2;
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var _a2;
      if (this.currentAnimation) {
        (_a2 = this.mixTargetDelta) === null || _a2 === void 0 ? void 0 : _a2.call(this, animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout)
        return;
      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.actual, layout.actual)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.actual.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.actual.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      var _a2, _b, _c;
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      node.promote({
        transition: (_a2 = node.options.initialPromotionConfig) === null || _a2 === void 0 ? void 0 : _a2.transition,
        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement: visualElement2 } = this.options;
      if (!visualElement2)
        return;
      let hasRotate = false;
      const resetValues = {};
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        const axis = transformAxes[i2];
        const key = "rotate" + axis;
        if (!visualElement2.getStaticValue(key)) {
          continue;
        }
        hasRotate = true;
        resetValues[key] = visualElement2.getStaticValue(key);
        visualElement2.setStaticValue(key, 0);
      }
      if (!hasRotate)
        return;
      visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
      for (const key in resetValues) {
        visualElement2.setStaticValue(key, resetValues[key]);
      }
      visualElement2.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a2, _b, _c;
      const styles = {};
      if (!this.instance || this.isSVG)
        return styles;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles.visibility = "";
      }
      const transformTemplate = (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_c = (_b = valuesToRender.opacity) !== null && _b !== void 0 ? _b : this.latestValues.opacity) !== null && _c !== void 0 ? _c : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            styles[applyTo[i2]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a2;
        return (_a2 = node.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a2, _b, _c;
  const snapshot = ((_a2 = node.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { actual: layout, measured: measuredLayout } = node.layout;
    const { animationType } = node.options;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layout, layout)) {
      eachAxis((axis) => {
        const axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        const length = calcLength(layout[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout, snapshot.layout);
    const visualDelta = createDelta();
    if (snapshot.isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);
    } else {
      calcBoxDelta(visualDelta, layout, snapshot.layout);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      node.relativeParent = node.getClosestProjectingParent();
      if (node.relativeParent && !node.relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = node.relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout, parentLayout.actual);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_c = (_b = node.options).onExitComplete) === null || _c === void 0 ? void 0 : _c.call(_b);
  }
  node.options.transition = void 0;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  const { visualElement: visualElement2 } = node.options;
  if (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.getProps().onBeforeLayoutMeasure) {
    visualElement2.notifyBeforeLayoutMeasure();
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output2, delta, p2) {
  output2.translate = mix(delta.translate, 0, p2);
  output2.scale = mix(delta.scale, 1, p2);
  output2.origin = delta.origin;
  output2.originPoint = delta.originPoint;
}
function mixAxis(output2, from, to, p2) {
  output2.min = mix(from.min, to.min, p2);
  output2.max = mix(from.max, to.max, p2);
}
function mixBox(output2, from, to, p2) {
  mixAxis(output2.x, from.x, to.x, p2);
  mixAxis(output2.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, id2) {
  let searchNode = node.root;
  for (let i2 = node.path.length - 1; i2 >= 0; i2--) {
    if (Boolean(node.path[i2].instance)) {
      searchNode = node.path[i2];
      break;
    }
  }
  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  const element = searchElement.querySelector(`[data-projection-id="${id2}"]`);
  if (element)
    node.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout) {
  return animationType === "position" || animationType === "preserve-aspect" && !isCloseTo(aspectRatio(snapshot), aspectRatio(layout), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutFeatures
};
const motion = /* @__PURE__ */ createMotionProxy((Component, config) => createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode));
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __2() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__2.prototype = b2.prototype, new __2());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __awaiter$2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function animationControls() {
  let hasMounted = false;
  const pendingAnimations = [];
  const subscribers = /* @__PURE__ */ new Set();
  const controls = {
    subscribe(visualElement2) {
      subscribers.add(visualElement2);
      return () => void subscribers.delete(visualElement2);
    },
    start(definition, transitionOverride) {
      if (hasMounted) {
        const animations2 = [];
        subscribers.forEach((visualElement2) => {
          animations2.push(animateVisualElement(visualElement2, definition, {
            transitionOverride
          }));
        });
        return Promise.all(animations2);
      } else {
        return new Promise((resolve2) => {
          pendingAnimations.push({
            animation: [definition, transitionOverride],
            resolve: resolve2
          });
        });
      }
    },
    set(definition) {
      return subscribers.forEach((visualElement2) => {
        setValues(visualElement2, definition);
      });
    },
    stop() {
      subscribers.forEach((visualElement2) => {
        stopAnimation(visualElement2);
      });
    },
    mount() {
      hasMounted = true;
      pendingAnimations.forEach(({ animation, resolve: resolve2 }) => {
        controls.start(...animation).then(resolve2);
      });
      return () => {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}
function useAnimationControls() {
  const controls = useConstant(animationControls);
  react.exports.useEffect(controls.mount, []);
  return controls;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o2, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest();
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg = arguments[i2];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn2.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
const classNames = classnames.exports;
var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    var valueA = objA[key];
    var valueB = objB[key];
    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
};
function useEvent$1(callback) {
  var fnRef = react.exports.useRef();
  fnRef.current = callback;
  var memoFn = react.exports.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useLayoutEffect = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
  var firstMountRef = react.exports.useRef(true);
  useLayoutEffect(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
function useSafeState(defaultValue) {
  var destroyRef = react.exports.useRef(false);
  var _React$useState = react.exports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
  react.exports.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  return [value, safeSetState];
}
var Source$1;
(function(Source2) {
  Source2[Source2["INNER"] = 0] = "INNER";
  Source2[Source2["PROP"] = 1] = "PROP";
})(Source$1 || (Source$1 = {}));
function hasValue(value) {
  return value !== void 0;
}
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
  var _useState = useSafeState(function() {
    var finalValue = void 0;
    var source;
    if (hasValue(value)) {
      finalValue = value;
      source = Source$1.PROP;
    } else if (hasValue(defaultValue)) {
      finalValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      source = Source$1.PROP;
    } else {
      finalValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      source = Source$1.INNER;
    }
    return [finalValue, source, finalValue];
  }), _useState2 = _slicedToArray(_useState, 2), mergedValue = _useState2[0], setMergedValue = _useState2[1];
  var chosenValue = hasValue(value) ? value : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue;
  useLayoutUpdateEffect(function() {
    setMergedValue(function(_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1), prevValue = _ref3[0];
      return [value, Source$1.PROP, prevValue];
    });
  }, [value]);
  var changeEventPrevRef = react.exports.useRef();
  var triggerChange = useEvent$1(function(updater, ignoreDestroy) {
    setMergedValue(function(prev) {
      var _prev = _slicedToArray(prev, 3), prevValue = _prev[0], prevSource = _prev[1], prevPrevValue = _prev[2];
      var nextValue = typeof updater === "function" ? updater(prevValue) : updater;
      if (nextValue === prevValue) {
        return prev;
      }
      var overridePrevValue = prevSource === Source$1.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source$1.INNER, overridePrevValue];
    }, ignoreDestroy);
  });
  var onChangeFn = useEvent$1(onChange);
  useLayoutEffect(function() {
    var _mergedValue = _slicedToArray(mergedValue, 3), current = _mergedValue[0], source = _mergedValue[1], prev = _mergedValue[2];
    if (current !== prev && source === Source$1.INNER) {
      onChangeFn(current, prev);
      changeEventPrevRef.current = prev;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var KeyCode = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e3) {
    var keyCode = e3.keyCode;
    if (e3.altKey && !e3.ctrlKey || e3.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var SliderContext = /* @__PURE__ */ react.exports.createContext({
  min: 0,
  max: 0,
  direction: "ltr",
  step: 1,
  includedStart: 0,
  includedEnd: 0,
  tabIndex: 0
});
function getOffset(value, min2, max2) {
  return (value - min2) / (max2 - min2);
}
function getDirectionStyle(direction, value, min2, max2) {
  var offset2 = getOffset(value, min2, max2);
  var positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = "".concat(offset2 * 100, "%");
      positionStyle.transform = "translateX(50%)";
      break;
    case "btt":
      positionStyle.bottom = "".concat(offset2 * 100, "%");
      positionStyle.transform = "translateY(50%)";
      break;
    case "ttb":
      positionStyle.top = "".concat(offset2 * 100, "%");
      positionStyle.transform = "translateY(-50%)";
      break;
    default:
      positionStyle.left = "".concat(offset2 * 100, "%");
      positionStyle.transform = "translateX(-50%)";
      break;
  }
  return positionStyle;
}
function getIndex(value, index2) {
  return Array.isArray(value) ? value[index2] : value;
}
var _excluded$1 = ["prefixCls", "value", "valueIndex", "onStartMove", "style", "render", "dragging", "onOffsetChange"];
var Handle = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames, _getIndex;
  var prefixCls = props.prefixCls, value = props.value, valueIndex = props.valueIndex, onStartMove = props.onStartMove, style = props.style, render = props.render, dragging = props.dragging, onOffsetChange = props.onOffsetChange, restProps = _objectWithoutProperties(props, _excluded$1);
  var _React$useContext = react.exports.useContext(SliderContext), min2 = _React$useContext.min, max2 = _React$useContext.max, direction = _React$useContext.direction, disabled = _React$useContext.disabled, range = _React$useContext.range, tabIndex = _React$useContext.tabIndex, ariaLabelForHandle = _React$useContext.ariaLabelForHandle, ariaLabelledByForHandle = _React$useContext.ariaLabelledByForHandle, ariaValueTextFormatterForHandle = _React$useContext.ariaValueTextFormatterForHandle;
  var handlePrefixCls = "".concat(prefixCls, "-handle");
  var onInternalStartMove = function onInternalStartMove2(e3) {
    if (!disabled) {
      onStartMove(e3, valueIndex);
    }
  };
  var onKeyDown = function onKeyDown2(e3) {
    if (!disabled) {
      var offset2 = null;
      switch (e3.which || e3.keyCode) {
        case KeyCode.LEFT:
          offset2 = direction === "ltr" || direction === "btt" ? -1 : 1;
          break;
        case KeyCode.RIGHT:
          offset2 = direction === "ltr" || direction === "btt" ? 1 : -1;
          break;
        case KeyCode.UP:
          offset2 = direction !== "ttb" ? 1 : -1;
          break;
        case KeyCode.DOWN:
          offset2 = direction !== "ttb" ? -1 : 1;
          break;
        case KeyCode.HOME:
          offset2 = "min";
          break;
        case KeyCode.END:
          offset2 = "max";
          break;
        case KeyCode.PAGE_UP:
          offset2 = 2;
          break;
        case KeyCode.PAGE_DOWN:
          offset2 = -2;
          break;
      }
      if (offset2 !== null) {
        e3.preventDefault();
        onOffsetChange(offset2, valueIndex);
      }
    }
  };
  var positionStyle = getDirectionStyle(direction, value, min2, max2);
  var handleNode = /* @__PURE__ */ jsx("div", {
    ref,
    className: classNames(handlePrefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(handlePrefixCls, "-").concat(valueIndex + 1), range), _defineProperty(_classNames, "".concat(handlePrefixCls, "-dragging"), dragging), _classNames)),
    style: _objectSpread2(_objectSpread2({}, positionStyle), style),
    onMouseDown: onInternalStartMove,
    onTouchStart: onInternalStartMove,
    onKeyDown,
    tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
    role: "slider",
    "aria-valuemin": min2,
    "aria-valuemax": max2,
    "aria-valuenow": value,
    "aria-disabled": disabled,
    "aria-label": getIndex(ariaLabelForHandle, valueIndex),
    "aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
    "aria-valuetext": (_getIndex = getIndex(ariaValueTextFormatterForHandle, valueIndex)) === null || _getIndex === void 0 ? void 0 : _getIndex(value),
    ...restProps
  });
  if (render) {
    handleNode = render(handleNode, {
      index: valueIndex,
      prefixCls,
      value,
      dragging
    });
  }
  return handleNode;
});
var _excluded = ["prefixCls", "style", "onStartMove", "onOffsetChange", "values", "handleRender", "draggingIndex"];
var Handles = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, style = props.style, onStartMove = props.onStartMove, onOffsetChange = props.onOffsetChange, values = props.values, handleRender = props.handleRender, draggingIndex = props.draggingIndex, restProps = _objectWithoutProperties(props, _excluded);
  var handlesRef = react.exports.useRef({});
  react.exports.useImperativeHandle(ref, function() {
    return {
      focus: function focus(index2) {
        var _handlesRef$current$i;
        (_handlesRef$current$i = handlesRef.current[index2]) === null || _handlesRef$current$i === void 0 ? void 0 : _handlesRef$current$i.focus();
      }
    };
  });
  return /* @__PURE__ */ jsx(Fragment, {
    children: values.map(function(value, index2) {
      return /* @__PURE__ */ jsx(Handle, {
        ref: function ref2(node) {
          if (!node) {
            delete handlesRef.current[index2];
          } else {
            handlesRef.current[index2] = node;
          }
        },
        dragging: draggingIndex === index2,
        prefixCls,
        style: getIndex(style, index2),
        value,
        valueIndex: index2,
        onStartMove,
        onOffsetChange,
        render: handleRender,
        ...restProps
      }, index2);
    })
  });
});
function getPosition(e3) {
  var obj = "touches" in e3 ? e3.touches[0] : e3;
  return {
    pageX: obj.pageX,
    pageY: obj.pageY
  };
}
function useDrag(containerRef, direction, rawValues, min2, max2, formatValue2, triggerChange, finishChange, offsetValues) {
  var _React$useState = react.exports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), draggingValue = _React$useState2[0], setDraggingValue = _React$useState2[1];
  var _React$useState3 = react.exports.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), draggingIndex = _React$useState4[0], setDraggingIndex = _React$useState4[1];
  var _React$useState5 = react.exports.useState(rawValues), _React$useState6 = _slicedToArray(_React$useState5, 2), cacheValues = _React$useState6[0], setCacheValues = _React$useState6[1];
  var _React$useState7 = react.exports.useState(rawValues), _React$useState8 = _slicedToArray(_React$useState7, 2), originValues = _React$useState8[0], setOriginValues = _React$useState8[1];
  var mouseMoveEventRef = react.exports.useRef(null);
  var mouseUpEventRef = react.exports.useRef(null);
  react.exports.useEffect(function() {
    if (draggingIndex === -1) {
      setCacheValues(rawValues);
    }
  }, [rawValues, draggingIndex]);
  react.exports.useEffect(function() {
    return function() {
      document.removeEventListener("mousemove", mouseMoveEventRef.current);
      document.removeEventListener("mouseup", mouseUpEventRef.current);
      document.removeEventListener("touchmove", mouseMoveEventRef.current);
      document.removeEventListener("touchend", mouseUpEventRef.current);
    };
  }, []);
  var flushValues = function flushValues2(nextValues, nextValue) {
    if (cacheValues.some(function(val, i2) {
      return val !== nextValues[i2];
    })) {
      if (nextValue !== void 0) {
        setDraggingValue(nextValue);
      }
      setCacheValues(nextValues);
      triggerChange(nextValues);
    }
  };
  var updateCacheValue = function updateCacheValue2(valueIndex, offsetPercent) {
    if (valueIndex === -1) {
      var startValue = originValues[0];
      var endValue = originValues[originValues.length - 1];
      var maxStartOffset = min2 - startValue;
      var maxEndOffset = max2 - endValue;
      var offset2 = offsetPercent * (max2 - min2);
      offset2 = Math.max(offset2, maxStartOffset);
      offset2 = Math.min(offset2, maxEndOffset);
      var formatStartValue = formatValue2(startValue + offset2);
      offset2 = formatStartValue - startValue;
      var cloneCacheValues = originValues.map(function(val) {
        return val + offset2;
      });
      flushValues(cloneCacheValues);
    } else {
      var offsetDist = (max2 - min2) * offsetPercent;
      var cloneValues = _toConsumableArray(cacheValues);
      cloneValues[valueIndex] = originValues[valueIndex];
      var next = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
      flushValues(next.values, next.value);
    }
  };
  var updateCacheValueRef = react.exports.useRef(updateCacheValue);
  updateCacheValueRef.current = updateCacheValue;
  var onStartMove = function onStartMove2(e3, valueIndex) {
    e3.stopPropagation();
    var originValue = rawValues[valueIndex];
    setDraggingIndex(valueIndex);
    setDraggingValue(originValue);
    setOriginValues(rawValues);
    var _getPosition = getPosition(e3), startX = _getPosition.pageX, startY = _getPosition.pageY;
    var onMouseMove = function onMouseMove2(event) {
      event.preventDefault();
      var _getPosition2 = getPosition(event), moveX = _getPosition2.pageX, moveY = _getPosition2.pageY;
      var offsetX = moveX - startX;
      var offsetY = moveY - startY;
      var _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height;
      var offSetPercent;
      switch (direction) {
        case "btt":
          offSetPercent = -offsetY / height;
          break;
        case "ttb":
          offSetPercent = offsetY / height;
          break;
        case "rtl":
          offSetPercent = -offsetX / width;
          break;
        default:
          offSetPercent = offsetX / width;
      }
      updateCacheValueRef.current(valueIndex, offSetPercent);
    };
    var onMouseUp = function onMouseUp2(event) {
      event.preventDefault();
      document.removeEventListener("mouseup", onMouseUp2);
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("touchend", onMouseUp2);
      document.removeEventListener("touchmove", onMouseMove);
      mouseMoveEventRef.current = null;
      mouseUpEventRef.current = null;
      setDraggingIndex(-1);
      finishChange();
    };
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("touchend", onMouseUp);
    document.addEventListener("touchmove", onMouseMove);
    mouseMoveEventRef.current = onMouseMove;
    mouseUpEventRef.current = onMouseUp;
  };
  var returnValues = react.exports.useMemo(function() {
    var sourceValues = _toConsumableArray(rawValues).sort(function(a2, b2) {
      return a2 - b2;
    });
    var targetValues = _toConsumableArray(cacheValues).sort(function(a2, b2) {
      return a2 - b2;
    });
    return sourceValues.every(function(val, index2) {
      return val === targetValues[index2];
    }) ? cacheValues : rawValues;
  }, [rawValues, cacheValues]);
  return [draggingIndex, draggingValue, returnValues, onStartMove];
}
function Track(props) {
  var prefixCls = props.prefixCls, style = props.style, start = props.start, end = props.end, index2 = props.index, onStartMove = props.onStartMove;
  var _React$useContext = react.exports.useContext(SliderContext), direction = _React$useContext.direction, min2 = _React$useContext.min, max2 = _React$useContext.max, disabled = _React$useContext.disabled, range = _React$useContext.range;
  var trackPrefixCls = "".concat(prefixCls, "-track");
  var offsetStart = getOffset(start, min2, max2);
  var offsetEnd = getOffset(end, min2, max2);
  var onInternalStartMove = function onInternalStartMove2(e3) {
    if (!disabled && onStartMove) {
      onStartMove(e3, -1);
    }
  };
  var positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = "".concat(offsetStart * 100, "%");
      positionStyle.width = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
      break;
    case "btt":
      positionStyle.bottom = "".concat(offsetStart * 100, "%");
      positionStyle.height = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
      break;
    case "ttb":
      positionStyle.top = "".concat(offsetStart * 100, "%");
      positionStyle.height = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
      break;
    default:
      positionStyle.left = "".concat(offsetStart * 100, "%");
      positionStyle.width = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
  }
  return /* @__PURE__ */ jsx("div", {
    className: classNames(trackPrefixCls, range && "".concat(trackPrefixCls, "-").concat(index2 + 1)),
    style: _objectSpread2(_objectSpread2({}, positionStyle), style),
    onMouseDown: onInternalStartMove,
    onTouchStart: onInternalStartMove
  });
}
function Tracks(props) {
  var prefixCls = props.prefixCls, style = props.style, values = props.values, startPoint = props.startPoint, onStartMove = props.onStartMove;
  var _React$useContext = react.exports.useContext(SliderContext), included = _React$useContext.included, range = _React$useContext.range, min2 = _React$useContext.min;
  var trackList = react.exports.useMemo(function() {
    if (!range) {
      if (values.length === 0) {
        return [];
      }
      var startValue = startPoint !== null && startPoint !== void 0 ? startPoint : min2;
      var endValue = values[0];
      return [{
        start: Math.min(startValue, endValue),
        end: Math.max(startValue, endValue)
      }];
    }
    var list = [];
    for (var i2 = 0; i2 < values.length - 1; i2 += 1) {
      list.push({
        start: values[i2],
        end: values[i2 + 1]
      });
    }
    return list;
  }, [values, range, startPoint, min2]);
  return included ? trackList.map(function(_ref, index2) {
    var start = _ref.start, end = _ref.end;
    return /* @__PURE__ */ jsx(Track, {
      index: index2,
      prefixCls,
      style: getIndex(style, index2),
      start,
      end,
      onStartMove
    }, index2);
  }) : null;
}
function Mark(props) {
  var prefixCls = props.prefixCls, style = props.style, children = props.children, value = props.value, _onClick = props.onClick;
  var _React$useContext = react.exports.useContext(SliderContext), min2 = _React$useContext.min, max2 = _React$useContext.max, direction = _React$useContext.direction, includedStart = _React$useContext.includedStart, includedEnd = _React$useContext.includedEnd, included = _React$useContext.included;
  var textCls = "".concat(prefixCls, "-text");
  var positionStyle = getDirectionStyle(direction, value, min2, max2);
  return /* @__PURE__ */ jsx("span", {
    className: classNames(textCls, _defineProperty({}, "".concat(textCls, "-active"), included && includedStart <= value && value <= includedEnd)),
    style: _objectSpread2(_objectSpread2({}, positionStyle), style),
    onMouseDown: function onMouseDown(e3) {
      e3.stopPropagation();
    },
    onClick: function onClick() {
      _onClick(value);
    },
    children
  });
}
function Marks(props) {
  var prefixCls = props.prefixCls, marks = props.marks, onClick = props.onClick;
  var markPrefixCls = "".concat(prefixCls, "-mark");
  if (!marks.length) {
    return null;
  }
  return /* @__PURE__ */ jsx("div", {
    className: markPrefixCls,
    children: marks.map(function(_ref) {
      var value = _ref.value, style = _ref.style, label = _ref.label;
      return /* @__PURE__ */ jsx(Mark, {
        prefixCls: markPrefixCls,
        style,
        value,
        onClick,
        children: label
      }, value);
    })
  });
}
function Dot(props) {
  var prefixCls = props.prefixCls, value = props.value, style = props.style, activeStyle = props.activeStyle;
  var _React$useContext = react.exports.useContext(SliderContext), min2 = _React$useContext.min, max2 = _React$useContext.max, direction = _React$useContext.direction, included = _React$useContext.included, includedStart = _React$useContext.includedStart, includedEnd = _React$useContext.includedEnd;
  var dotClassName = "".concat(prefixCls, "-dot");
  var active = included && includedStart <= value && value <= includedEnd;
  var mergedStyle = _objectSpread2(_objectSpread2({}, getDirectionStyle(direction, value, min2, max2)), typeof style === "function" ? style(value) : style);
  if (active) {
    mergedStyle = _objectSpread2(_objectSpread2({}, mergedStyle), typeof activeStyle === "function" ? activeStyle(value) : activeStyle);
  }
  return /* @__PURE__ */ jsx("span", {
    className: classNames(dotClassName, _defineProperty({}, "".concat(dotClassName, "-active"), active)),
    style: mergedStyle
  });
}
function Steps(props) {
  var prefixCls = props.prefixCls, marks = props.marks, dots = props.dots, style = props.style, activeStyle = props.activeStyle;
  var _React$useContext = react.exports.useContext(SliderContext), min2 = _React$useContext.min, max2 = _React$useContext.max, step = _React$useContext.step;
  var stepDots = react.exports.useMemo(function() {
    var dotSet = /* @__PURE__ */ new Set();
    marks.forEach(function(mark) {
      dotSet.add(mark.value);
    });
    if (dots && step !== null) {
      var current = min2;
      while (current <= max2) {
        dotSet.add(current);
        current += step;
      }
    }
    return Array.from(dotSet);
  }, [min2, max2, step, dots, marks]);
  return /* @__PURE__ */ jsx("div", {
    className: "".concat(prefixCls, "-step"),
    children: stepDots.map(function(dotValue) {
      return /* @__PURE__ */ jsx(Dot, {
        prefixCls,
        value: dotValue,
        style,
        activeStyle
      }, dotValue);
    })
  });
}
function useOffset(min2, max2, step, markList, allowCross, pushable) {
  var formatRangeValue = react.exports.useCallback(function(val) {
    var formatNextValue = isFinite(val) ? val : min2;
    formatNextValue = Math.min(max2, val);
    formatNextValue = Math.max(min2, formatNextValue);
    return formatNextValue;
  }, [min2, max2]);
  var formatStepValue = react.exports.useCallback(function(val) {
    if (step !== null) {
      var stepValue = min2 + Math.round((formatRangeValue(val) - min2) / step) * step;
      var getDecimal = function getDecimal2(num) {
        return (String(num).split(".")[1] || "").length;
      };
      var maxDecimal = Math.max(getDecimal(step), getDecimal(max2), getDecimal(min2));
      var fixedValue = Number(stepValue.toFixed(maxDecimal));
      return min2 <= fixedValue && fixedValue <= max2 ? fixedValue : null;
    }
    return null;
  }, [step, min2, max2, formatRangeValue]);
  var formatValue2 = react.exports.useCallback(function(val) {
    var formatNextValue = formatRangeValue(val);
    var alignValues = markList.map(function(mark) {
      return mark.value;
    });
    if (step !== null) {
      alignValues.push(formatStepValue(val));
    }
    alignValues.push(min2, max2);
    var closeValue = alignValues[0];
    var closeDist = max2 - min2;
    alignValues.forEach(function(alignValue) {
      var dist2 = Math.abs(formatNextValue - alignValue);
      if (dist2 <= closeDist) {
        closeValue = alignValue;
        closeDist = dist2;
      }
    });
    return closeValue;
  }, [min2, max2, markList, step, formatRangeValue, formatStepValue]);
  var offsetValue = function offsetValue2(values, offset2, valueIndex) {
    var mode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit";
    if (typeof offset2 === "number") {
      var nextValue;
      var originValue = values[valueIndex];
      var targetDistValue = originValue + offset2;
      var potentialValues = [];
      markList.forEach(function(mark) {
        potentialValues.push(mark.value);
      });
      potentialValues.push(min2, max2);
      potentialValues.push(formatStepValue(originValue));
      var sign = offset2 > 0 ? 1 : -1;
      if (mode === "unit") {
        potentialValues.push(formatStepValue(originValue + sign * step));
      } else {
        potentialValues.push(formatStepValue(targetDistValue));
      }
      potentialValues = potentialValues.filter(function(val) {
        return val !== null;
      }).filter(function(val) {
        return offset2 < 0 ? val <= originValue : val >= originValue;
      });
      if (mode === "unit") {
        potentialValues = potentialValues.filter(function(val) {
          return val !== originValue;
        });
      }
      var compareValue = mode === "unit" ? originValue : targetDistValue;
      nextValue = potentialValues[0];
      var valueDist = Math.abs(nextValue - compareValue);
      potentialValues.forEach(function(potentialValue) {
        var dist2 = Math.abs(potentialValue - compareValue);
        if (dist2 < valueDist) {
          nextValue = potentialValue;
          valueDist = dist2;
        }
      });
      if (nextValue === void 0) {
        return offset2 < 0 ? min2 : max2;
      }
      if (mode === "dist") {
        return nextValue;
      }
      if (Math.abs(offset2) > 1) {
        var cloneValues = _toConsumableArray(values);
        cloneValues[valueIndex] = nextValue;
        return offsetValue2(cloneValues, offset2 - sign, valueIndex, mode);
      }
      return nextValue;
    } else if (offset2 === "min") {
      return min2;
    } else if (offset2 === "max") {
      return max2;
    }
  };
  var offsetChangedValue = function offsetChangedValue2(values, offset2, valueIndex) {
    var mode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit";
    var originValue = values[valueIndex];
    var nextValue = offsetValue(values, offset2, valueIndex, mode);
    return {
      value: nextValue,
      changed: nextValue !== originValue
    };
  };
  var needPush = function needPush2(dist2) {
    return pushable === null && dist2 === 0 || typeof pushable === "number" && dist2 < pushable;
  };
  var offsetValues = function offsetValues2(values, offset2, valueIndex) {
    var mode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit";
    var nextValues = values.map(formatValue2);
    var originValue = nextValues[valueIndex];
    var nextValue = offsetValue(nextValues, offset2, valueIndex, mode);
    nextValues[valueIndex] = nextValue;
    if (allowCross === false) {
      var pushNum = pushable || 0;
      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {
        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);
      }
      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {
        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);
      }
    } else if (typeof pushable === "number" || pushable === null) {
      for (var i2 = valueIndex + 1; i2 < nextValues.length; i2 += 1) {
        var changed = true;
        while (needPush(nextValues[i2] - nextValues[i2 - 1]) && changed) {
          var _offsetChangedValue = offsetChangedValue(nextValues, 1, i2);
          nextValues[i2] = _offsetChangedValue.value;
          changed = _offsetChangedValue.changed;
        }
      }
      for (var _i = valueIndex; _i > 0; _i -= 1) {
        var _changed = true;
        while (needPush(nextValues[_i] - nextValues[_i - 1]) && _changed) {
          var _offsetChangedValue2 = offsetChangedValue(nextValues, -1, _i - 1);
          nextValues[_i - 1] = _offsetChangedValue2.value;
          _changed = _offsetChangedValue2.changed;
        }
      }
      for (var _i2 = nextValues.length - 1; _i2 > 0; _i2 -= 1) {
        var _changed2 = true;
        while (needPush(nextValues[_i2] - nextValues[_i2 - 1]) && _changed2) {
          var _offsetChangedValue3 = offsetChangedValue(nextValues, -1, _i2 - 1);
          nextValues[_i2 - 1] = _offsetChangedValue3.value;
          _changed2 = _offsetChangedValue3.changed;
        }
      }
      for (var _i3 = 0; _i3 < nextValues.length - 1; _i3 += 1) {
        var _changed3 = true;
        while (needPush(nextValues[_i3 + 1] - nextValues[_i3]) && _changed3) {
          var _offsetChangedValue4 = offsetChangedValue(nextValues, 1, _i3 + 1);
          nextValues[_i3 + 1] = _offsetChangedValue4.value;
          _changed3 = _offsetChangedValue4.changed;
        }
      }
    }
    return {
      value: nextValues[valueIndex],
      values: nextValues
    };
  };
  return [formatValue2, offsetValues];
}
var Slider = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-slider" : _props$prefixCls, className = props.className, style = props.style, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, autoFocus = props.autoFocus, onFocus = props.onFocus, onBlur = props.onBlur, _props$min = props.min, min2 = _props$min === void 0 ? 0 : _props$min, _props$max = props.max, max2 = _props$max === void 0 ? 100 : _props$max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, value = props.value, defaultValue = props.defaultValue, range = props.range, count2 = props.count, onChange = props.onChange, onBeforeChange = props.onBeforeChange, onAfterChange = props.onAfterChange, _props$allowCross = props.allowCross, allowCross = _props$allowCross === void 0 ? true : _props$allowCross, _props$pushable = props.pushable, pushable = _props$pushable === void 0 ? false : _props$pushable, draggableTrack = props.draggableTrack, reverse = props.reverse, vertical = props.vertical, _props$included = props.included, included = _props$included === void 0 ? true : _props$included, startPoint = props.startPoint, trackStyle = props.trackStyle, handleStyle = props.handleStyle, railStyle = props.railStyle, dotStyle = props.dotStyle, activeDotStyle = props.activeDotStyle, marks = props.marks, dots = props.dots, handleRender = props.handleRender, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, ariaLabelForHandle = props.ariaLabelForHandle, ariaLabelledByForHandle = props.ariaLabelledByForHandle, ariaValueTextFormatterForHandle = props.ariaValueTextFormatterForHandle;
  var handlesRef = react.exports.useRef();
  var containerRef = react.exports.useRef();
  var direction = react.exports.useMemo(function() {
    if (vertical) {
      return reverse ? "ttb" : "btt";
    }
    return reverse ? "rtl" : "ltr";
  }, [reverse, vertical]);
  var mergedMin = react.exports.useMemo(function() {
    return isFinite(min2) ? min2 : 0;
  }, [min2]);
  var mergedMax = react.exports.useMemo(function() {
    return isFinite(max2) ? max2 : 100;
  }, [max2]);
  var mergedStep = react.exports.useMemo(function() {
    return step !== null && step <= 0 ? 1 : step;
  }, [step]);
  var mergedPush = react.exports.useMemo(function() {
    if (pushable === true) {
      return mergedStep;
    }
    return pushable >= 0 ? pushable : false;
  }, [pushable, mergedStep]);
  var markList = react.exports.useMemo(function() {
    var keys = Object.keys(marks || {});
    return keys.map(function(key) {
      var mark = marks[key];
      var markObj = {
        value: Number(key)
      };
      if (mark && _typeof(mark) === "object" && !/* @__PURE__ */ react.exports.isValidElement(mark) && ("label" in mark || "style" in mark)) {
        markObj.style = mark.style;
        markObj.label = mark.label;
      } else {
        markObj.label = mark;
      }
      return markObj;
    }).filter(function(_ref) {
      var label = _ref.label;
      return label || typeof label === "number";
    }).sort(function(a2, b2) {
      return a2.value - b2.value;
    });
  }, [marks]);
  var _useOffset = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush), _useOffset2 = _slicedToArray(_useOffset, 2), formatValue2 = _useOffset2[0], offsetValues = _useOffset2[1];
  var _useMergedState = useMergedState(defaultValue, {
    value
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setValue = _useMergedState2[1];
  var rawValues = react.exports.useMemo(function() {
    var valueList = mergedValue === null || mergedValue === void 0 ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];
    var _valueList = _slicedToArray(valueList, 1), _valueList$ = _valueList[0], val0 = _valueList$ === void 0 ? mergedMin : _valueList$;
    var returnValues = mergedValue === null ? [] : [val0];
    if (range) {
      returnValues = _toConsumableArray(valueList);
      if (count2 || mergedValue === void 0) {
        var pointCount = count2 >= 0 ? count2 + 1 : 2;
        returnValues = returnValues.slice(0, pointCount);
        while (returnValues.length < pointCount) {
          var _returnValues;
          returnValues.push((_returnValues = returnValues[returnValues.length - 1]) !== null && _returnValues !== void 0 ? _returnValues : mergedMin);
        }
      }
      returnValues.sort(function(a2, b2) {
        return a2 - b2;
      });
    }
    returnValues.forEach(function(val, index2) {
      returnValues[index2] = formatValue2(val);
    });
    return returnValues;
  }, [mergedValue, range, mergedMin, count2, formatValue2]);
  var rawValuesRef = react.exports.useRef(rawValues);
  rawValuesRef.current = rawValues;
  var getTriggerValue = function getTriggerValue2(triggerValues) {
    return range ? triggerValues : triggerValues[0];
  };
  var triggerChange = function triggerChange2(nextValues) {
    var cloneNextValues = _toConsumableArray(nextValues).sort(function(a2, b2) {
      return a2 - b2;
    });
    if (onChange && !shallowequal(cloneNextValues, rawValuesRef.current)) {
      onChange(getTriggerValue(cloneNextValues));
    }
    setValue(cloneNextValues);
  };
  var changeToCloseValue = function changeToCloseValue2(newValue) {
    if (!disabled) {
      var valueIndex = 0;
      var valueDist = mergedMax - mergedMin;
      rawValues.forEach(function(val, index2) {
        var dist2 = Math.abs(newValue - val);
        if (dist2 <= valueDist) {
          valueDist = dist2;
          valueIndex = index2;
        }
      });
      var cloneNextValues = _toConsumableArray(rawValues);
      cloneNextValues[valueIndex] = newValue;
      if (range && !rawValues.length && count2 === void 0) {
        cloneNextValues.push(newValue);
      }
      onBeforeChange === null || onBeforeChange === void 0 ? void 0 : onBeforeChange(getTriggerValue(cloneNextValues));
      triggerChange(cloneNextValues);
      onAfterChange === null || onAfterChange === void 0 ? void 0 : onAfterChange(getTriggerValue(cloneNextValues));
    }
  };
  var onSliderMouseDown = function onSliderMouseDown2(e3) {
    e3.preventDefault();
    var _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height, left = _containerRef$current.left, top = _containerRef$current.top, bottom = _containerRef$current.bottom, right = _containerRef$current.right;
    var clientX = e3.clientX, clientY = e3.clientY;
    var percent2;
    switch (direction) {
      case "btt":
        percent2 = (bottom - clientY) / height;
        break;
      case "ttb":
        percent2 = (clientY - top) / height;
        break;
      case "rtl":
        percent2 = (right - clientX) / width;
        break;
      default:
        percent2 = (clientX - left) / width;
    }
    var nextValue = mergedMin + percent2 * (mergedMax - mergedMin);
    changeToCloseValue(formatValue2(nextValue));
  };
  var _React$useState = react.exports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), keyboardValue = _React$useState2[0], setKeyboardValue = _React$useState2[1];
  var onHandleOffsetChange = function onHandleOffsetChange2(offset2, valueIndex) {
    if (!disabled) {
      var next = offsetValues(rawValues, offset2, valueIndex);
      onBeforeChange === null || onBeforeChange === void 0 ? void 0 : onBeforeChange(getTriggerValue(rawValues));
      triggerChange(next.values);
      onAfterChange === null || onAfterChange === void 0 ? void 0 : onAfterChange(getTriggerValue(next.values));
      setKeyboardValue(next.value);
    }
  };
  react.exports.useEffect(function() {
    if (keyboardValue !== null) {
      var valueIndex = rawValues.indexOf(keyboardValue);
      if (valueIndex >= 0) {
        handlesRef.current.focus(valueIndex);
      }
    }
    setKeyboardValue(null);
  }, [keyboardValue]);
  var mergedDraggableTrack = react.exports.useMemo(function() {
    if (draggableTrack && mergedStep === null) {
      return false;
    }
    return draggableTrack;
  }, [draggableTrack, mergedStep]);
  var finishChange = function finishChange2() {
    onAfterChange === null || onAfterChange === void 0 ? void 0 : onAfterChange(getTriggerValue(rawValuesRef.current));
  };
  var _useDrag = useDrag(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue2, triggerChange, finishChange, offsetValues), _useDrag2 = _slicedToArray(_useDrag, 4), draggingIndex = _useDrag2[0], draggingValue = _useDrag2[1], cacheValues = _useDrag2[2], onStartDrag = _useDrag2[3];
  var onStartMove = function onStartMove2(e3, valueIndex) {
    onStartDrag(e3, valueIndex);
    onBeforeChange === null || onBeforeChange === void 0 ? void 0 : onBeforeChange(getTriggerValue(rawValuesRef.current));
  };
  var dragging = draggingIndex !== -1;
  react.exports.useEffect(function() {
    if (!dragging) {
      var valueIndex = rawValues.lastIndexOf(draggingValue);
      handlesRef.current.focus(valueIndex);
    }
  }, [dragging]);
  var sortedCacheValues = react.exports.useMemo(function() {
    return _toConsumableArray(cacheValues).sort(function(a2, b2) {
      return a2 - b2;
    });
  }, [cacheValues]);
  var _React$useMemo = react.exports.useMemo(function() {
    if (!range) {
      return [mergedMin, sortedCacheValues[0]];
    }
    return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];
  }, [sortedCacheValues, range, mergedMin]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), includedStart = _React$useMemo2[0], includedEnd = _React$useMemo2[1];
  react.exports.useImperativeHandle(ref, function() {
    return {
      focus: function focus() {
        handlesRef.current.focus(0);
      },
      blur: function blur() {
        var _document = document, activeElement = _document.activeElement;
        if (containerRef.current.contains(activeElement)) {
          activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
        }
      }
    };
  });
  react.exports.useEffect(function() {
    if (autoFocus) {
      handlesRef.current.focus(0);
    }
  }, []);
  var context = react.exports.useMemo(function() {
    return {
      min: mergedMin,
      max: mergedMax,
      direction,
      disabled,
      step: mergedStep,
      included,
      includedStart,
      includedEnd,
      range,
      tabIndex,
      ariaLabelForHandle,
      ariaLabelledByForHandle,
      ariaValueTextFormatterForHandle
    };
  }, [mergedMin, mergedMax, direction, disabled, mergedStep, included, includedStart, includedEnd, range, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaValueTextFormatterForHandle]);
  return /* @__PURE__ */ jsx(SliderContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxs("div", {
      ref: containerRef,
      className: classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty(_classNames, "".concat(prefixCls, "-vertical"), vertical), _defineProperty(_classNames, "".concat(prefixCls, "-horizontal"), !vertical), _defineProperty(_classNames, "".concat(prefixCls, "-with-marks"), markList.length), _classNames)),
      style,
      onMouseDown: onSliderMouseDown,
      children: [/* @__PURE__ */ jsx("div", {
        className: "".concat(prefixCls, "-rail"),
        style: railStyle
      }), /* @__PURE__ */ jsx(Tracks, {
        prefixCls,
        style: trackStyle,
        values: sortedCacheValues,
        startPoint,
        onStartMove: mergedDraggableTrack ? onStartMove : null
      }), /* @__PURE__ */ jsx(Steps, {
        prefixCls,
        marks: markList,
        dots,
        style: dotStyle,
        activeStyle: activeDotStyle
      }), /* @__PURE__ */ jsx(Handles, {
        ref: handlesRef,
        prefixCls,
        style: handleStyle,
        values: cacheValues,
        draggingIndex,
        onStartMove,
        onOffsetChange: onHandleOffsetChange,
        onFocus,
        onBlur,
        handleRender
      }), /* @__PURE__ */ jsx(Marks, {
        prefixCls,
        marks: markList,
        onClick: changeToCloseValue
      })]
    })
  });
});
/**
 * react-table
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d2) {
  return d2 instanceof Function;
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return () => {
    let depTime;
    if (opts.key && opts.debug)
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep2, index2) => deps[index2] !== dep2);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug)
      resultTime = Date.now();
    result = fn(...newDeps);
    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c\u23F1 ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function createColumn(table, columnDef, depth, parent) {
  var _a2, _b;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id2 = (_b = (_a2 = resolvedColumnDef.id) != null ? _a2 : accessorKey ? accessorKey.replace(".", "_") : void 0) != null ? _b : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          result = result[key];
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id2) {
    throw new Error();
  }
  let column = {
    id: `${String(id2)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d2) => d2.getFlatColumns())];
    }, {
      key: "column.getFlatColumns",
      debug: () => {
        var _a3;
        return (_a3 = table.options.debugAll) != null ? _a3 : table.options.debugColumns;
      }
    }),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, {
      key: "column.getLeafColumns",
      debug: () => {
        var _a3;
        return (_a3 = table.options.debugAll) != null ? _a3 : table.options.debugColumns;
      }
    })
  };
  column = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, table));
  }, column);
  return column;
}
function createHeader(table, column, options) {
  var _a2;
  const id2 = (_a2 = options.id) != null ? _a2 : column.id;
  let header = {
    id: id2,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h2) => {
        if (h2.subHeaders && h2.subHeaders.length) {
          h2.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h2);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    Object.assign(header, feature.createHeader == null ? void 0 : feature.createHeader(header, table));
  });
  return header;
}
const Headers = {
  createTable: (table) => {
    return {
      getHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        var _a2, _b;
        const leftColumns = (_a2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _a2 : [];
        const rightColumns = (_b = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _b : [];
        const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
        return headerGroups;
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getCenterHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        return buildHeaderGroups(allColumns, leafColumns, table, "center");
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getLeftHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
        var _a2;
        const orderedLeafColumns = (_a2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _a2 : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getRightHeaderGroups: memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
        var _a2;
        const orderedLeafColumns = (_a2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _a2 : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getFooterGroups: memo(() => [table.getHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getLeftFooterGroups: memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getCenterFooterGroups: memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getRightFooterGroups: memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
        return [...headerGroups].reverse();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getFlatHeaders: memo(() => [table.getHeaderGroups()], (headerGroups) => {
        return headerGroups.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getLeftFlatHeaders: memo(() => [table.getLeftHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getCenterFlatHeaders: memo(() => [table.getCenterHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getRightFlatHeaders: memo(() => [table.getRightHeaderGroups()], (left) => {
        return left.map((headerGroup) => {
          return headerGroup.headers;
        }).flat();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getCenterLeafHeaders: memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders;
          return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
        });
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getLeftLeafHeaders: memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders2;
          return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
        });
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getRightLeafHeaders: memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
        return flatHeaders.filter((header) => {
          var _header$subHeaders3;
          return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
        });
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      }),
      getLeafHeaders: memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
        var _a2, _b, _c;
        var _left$, _center$, _right$;
        return [...(_a2 = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _a2 : [], ...(_b = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _b : [], ...(_c = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _c : []].map((header) => {
          return header.getLeafHeaders();
        }).flat();
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugHeaders;
        }
      })
    };
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _a2;
  var _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d2) => d2.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index2) => createHeader(table, column, {
    depth: maxDepth,
    index: index2
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_a2 = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _a2 : []);
  return headerGroups;
}
const defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
const getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
const ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    return {
      getSize: () => {
        var _a2, _b, _c;
        const columnSize = table.getState().columnSizing[column.id];
        return Math.min(Math.max((_a2 = column.columnDef.minSize) != null ? _a2 : defaultColumnSizing.minSize, (_b = columnSize != null ? columnSize : column.columnDef.size) != null ? _b : defaultColumnSizing.size), (_c = column.columnDef.maxSize) != null ? _c : defaultColumnSizing.maxSize);
      },
      getStart: (position) => {
        const columns = !position ? table.getVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
        const index2 = columns.findIndex((d2) => d2.id === column.id);
        if (index2 > 0) {
          const prevSiblingColumn = columns[index2 - 1];
          return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();
        }
        return 0;
      },
      resetSize: () => {
        table.setColumnSizing((_ref) => {
          let {
            [column.id]: _2,
            ...rest
          } = _ref;
          return rest;
        });
      },
      getCanResize: () => {
        var _a2, _b;
        return ((_a2 = column.columnDef.enableResizing) != null ? _a2 : true) && ((_b = table.options.enableColumnResizing) != null ? _b : true);
      },
      getIsResizing: () => {
        return table.getState().columnSizingInfo.isResizingColumn === column.id;
      }
    };
  },
  createHeader: (header, table) => {
    return {
      getSize: () => {
        let sum2 = 0;
        const recurse = (header2) => {
          var _a2;
          if (header2.subHeaders.length) {
            header2.subHeaders.forEach(recurse);
          } else {
            sum2 += (_a2 = header2.column.getSize()) != null ? _a2 : 0;
          }
        };
        recurse(header);
        return sum2;
      },
      getStart: () => {
        if (header.index > 0) {
          const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
          return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
        }
        return 0;
      },
      getResizeHandler: () => {
        const column = table.getColumn(header.column.id);
        const canResize = column.getCanResize();
        return (e3) => {
          if (!canResize) {
            return;
          }
          e3.persist == null ? void 0 : e3.persist();
          if (isTouchStartEvent(e3)) {
            if (e3.touches && e3.touches.length > 1) {
              return;
            }
          }
          const startSize = header.getSize();
          const columnSizingStart = header ? header.getLeafHeaders().map((d2) => [d2.column.id, d2.column.getSize()]) : [[column.id, column.getSize()]];
          const clientX = isTouchStartEvent(e3) ? Math.round(e3.touches[0].clientX) : e3.clientX;
          const updateOffset = (eventType, clientXPos) => {
            if (typeof clientXPos !== "number") {
              return;
            }
            let newColumnSizing = {};
            table.setColumnSizingInfo((old) => {
              var _a2, _b;
              const deltaOffset = clientXPos - ((_a2 = old == null ? void 0 : old.startOffset) != null ? _a2 : 0);
              const deltaPercentage = Math.max(deltaOffset / ((_b = old == null ? void 0 : old.startSize) != null ? _b : 0), -0.999999);
              old.columnSizingStart.forEach((_ref2) => {
                let [columnId, headerSize] = _ref2;
                newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
              });
              return {
                ...old,
                deltaOffset,
                deltaPercentage
              };
            });
            if (table.options.columnResizeMode === "onChange" || eventType === "end") {
              table.setColumnSizing((old) => ({
                ...old,
                ...newColumnSizing
              }));
            }
          };
          const onMove = (clientXPos) => updateOffset("move", clientXPos);
          const onEnd = (clientXPos) => {
            updateOffset("end", clientXPos);
            table.setColumnSizingInfo((old) => ({
              ...old,
              isResizingColumn: false,
              startOffset: null,
              startSize: null,
              deltaOffset: null,
              deltaPercentage: null,
              columnSizingStart: []
            }));
          };
          const mouseEvents = {
            moveHandler: (e4) => onMove(e4.clientX),
            upHandler: (e4) => {
              document.removeEventListener("mousemove", mouseEvents.moveHandler);
              document.removeEventListener("mouseup", mouseEvents.upHandler);
              onEnd(e4.clientX);
            }
          };
          const touchEvents = {
            moveHandler: (e4) => {
              if (e4.cancelable) {
                e4.preventDefault();
                e4.stopPropagation();
              }
              onMove(e4.touches[0].clientX);
              return false;
            },
            upHandler: (e4) => {
              var _e$touches$;
              document.removeEventListener("touchmove", touchEvents.moveHandler);
              document.removeEventListener("touchend", touchEvents.upHandler);
              if (e4.cancelable) {
                e4.preventDefault();
                e4.stopPropagation();
              }
              onEnd((_e$touches$ = e4.touches[0]) == null ? void 0 : _e$touches$.clientX);
            }
          };
          const passiveIfSupported = passiveEventSupported() ? {
            passive: false
          } : false;
          if (isTouchStartEvent(e3)) {
            document.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
            document.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
          } else {
            document.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
            document.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
          }
          table.setColumnSizingInfo((old) => ({
            ...old,
            startOffset: clientX,
            startSize,
            deltaOffset: 0,
            deltaPercentage: 0,
            columnSizingStart,
            isResizingColumn: column.id
          }));
        };
      }
    };
  },
  createTable: (table) => {
    return {
      setColumnSizing: (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater),
      setColumnSizingInfo: (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater),
      resetColumnSizing: (defaultState) => {
        var _a2;
        table.setColumnSizing(defaultState ? {} : (_a2 = table.initialState.columnSizing) != null ? _a2 : {});
      },
      resetHeaderSizeInfo: (defaultState) => {
        var _a2;
        table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_a2 = table.initialState.columnSizingInfo) != null ? _a2 : getDefaultColumnSizingInfoState());
      },
      getTotalSize: () => {
        var _a2;
        var _table$getHeaderGroup;
        return (_a2 = (_table$getHeaderGroup = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a2 : 0;
      },
      getLeftTotalSize: () => {
        var _a2;
        var _table$getLeftHeaderG;
        return (_a2 = (_table$getLeftHeaderG = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a2 : 0;
      },
      getCenterTotalSize: () => {
        var _a2;
        var _table$getCenterHeade;
        return (_a2 = (_table$getCenterHeade = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a2 : 0;
      },
      getRightTotalSize: () => {
        var _a2;
        var _table$getRightHeader;
        return (_a2 = (_table$getRightHeader = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader.headers.reduce((sum2, header) => {
          return sum2 + header.getSize();
        }, 0)) != null ? _a2 : 0;
      }
    };
  }
};
let passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean")
    return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {
    };
    window.addEventListener("test", noop, options);
    window.removeEventListener("test", noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e3) {
  return e3.type === "touchstart";
}
const Expanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    return {
      _autoResetExpanded: () => {
        var _a2, _b;
        if (!registered) {
          table._queue(() => {
            registered = true;
          });
          return;
        }
        if ((_b = (_a2 = table.options.autoResetAll) != null ? _a2 : table.options.autoResetExpanded) != null ? _b : !table.options.manualExpanding) {
          if (queued)
            return;
          queued = true;
          table._queue(() => {
            table.resetExpanded();
            queued = false;
          });
        }
      },
      setExpanded: (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater),
      toggleAllRowsExpanded: (expanded) => {
        if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
          table.setExpanded(true);
        } else {
          table.setExpanded({});
        }
      },
      resetExpanded: (defaultState) => {
        var _a2;
        var _table$initialState;
        table.setExpanded(defaultState ? {} : (_a2 = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _a2 : {});
      },
      getCanSomeRowsExpand: () => {
        return table.getRowModel().flatRows.some((row) => row.getCanExpand());
      },
      getToggleAllRowsExpandedHandler: () => {
        return (e3) => {
          e3.persist == null ? void 0 : e3.persist();
          table.toggleAllRowsExpanded();
        };
      },
      getIsSomeRowsExpanded: () => {
        const expanded = table.getState().expanded;
        return expanded === true || Object.values(expanded).some(Boolean);
      },
      getIsAllRowsExpanded: () => {
        const expanded = table.getState().expanded;
        if (typeof expanded === "boolean") {
          return expanded === true;
        }
        if (!Object.keys(expanded).length) {
          return false;
        }
        if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
          return false;
        }
        return true;
      },
      getExpandedDepth: () => {
        let maxDepth = 0;
        const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
        rowIds.forEach((id2) => {
          const splitId = id2.split(".");
          maxDepth = Math.max(maxDepth, splitId.length);
        });
        return maxDepth;
      },
      getPreExpandedRowModel: () => table.getSortedRowModel(),
      getExpandedRowModel: () => {
        if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
          table._getExpandedRowModel = table.options.getExpandedRowModel(table);
        }
        if (table.options.manualExpanding || !table._getExpandedRowModel) {
          return table.getPreExpandedRowModel();
        }
        return table._getExpandedRowModel();
      }
    };
  },
  createRow: (row, table) => {
    return {
      toggleExpanded: (expanded) => {
        table.setExpanded((old) => {
          const exists2 = old === true ? true : !!(old != null && old[row.id]);
          let oldExpanded = {};
          if (old === true) {
            Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
              oldExpanded[rowId] = true;
            });
          } else {
            oldExpanded = old;
          }
          expanded = expanded != null ? expanded : !exists2;
          if (!exists2 && expanded) {
            return {
              ...oldExpanded,
              [row.id]: true
            };
          }
          if (exists2 && !expanded) {
            const {
              [row.id]: _2,
              ...rest
            } = oldExpanded;
            return rest;
          }
          return old;
        });
      },
      getIsExpanded: () => {
        var _a2;
        const expanded = table.getState().expanded;
        return !!((_a2 = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _a2 : expanded === true || expanded != null && expanded[row.id]);
      },
      getCanExpand: () => {
        var _a2, _b;
        var _row$subRows;
        return (_b = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _b : ((_a2 = table.options.enableExpanding) != null ? _a2 : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
      },
      getToggleExpandedHandler: () => {
        const canExpand = row.getCanExpand();
        return () => {
          if (!canExpand)
            return;
          row.toggleExpanded();
        };
      }
    };
  }
};
const includesString = (row, columnId, filterValue) => {
  var _row$getValue;
  const search = filterValue.toLowerCase();
  return (_row$getValue = row.getValue(columnId)) == null ? void 0 : _row$getValue.toLowerCase().includes(search);
};
includesString.autoRemove = (val) => testFalsey(val);
const includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return (_row$getValue2 = row.getValue(columnId)) == null ? void 0 : _row$getValue2.includes(filterValue);
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
const equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null ? void 0 : _row$getValue3.toLowerCase()) === filterValue.toLowerCase();
};
equalsString.autoRemove = (val) => testFalsey(val);
const arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
const weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
const inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
const filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
const Filters = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      globalFilter: void 0,
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      filterFromLeafRows: false,
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode, _table$getCoreRowMode2;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null ? void 0 : (_table$getCoreRowMode2 = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode2.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    return {
      getAutoFilterFn: () => {
        const firstRow = table.getCoreRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "string") {
          return filterFns.includesString;
        }
        if (typeof value === "number") {
          return filterFns.inNumberRange;
        }
        if (typeof value === "boolean") {
          return filterFns.equals;
        }
        if (value !== null && typeof value === "object") {
          return filterFns.equals;
        }
        if (Array.isArray(value)) {
          return filterFns.arrIncludes;
        }
        return filterFns.weakEquals;
      },
      getFilterFn: () => {
        var _a2;
        var _table$options$filter;
        return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (_a2 = (_table$options$filter = table.options.filterFns) == null ? void 0 : _table$options$filter[column.columnDef.filterFn]) != null ? _a2 : filterFns[column.columnDef.filterFn];
      },
      getCanFilter: () => {
        var _a2, _b, _c;
        return ((_a2 = column.columnDef.enableColumnFilter) != null ? _a2 : true) && ((_b = table.options.enableColumnFilters) != null ? _b : true) && ((_c = table.options.enableFilters) != null ? _c : true) && !!column.accessorFn;
      },
      getCanGlobalFilter: () => {
        var _a2, _b, _c, _d;
        return ((_a2 = column.columnDef.enableGlobalFilter) != null ? _a2 : true) && ((_b = table.options.enableGlobalFilter) != null ? _b : true) && ((_c = table.options.enableFilters) != null ? _c : true) && ((_d = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _d : true) && !!column.accessorFn;
      },
      getIsFiltered: () => column.getFilterIndex() > -1,
      getFilterValue: () => {
        var _table$getState$colum, _table$getState$colum2;
        return (_table$getState$colum = table.getState().columnFilters) == null ? void 0 : (_table$getState$colum2 = _table$getState$colum.find((d2) => d2.id === column.id)) == null ? void 0 : _table$getState$colum2.value;
      },
      getFilterIndex: () => {
        var _a2;
        var _table$getState$colum3;
        return (_a2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d2) => d2.id === column.id)) != null ? _a2 : -1;
      },
      setFilterValue: (value) => {
        table.setColumnFilters((old) => {
          var _a2, _b;
          const filterFn = column.getFilterFn();
          const previousfilter = old == null ? void 0 : old.find((d2) => d2.id === column.id);
          const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : void 0);
          if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
            return (_a2 = old == null ? void 0 : old.filter((d2) => d2.id !== column.id)) != null ? _a2 : [];
          }
          const newFilterObj = {
            id: column.id,
            value: newFilter
          };
          if (previousfilter) {
            return (_b = old == null ? void 0 : old.map((d2) => {
              if (d2.id === column.id) {
                return newFilterObj;
              }
              return d2;
            })) != null ? _b : [];
          }
          if (old != null && old.length) {
            return [...old, newFilterObj];
          }
          return [newFilterObj];
        });
      },
      _getFacetedRowModel: table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id),
      getFacetedRowModel: () => {
        if (!column._getFacetedRowModel) {
          return table.getPreFilteredRowModel();
        }
        return column._getFacetedRowModel();
      },
      _getFacetedUniqueValues: table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id),
      getFacetedUniqueValues: () => {
        if (!column._getFacetedUniqueValues) {
          return /* @__PURE__ */ new Map();
        }
        return column._getFacetedUniqueValues();
      },
      _getFacetedMinMaxValues: table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id),
      getFacetedMinMaxValues: () => {
        if (!column._getFacetedMinMaxValues) {
          return void 0;
        }
        return column._getFacetedMinMaxValues();
      }
    };
  },
  createRow: (row, table) => {
    return {
      columnFilters: {},
      columnFiltersMeta: {}
    };
  },
  createTable: (table) => {
    return {
      getGlobalAutoFilterFn: () => {
        return filterFns.includesString;
      },
      getGlobalFilterFn: () => {
        var _a2;
        var _table$options$filter2;
        const {
          globalFilterFn
        } = table.options;
        return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_a2 = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _a2 : filterFns[globalFilterFn];
      },
      setColumnFilters: (updater) => {
        const leafColumns = table.getAllLeafColumns();
        const updateFn = (old) => {
          var _functionalUpdate;
          return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter2) => {
            const column = leafColumns.find((d2) => d2.id === filter2.id);
            if (column) {
              const filterFn = column.getFilterFn();
              if (shouldAutoRemoveFilter(filterFn, filter2.value, column)) {
                return false;
              }
            }
            return true;
          });
        };
        table.options.onColumnFiltersChange == null ? void 0 : table.options.onColumnFiltersChange(updateFn);
      },
      setGlobalFilter: (updater) => {
        table.options.onGlobalFilterChange == null ? void 0 : table.options.onGlobalFilterChange(updater);
      },
      resetGlobalFilter: (defaultState) => {
        table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
      },
      resetColumnFilters: (defaultState) => {
        var _a2;
        var _table$initialState;
        table.setColumnFilters(defaultState ? [] : (_a2 = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _a2 : []);
      },
      getPreFilteredRowModel: () => table.getCoreRowModel(),
      getFilteredRowModel: () => {
        if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
          table._getFilteredRowModel = table.options.getFilteredRowModel(table);
        }
        if (table.options.manualFiltering || !table._getFilteredRowModel) {
          return table.getPreFilteredRowModel();
        }
        return table._getFilteredRowModel();
      },
      _getGlobalFacetedRowModel: table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__"),
      getGlobalFacetedRowModel: () => {
        if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
          return table.getPreFilteredRowModel();
        }
        return table._getGlobalFacetedRowModel();
      },
      _getGlobalFacetedUniqueValues: table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__"),
      getGlobalFacetedUniqueValues: () => {
        if (!table._getGlobalFacetedUniqueValues) {
          return /* @__PURE__ */ new Map();
        }
        return table._getGlobalFacetedUniqueValues();
      },
      _getGlobalFacetedMinMaxValues: table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__"),
      getGlobalFacetedMinMaxValues: () => {
        if (!table._getGlobalFacetedMinMaxValues) {
          return;
        }
        return table._getGlobalFacetedMinMaxValues();
      }
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
const sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
const min$2 = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
      min2 = value;
    }
  });
  return min2;
};
const max$2 = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
      max2 = value;
    }
  });
  return max2;
};
const extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min2 === void 0) {
        if (value >= value)
          min2 = max2 = value;
      } else {
        if (min2 > value)
          min2 = value;
        if (max2 < value)
          max2 = value;
      }
    }
  });
  return [min2, max2];
};
const mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum2 += value;
    }
  });
  if (count2)
    return sum2 / count2;
  return;
};
const median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  let min2 = 0;
  let max2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (typeof value === "number") {
      min2 = Math.min(min2, value);
      max2 = Math.max(max2, value);
    }
  });
  return (min2 + max2) / 2;
};
const unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d2) => d2.getValue(columnId))).values());
};
const uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d2) => d2.getValue(columnId))).size;
};
const count$1 = (_columnId, leafRows) => {
  return leafRows.length;
};
const aggregationFns = {
  sum,
  min: min$2,
  max: max$2,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count: count$1
};
const Grouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _a2;
        var _props$getValue;
        return (_a2 = (_props$getValue = props.getValue()) == null ? void 0 : _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _a2 : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    return {
      toggleGrouping: () => {
        table.setGrouping((old) => {
          if (old != null && old.includes(column.id)) {
            return old.filter((d2) => d2 !== column.id);
          }
          return [...old != null ? old : [], column.id];
        });
      },
      getCanGroup: () => {
        var _a2, _b, _c, _d;
        return (_d = (_c = (_b = (_a2 = column.columnDef.enableGrouping) != null ? _a2 : true) != null ? _b : table.options.enableGrouping) != null ? _c : true) != null ? _d : !!column.accessorFn;
      },
      getIsGrouped: () => {
        var _table$getState$group;
        return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
      },
      getGroupedIndex: () => {
        var _table$getState$group2;
        return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
      },
      getToggleGroupingHandler: () => {
        const canGroup = column.getCanGroup();
        return () => {
          if (!canGroup)
            return;
          column.toggleGrouping();
        };
      },
      getAutoAggregationFn: () => {
        const firstRow = table.getCoreRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "number") {
          return aggregationFns.sum;
        }
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return aggregationFns.extent;
        }
      },
      getAggregationFn: () => {
        var _a2;
        var _table$options$aggreg;
        if (!column) {
          throw new Error();
        }
        return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_a2 = (_table$options$aggreg = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg[column.columnDef.aggregationFn]) != null ? _a2 : aggregationFns[column.columnDef.aggregationFn];
      }
    };
  },
  createTable: (table) => {
    return {
      setGrouping: (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater),
      resetGrouping: (defaultState) => {
        var _a2;
        var _table$initialState;
        table.setGrouping(defaultState ? [] : (_a2 = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _a2 : []);
      },
      getPreGroupedRowModel: () => table.getFilteredRowModel(),
      getGroupedRowModel: () => {
        if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
          table._getGroupedRowModel = table.options.getGroupedRowModel(table);
        }
        if (table.options.manualGrouping || !table._getGroupedRowModel) {
          return table.getPreGroupedRowModel();
        }
        return table._getGroupedRowModel();
      }
    };
  },
  createRow: (row) => {
    return {
      getIsGrouped: () => !!row.groupingColumnId,
      _groupingValuesCache: {}
    };
  },
  createCell: (cell, column, row, table) => {
    return {
      getIsGrouped: () => column.getIsGrouped() && column.id === row.groupingColumnId,
      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),
      getIsAggregated: () => {
        var _row$subRows;
        return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
      }
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g) => leafColumns.find((col) => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
const Ordering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createTable: (table) => {
    return {
      setColumnOrder: (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater),
      resetColumnOrder: (defaultState) => {
        var _a2;
        table.setColumnOrder(defaultState ? [] : (_a2 = table.initialState.columnOrder) != null ? _a2 : []);
      },
      _getOrderColumnsFn: memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
        let orderedColumns = [];
        if (!(columnOrder != null && columnOrder.length)) {
          orderedColumns = columns;
        } else {
          const columnOrderCopy = [...columnOrder];
          const columnsCopy = [...columns];
          while (columnsCopy.length && columnOrderCopy.length) {
            const targetColumnId = columnOrderCopy.shift();
            const foundIndex = columnsCopy.findIndex((d2) => d2.id === targetColumnId);
            if (foundIndex > -1) {
              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
            }
          }
          orderedColumns = [...orderedColumns, ...columnsCopy];
        }
        return orderColumns(orderedColumns, grouping, groupedColumnMode);
      }, {
        key: false
      })
    };
  }
};
const defaultPageIndex = 0;
const defaultPageSize = 10;
const getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
const Pagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? void 0 : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    return {
      _autoResetPageIndex: () => {
        var _a2, _b;
        if (!registered) {
          table._queue(() => {
            registered = true;
          });
          return;
        }
        if ((_b = (_a2 = table.options.autoResetAll) != null ? _a2 : table.options.autoResetPageIndex) != null ? _b : !table.options.manualPagination) {
          if (queued)
            return;
          queued = true;
          table._queue(() => {
            table.resetPageIndex();
            queued = false;
          });
        }
      },
      setPagination: (updater) => {
        const safeUpdater = (old) => {
          let newState = functionalUpdate(updater, old);
          return newState;
        };
        return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
      },
      resetPagination: (defaultState) => {
        var _a2;
        table.setPagination(defaultState ? getDefaultPaginationState() : (_a2 = table.initialState.pagination) != null ? _a2 : getDefaultPaginationState());
      },
      setPageIndex: (updater) => {
        table.setPagination((old) => {
          let pageIndex = functionalUpdate(updater, old.pageIndex);
          const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
          pageIndex = Math.min(Math.max(0, pageIndex), maxPageIndex);
          return {
            ...old,
            pageIndex
          };
        });
      },
      resetPageIndex: (defaultState) => {
        var _a2;
        var _table$initialState, _table$initialState$p;
        table.setPageIndex(defaultState ? defaultPageIndex : (_a2 = (_table$initialState = table.initialState) == null ? void 0 : (_table$initialState$p = _table$initialState.pagination) == null ? void 0 : _table$initialState$p.pageIndex) != null ? _a2 : defaultPageIndex);
      },
      resetPageSize: (defaultState) => {
        var _a2;
        var _table$initialState2, _table$initialState2$;
        table.setPageSize(defaultState ? defaultPageSize : (_a2 = (_table$initialState2 = table.initialState) == null ? void 0 : (_table$initialState2$ = _table$initialState2.pagination) == null ? void 0 : _table$initialState2$.pageSize) != null ? _a2 : defaultPageSize);
      },
      setPageSize: (updater) => {
        table.setPagination((old) => {
          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
          const topRowIndex = old.pageSize * old.pageIndex;
          const pageIndex = Math.floor(topRowIndex / pageSize);
          return {
            ...old,
            pageIndex,
            pageSize
          };
        });
      },
      setPageCount: (updater) => table.setPagination((old) => {
        var _a2;
        let newPageCount = functionalUpdate(updater, (_a2 = table.options.pageCount) != null ? _a2 : -1);
        if (typeof newPageCount === "number") {
          newPageCount = Math.max(-1, newPageCount);
        }
        return {
          ...old,
          pageCount: newPageCount
        };
      }),
      getPageOptions: memo(() => [table.getPageCount()], (pageCount) => {
        let pageOptions = [];
        if (pageCount && pageCount > 0) {
          pageOptions = [...new Array(pageCount)].fill(null).map((_2, i2) => i2);
        }
        return pageOptions;
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugTable;
        }
      }),
      getCanPreviousPage: () => table.getState().pagination.pageIndex > 0,
      getCanNextPage: () => {
        const {
          pageIndex
        } = table.getState().pagination;
        const pageCount = table.getPageCount();
        if (pageCount === -1) {
          return true;
        }
        if (pageCount === 0) {
          return false;
        }
        return pageIndex < pageCount - 1;
      },
      previousPage: () => {
        return table.setPageIndex((old) => old - 1);
      },
      nextPage: () => {
        return table.setPageIndex((old) => {
          return old + 1;
        });
      },
      getPrePaginationRowModel: () => table.getExpandedRowModel(),
      getPaginationRowModel: () => {
        if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
          table._getPaginationRowModel = table.options.getPaginationRowModel(table);
        }
        if (table.options.manualPagination || !table._getPaginationRowModel) {
          return table.getPrePaginationRowModel();
        }
        return table._getPaginationRowModel();
      },
      getPageCount: () => {
        var _a2;
        return (_a2 = table.options.pageCount) != null ? _a2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);
      }
    };
  }
};
const getDefaultPinningState = () => ({
  left: [],
  right: []
});
const Pinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    return {
      pin: (position) => {
        const columnIds = column.getLeafColumns().map((d2) => d2.id).filter(Boolean);
        table.setColumnPinning((old) => {
          var _a2, _b, _c, _d, _e2, _f;
          if (position === "right") {
            return {
              left: ((_a2 = old == null ? void 0 : old.left) != null ? _a2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
              right: [...((_b = old == null ? void 0 : old.right) != null ? _b : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds]
            };
          }
          if (position === "left") {
            return {
              left: [...((_c = old == null ? void 0 : old.left) != null ? _c : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds],
              right: ((_d = old == null ? void 0 : old.right) != null ? _d : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
            };
          }
          return {
            left: ((_e2 = old == null ? void 0 : old.left) != null ? _e2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
            right: ((_f = old == null ? void 0 : old.right) != null ? _f : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
          };
        });
      },
      getCanPin: () => {
        const leafColumns = column.getLeafColumns();
        return leafColumns.some((d2) => {
          var _a2, _b;
          return ((_a2 = d2.columnDef.enablePinning) != null ? _a2 : true) && ((_b = table.options.enablePinning) != null ? _b : true);
        });
      },
      getIsPinned: () => {
        const leafColumnIds = column.getLeafColumns().map((d2) => d2.id);
        const {
          left,
          right
        } = table.getState().columnPinning;
        const isLeft = leafColumnIds.some((d2) => left == null ? void 0 : left.includes(d2));
        const isRight = leafColumnIds.some((d2) => right == null ? void 0 : right.includes(d2));
        return isLeft ? "left" : isRight ? "right" : false;
      },
      getPinnedIndex: () => {
        var _a2;
        var _table$getState$colum, _table$getState$colum2;
        const position = column.getIsPinned();
        return position ? (_a2 = (_table$getState$colum = table.getState().columnPinning) == null ? void 0 : (_table$getState$colum2 = _table$getState$colum[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _a2 : -1 : 0;
      }
    };
  },
  createRow: (row, table) => {
    return {
      getCenterVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
        const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
        return allCells.filter((d2) => !leftAndRight.includes(d2.column.id));
      }, {
        key: "row.getCenterVisibleCells",
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugRows;
        }
      }),
      getLeftVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, ,], (allCells, left) => {
        const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
          ...d2,
          position: "left"
        }));
        return cells;
      }, {
        key: "row.getLeftVisibleCells",
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugRows;
        }
      }),
      getRightVisibleCells: memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
        const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
          ...d2,
          position: "right"
        }));
        return cells;
      }, {
        key: "row.getRightVisibleCells",
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugRows;
        }
      })
    };
  },
  createTable: (table) => {
    return {
      setColumnPinning: (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater),
      resetColumnPinning: (defaultState) => {
        var _a2;
        var _table$initialState;
        return table.setColumnPinning(defaultState ? getDefaultPinningState() : (_a2 = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _a2 : getDefaultPinningState());
      },
      getIsSomeColumnsPinned: (position) => {
        var _pinningState$positio;
        const pinningState = table.getState().columnPinning;
        if (!position) {
          var _pinningState$left, _pinningState$right;
          return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
        }
        return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
      },
      getLeftLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
        return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
        }
      }),
      getRightLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
        return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
        }
      }),
      getCenterLeafColumns: memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
        const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
        return allColumns.filter((d2) => !leftAndRight.includes(d2.id));
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
        }
      })
    };
  }
};
const RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
    };
  },
  createTable: (table) => {
    return {
      setRowSelection: (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater),
      resetRowSelection: (defaultState) => {
        var _a2;
        return table.setRowSelection(defaultState ? {} : (_a2 = table.initialState.rowSelection) != null ? _a2 : {});
      },
      toggleAllRowsSelected: (value) => {
        table.setRowSelection((old) => {
          value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
          const rowSelection = {
            ...old
          };
          const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
          if (value) {
            preGroupedFlatRows.forEach((row) => {
              if (!row.getCanSelect()) {
                return;
              }
              rowSelection[row.id] = true;
            });
          } else {
            preGroupedFlatRows.forEach((row) => {
              delete rowSelection[row.id];
            });
          }
          return rowSelection;
        });
      },
      toggleAllPageRowsSelected: (value) => table.setRowSelection((old) => {
        const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
        const rowSelection = {
          ...old
        };
        table.getRowModel().rows.forEach((row) => {
          mutateRowIsSelected(rowSelection, row.id, resolvedValue, table);
        });
        return rowSelection;
      }),
      getPreSelectedRowModel: () => table.getCoreRowModel(),
      getSelectedRowModel: memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugTable;
        }
      }),
      getFilteredSelectedRowModel: memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: "getFilteredSelectedRowModel",
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugTable;
        }
      }),
      getGroupedSelectedRowModel: memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
        if (!Object.keys(rowSelection).length) {
          return {
            rows: [],
            flatRows: [],
            rowsById: {}
          };
        }
        return selectRowsFn(table, rowModel);
      }, {
        key: "getGroupedSelectedRowModel",
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugTable;
        }
      }),
      getIsAllRowsSelected: () => {
        const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
        const {
          rowSelection
        } = table.getState();
        let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
        if (isAllRowsSelected) {
          if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
            isAllRowsSelected = false;
          }
        }
        return isAllRowsSelected;
      },
      getIsAllPageRowsSelected: () => {
        const paginationFlatRows = table.getPaginationRowModel().flatRows;
        const {
          rowSelection
        } = table.getState();
        let isAllPageRowsSelected = !!paginationFlatRows.length;
        if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
          isAllPageRowsSelected = false;
        }
        return isAllPageRowsSelected;
      },
      getIsSomeRowsSelected: () => {
        var _a2;
        const totalSelected = Object.keys((_a2 = table.getState().rowSelection) != null ? _a2 : {}).length;
        return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
      },
      getIsSomePageRowsSelected: () => {
        const paginationFlatRows = table.getPaginationRowModel().flatRows;
        return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.some((d2) => d2.getIsSelected() || d2.getIsSomeSelected());
      },
      getToggleAllRowsSelectedHandler: () => {
        return (e3) => {
          table.toggleAllRowsSelected(e3.target.checked);
        };
      },
      getToggleAllPageRowsSelectedHandler: () => {
        return (e3) => {
          table.toggleAllPageRowsSelected(e3.target.checked);
        };
      }
    };
  },
  createRow: (row, table) => {
    return {
      toggleSelected: (value) => {
        const isSelected = row.getIsSelected();
        table.setRowSelection((old) => {
          value = typeof value !== "undefined" ? value : !isSelected;
          if (isSelected === value) {
            return old;
          }
          const selectedRowIds = {
            ...old
          };
          mutateRowIsSelected(selectedRowIds, row.id, value, table);
          return selectedRowIds;
        });
      },
      getIsSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isRowSelected(row, rowSelection);
      },
      getIsSomeSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isSubRowSelected(row, rowSelection) === "some";
      },
      getIsAllSubRowsSelected: () => {
        const {
          rowSelection
        } = table.getState();
        return isSubRowSelected(row, rowSelection) === "all";
      },
      getCanSelect: () => {
        var _a2;
        if (typeof table.options.enableRowSelection === "function") {
          return table.options.enableRowSelection(row);
        }
        return (_a2 = table.options.enableRowSelection) != null ? _a2 : true;
      },
      getCanSelectSubRows: () => {
        var _a2;
        if (typeof table.options.enableSubRowSelection === "function") {
          return table.options.enableSubRowSelection(row);
        }
        return (_a2 = table.options.enableSubRowSelection) != null ? _a2 : true;
      },
      getCanMultiSelect: () => {
        var _a2;
        if (typeof table.options.enableMultiRowSelection === "function") {
          return table.options.enableMultiRowSelection(row);
        }
        return (_a2 = table.options.enableMultiRowSelection) != null ? _a2 : true;
      },
      getToggleSelectedHandler: () => {
        const canSelect = row.getCanSelect();
        return (e3) => {
          var _target;
          if (!canSelect)
            return;
          row.toggleSelected((_target = e3.target) == null ? void 0 : _target.checked);
        };
      }
    };
  }
};
const mutateRowIsSelected = (selectedRowIds, id2, value, table) => {
  var _row$subRows;
  const row = table.getRow(id2);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id2] = true;
    }
  } else {
    delete selectedRowIds[id2];
  }
  if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _a2;
  return (_a2 = selection[row.id]) != null ? _a2 : false;
}
function isSubRowSelected(row, selection, table) {
  if (row.subRows && row.subRows.length) {
    let allChildrenSelected = true;
    let someSelected = false;
    row.subRows.forEach((subRow) => {
      if (someSelected && !allChildrenSelected) {
        return;
      }
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    });
    return allChildrenSelected ? "all" : someSelected ? "some" : false;
  }
  return false;
}
const reSplitAlphaNumeric = /([0-9]+)/gm;
const alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString$2(rowA.getValue(columnId)).toLowerCase(), toString$2(rowB.getValue(columnId)).toLowerCase());
};
const alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString$2(rowA.getValue(columnId)), toString$2(rowB.getValue(columnId)));
};
const text = (rowA, rowB, columnId) => {
  return compareBasic(toString$2(rowA.getValue(columnId)).toLowerCase(), toString$2(rowB.getValue(columnId)).toLowerCase());
};
const textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString$2(rowA.getValue(columnId)), toString$2(rowB.getValue(columnId)));
};
const datetime = (rowA, rowB, columnId) => {
  const a2 = rowA.getValue(columnId);
  const b2 = rowB.getValue(columnId);
  return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
};
const basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a2, b2) {
  return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;
}
function toString$2(a2) {
  if (typeof a2 === "number") {
    if (isNaN(a2) || a2 === Infinity || a2 === -Infinity) {
      return "";
    }
    return String(a2);
  }
  if (typeof a2 === "string") {
    return a2;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a2 = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b2 = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a2.length && b2.length) {
    const aa2 = a2.shift();
    const bb2 = b2.shift();
    const an = parseInt(aa2, 10);
    const bn = parseInt(bb2, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa2 > bb2) {
        return 1;
      }
      if (bb2 > aa2) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a2.length - b2.length;
}
const sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
const Sorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto"
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e3) => {
        return e3.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    return {
      getAutoSortingFn: () => {
        const firstRows = table.getFilteredRowModel().flatRows.slice(10);
        let isString2 = false;
        for (const row of firstRows) {
          const value = row == null ? void 0 : row.getValue(column.id);
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return sortingFns.datetime;
          }
          if (typeof value === "string") {
            isString2 = true;
            if (value.split(reSplitAlphaNumeric).length > 1) {
              return sortingFns.alphanumeric;
            }
          }
        }
        if (isString2) {
          return sortingFns.text;
        }
        return sortingFns.basic;
      },
      getAutoSortDir: () => {
        const firstRow = table.getFilteredRowModel().flatRows[0];
        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
        if (typeof value === "string") {
          return "asc";
        }
        return "desc";
      },
      getSortingFn: () => {
        var _a2;
        var _table$options$sortin;
        if (!column) {
          throw new Error();
        }
        return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_a2 = (_table$options$sortin = table.options.sortingFns) == null ? void 0 : _table$options$sortin[column.columnDef.sortingFn]) != null ? _a2 : sortingFns[column.columnDef.sortingFn];
      },
      toggleSorting: (desc, multi) => {
        const nextSortingOrder = column.getNextSortingOrder();
        const hasManualValue = typeof desc !== "undefined" && desc !== null;
        table.setSorting((old) => {
          var _a2;
          const existingSorting = old == null ? void 0 : old.find((d2) => d2.id === column.id);
          const existingIndex = old == null ? void 0 : old.findIndex((d2) => d2.id === column.id);
          let newSorting = [];
          let sortAction;
          let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
          if (old != null && old.length && column.getCanMultiSort() && multi) {
            if (existingSorting) {
              sortAction = "toggle";
            } else {
              sortAction = "add";
            }
          } else {
            if (old != null && old.length && existingIndex !== old.length - 1) {
              sortAction = "replace";
            } else if (existingSorting) {
              sortAction = "toggle";
            } else {
              sortAction = "replace";
            }
          }
          if (sortAction === "toggle") {
            if (!hasManualValue) {
              if (!nextSortingOrder) {
                sortAction = "remove";
              }
            }
          }
          if (sortAction === "add") {
            newSorting = [...old, {
              id: column.id,
              desc: nextDesc
            }];
            newSorting.splice(0, newSorting.length - ((_a2 = table.options.maxMultiSortColCount) != null ? _a2 : Number.MAX_SAFE_INTEGER));
          } else if (sortAction === "toggle") {
            newSorting = old.map((d2) => {
              if (d2.id === column.id) {
                return {
                  ...d2,
                  desc: nextDesc
                };
              }
              return d2;
            });
          } else if (sortAction === "remove") {
            newSorting = old.filter((d2) => d2.id !== column.id);
          } else {
            newSorting = [{
              id: column.id,
              desc: nextDesc
            }];
          }
          return newSorting;
        });
      },
      getFirstSortDir: () => {
        var _a2, _b;
        const sortDescFirst = (_b = (_a2 = column.columnDef.sortDescFirst) != null ? _a2 : table.options.sortDescFirst) != null ? _b : column.getAutoSortDir() === "desc";
        return sortDescFirst ? "desc" : "asc";
      },
      getNextSortingOrder: (multi) => {
        var _a2, _b;
        const firstSortDirection = column.getFirstSortDir();
        const isSorted = column.getIsSorted();
        if (!isSorted) {
          return firstSortDirection;
        }
        if (isSorted !== firstSortDirection && ((_a2 = table.options.enableSortingRemoval) != null ? _a2 : true) && (multi ? (_b = table.options.enableMultiRemove) != null ? _b : true : true)) {
          return false;
        }
        return isSorted === "desc" ? "asc" : "desc";
      },
      getCanSort: () => {
        var _a2, _b;
        return ((_a2 = column.columnDef.enableSorting) != null ? _a2 : true) && ((_b = table.options.enableSorting) != null ? _b : true) && !!column.accessorFn;
      },
      getCanMultiSort: () => {
        var _a2, _b;
        return (_b = (_a2 = column.columnDef.enableMultiSort) != null ? _a2 : table.options.enableMultiSort) != null ? _b : !!column.accessorFn;
      },
      getIsSorted: () => {
        var _table$getState$sorti;
        const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d2) => d2.id === column.id);
        return !columnSort ? false : columnSort.desc ? "desc" : "asc";
      },
      getSortIndex: () => {
        var _a2;
        var _table$getState$sorti2;
        return (_a2 = (_table$getState$sorti2 = table.getState().sorting) == null ? void 0 : _table$getState$sorti2.findIndex((d2) => d2.id === column.id)) != null ? _a2 : -1;
      },
      clearSorting: () => {
        table.setSorting((old) => old != null && old.length ? old.filter((d2) => d2.id !== column.id) : []);
      },
      getToggleSortingHandler: () => {
        const canSort = column.getCanSort();
        return (e3) => {
          if (!canSort)
            return;
          e3.persist == null ? void 0 : e3.persist();
          column.toggleSorting == null ? void 0 : column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e3) : false);
        };
      }
    };
  },
  createTable: (table) => {
    return {
      setSorting: (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater),
      resetSorting: (defaultState) => {
        var _a2;
        var _table$initialState;
        table.setSorting(defaultState ? [] : (_a2 = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _a2 : []);
      },
      getPreSortedRowModel: () => table.getGroupedRowModel(),
      getSortedRowModel: () => {
        if (!table._getSortedRowModel && table.options.getSortedRowModel) {
          table._getSortedRowModel = table.options.getSortedRowModel(table);
        }
        if (table.options.manualSorting || !table._getSortedRowModel) {
          return table.getPreSortedRowModel();
        }
        return table._getSortedRowModel();
      }
    };
  }
};
const Visibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    return {
      toggleVisibility: (value) => {
        if (column.getCanHide()) {
          table.setColumnVisibility((old) => ({
            ...old,
            [column.id]: value != null ? value : !column.getIsVisible()
          }));
        }
      },
      getIsVisible: () => {
        var _a2;
        var _table$getState$colum;
        return (_a2 = (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _a2 : true;
      },
      getCanHide: () => {
        var _a2, _b;
        return ((_a2 = column.columnDef.enableHiding) != null ? _a2 : true) && ((_b = table.options.enableHiding) != null ? _b : true);
      },
      getToggleVisibilityHandler: () => {
        return (e3) => {
          column.toggleVisibility == null ? void 0 : column.toggleVisibility(e3.target.checked);
        };
      }
    };
  },
  createRow: (row, table) => {
    return {
      _getAllVisibleCells: memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
        return cells.filter((cell) => cell.column.getIsVisible());
      }, {
        key: "row._getAllVisibleCells",
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugRows;
        }
      }),
      getVisibleCells: memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], {
        key: false,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugRows;
        }
      })
    };
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d2) => d2.getIsVisible()).map((d2) => d2.id).join("_")], (columns) => {
        return columns.filter((d2) => d2.getIsVisible == null ? void 0 : d2.getIsVisible());
      }, {
        key,
        debug: () => {
          var _a2;
          return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugColumns;
        }
      });
    };
    return {
      getVisibleFlatColumns: makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns()),
      getVisibleLeafColumns: makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns()),
      getLeftVisibleLeafColumns: makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns()),
      getRightVisibleLeafColumns: makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns()),
      getCenterVisibleLeafColumns: makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns()),
      setColumnVisibility: (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater),
      resetColumnVisibility: (defaultState) => {
        var _a2;
        table.setColumnVisibility(defaultState ? {} : (_a2 = table.initialState.columnVisibility) != null ? _a2 : {});
      },
      toggleAllColumnsVisible: (value) => {
        value = value != null ? value : !table.getIsAllColumnsVisible();
        table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
          ...obj,
          [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
        }), {}));
      },
      getIsAllColumnsVisible: () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible())),
      getIsSomeColumnsVisible: () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible()),
      getToggleAllColumnsVisibilityHandler: () => {
        return (e3) => {
          var _target;
          table.toggleAllColumnsVisible((_target = e3.target) == null ? void 0 : _target.checked);
        };
      }
    };
  }
};
const features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing];
function createTable(options) {
  var _a2;
  if (options.debugAll || options.debugTable) {
    console.info("Creating Table Instance...");
  }
  let table = {
    _features: features
  };
  const defaultOptions2 = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions2 = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions2, options2);
    }
    return {
      ...defaultOptions2,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState2 = {
    ...coreInitialState,
    ...(_a2 = options.initialState) != null ? _a2 : {}
  };
  table._features.forEach((feature) => {
    var _a3;
    initialState2 = (_a3 = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState2)) != null ? _a3 : initialState2;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features: features,
    options: {
      ...defaultOptions2,
      ...options
    },
    initialState: initialState2,
    _queue: (cb2) => {
      queued.push(cb2);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions2(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null ? void 0 : table.options.onStateChange(updater);
    },
    _getRowId: (row, index2, parent) => {
      var _a3;
      return (_a3 = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index2, parent)) != null ? _a3 : `${parent ? [parent.id, index2].join(".") : index2}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    getRow: (id2) => {
      const row = table.getRowModel().rowsById[id2];
      if (!row) {
        throw new Error();
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      defaultColumn = defaultColumn != null ? defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        cell: (props) => {
          var _a3;
          var _props$renderValue;
          return (_a3 = (_props$renderValue = props.renderValue()) == null ? void 0 : _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _a3 : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, {
      debug: () => {
        var _a3;
        return (_a3 = table.options.debugAll) != null ? _a3 : table.options.debugColumns;
      },
      key: false
    }),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, {
      key: false,
      debug: () => {
        var _a3;
        return (_a3 = table.options.debugAll) != null ? _a3 : table.options.debugColumns;
      }
    }),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, {
      key: false,
      debug: () => {
        var _a3;
        return (_a3 = table.options.debugAll) != null ? _a3 : table.options.debugColumns;
      }
    }),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, {
      key: false,
      debug: () => {
        var _a3;
        return (_a3 = table.options.debugAll) != null ? _a3 : table.options.debugColumns;
      }
    }),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, {
      key: false,
      debug: () => {
        var _a3;
        return (_a3 = table.options.debugAll) != null ? _a3 : table.options.debugColumns;
      }
    }),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (!column) {
        throw new Error();
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  table._features.forEach((feature) => {
    return Object.assign(table, feature.createTable == null ? void 0 : feature.createTable(table));
  });
  return table;
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _a2;
    return (_a2 = cell.getValue()) != null ? _a2 : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), {
      key: false,
      debug: () => table.options.debugAll
    })
  };
  table._features.forEach((feature) => {
    Object.assign(cell, feature.createCell == null ? void 0 : feature.createCell(cell, column, row, table));
  }, {});
  return cell;
}
const createRow = (table, id2, original, rowIndex, depth, subRows) => {
  let row = {
    id: id2,
    index: rowIndex,
    original,
    depth,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!column.accessorFn) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!column.accessorFn) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _a2;
      return (_a2 = row.getValue(columnId)) != null ? _a2 : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d2) => d2.subRows),
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, {
      key: false,
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugRows;
      }
    }),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, {
      key: "row.getAllCellsByColumnId",
      debug: () => {
        var _a2;
        return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugRows;
      }
    })
  };
  for (let i2 = 0; i2 < table._features.length; i2++) {
    const feature = table._features[i2];
    Object.assign(row, feature == null ? void 0 : feature.createRow == null ? void 0 : feature.createRow(row, table));
  }
  return row;
};
function createColumnHelper() {
  return {
    accessor: (accessor, column) => {
      return typeof accessor === "function" ? {
        ...column,
        accessorFn: accessor
      } : {
        ...column,
        accessorKey: accessor
      };
    },
    display: (column) => column,
    group: (column) => column
  };
}
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data2) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parent) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i2 = 0; i2 < originalRows.length; i2++) {
        const row = createRow(table, table._getRowId(originalRows[i2], i2, parent), originalRows[i2], i2, depth);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i2], i2);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data2);
    return rowModel;
  }, {
    key: false,
    debug: () => {
      var _a2;
      return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function getSortedRowModel() {
  return (table) => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => table.getColumn(sort.id).getCanSort());
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column = table.getColumn(sortEntry.id);
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = [...rows];
      sortedData.sort((rowA, rowB) => {
        var _a2;
        for (let i2 = 0; i2 < availableSorting.length; i2 += 1) {
          const sortEntry = availableSorting[i2];
          const columnInfo = columnInfoById[sortEntry.id];
          const isDesc = (_a2 = sortEntry == null ? void 0 : sortEntry.desc) != null ? _a2 : false;
          if (columnInfo.sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = typeof aValue === "undefined";
            const bUndefined = typeof bValue === "undefined";
            if (aUndefined || bUndefined) {
              return aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;
            }
          }
          let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        sortedFlatRows.push(row);
        if (!row.subRows || row.subRows.length <= 1) {
          return;
        }
        row.subRows = sortData(row.subRows);
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, {
    key: false,
    debug: () => {
      var _a2;
      return (_a2 = table.options.debugAll) != null ? _a2 : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? /* @__PURE__ */ jsx(Comp, {
    ...props
  }) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    onStateChange: () => {
    },
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = react.exports.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = react.exports.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null ? void 0 : options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}
function ArrowLongRightIcon$2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M2 10a.75.75 0 01.75-.75h12.59l-2.1-1.95a.75.75 0 111.02-1.1l3.5 3.25a.75.75 0 010 1.1l-3.5 3.25a.75.75 0 11-1.02-1.1l2.1-1.95H2.75A.75.75 0 012 10z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$b = react.exports.forwardRef(ArrowLongRightIcon$2);
const ArrowLongRightIcon$3 = ForwardRef$b;
function InformationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$a = react.exports.forwardRef(InformationCircleIcon);
const InformationCircleIcon$1 = ForwardRef$a;
function XMarkIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      d: "M6.28 5.22a.75.75 0 00-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 00-1.06-1.06L10 8.94 6.28 5.22z"
    })]
  });
}
const ForwardRef$9 = react.exports.forwardRef(XMarkIcon);
const XMarkIcon$1 = ForwardRef$9;
var genericMessage = "Invariant Violation";
var _a$3 = Object.setPrototypeOf, setPrototypeOf = _a$3 === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a$3;
var InvariantError = function(_super) {
  __extends(InvariantError2, _super);
  function InvariantError2(message) {
    if (message === void 0) {
      message = genericMessage;
    }
    var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
    _this.framesToPop = 1;
    _this.name = genericMessage;
    setPrototypeOf(_this, InvariantError2.prototype);
    return _this;
  }
  return InvariantError2;
}(Error);
function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name) {
  return function() {
    if (verbosityLevels.indexOf(name) >= verbosityLevel) {
      var method = console[name] || console.log;
      return method.apply(console, arguments);
    }
  };
}
(function(invariant2) {
  invariant2.debug = wrapConsoleMethod("debug");
  invariant2.log = wrapConsoleMethod("log");
  invariant2.warn = wrapConsoleMethod("warn");
  invariant2.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));
function maybe$2(thunk) {
  try {
    return thunk();
  } catch (_a2) {
  }
}
const global$1 = maybe$2(function() {
  return globalThis;
}) || maybe$2(function() {
  return window;
}) || maybe$2(function() {
  return self;
}) || maybe$2(function() {
  return global;
}) || maybe$2(function() {
  return maybe$2.constructor("return this")();
});
var __ = "__";
var GLOBAL_KEY = [__, __].join("DEV");
function getDEV() {
  try {
    return Boolean(__DEV__);
  } catch (_a2) {
    Object.defineProperty(global$1, GLOBAL_KEY, {
      value: maybe$2(function() {
        return "production";
      }) !== "production",
      enumerable: false,
      configurable: true,
      writable: true
    });
    return global$1[GLOBAL_KEY];
  }
}
const DEV = getDEV();
function maybe$1(thunk) {
  try {
    return thunk();
  } catch (_2) {
  }
}
var safeGlobal = maybe$1(function() {
  return globalThis;
}) || maybe$1(function() {
  return window;
}) || maybe$1(function() {
  return self;
}) || maybe$1(function() {
  return global;
}) || maybe$1(function() {
  return maybe$1.constructor("return this")();
});
var needToRemove = false;
function install() {
  if (safeGlobal && !maybe$1(function() {
    return "production";
  }) && !maybe$1(function() {
    return process;
  })) {
    Object.defineProperty(safeGlobal, "process", {
      value: {
        env: {
          NODE_ENV: "production"
        }
      },
      configurable: true,
      enumerable: false,
      writable: true
    });
    needToRemove = true;
  }
}
install();
function remove() {
  if (needToRemove) {
    delete safeGlobal.process;
    needToRemove = false;
  }
}
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode$1(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
function isWhiteSpace$1(code) {
  return code === 9 || code === 32;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace$1(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace$1(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries = Object.entries(object2);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    const name = object2.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK = Object.freeze({});
function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys = [root2];
  let index2 = -1;
  let edits = [];
  let node = root2;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys[index2];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode$1(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode$1(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function print(ast) {
  return visit(ast, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap$1("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap$1(" = ", defaultValue) + wrap$1(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap$1("", alias, ": ") + name;
      let argsLine = prefix + wrap$1("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap$1("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap$1(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap$1("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap$1("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap$1("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap$1("(", join(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap$1("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap$1("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$1("", description, "\n") + join(
      [
        "type",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap$1("", description, "\n") + name + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + ": " + type + wrap$1(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap$1("", description, "\n") + join(
      [name + ": " + type, wrap$1("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$1("", description, "\n") + join(
      [
        "interface",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types: types2 }) => wrap$1("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap$1("= ", join(types2, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap$1("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap$1("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap$1("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap$1("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap$1("(\n", indent(join(args, "\n")), "\n)") : wrap$1("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap$1("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types: types2 }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap$1("= ", join(types2, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray2, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray2 === null || maybeArray2 === void 0 ? void 0 : maybeArray2.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap$1("{\n", indent(join(array, "\n")), "\n}");
}
function wrap$1(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap$1("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray2) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray2 === null || maybeArray2 === void 0 ? void 0 : maybeArray2.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
function removeTemporaryGlobals() {
  return typeof Source === "function" ? remove() : remove();
}
function checkDEV() {
  __DEV__ ? invariant("boolean" === typeof DEV, DEV) : invariant("boolean" === typeof DEV, 38);
}
removeTemporaryGlobals();
checkDEV();
function shouldInclude(_a2, variables) {
  var directives = _a2.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a3) {
    var directive = _a3.directive, ifArgument = _a3.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      __DEV__ ? invariant(evaledValue !== void 0, "Invalid variable referenced in @".concat(directive.name.value, " directive.")) : invariant(evaledValue !== void 0, 39);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function hasDirectives(names2, root2, all) {
  var nameSet = new Set(names2);
  var uniqueCount2 = nameSet.size;
  visit(root2, {
    Directive: function(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount2;
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client", "export"], document2, true);
}
function isInclusionDirective(_a2) {
  var value = _a2.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      __DEV__ ? invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @".concat(directiveName, " directive.")) : invariant(directiveArguments && directiveArguments.length === 1, 40);
      var ifArgument = directiveArguments[0];
      __DEV__ ? invariant(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @".concat(directiveName, " directive.")) : invariant(ifArgument.name && ifArgument.name.value === "if", 41);
      var ifValue = ifArgument.value;
      __DEV__ ? invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @".concat(directiveName, " directive must be a variable or a boolean value.")) : invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 42);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw __DEV__ ? new InvariantError("Found a ".concat(definition.operation, " operation").concat(definition.name ? " named '".concat(definition.name.value, "'") : "", ". ") + "No operations are allowed when using a fragment as a query. Only fragments are allowed.") : new InvariantError(43);
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    __DEV__ ? invariant(fragments.length === 1, "Found ".concat(fragments.length, " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.")) : invariant(fragments.length === 1, 44);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign$1(__assign$1({}, document2), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      __DEV__ ? invariant(fragment, "No fragment named ".concat(fragmentName)) : invariant(fragment, 45);
      return fragment || null;
    }
    default:
      return null;
  }
}
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}
function makeReference(id2) {
  return { __ref: String(id2) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw __DEV__ ? new InvariantError('The inline argument "'.concat(name.value, '" of kind "').concat(value.kind, '"') + "is not supported. Use variables instead of inline arguments to overcome this limitation.") : new InvariantError(54);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export"
];
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(stringify(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = stringify(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(stringify(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s2) {
    var previous = stringify;
    stringify = s2;
    return previous;
  }
});
var stringify = function defaultStringify(value) {
  return JSON.stringify(value, stringifyReplacer);
};
function stringifyReplacer(_key, value) {
  if (isNonNullObject(value) && !Array.isArray(value)) {
    value = Object.keys(value).sort().reduce(function(copy2, key) {
      copy2[key] = value[key];
      return copy2;
    }, {});
  }
  return value;
}
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
    var selection = _a2[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else {
      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}
function checkDocument(doc) {
  __DEV__ ? invariant(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant(doc && doc.kind === "Document", 46);
  var operations = doc.definitions.filter(function(d2) {
    return d2.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw __DEV__ ? new InvariantError('Schema type definitions not allowed in queries. Found: "'.concat(definition.kind, '"')) : new InvariantError(47);
    }
    return definition;
  });
  __DEV__ ? invariant(operations.length <= 1, "Ambiguous GraphQL document: contains ".concat(operations.length, " operations")) : invariant(operations.length <= 1, 48);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && definition.name;
  }).map(function(x2) {
    return x2.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  __DEV__ ? invariant(queryDef && queryDef.operation === "query", "Must contain a query definition.") : invariant(queryDef && queryDef.operation === "query", 49);
  return queryDef;
}
function getFragmentDefinition(doc) {
  __DEV__ ? invariant(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant(doc.kind === "Document", 50);
  __DEV__ ? invariant(doc.definitions.length <= 1, "Fragment must have exactly one definition.") : invariant(doc.definitions.length <= 1, 51);
  var fragmentDef = doc.definitions[0];
  __DEV__ ? invariant(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.") : invariant(fragmentDef.kind === "FragmentDefinition", 52);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
    var definition = _a2[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw __DEV__ ? new InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.") : new InvariantError(53);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
function filterInPlace(array, test2, context) {
  var target = 0;
  array.forEach(function(elem, i2) {
    if (test2.call(this, elem, i2, array)) {
      array[target++] = elem;
    }
  }, context);
  array.length = target;
  return array;
}
var TYPENAME_FIELD = {
  kind: "Field",
  name: {
    kind: "Name",
    value: "__typename"
  }
};
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === "FragmentSpread" && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(directives) {
  return function directiveMatcher(directive) {
    return directives.some(function(dir) {
      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
    });
  };
}
function removeDirectivesFromDocument(directives, doc) {
  var variablesInUse = /* @__PURE__ */ Object.create(null);
  var variablesToRemove = [];
  var fragmentSpreadsInUse = /* @__PURE__ */ Object.create(null);
  var fragmentSpreadsToRemove = [];
  var modifiedDoc = nullIfDocIsEmpty(visit(doc, {
    Variable: {
      enter: function(node, _key, parent) {
        if (parent.kind !== "VariableDefinition") {
          variablesInUse[node.name.value] = true;
        }
      }
    },
    Field: {
      enter: function(node) {
        if (directives && node.directives) {
          var shouldRemoveField = directives.some(function(directive) {
            return directive.remove;
          });
          if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {
            if (node.arguments) {
              node.arguments.forEach(function(arg) {
                if (arg.value.kind === "Variable") {
                  variablesToRemove.push({
                    name: arg.value.name.value
                  });
                }
              });
            }
            if (node.selectionSet) {
              getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function(frag) {
                fragmentSpreadsToRemove.push({
                  name: frag.name.value
                });
              });
            }
            return null;
          }
        }
      }
    },
    FragmentSpread: {
      enter: function(node) {
        fragmentSpreadsInUse[node.name.value] = true;
      }
    },
    Directive: {
      enter: function(node) {
        if (getDirectiveMatcher(directives)(node)) {
          return null;
        }
      }
    }
  }));
  if (modifiedDoc && filterInPlace(variablesToRemove, function(v2) {
    return !!v2.name && !variablesInUse[v2.name];
  }).length) {
    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
  }
  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function(fs) {
    return !!fs.name && !fragmentSpreadsInUse[fs.name];
  }).length) {
    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
  }
  return modifiedDoc;
}
var addTypenameToDocument = Object.assign(function(doc) {
  return visit(doc, {
    SelectionSet: {
      enter: function(node, _key, parent) {
        if (parent && parent.kind === "OperationDefinition") {
          return;
        }
        var selections = node.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d2) {
          return d2.name.value === "export";
        })) {
          return;
        }
        return __assign$1(__assign$1({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
var connectionRemoveConfig = {
  test: function(directive) {
    var willRemove = directive.name.value === "connection";
    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function(arg) {
        return arg.name.value === "key";
      })) {
        __DEV__ && invariant.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key.");
      }
    }
    return willRemove;
  }
};
function removeConnectionDirectiveFromDocument(doc) {
  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function getArgumentMatcher(config) {
  return function argumentMatcher(argument) {
    return config.some(function(aConfig) {
      return argument.value && argument.value.kind === "Variable" && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}
function removeArgumentsFromDocument(config, doc) {
  var argMatcher = getArgumentMatcher(config);
  return nullIfDocIsEmpty(visit(doc, {
    OperationDefinition: {
      enter: function(node) {
        return __assign$1(__assign$1({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
          return !config.some(function(arg) {
            return arg.name === varDef.variable.name.value;
          });
        }) : [] });
      }
    },
    Field: {
      enter: function(node) {
        var shouldRemoveField = config.some(function(argConfig) {
          return argConfig.remove;
        });
        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          if (node.arguments) {
            node.arguments.forEach(function(arg) {
              if (argMatcher(arg)) {
                argMatchCount_1 += 1;
              }
            });
          }
          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function(node) {
        if (argMatcher(node)) {
          return null;
        }
      }
    }
  }));
}
function removeFragmentSpreadFromDocument(config, doc) {
  function enter(node) {
    if (config.some(function(def) {
      return def.name === node.name.value;
    })) {
      return null;
    }
  }
  return nullIfDocIsEmpty(visit(doc, {
    FragmentSpread: { enter },
    FragmentDefinition: { enter }
  }));
}
function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
  var allFragments = [];
  selectionSet.selections.forEach(function(selection) {
    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag) {
        return allFragments.push(frag);
      });
    } else if (selection.kind === "FragmentSpread") {
      allFragments.push(selection);
    }
  });
  return allFragments;
}
function buildQueryFromSelectionSet(document2) {
  var definition = getMainDefinition(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit(document2, {
    OperationDefinition: {
      enter: function(node) {
        return __assign$1(__assign$1({}, node), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  if (modifiedDoc) {
    modifiedDoc = visit(modifiedDoc, {
      FragmentDefinition: {
        enter: function(node) {
          if (node.selectionSet) {
            var isTypenameOnly = node.selectionSet.selections.every(function(selection) {
              return isField(selection) && selection.name.value === "__typename";
            });
            if (isTypenameOnly) {
              return null;
            }
          }
        }
      }
    });
  }
  return modifiedDoc;
}
var hasOwnProperty$7 = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count2 = sources.length;
  if (count2 > 1) {
    var merger = new DeepMerger();
    for (var i2 = 1; i2 < count2; ++i2) {
      target = merger.merge(target, sources[i2]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = function() {
  function DeepMerger2(reconciler) {
    if (reconciler === void 0) {
      reconciler = defaultReconciler;
    }
    this.reconciler = reconciler;
    this.isObject = isNonNullObject;
    this.pastCopies = /* @__PURE__ */ new Set();
  }
  DeepMerger2.prototype.merge = function(target, source) {
    var _this = this;
    var context = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      context[_i - 2] = arguments[_i];
    }
    if (isNonNullObject(source) && isNonNullObject(target)) {
      Object.keys(source).forEach(function(sourceKey) {
        if (hasOwnProperty$7.call(target, sourceKey)) {
          var targetValue = target[sourceKey];
          if (source[sourceKey] !== targetValue) {
            var result = _this.reconciler.apply(_this, __spreadArray([target, source, sourceKey], context, false));
            if (result !== targetValue) {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = result;
            }
          }
        } else {
          target = _this.shallowCopyForMerge(target);
          target[sourceKey] = source[sourceKey];
        }
      });
      return target;
    }
    return source;
  };
  DeepMerger2.prototype.shallowCopyForMerge = function(value) {
    if (isNonNullObject(value)) {
      if (!this.pastCopies.has(value)) {
        if (Array.isArray(value)) {
          value = value.slice(0);
        } else {
          value = __assign$1({ __proto__: Object.getPrototypeOf(value) }, value);
        }
        this.pastCopies.add(value);
      }
    }
    return value;
  };
  return DeepMerger2;
}();
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (it)
    return (it = it.call(o2)).next.bind(it);
  if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
    if (it)
      o2 = it;
    var i2 = 0;
    return function() {
      if (i2 >= o2.length)
        return { done: true };
      return { done: false, value: o2[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var hasSymbols = function() {
  return typeof Symbol === "function";
};
var hasSymbol = function(name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function(name) {
  return hasSymbol(name) ? Symbol[name] : "@@" + name;
};
if (hasSymbols() && !hasSymbol("observable")) {
  Symbol.observable = Symbol("observable");
}
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null)
    return void 0;
  if (typeof value !== "function")
    throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x2) {
  return x2 instanceof Observable;
}
function hostReportError(e3) {
  if (hostReportError.log) {
    hostReportError.log(e3);
  } else {
    setTimeout(function() {
      throw e3;
    });
  }
}
function enqueue(fn) {
  Promise.resolve().then(function() {
    try {
      fn();
    } catch (e3) {
      hostReportError(e3);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0)
    return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e3) {
    hostReportError(e3);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i2 = 0; i2 < queue.length; ++i2) {
    notifySubscription(subscription, queue[i2].type, queue[i2].value);
    if (subscription._state === "closed")
      break;
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m2 = getMethod(observer, type);
    switch (type) {
      case "next":
        if (m2)
          m2.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m2)
          m2.call(observer);
        break;
    }
  } catch (e3) {
    hostReportError(e3);
  }
  if (subscription._state === "closed")
    cleanupSubscription(subscription);
  else if (subscription._state === "running")
    subscription._state = "ready";
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed")
    return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type, value);
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    var subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e3) {
      subscriptionObserver.error(e3);
    }
    if (this._state === "initializing")
      this._state = "ready";
  }
  var _proto = Subscription2.prototype;
  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };
  _createClass(Subscription2, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]);
  return Subscription2;
}();
var SubscriptionObserver = /* @__PURE__ */ function() {
  function SubscriptionObserver2(subscription) {
    this._subscription = subscription;
  }
  var _proto2 = SubscriptionObserver2.prototype;
  _proto2.next = function next(value) {
    onNotify(this._subscription, "next", value);
  };
  _proto2.error = function error(value) {
    onNotify(this._subscription, "error", value);
  };
  _proto2.complete = function complete() {
    onNotify(this._subscription, "complete");
  };
  _createClass(SubscriptionObserver2, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]);
  return SubscriptionObserver2;
}();
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscriber) {
    if (!(this instanceof Observable2))
      throw new TypeError("Observable cannot be called as a function");
    if (typeof subscriber !== "function")
      throw new TypeError("Observable initializer must be a function");
    this._subscriber = subscriber;
  }
  var _proto3 = Observable2.prototype;
  _proto3.subscribe = function subscribe(observer) {
    if (typeof observer !== "object" || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }
    return new Subscription(observer, this._subscriber);
  };
  _proto3.forEach = function forEach2(fn) {
    var _this = this;
    return new Promise(function(resolve2, reject) {
      if (typeof fn !== "function") {
        reject(new TypeError(fn + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve2();
      }
      var subscription = _this.subscribe({
        next: function(value) {
          try {
            fn(value, done);
          } catch (e3) {
            reject(e3);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
    });
  };
  _proto3.map = function map2(fn) {
    var _this2 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this2.subscribe({
        next: function(value) {
          try {
            value = fn(value);
          } catch (e3) {
            return observer.error(e3);
          }
          observer.next(value);
        },
        error: function(e3) {
          observer.error(e3);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.filter = function filter2(fn) {
    var _this3 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this3.subscribe({
        next: function(value) {
          try {
            if (!fn(value))
              return;
          } catch (e3) {
            return observer.error(e3);
          }
          observer.next(value);
        },
        error: function(e3) {
          observer.error(e3);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.reduce = function reduce(fn) {
    var _this4 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue2 = false;
    var seed = arguments[1];
    var acc = seed;
    return new C2(function(observer) {
      return _this4.subscribe({
        next: function(value) {
          var first = !hasValue2;
          hasValue2 = true;
          if (!first || hasSeed) {
            try {
              acc = fn(acc, value);
            } catch (e3) {
              return observer.error(e3);
            }
          } else {
            acc = value;
          }
        },
        error: function(e3) {
          observer.error(e3);
        },
        complete: function() {
          if (!hasValue2 && !hasSeed)
            return observer.error(new TypeError("Cannot reduce an empty sequence"));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };
  _proto3.concat = function concat() {
    var _this5 = this;
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscription;
      var index2 = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next: function(v2) {
            observer.next(v2);
          },
          error: function(e3) {
            observer.error(e3);
          },
          complete: function() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C2.from(sources[index2++]));
            }
          }
        });
      }
      startNext(_this5);
      return function() {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  };
  _proto3.flatMap = function flatMap(fn) {
    var _this6 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscriptions = [];
      var outer = _this6.subscribe({
        next: function(value) {
          if (fn) {
            try {
              value = fn(value);
            } catch (e3) {
              return observer.error(e3);
            }
          }
          var inner = C2.from(value).subscribe({
            next: function(value2) {
              observer.next(value2);
            },
            error: function(e3) {
              observer.error(e3);
            },
            complete: function() {
              var i2 = subscriptions.indexOf(inner);
              if (i2 >= 0)
                subscriptions.splice(i2, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error: function(e3) {
          observer.error(e3);
        },
        complete: function() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0)
          observer.complete();
      }
      return function() {
        subscriptions.forEach(function(s2) {
          return s2.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };
  _proto3[SymbolObservable] = function() {
    return this;
  };
  Observable2.from = function from(x2) {
    var C2 = typeof this === "function" ? this : Observable2;
    if (x2 == null)
      throw new TypeError(x2 + " is not an object");
    var method = getMethod(x2, SymbolObservable);
    if (method) {
      var observable = method.call(x2);
      if (Object(observable) !== observable)
        throw new TypeError(observable + " is not an object");
      if (isObservable(observable) && observable.constructor === C2)
        return observable;
      return new C2(function(observer) {
        return observable.subscribe(observer);
      });
    }
    if (hasSymbol("iterator")) {
      method = getMethod(x2, SymbolIterator);
      if (method) {
        return new C2(function(observer) {
          enqueue(function() {
            if (observer.closed)
              return;
            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x2)), _step; !(_step = _iterator()).done; ) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x2)) {
      return new C2(function(observer) {
        enqueue(function() {
          if (observer.closed)
            return;
          for (var i2 = 0; i2 < x2.length; ++i2) {
            observer.next(x2[i2]);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x2 + " is not observable");
  };
  Observable2.of = function of2() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    var C2 = typeof this === "function" ? this : Observable2;
    return new C2(function(observer) {
      enqueue(function() {
        if (observer.closed)
          return;
        for (var i2 = 0; i2 < items.length; ++i2) {
          observer.next(items[i2]);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  };
  _createClass(Observable2, null, [{
    key: SymbolSpecies,
    get: function() {
      return this;
    }
  }]);
  return Observable2;
}();
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}
function symbolObservablePonyfill(root2) {
  var result;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result;
      } catch (err) {
      }
    }
  } else {
    result = "@@observable";
  }
  return result;
}
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
symbolObservablePonyfill(root);
var prototype = Observable.prototype;
var fakeObsSymbol = "@@observable";
if (!prototype[fakeObsSymbol]) {
  prototype[fakeObsSymbol] = function() {
    return this;
  };
}
var toString$1 = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
  switch (toString$1.call(val)) {
    case "[object Array]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_1 = val.slice(0);
      seen.set(val, copy_1);
      copy_1.forEach(function(child, i2) {
        copy_1[i2] = cloneDeepHelper(child, seen);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (isNonNullObject(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (__DEV__ && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e3) {
      if (e3 instanceof TypeError)
        return null;
      throw e3;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (__DEV__) {
    deepFreeze(obj);
  }
  return obj;
}
function iterateObserversSafely(observers2, method, argument) {
  var observersWithMethod = [];
  observers2.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
function asyncMap(observable, mapFn, catchFn) {
  return new Observable(function(observer) {
    var next = observer.next, error = observer.error, complete = observer.complete;
    var activeCallbackCount = 0;
    var completed = false;
    var promiseQueue = {
      then: function(callback) {
        return new Promise(function(resolve2) {
          return resolve2(callback());
        });
      }
    };
    function makeCallback(examiner, delegate) {
      if (examiner) {
        return function(arg) {
          ++activeCallbackCount;
          var both = function() {
            return examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result) {
            --activeCallbackCount;
            next && next.call(observer, result);
            if (completed) {
              handler.complete();
            }
          }, function(error2) {
            --activeCallbackCount;
            throw error2;
          }).catch(function(caught) {
            error && error.call(observer, caught);
          });
        };
      } else {
        return function(arg) {
          return delegate && delegate.call(observer, arg);
        };
      }
    }
    var handler = {
      next: makeCallback(mapFn, next),
      error: makeCallback(catchFn, error),
      complete: function() {
        completed = true;
        if (!activeCallbackCount) {
          complete && complete.call(observer);
        }
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
var canUseWeakMap = typeof WeakMap === "function" && maybe$2(function() {
  return navigator.product;
}) !== "ReactNative";
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
var canUseDOM = typeof maybe$2(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = maybe$2(function() {
  return navigator.userAgent.indexOf("jsdom") >= 0;
}) || false;
var canUseLayoutEffect = canUseDOM && !usingJSDOM;
function fixObservableSubclass(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = function(_super) {
  __extends(Concast2, _super);
  function Concast2(sources) {
    var _this = _super.call(this, function(observer) {
      _this.addObserver(observer);
      return function() {
        return _this.removeObserver(observer);
      };
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.promise = new Promise(function(resolve2, reject) {
      _this.resolve = resolve2;
      _this.reject = reject;
    });
    _this.handlers = {
      next: function(result) {
        if (_this.sub !== null) {
          _this.latest = ["next", result];
          _this.notify("next", result);
          iterateObserversSafely(_this.observers, "next", result);
        }
      },
      error: function(error) {
        var sub = _this.sub;
        if (sub !== null) {
          if (sub)
            setTimeout(function() {
              return sub.unsubscribe();
            });
          _this.sub = null;
          _this.latest = ["error", error];
          _this.reject(error);
          _this.notify("error", error);
          iterateObserversSafely(_this.observers, "error", error);
        }
      },
      complete: function() {
        var sub = _this.sub;
        if (sub !== null) {
          var value = _this.sources.shift();
          if (!value) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            if (_this.latest && _this.latest[0] === "next") {
              _this.resolve(_this.latest[1]);
            } else {
              _this.resolve();
            }
            _this.notify("complete");
            iterateObserversSafely(_this.observers, "complete");
          } else if (isPromiseLike(value)) {
            value.then(function(obs) {
              return _this.sub = obs.subscribe(_this.handlers);
            });
          } else {
            _this.sub = value.subscribe(_this.handlers);
          }
        }
      }
    };
    _this.nextResultListeners = /* @__PURE__ */ new Set();
    _this.cancel = function(reason) {
      _this.reject(reason);
      _this.sources = [];
      _this.handlers.complete();
    };
    _this.promise.catch(function(_2) {
    });
    if (typeof sources === "function") {
      sources = [new Observable(sources)];
    }
    if (isPromiseLike(sources)) {
      sources.then(function(iterable) {
        return _this.start(iterable);
      }, _this.handlers.error);
    } else {
      _this.start(sources);
    }
    return _this;
  }
  Concast2.prototype.start = function(sources) {
    if (this.sub !== void 0)
      return;
    this.sources = Array.from(sources);
    this.handlers.complete();
  };
  Concast2.prototype.deliverLastMessage = function(observer) {
    if (this.latest) {
      var nextOrError = this.latest[0];
      var method = observer[nextOrError];
      if (method) {
        method.call(observer, this.latest[1]);
      }
      if (this.sub === null && nextOrError === "next" && observer.complete) {
        observer.complete();
      }
    }
  };
  Concast2.prototype.addObserver = function(observer) {
    if (!this.observers.has(observer)) {
      this.deliverLastMessage(observer);
      this.observers.add(observer);
    }
  };
  Concast2.prototype.removeObserver = function(observer) {
    if (this.observers.delete(observer) && this.observers.size < 1) {
      this.handlers.complete();
    }
  };
  Concast2.prototype.notify = function(method, arg) {
    var nextResultListeners = this.nextResultListeners;
    if (nextResultListeners.size) {
      this.nextResultListeners = /* @__PURE__ */ new Set();
      nextResultListeners.forEach(function(listener) {
        return listener(method, arg);
      });
    }
  };
  Concast2.prototype.beforeNext = function(callback) {
    var called = false;
    this.nextResultListeners.add(function(method, arg) {
      if (!called) {
        called = true;
        callback(method, arg);
      }
    });
  };
  return Concast2;
}(Observable);
fixObservableSubclass(Concast);
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function graphQLResultHasError(result) {
  return result.errors && result.errors.length > 0 || false;
}
function compact() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix) {
  var count2 = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count2 + 1);
  return "".concat(prefix, ":").concat(count2, ":").concat(Math.random().toString(36).slice(2));
}
function stringifyForDisplay(value) {
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }).split(JSON.stringify(undefId)).join("<undefined>");
}
function mergeOptions(defaults, options) {
  return compact(defaults, options, options.variables && {
    variables: __assign$1(__assign$1({}, defaults && defaults.variables), options.variables)
  });
}
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}
var throwServerError = function(response, result, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result;
  throw error;
};
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
    var key = _a2[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw __DEV__ ? new InvariantError("illegal argument: ".concat(key)) : new InvariantError(26);
    }
  }
  return operation;
}
function createOperation(starting, operation) {
  var context = __assign$1({}, starting);
  var setContext = function(next) {
    if (typeof next === "function") {
      context = __assign$1(__assign$1({}, context), next(context));
    } else {
      context = __assign$1(__assign$1({}, context), next);
    }
  };
  var getContext = function() {
    return __assign$1({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var LinkError = function(_super) {
  __extends(LinkError2, _super);
  function LinkError2(message, link) {
    var _this = _super.call(this, message) || this;
    _this.link = link;
    return _this;
  }
  return LinkError2;
}(Error);
var ApolloLink = function() {
  function ApolloLink2(request2) {
    if (request2)
      this.request = request2;
  }
  ApolloLink2.empty = function() {
    return new ApolloLink2(function() {
      return Observable.of();
    });
  };
  ApolloLink2.from = function(links) {
    if (links.length === 0)
      return ApolloLink2.empty();
    return links.map(toLink).reduce(function(x2, y2) {
      return x2.concat(y2);
    });
  };
  ApolloLink2.split = function(test2, left, right) {
    var leftLink = toLink(left);
    var rightLink = toLink(right || new ApolloLink2(passthrough));
    if (isTerminating(leftLink) && isTerminating(rightLink)) {
      return new ApolloLink2(function(operation) {
        return test2(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return test2(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
      });
    }
  };
  ApolloLink2.execute = function(link, operation) {
    return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
  };
  ApolloLink2.concat = function(first, second) {
    var firstLink = toLink(first);
    if (isTerminating(firstLink)) {
      __DEV__ && invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
      return firstLink;
    }
    var nextLink = toLink(second);
    if (isTerminating(nextLink)) {
      return new ApolloLink2(function(operation) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op) || Observable.of();
        }) || Observable.of();
      });
    } else {
      return new ApolloLink2(function(operation, forward) {
        return firstLink.request(operation, function(op) {
          return nextLink.request(op, forward) || Observable.of();
        }) || Observable.of();
      });
    }
  };
  ApolloLink2.prototype.split = function(test2, left, right) {
    return this.concat(ApolloLink2.split(test2, left, right || new ApolloLink2(passthrough)));
  };
  ApolloLink2.prototype.concat = function(next) {
    return ApolloLink2.concat(this, next);
  };
  ApolloLink2.prototype.request = function(operation, forward) {
    throw __DEV__ ? new InvariantError("request is not implemented") : new InvariantError(21);
  };
  ApolloLink2.prototype.onError = function(error, observer) {
    if (observer && observer.error) {
      observer.error(error);
      return false;
    }
    throw error;
  };
  ApolloLink2.prototype.setOnError = function(fn) {
    this.onError = fn;
    return this;
  };
  return ApolloLink2;
}();
var split = ApolloLink.split;
var execute = ApolloLink.execute;
var version = "3.7.1";
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob$1(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function asyncIterator(source) {
  var _a2;
  var iterator = source[Symbol.asyncIterator]();
  return _a2 = {
    next: function() {
      return iterator.next();
    }
  }, _a2[Symbol.asyncIterator] = function() {
    return this;
  }, _a2;
}
function nodeStreamIterator(stream) {
  var cleanup = null;
  var error = null;
  var done = false;
  var data2 = [];
  var waiting = [];
  function onData(chunk) {
    if (error)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data2.push(chunk);
  }
  function onError(err) {
    error = err;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup || cleanup();
  }
  function onEnd() {
    done = true;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup || cleanup();
  }
  cleanup = function() {
    cleanup = null;
    stream.removeListener("data", onData);
    stream.removeListener("error", onError);
    stream.removeListener("end", onEnd);
    stream.removeListener("finish", onEnd);
    stream.removeListener("close", onEnd);
  };
  stream.on("data", onData);
  stream.on("error", onError);
  stream.on("end", onEnd);
  stream.on("finish", onEnd);
  stream.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve2, reject) {
      if (error)
        return reject(error);
      if (data2.length)
        return resolve2({ value: data2.shift(), done: false });
      if (done)
        return resolve2({ value: void 0, done: true });
      waiting.push([resolve2, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve2, reject) {
        promise.then(function(value) {
          resolve2({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function readerIterator(reader) {
  var iterator = {
    next: function() {
      return reader.read();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob$1(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
function readMultipartBody(response, observer) {
  var _a2, _b, _c;
  return __awaiter$2(this, void 0, void 0, function() {
    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _d, value, done, chunk, bi2, message, i2, headers, contentType_1, body, result;
    var _e2;
    return __generator$1(this, function(_f) {
      switch (_f.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_a2 = response.headers) === null || _a2 === void 0 ? void 0 : _a2.get("content-type");
          delimiter = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "--".concat(boundaryVal);
          buffer = "";
          iterator = responseIterator(response);
          running = true;
          _f.label = 1;
        case 1:
          if (!running)
            return [3, 3];
          return [4, iterator.next()];
        case 2:
          _d = _f.sent(), value = _d.value, done = _d.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          running = !done;
          buffer += chunk;
          bi2 = buffer.indexOf(boundary);
          while (bi2 > -1) {
            message = void 0;
            _e2 = [
              buffer.slice(0, bi2),
              buffer.slice(bi2 + boundary.length)
            ], message = _e2[0], buffer = _e2[1];
            if (message.trim()) {
              i2 = message.indexOf("\r\n\r\n");
              headers = parseHeaders$1(message.slice(0, i2));
              contentType_1 = headers["content-type"];
              if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                throw new Error("Unsupported patch content type: application/json is required.");
              }
              body = message.slice(i2);
              try {
                result = parseJsonBody(response, body.replace("\r\n", ""));
                if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result) {
                  (_b = observer.next) === null || _b === void 0 ? void 0 : _b.call(observer, result);
                }
              } catch (err) {
                handleError(err, observer);
              }
            }
            bi2 = buffer.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
          return [2];
      }
    });
  });
}
function parseHeaders$1(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line) {
    var i2 = line.indexOf(":");
    if (i2 > -1) {
      var name_1 = line.slice(0, i2).trim().toLowerCase();
      var value = line.slice(i2 + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  var _a2, _b;
  if (err.name === "AbortError")
    return;
  if (err.result && err.result.errors && err.result.data) {
    (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, err.result);
  }
  (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, err);
}
function readJsonBody(response, operation, observer) {
  parseAndCheckHttpResponse(operation)(response).then(function(result) {
    var _a2, _b;
    (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, result);
    (_b = observer.complete) === null || _b === void 0 ? void 0 : _b.call(observer);
  }).catch(function(err) {
    return handleError(err, observer);
  });
}
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result) {
      if (response.status >= 300) {
        throwServerError(response, result, "Response not successful: Received status code ".concat(response.status));
      }
      if (!Array.isArray(result) && !hasOwnProperty$6.call(result, "data") && !hasOwnProperty$6.call(result, "errors")) {
        throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result;
    });
  };
}
var serializeFetchParameter = function(p2, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p2);
  } catch (e3) {
    var parseError = __DEV__ ? new InvariantError("Network request failed. ".concat(label, " is not serializable: ").concat(e3.message)) : new InvariantError(23);
    parseError.parseError = e3;
    throw parseError;
  }
  return serialized;
};
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false,
  preserveHeaderCase: false
};
var defaultHeaders = {
  accept: "*/*",
  "content-type": "application/json"
};
var defaultOptions = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions
};
var defaultPrinter = function(ast, printer) {
  return printer(ast);
};
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = {};
  var http = {};
  configs.forEach(function(config) {
    options = __assign$1(__assign$1(__assign$1({}, options), config.options), { headers: __assign$1(__assign$1({}, options.headers), config.headers) });
    if (config.credentials) {
      options.credentials = config.credentials;
    }
    http = __assign$1(__assign$1({}, http), config.http);
  });
  options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
  var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName: operationName2, variables };
  if (http.includeExtensions)
    body.extensions = extensions;
  if (http.includeQuery)
    body.query = printer(query, print);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
    Object.keys(Object(headers)).forEach(function(name) {
      normalizedHeaders_1[name.toLowerCase()] = headers[name];
    });
    return normalizedHeaders_1;
  }
  var headerData = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(headers)).forEach(function(name) {
    headerData[name.toLowerCase()] = { originalName: name, value: headers[name] };
  });
  var normalizedHeaders = /* @__PURE__ */ Object.create(null);
  Object.keys(headerData).forEach(function(name) {
    normalizedHeaders[headerData[name].originalName] = headerData[name].value;
  });
  return normalizedHeaders;
}
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw __DEV__ ? new InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `) : new InvariantError(22);
  }
};
var createSignalIfSupported = function() {
  if (typeof AbortController === "undefined")
    return { controller: false, signal: false };
  var controller = new AbortController();
  var signal = controller.signal;
  return { controller, signal };
};
var selectURI = function(operation, fallbackURI) {
  var context = operation.getContext();
  var contextURI = context.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var backupFetch = maybe$2(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print2 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest$1(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  if (__DEV__) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions, preserveHeaderCase },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context.clientAwareness) {
      var _a3 = context.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign$1(__assign$1({}, clientAwarenessHeaders), context.headers);
    var contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: contextHeaders
    };
    var _b2 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
    if (body.variables && !includeUnusedVariables) {
      var unusedNames_1 = new Set(Object.keys(body.variables));
      visit(operation.query, {
        Variable: function(node, _key, parent) {
          if (parent && parent.kind !== "VariableDefinition") {
            unusedNames_1.delete(node.name.value);
          }
        }
      });
      if (unusedNames_1.size) {
        body.variables = __assign$1({}, body.variables);
        unusedNames_1.forEach(function(name) {
          delete body.variables[name];
        });
      }
    }
    var controller;
    if (!options.signal) {
      var _c2 = createSignalIfSupported(), _controller = _c2.controller, signal = _c2.signal;
      controller = _controller;
      if (controller)
        options.signal = signal;
    }
    var definitionIsMutation = function(d2) {
      return d2.kind === "OperationDefinition" && d2.operation === "mutation";
    };
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (hasDirectives(["defer"], operation.query)) {
      options.headers.accept = "multipart/mixed; deferSpec=20220824, application/json";
    }
    if (options.method === "GET") {
      var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable(function(observer) {
      var currentFetch = preferredFetch || maybe$2(function() {
        return fetch;
      }) || backupFetch;
      currentFetch(chosenURI, options).then(function(response) {
        var _a4;
        operation.setContext({ response });
        var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
          return readMultipartBody(response, observer);
        } else {
          return readJsonBody(response, operation, observer);
        }
      }).catch(function(err) {
        return handleError(err, observer);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};
var HttpLink = function(_super) {
  __extends(HttpLink2, _super);
  function HttpLink2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, createHttpLink(options).request) || this;
    _this.options = options;
    return _this;
  }
  return HttpLink2;
}(ApolloLink);
var _a$2 = Object.prototype, toString = _a$2.toString, hasOwnProperty$5 = _a$2.hasOwnProperty;
var fnToStr = Function.prototype.toString;
var previousComparisons = /* @__PURE__ */ new Map();
function equal(a2, b2) {
  try {
    return check(a2, b2);
  } finally {
    previousComparisons.clear();
  }
}
function check(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  var aTag = toString.call(a2);
  var bTag = toString.call(b2);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a2.length !== b2.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a2, b2))
        return true;
      var aKeys = definedKeys(a2);
      var bKeys = definedKeys(b2);
      var keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (var k2 = 0; k2 < keyCount; ++k2) {
        if (!hasOwnProperty$5.call(b2, aKeys[k2])) {
          return false;
        }
      }
      for (var k2 = 0; k2 < keyCount; ++k2) {
        var key = aKeys[k2];
        if (!check(a2[key], b2[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a2.name === b2.name && a2.message === b2.message;
    case "[object Number]":
      if (a2 !== a2)
        return b2 !== b2;
    case "[object Boolean]":
    case "[object Date]":
      return +a2 === +b2;
    case "[object RegExp]":
    case "[object String]":
      return a2 == "".concat(b2);
    case "[object Map]":
    case "[object Set]": {
      if (a2.size !== b2.size)
        return false;
      if (previouslyCompared(a2, b2))
        return true;
      var aIterator = a2.entries();
      var isMap = aTag === "[object Map]";
      while (true) {
        var info = aIterator.next();
        if (info.done)
          break;
        var _a2 = info.value, aKey = _a2[0], aValue = _a2[1];
        if (!b2.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b2.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a2 = new Uint8Array(a2);
      b2 = new Uint8Array(b2);
    case "[object DataView]": {
      var len = a2.byteLength;
      if (len === b2.byteLength) {
        while (len-- && a2[len] === b2[len]) {
        }
      }
      return len === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      var aCode = fnToStr.call(a2);
      if (aCode !== fnToStr.call(b2)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
var nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  var fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a2, b2) {
  var bSet = previousComparisons.get(a2);
  if (bSet) {
    if (bSet.has(b2))
      return true;
  } else {
    previousComparisons.set(a2, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b2);
  return false;
}
function isExecutionPatchIncrementalResult(value) {
  return !!value.incremental;
}
var defaultMakeData = function() {
  return /* @__PURE__ */ Object.create(null);
};
var _a$1 = Array.prototype, forEach = _a$1.forEach, slice = _a$1.slice;
var Trie = function() {
  function Trie2(weakness, makeData) {
    if (weakness === void 0) {
      weakness = true;
    }
    if (makeData === void 0) {
      makeData = defaultMakeData;
    }
    this.weakness = weakness;
    this.makeData = makeData;
  }
  Trie2.prototype.lookup = function() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      array[_i] = arguments[_i];
    }
    return this.lookupArray(array);
  };
  Trie2.prototype.lookupArray = function(array) {
    var node = this;
    forEach.call(array, function(key) {
      return node = node.getChildTrie(key);
    });
    return node.data || (node.data = this.makeData(slice.call(array)));
  };
  Trie2.prototype.getChildTrie = function(key) {
    var map2 = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
    var child = map2.get(key);
    if (!child)
      map2.set(key, child = new Trie2(this.weakness, this.makeData));
    return child;
  };
  return Trie2;
}();
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var currentContext$1 = null;
var MISSING_VALUE$1 = {};
var idCounter$1 = 1;
var makeSlotClass$1 = function() {
  return function() {
    function Slot2() {
      this.id = [
        "slot",
        idCounter$1++,
        Date.now(),
        Math.random().toString(36).slice(2)
      ].join(":");
    }
    Slot2.prototype.hasValue = function() {
      for (var context_1 = currentContext$1; context_1; context_1 = context_1.parent) {
        if (this.id in context_1.slots) {
          var value = context_1.slots[this.id];
          if (value === MISSING_VALUE$1)
            break;
          if (context_1 !== currentContext$1) {
            currentContext$1.slots[this.id] = value;
          }
          return true;
        }
      }
      if (currentContext$1) {
        currentContext$1.slots[this.id] = MISSING_VALUE$1;
      }
      return false;
    };
    Slot2.prototype.getValue = function() {
      if (this.hasValue()) {
        return currentContext$1.slots[this.id];
      }
    };
    Slot2.prototype.withValue = function(value, callback, args, thisArg) {
      var _a2;
      var slots = (_a2 = {
        __proto__: null
      }, _a2[this.id] = value, _a2);
      var parent = currentContext$1;
      currentContext$1 = { parent, slots };
      try {
        return callback.apply(thisArg, args);
      } finally {
        currentContext$1 = parent;
      }
    };
    Slot2.bind = function(callback) {
      var context = currentContext$1;
      return function() {
        var saved = currentContext$1;
        try {
          currentContext$1 = context;
          return callback.apply(this, arguments);
        } finally {
          currentContext$1 = saved;
        }
      };
    };
    Slot2.noContext = function(callback, args, thisArg) {
      if (currentContext$1) {
        var saved = currentContext$1;
        try {
          currentContext$1 = null;
          return callback.apply(thisArg, args);
        } finally {
          currentContext$1 = saved;
        }
      } else {
        return callback.apply(thisArg, args);
      }
    };
    return Slot2;
  }();
};
var globalKey$1 = "@wry/context:Slot";
var host$1 = Array;
var Slot$1 = host$1[globalKey$1] || function() {
  var Slot2 = makeSlotClass$1();
  try {
    Object.defineProperty(host$1, globalKey$1, {
      value: host$1[globalKey$1] = Slot2,
      enumerable: false,
      writable: false,
      configurable: false
    });
  } finally {
    return Slot2;
  }
}();
Slot$1.bind;
Slot$1.noContext;
function defaultDispose() {
}
var Cache = function() {
  function Cache2(max2, dispose) {
    if (max2 === void 0) {
      max2 = Infinity;
    }
    if (dispose === void 0) {
      dispose = defaultDispose;
    }
    this.max = max2;
    this.dispose = dispose;
    this.map = /* @__PURE__ */ new Map();
    this.newest = null;
    this.oldest = null;
  }
  Cache2.prototype.has = function(key) {
    return this.map.has(key);
  };
  Cache2.prototype.get = function(key) {
    var node = this.getNode(key);
    return node && node.value;
  };
  Cache2.prototype.getNode = function(key) {
    var node = this.map.get(key);
    if (node && node !== this.newest) {
      var older = node.older, newer = node.newer;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node.older = this.newest;
      node.older.newer = node;
      node.newer = null;
      this.newest = node;
      if (node === this.oldest) {
        this.oldest = newer;
      }
    }
    return node;
  };
  Cache2.prototype.set = function(key, value) {
    var node = this.getNode(key);
    if (node) {
      return node.value = value;
    }
    node = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node;
    }
    this.newest = node;
    this.oldest = this.oldest || node;
    this.map.set(key, node);
    return node.value;
  };
  Cache2.prototype.clean = function() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  };
  Cache2.prototype.delete = function(key) {
    var node = this.map.get(key);
    if (node) {
      if (node === this.newest) {
        this.newest = node.older;
      }
      if (node === this.oldest) {
        this.oldest = node.newer;
      }
      if (node.newer) {
        node.newer.older = node.older;
      }
      if (node.older) {
        node.older.newer = node.newer;
      }
      this.map.delete(key);
      this.dispose(node.value, key);
      return true;
    }
    return false;
  };
  return Cache2;
}();
var parentEntrySlot = new Slot$1();
var _a;
var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
var toArray = (_a = Array.from, _a === void 0 ? function(collection) {
  var array = [];
  collection.forEach(function(item) {
    return array.push(item);
  });
  return array;
} : _a);
function maybeUnsubscribe(entryOrDep) {
  var unsubscribe = entryOrDep.unsubscribe;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
function assert$1(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a2, b2) {
  var len = a2.length;
  return len > 0 && len === b2.length && a2[len - 1] === b2[len - 1];
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
var Entry = function() {
  function Entry2(fn) {
    this.fn = fn;
    this.parents = /* @__PURE__ */ new Set();
    this.childValues = /* @__PURE__ */ new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    this.deps = null;
    ++Entry2.count;
  }
  Entry2.prototype.peek = function() {
    if (this.value.length === 1 && !mightBeDirty(this)) {
      rememberParent(this);
      return this.value[0];
    }
  };
  Entry2.prototype.recompute = function(args) {
    assert$1(!this.recomputing, "already recomputing");
    rememberParent(this);
    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
  };
  Entry2.prototype.setDirty = function() {
    if (this.dirty)
      return;
    this.dirty = true;
    this.value.length = 0;
    reportDirty(this);
    maybeUnsubscribe(this);
  };
  Entry2.prototype.dispose = function() {
    var _this = this;
    this.setDirty();
    forgetChildren(this);
    eachParent(this, function(parent, child) {
      parent.setDirty();
      forgetChild(parent, _this);
    });
  };
  Entry2.prototype.forget = function() {
    this.dispose();
  };
  Entry2.prototype.dependOn = function(dep2) {
    dep2.add(this);
    if (!this.deps) {
      this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
    }
    this.deps.add(dep2);
  };
  Entry2.prototype.forgetDeps = function() {
    var _this = this;
    if (this.deps) {
      toArray(this.deps).forEach(function(dep2) {
        return dep2.delete(_this);
      });
      this.deps.clear();
      emptySetPool.push(this.deps);
      this.deps = null;
    }
  };
  Entry2.count = 0;
  return Entry2;
}();
function rememberParent(child) {
  var parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
  } catch (e3) {
    entry.value[1] = e3;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  var parentCount = child.parents.size;
  if (parentCount) {
    var parents = toArray(child.parents);
    for (var i2 = 0; i2 < parentCount; ++i2) {
      callback(parents[i2], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert$1(parent.childValues.has(child));
  assert$1(mightBeDirty(child));
  var parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert$1(parent.childValues.has(child));
  assert$1(!mightBeDirty(child));
  var childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  var dc2 = parent.dirtyChildren;
  if (dc2) {
    dc2.delete(child);
    if (dc2.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc2);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach(function(_value, child) {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert$1(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e3) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
var EntryMethods = {
  setDirty: true,
  dispose: true,
  forget: true
};
function dep(options) {
  var depsByKey = /* @__PURE__ */ new Map();
  var subscribe = options && options.subscribe;
  function depend(key) {
    var parent = parentEntrySlot.getValue();
    if (parent) {
      var dep_1 = depsByKey.get(key);
      if (!dep_1) {
        depsByKey.set(key, dep_1 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep_1);
      if (typeof subscribe === "function") {
        maybeUnsubscribe(dep_1);
        dep_1.unsubscribe = subscribe(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    var dep2 = depsByKey.get(key);
    if (dep2) {
      var m_1 = entryMethodName && hasOwnProperty$4.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      toArray(dep2).forEach(function(entry) {
        return entry[m_1]();
      });
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
function makeDefaultMakeCacheKeyFunction() {
  var keyTrie = new Trie(typeof WeakMap === "function");
  return function() {
    return keyTrie.lookupArray(arguments);
  };
}
makeDefaultMakeCacheKeyFunction();
var caches = /* @__PURE__ */ new Set();
function wrap(originalFunction, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  var cache2 = new Cache(options.max || Math.pow(2, 16), function(entry) {
    return entry.dispose();
  });
  var keyArgs = options.keyArgs;
  var makeCacheKey = options.makeCacheKey || makeDefaultMakeCacheKeyFunction();
  var optimistic = function() {
    var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    var entry = cache2.get(key);
    if (!entry) {
      cache2.set(key, entry = new Entry(originalFunction));
      entry.subscribe = options.subscribe;
      entry.forget = function() {
        return cache2.delete(key);
      };
    }
    var value = entry.recompute(Array.prototype.slice.call(arguments));
    cache2.set(key, entry);
    caches.add(cache2);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach(function(cache3) {
        return cache3.clean();
      });
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: function() {
      return cache2["map"].size;
    },
    configurable: false,
    enumerable: false
  });
  function dirtyKey(key) {
    var entry = cache2.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    var entry = cache2.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return cache2.delete(key);
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}
var ApolloCache = function() {
  function ApolloCache2() {
    this.getFragmentDoc = wrap(getFragmentQueryDocument);
  }
  ApolloCache2.prototype.batch = function(options) {
    var _this = this;
    var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
    var updateResult;
    this.performTransaction(function() {
      return updateResult = options.update(_this);
    }, optimisticId);
    return updateResult;
  };
  ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
    this.performTransaction(transaction, optimisticId);
  };
  ApolloCache2.prototype.transformDocument = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.transformForLink = function(document2) {
    return document2;
  };
  ApolloCache2.prototype.identify = function(object2) {
    return;
  };
  ApolloCache2.prototype.gc = function() {
    return [];
  };
  ApolloCache2.prototype.modify = function(options) {
    return false;
  };
  ApolloCache2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read(__assign$1(__assign$1({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
  };
  ApolloCache2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = !!options.optimistic;
    }
    return this.read(__assign$1(__assign$1({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
  };
  ApolloCache2.prototype.writeQuery = function(_a2) {
    var id2 = _a2.id, data2 = _a2.data, options = __rest$1(_a2, ["id", "data"]);
    return this.write(Object.assign(options, {
      dataId: id2 || "ROOT_QUERY",
      result: data2
    }));
  };
  ApolloCache2.prototype.writeFragment = function(_a2) {
    var id2 = _a2.id, data2 = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest$1(_a2, ["id", "data", "fragment", "fragmentName"]);
    return this.write(Object.assign(options, {
      query: this.getFragmentDoc(fragment, fragmentName),
      dataId: id2,
      result: data2
    }));
  };
  ApolloCache2.prototype.updateQuery = function(options, update) {
    return this.batch({
      update: function(cache2) {
        var value = cache2.readQuery(options);
        var data2 = update(value);
        if (data2 === void 0 || data2 === null)
          return value;
        cache2.writeQuery(__assign$1(__assign$1({}, options), { data: data2 }));
        return data2;
      }
    });
  };
  ApolloCache2.prototype.updateFragment = function(options, update) {
    return this.batch({
      update: function(cache2) {
        var value = cache2.readFragment(options);
        var data2 = update(value);
        if (data2 === void 0 || data2 === null)
          return value;
        cache2.writeFragment(__assign$1(__assign$1({}, options), { data: data2 }));
        return data2;
      }
    });
  };
  return ApolloCache2;
}();
var MissingFieldError = function(_super) {
  __extends(MissingFieldError2, _super);
  function MissingFieldError2(message, path, query, variables) {
    var _a2;
    var _this = _super.call(this, message) || this;
    _this.message = message;
    _this.path = path;
    _this.query = query;
    _this.variables = variables;
    if (Array.isArray(_this.path)) {
      _this.missing = _this.message;
      for (var i2 = _this.path.length - 1; i2 >= 0; --i2) {
        _this.missing = (_a2 = {}, _a2[_this.path[i2]] = _this.missing, _a2);
      }
    } else {
      _this.missing = _this.path;
    }
    _this.__proto__ = MissingFieldError2.prototype;
    return _this;
  }
  return MissingFieldError2;
}(Error);
var hasOwn = Object.prototype.hasOwnProperty;
function isNullish(value) {
  return value === null || value === void 0;
}
var isArray = Array.isArray;
function defaultDataIdFromObject(_a2, context) {
  var __typename = _a2.__typename, id2 = _a2.id, _id = _a2._id;
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = !isNullish(id2) ? { id: id2 } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id2) && !isNullish(_id)) {
      id2 = _id;
    }
    if (!isNullish(id2)) {
      return "".concat(__typename, ":").concat(typeof id2 === "number" || typeof id2 === "string" ? id2 : JSON.stringify(id2));
    }
  }
}
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  canonizeResults: false
};
function normalizeConfig(config) {
  return compact(defaultConfig, config);
}
function shouldCanonizeResults(config) {
  var value = config.canonizeResults;
  return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match2 = storeFieldName.match(TypeOrFieldNameRegExp);
  return match2 ? match2[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (isNonNullObject(result)) {
    return isArray(result) ? result.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document2, fragments) {
  var fragmentMap = createFragmentMap(getFragmentDefinitions(document2));
  return {
    fragmentMap,
    lookupFragment: function(name) {
      var def = fragmentMap[name];
      if (!def && fragments) {
        def = fragments.lookup(name);
      }
      return def || null;
    }
  };
}
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = /* @__PURE__ */ Object.create(null);
var EntityStore = function() {
  function EntityStore2(policies, group) {
    var _this = this;
    this.policies = policies;
    this.group = group;
    this.data = /* @__PURE__ */ Object.create(null);
    this.rootIds = /* @__PURE__ */ Object.create(null);
    this.refs = /* @__PURE__ */ Object.create(null);
    this.getFieldValue = function(objectOrReference, storeFieldName) {
      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
    };
    this.canRead = function(objOrRef) {
      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
    };
    this.toReference = function(objOrIdOrRef, mergeIntoStore) {
      if (typeof objOrIdOrRef === "string") {
        return makeReference(objOrIdOrRef);
      }
      if (isReference(objOrIdOrRef)) {
        return objOrIdOrRef;
      }
      var id2 = _this.policies.identify(objOrIdOrRef)[0];
      if (id2) {
        var ref = makeReference(id2);
        if (mergeIntoStore) {
          _this.merge(id2, objOrIdOrRef);
        }
        return ref;
      }
    };
  }
  EntityStore2.prototype.toObject = function() {
    return __assign$1({}, this.data);
  };
  EntityStore2.prototype.has = function(dataId) {
    return this.lookup(dataId, true) !== void 0;
  };
  EntityStore2.prototype.get = function(dataId, fieldName) {
    this.group.depend(dataId, fieldName);
    if (hasOwn.call(this.data, dataId)) {
      var storeObject = this.data[dataId];
      if (storeObject && hasOwn.call(storeObject, fieldName)) {
        return storeObject[fieldName];
      }
    }
    if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
      return this.policies.rootTypenamesById[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.get(dataId, fieldName);
    }
  };
  EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
    if (dependOnExistence)
      this.group.depend(dataId, "__exists");
    if (hasOwn.call(this.data, dataId)) {
      return this.data[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.lookup(dataId, dependOnExistence);
    }
    if (this.policies.rootTypenamesById[dataId]) {
      return /* @__PURE__ */ Object.create(null);
    }
  };
  EntityStore2.prototype.merge = function(older, newer) {
    var _this = this;
    var dataId;
    if (isReference(older))
      older = older.__ref;
    if (isReference(newer))
      newer = newer.__ref;
    var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
    var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
    if (!incoming)
      return;
    __DEV__ ? invariant(typeof dataId === "string", "store.merge expects a string ID") : invariant(typeof dataId === "string", 1);
    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
    this.data[dataId] = merged;
    if (merged !== existing) {
      delete this.refs[dataId];
      if (this.group.caching) {
        var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
        if (!existing)
          fieldsToDirty_1.__exists = 1;
        Object.keys(incoming).forEach(function(storeFieldName) {
          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
            fieldsToDirty_1[storeFieldName] = 1;
            var fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
              fieldsToDirty_1[fieldName] = 1;
            }
            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
              delete merged[storeFieldName];
            }
          }
        });
        if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
          delete fieldsToDirty_1.__typename;
        }
        Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
          return _this.group.dirty(dataId, fieldName);
        });
      }
    }
  };
  EntityStore2.prototype.modify = function(dataId, fields) {
    var _this = this;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var changedFields_1 = /* @__PURE__ */ Object.create(null);
      var needToMerge_1 = false;
      var allDeleted_1 = true;
      var sharedDetails_1 = {
        DELETE,
        INVALIDATE,
        isReference,
        toReference: this.toReference,
        canRead: this.canRead,
        readField: function(fieldNameOrOptions, from) {
          return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
            fieldName: fieldNameOrOptions,
            from: from || makeReference(dataId)
          } : fieldNameOrOptions, { store: _this });
        }
      };
      Object.keys(storeObject).forEach(function(storeFieldName) {
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var fieldValue = storeObject[storeFieldName];
        if (fieldValue === void 0)
          return;
        var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
        if (modify) {
          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign$1(__assign$1({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
          if (newValue === INVALIDATE) {
            _this.group.dirty(dataId, storeFieldName);
          } else {
            if (newValue === DELETE)
              newValue = void 0;
            if (newValue !== fieldValue) {
              changedFields_1[storeFieldName] = newValue;
              needToMerge_1 = true;
              fieldValue = newValue;
            }
          }
        }
        if (fieldValue !== void 0) {
          allDeleted_1 = false;
        }
      });
      if (needToMerge_1) {
        this.merge(dataId, changedFields_1);
        if (allDeleted_1) {
          if (this instanceof Layer) {
            this.data[dataId] = void 0;
          } else {
            delete this.data[dataId];
          }
          this.group.dirty(dataId, "__exists");
        }
        return true;
      }
    }
    return false;
  };
  EntityStore2.prototype.delete = function(dataId, fieldName, args) {
    var _a2;
    var storeObject = this.lookup(dataId);
    if (storeObject) {
      var typename = this.getFieldValue(storeObject, "__typename");
      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
      return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
    }
    return false;
  };
  EntityStore2.prototype.evict = function(options, limit) {
    var evicted = false;
    if (options.id) {
      if (hasOwn.call(this.data, options.id)) {
        evicted = this.delete(options.id, options.fieldName, options.args);
      }
      if (this instanceof Layer && this !== limit) {
        evicted = this.parent.evict(options, limit) || evicted;
      }
      if (options.fieldName || evicted) {
        this.group.dirty(options.id, options.fieldName || "__exists");
      }
    }
    return evicted;
  };
  EntityStore2.prototype.clear = function() {
    this.replace(null);
  };
  EntityStore2.prototype.extract = function() {
    var _this = this;
    var obj = this.toObject();
    var extraRootIds = [];
    this.getRootIdSet().forEach(function(id2) {
      if (!hasOwn.call(_this.policies.rootTypenamesById, id2)) {
        extraRootIds.push(id2);
      }
    });
    if (extraRootIds.length) {
      obj.__META = { extraRootIds: extraRootIds.sort() };
    }
    return obj;
  };
  EntityStore2.prototype.replace = function(newData) {
    var _this = this;
    Object.keys(this.data).forEach(function(dataId) {
      if (!(newData && hasOwn.call(newData, dataId))) {
        _this.delete(dataId);
      }
    });
    if (newData) {
      var __META = newData.__META, rest_1 = __rest$1(newData, ["__META"]);
      Object.keys(rest_1).forEach(function(dataId) {
        _this.merge(dataId, rest_1[dataId]);
      });
      if (__META) {
        __META.extraRootIds.forEach(this.retain, this);
      }
    }
  };
  EntityStore2.prototype.retain = function(rootId) {
    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
  };
  EntityStore2.prototype.release = function(rootId) {
    if (this.rootIds[rootId] > 0) {
      var count2 = --this.rootIds[rootId];
      if (!count2)
        delete this.rootIds[rootId];
      return count2;
    }
    return 0;
  };
  EntityStore2.prototype.getRootIdSet = function(ids) {
    if (ids === void 0) {
      ids = /* @__PURE__ */ new Set();
    }
    Object.keys(this.rootIds).forEach(ids.add, ids);
    if (this instanceof Layer) {
      this.parent.getRootIdSet(ids);
    } else {
      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
    }
    return ids;
  };
  EntityStore2.prototype.gc = function() {
    var _this = this;
    var ids = this.getRootIdSet();
    var snapshot = this.toObject();
    ids.forEach(function(id2) {
      if (hasOwn.call(snapshot, id2)) {
        Object.keys(_this.findChildRefIds(id2)).forEach(ids.add, ids);
        delete snapshot[id2];
      }
    });
    var idsToRemove = Object.keys(snapshot);
    if (idsToRemove.length) {
      var root_1 = this;
      while (root_1 instanceof Layer)
        root_1 = root_1.parent;
      idsToRemove.forEach(function(id2) {
        return root_1.delete(id2);
      });
    }
    return idsToRemove;
  };
  EntityStore2.prototype.findChildRefIds = function(dataId) {
    if (!hasOwn.call(this.refs, dataId)) {
      var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
      var root2 = this.data[dataId];
      if (!root2)
        return found_1;
      var workSet_1 = /* @__PURE__ */ new Set([root2]);
      workSet_1.forEach(function(obj) {
        if (isReference(obj)) {
          found_1[obj.__ref] = true;
        }
        if (isNonNullObject(obj)) {
          Object.keys(obj).forEach(function(key) {
            var child = obj[key];
            if (isNonNullObject(child)) {
              workSet_1.add(child);
            }
          });
        }
      });
    }
    return this.refs[dataId];
  };
  EntityStore2.prototype.makeCacheKey = function() {
    return this.group.keyMaker.lookupArray(arguments);
  };
  return EntityStore2;
}();
var CacheGroup = function() {
  function CacheGroup2(caching, parent) {
    if (parent === void 0) {
      parent = null;
    }
    this.caching = caching;
    this.parent = parent;
    this.d = null;
    this.resetCaching();
  }
  CacheGroup2.prototype.resetCaching = function() {
    this.d = this.caching ? dep() : null;
    this.keyMaker = new Trie(canUseWeakMap);
  };
  CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
    if (this.d) {
      this.d(makeDepKey(dataId, storeFieldName));
      var fieldName = fieldNameFromStoreName(storeFieldName);
      if (fieldName !== storeFieldName) {
        this.d(makeDepKey(dataId, fieldName));
      }
      if (this.parent) {
        this.parent.depend(dataId, storeFieldName);
      }
    }
  };
  CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
    if (this.d) {
      this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
    }
  };
  return CacheGroup2;
}();
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root = function(_super) {
    __extends(Root2, _super);
    function Root2(_a2) {
      var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
      _this.stump = new Stump(_this);
      _this.storageTrie = new Trie(canUseWeakMap);
      if (seed)
        _this.replace(seed);
      return _this;
    }
    Root2.prototype.addLayer = function(layerId, replay) {
      return this.stump.addLayer(layerId, replay);
    };
    Root2.prototype.removeLayer = function() {
      return this;
    };
    Root2.prototype.getStorage = function() {
      return this.storageTrie.lookupArray(arguments);
    };
    return Root2;
  }(EntityStore2);
  EntityStore2.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = function(_super) {
  __extends(Layer2, _super);
  function Layer2(id2, parent, replay, group) {
    var _this = _super.call(this, parent.policies, group) || this;
    _this.id = id2;
    _this.parent = parent;
    _this.replay = replay;
    _this.group = group;
    replay(_this);
    return _this;
  }
  Layer2.prototype.addLayer = function(layerId, replay) {
    return new Layer2(layerId, this, replay, this.group);
  };
  Layer2.prototype.removeLayer = function(layerId) {
    var _this = this;
    var parent = this.parent.removeLayer(layerId);
    if (layerId === this.id) {
      if (this.group.caching) {
        Object.keys(this.data).forEach(function(dataId) {
          var ownStoreObject = _this.data[dataId];
          var parentStoreObject = parent["lookup"](dataId);
          if (!parentStoreObject) {
            _this.delete(dataId);
          } else if (!ownStoreObject) {
            _this.group.dirty(dataId, "__exists");
            Object.keys(parentStoreObject).forEach(function(storeFieldName) {
              _this.group.dirty(dataId, storeFieldName);
            });
          } else if (ownStoreObject !== parentStoreObject) {
            Object.keys(ownStoreObject).forEach(function(storeFieldName) {
              if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                _this.group.dirty(dataId, storeFieldName);
              }
            });
          }
        });
      }
      return parent;
    }
    if (parent === this.parent)
      return this;
    return parent.addLayer(this.id, this.replay);
  };
  Layer2.prototype.toObject = function() {
    return __assign$1(__assign$1({}, this.parent.toObject()), this.data);
  };
  Layer2.prototype.findChildRefIds = function(dataId) {
    var fromParent = this.parent.findChildRefIds(dataId);
    return hasOwn.call(this.data, dataId) ? __assign$1(__assign$1({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
  };
  Layer2.prototype.getStorage = function() {
    var p2 = this.parent;
    while (p2.parent)
      p2 = p2.parent;
    return p2.getStorage.apply(p2, arguments);
  };
  return Layer2;
}(EntityStore);
var Stump = function(_super) {
  __extends(Stump2, _super);
  function Stump2(root2) {
    return _super.call(this, "EntityStore.Stump", root2, function() {
    }, new CacheGroup(root2.group.caching, root2.group)) || this;
  }
  Stump2.prototype.removeLayer = function() {
    return this;
  };
  Stump2.prototype.merge = function() {
    return this.parent.merge.apply(this.parent, arguments);
  };
  return Stump2;
}(Layer);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray(value) ? value.slice(0) : __assign$1({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = function() {
  function ObjectCanon2() {
    this.known = new (canUseWeakSet ? WeakSet : Set)();
    this.pool = new Trie(canUseWeakMap);
    this.passes = /* @__PURE__ */ new WeakMap();
    this.keysByJSON = /* @__PURE__ */ new Map();
    this.empty = this.admit({});
  }
  ObjectCanon2.prototype.isKnown = function(value) {
    return isNonNullObject(value) && this.known.has(value);
  };
  ObjectCanon2.prototype.pass = function(value) {
    if (isNonNullObject(value)) {
      var copy2 = shallowCopy(value);
      this.passes.set(copy2, value);
      return copy2;
    }
    return value;
  };
  ObjectCanon2.prototype.admit = function(value) {
    var _this = this;
    if (isNonNullObject(value)) {
      var original = this.passes.get(value);
      if (original)
        return original;
      var proto = Object.getPrototypeOf(value);
      switch (proto) {
        case Array.prototype: {
          if (this.known.has(value))
            return value;
          var array = value.map(this.admit, this);
          var node = this.pool.lookupArray(array);
          if (!node.array) {
            this.known.add(node.array = array);
            if (__DEV__) {
              Object.freeze(array);
            }
          }
          return node.array;
        }
        case null:
        case Object.prototype: {
          if (this.known.has(value))
            return value;
          var proto_1 = Object.getPrototypeOf(value);
          var array_1 = [proto_1];
          var keys = this.sortedKeys(value);
          array_1.push(keys.json);
          var firstValueIndex_1 = array_1.length;
          keys.sorted.forEach(function(key) {
            array_1.push(_this.admit(value[key]));
          });
          var node = this.pool.lookupArray(array_1);
          if (!node.object) {
            var obj_1 = node.object = Object.create(proto_1);
            this.known.add(obj_1);
            keys.sorted.forEach(function(key, i2) {
              obj_1[key] = array_1[firstValueIndex_1 + i2];
            });
            if (__DEV__) {
              Object.freeze(obj_1);
            }
          }
          return node.object;
        }
      }
    }
    return value;
  };
  ObjectCanon2.prototype.sortedKeys = function(obj) {
    var keys = Object.keys(obj);
    var node = this.pool.lookupArray(keys);
    if (!node.keys) {
      keys.sort();
      var json = JSON.stringify(keys);
      if (!(node.keys = this.keysByJSON.get(json))) {
        this.keysByJSON.set(json, node.keys = { sorted: keys, json });
      }
    }
    return node.keys;
  };
  return ObjectCanon2;
}();
var canonicalStringify = Object.assign(function(value) {
  if (isNonNullObject(value)) {
    if (stringifyCanon === void 0) {
      resetCanonicalStringify();
    }
    var canonical = stringifyCanon.admit(value);
    var json = stringifyCache.get(canonical);
    if (json === void 0) {
      stringifyCache.set(canonical, json = JSON.stringify(canonical));
    }
    return json;
  }
  return JSON.stringify(value);
}, {
  reset: resetCanonicalStringify
});
var stringifyCanon;
var stringifyCache;
function resetCanonicalStringify() {
  stringifyCanon = new ObjectCanon();
  stringifyCache = new (canUseWeakMap ? WeakMap : Map)();
}
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    options.context.canonizeResults
  ];
}
var StoreReader = function() {
  function StoreReader2(config) {
    var _this = this;
    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
    this.config = compact(config, {
      addTypename: config.addTypename !== false,
      canonizeResults: shouldCanonizeResults(config)
    });
    this.canon = config.canon || new ObjectCanon();
    this.executeSelectionSet = wrap(function(options) {
      var _a2;
      var canonizeResults = options.context.canonizeResults;
      var peekArgs = execSelectionSetKeyArgs(options);
      peekArgs[3] = !canonizeResults;
      var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
      if (other) {
        if (canonizeResults) {
          return __assign$1(__assign$1({}, other), { result: _this.canon.admit(other.result) });
        }
        return other;
      }
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return _this.execSelectionSetImpl(options);
    }, {
      max: this.config.resultCacheMaxSize,
      keyArgs: execSelectionSetKeyArgs,
      makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
        if (supportsResultCaching(context.store)) {
          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
        }
      }
    });
    this.executeSubSelectedArray = wrap(function(options) {
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return _this.execSubSelectedArrayImpl(options);
    }, {
      max: this.config.resultCacheMaxSize,
      makeCacheKey: function(_a2) {
        var field = _a2.field, array = _a2.array, context = _a2.context;
        if (supportsResultCaching(context.store)) {
          return context.store.makeCacheKey(field, array, context.varString);
        }
      }
    });
  }
  StoreReader2.prototype.resetCanon = function() {
    this.canon = new ObjectCanon();
  };
  StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
    var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
    var policies = this.config.cache.policies;
    variables = __assign$1(__assign$1({}, getDefaultValues(getQueryDefinition(query))), variables);
    var rootRef = makeReference(rootId);
    var execResult = this.executeSelectionSet({
      selectionSet: getMainDefinition(query).selectionSet,
      objectOrReference: rootRef,
      enclosingRef: rootRef,
      context: __assign$1({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
    });
    var missing;
    if (execResult.missing) {
      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];
      if (!returnPartialData) {
        throw missing[0];
      }
    }
    return {
      result: execResult.result,
      complete: !missing,
      missing
    };
  };
  StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context) {
    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {
      var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));
      if (latest && result === latest.result) {
        return true;
      }
    }
    return false;
  };
  StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
    var _this = this;
    var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
      return {
        result: this.canon.empty,
        missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
      };
    }
    var variables = context.variables, policies = context.policies, store = context.store;
    var typename = store.getFieldValue(objectOrReference, "__typename");
    var objectsToMerge = [];
    var missing;
    var missingMerger = new DeepMerger();
    if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
      objectsToMerge.push({ __typename: typename });
    }
    function handleMissing(result2, resultName) {
      var _a3;
      if (result2.missing) {
        missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result2.missing, _a3));
      }
      return result2.result;
    }
    var workSet = new Set(selectionSet.selections);
    workSet.forEach(function(selection) {
      var _a3, _b;
      if (!shouldInclude(selection, variables))
        return;
      if (isField(selection)) {
        var fieldValue = policies.readField({
          fieldName: selection.name.value,
          field: selection,
          variables: context.variables,
          from: objectOrReference
        }, context);
        var resultName = resultKeyNameFromField(selection);
        if (fieldValue === void 0) {
          if (!addTypenameToDocument.added(selection)) {
            missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
          }
        } else if (isArray(fieldValue)) {
          fieldValue = handleMissing(_this.executeSubSelectedArray({
            field: selection,
            array: fieldValue,
            enclosingRef,
            context
          }), resultName);
        } else if (!selection.selectionSet) {
          if (context.canonizeResults) {
            fieldValue = _this.canon.pass(fieldValue);
          }
        } else if (fieldValue != null) {
          fieldValue = handleMissing(_this.executeSelectionSet({
            selectionSet: selection.selectionSet,
            objectOrReference: fieldValue,
            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
            context
          }), resultName);
        }
        if (fieldValue !== void 0) {
          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
        }
      } else {
        var fragment = getFragmentFromSelection(selection, context.lookupFragment);
        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
          throw __DEV__ ? new InvariantError("No fragment named ".concat(selection.name.value)) : new InvariantError(5);
        }
        if (fragment && policies.fragmentMatches(fragment, typename)) {
          fragment.selectionSet.selections.forEach(workSet.add, workSet);
        }
      }
    });
    var result = mergeDeepArray(objectsToMerge);
    var finalResult = { result, missing };
    var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
    if (frozen.result) {
      this.knownResults.set(frozen.result, selectionSet);
    }
    return frozen;
  };
  StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
    var _this = this;
    var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
    var missing;
    var missingMerger = new DeepMerger();
    function handleMissing(childResult, i2) {
      var _a3;
      if (childResult.missing) {
        missing = missingMerger.merge(missing, (_a3 = {}, _a3[i2] = childResult.missing, _a3));
      }
      return childResult.result;
    }
    if (field.selectionSet) {
      array = array.filter(context.store.canRead);
    }
    array = array.map(function(item, i2) {
      if (item === null) {
        return null;
      }
      if (isArray(item)) {
        return handleMissing(_this.executeSubSelectedArray({
          field,
          array: item,
          enclosingRef,
          context
        }), i2);
      }
      if (field.selectionSet) {
        return handleMissing(_this.executeSelectionSet({
          selectionSet: field.selectionSet,
          objectOrReference: item,
          enclosingRef: isReference(item) ? item : enclosingRef,
          context
        }), i2);
      }
      if (__DEV__) {
        assertSelectionSetForIdValue(context.store, field, item);
      }
      return item;
    });
    return {
      result: context.canonizeResults ? this.canon.admit(array) : array,
      missing
    };
  };
  return StoreReader2;
}();
function firstMissing(tree) {
  try {
    JSON.stringify(tree, function(_2, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result) {
    return result;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        __DEV__ ? invariant(!isReference(value), "Missing selection set for object of type ".concat(getTypenameFromStoreObject(store, value), " returned for query field ").concat(field.name.value)) : invariant(!isReference(value), 6);
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}
var currentContext = null;
var MISSING_VALUE = {};
var idCounter = 1;
var makeSlotClass = function() {
  return function() {
    function Slot2() {
      this.id = [
        "slot",
        idCounter++,
        Date.now(),
        Math.random().toString(36).slice(2)
      ].join(":");
    }
    Slot2.prototype.hasValue = function() {
      for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
        if (this.id in context_1.slots) {
          var value = context_1.slots[this.id];
          if (value === MISSING_VALUE)
            break;
          if (context_1 !== currentContext) {
            currentContext.slots[this.id] = value;
          }
          return true;
        }
      }
      if (currentContext) {
        currentContext.slots[this.id] = MISSING_VALUE;
      }
      return false;
    };
    Slot2.prototype.getValue = function() {
      if (this.hasValue()) {
        return currentContext.slots[this.id];
      }
    };
    Slot2.prototype.withValue = function(value, callback, args, thisArg) {
      var _a2;
      var slots = (_a2 = {
        __proto__: null
      }, _a2[this.id] = value, _a2);
      var parent = currentContext;
      currentContext = { parent, slots };
      try {
        return callback.apply(thisArg, args);
      } finally {
        currentContext = parent;
      }
    };
    Slot2.bind = function(callback) {
      var context = currentContext;
      return function() {
        var saved = currentContext;
        try {
          currentContext = context;
          return callback.apply(this, arguments);
        } finally {
          currentContext = saved;
        }
      };
    };
    Slot2.noContext = function(callback, args, thisArg) {
      if (currentContext) {
        var saved = currentContext;
        try {
          currentContext = null;
          return callback.apply(thisArg, args);
        } finally {
          currentContext = saved;
        }
      } else {
        return callback.apply(thisArg, args);
      }
    };
    return Slot2;
  }();
};
function maybe(fn) {
  try {
    return fn();
  } catch (ignored) {
  }
}
var globalKey = "@wry/context:Slot";
var host = maybe(function() {
  return globalThis;
}) || maybe(function() {
  return global;
}) || /* @__PURE__ */ Object.create(null);
var globalHost = host;
var Slot = globalHost[globalKey] || Array[globalKey] || function(Slot2) {
  try {
    Object.defineProperty(globalHost, globalKey, {
      value: Slot2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  } finally {
    return Slot2;
  }
}(makeSlotClass());
Slot.bind;
Slot.noContext;
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache3) {
          getCacheInfo(cache3).dep.dirty(rv);
          broadcast(cache3);
        });
        var oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches2.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches2.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object2, context) {
    var extract = function(from, key) {
      return context.readField(key, from);
    };
    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);
      if (extracted === void 0 && object2 !== context.storeObject && hasOwn.call(object2, schemaKeyPath[0])) {
        extracted = extractKeyPath(object2, schemaKeyPath, extractKey);
      }
      __DEV__ ? invariant(extracted !== void 0, "Missing field '".concat(schemaKeyPath.join("."), "' while extracting keyFields from ").concat(JSON.stringify(object2))) : invariant(extracted !== void 0, 2);
      return extracted;
    });
    return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
    var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d2 = field.directives.find(function(d3) {
            return d3.name.value === directiveName_1;
          });
          var directiveArgs = d2 && argumentsObjectFromField(d2, variables);
          return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a2;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i2 = path.length - 1; i2 >= 0; --i2) {
        toMerge = (_a2 = {}, _a2[path[i2]] = toMerge, _a2);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s2, i2) {
      if (isArray(s2)) {
        getSpecifierPaths(s2).forEach(function(p2) {
          return paths_1.push(currentPath_1.concat(p2));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s2);
        if (!isArray(spec[i2 + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object2, key) {
  return object2[key];
}
function extractKeyPath(object2, path, extract) {
  extract = extract || extractKey;
  return normalize$1(path.reduce(function reducer(obj, key) {
    return isArray(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract(obj, key);
  }, object2));
}
function normalize$1(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize$1);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}
getStoreKeyName.setStringify(canonicalStringify);
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context) {
  return context.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a2) {
  var mergeObjects = _a2.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_2, incoming) {
  return incoming;
};
var Policies = function() {
  function Policies2(config) {
    this.config = config;
    this.typePolicies = /* @__PURE__ */ Object.create(null);
    this.toBeAdded = /* @__PURE__ */ Object.create(null);
    this.supertypeMap = /* @__PURE__ */ new Map();
    this.fuzzySubtypes = /* @__PURE__ */ new Map();
    this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
    this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
    this.usingPossibleTypes = false;
    this.config = __assign$1({ dataIdFromObject: defaultDataIdFromObject }, config);
    this.cache = this.config.cache;
    this.setRootTypename("Query");
    this.setRootTypename("Mutation");
    this.setRootTypename("Subscription");
    if (config.possibleTypes) {
      this.addPossibleTypes(config.possibleTypes);
    }
    if (config.typePolicies) {
      this.addTypePolicies(config.typePolicies);
    }
  }
  Policies2.prototype.identify = function(object2, partialContext) {
    var _a2;
    var policies = this;
    var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object2.__typename;
    if (typename === this.rootTypenamesById.ROOT_QUERY) {
      return ["ROOT_QUERY"];
    }
    var storeObject = partialContext && partialContext.storeObject || object2;
    var context = __assign$1(__assign$1({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
      var options = normalizeReadFieldOptions(arguments, storeObject);
      return policies.readField(options, {
        store: policies.cache["data"],
        variables: options.variables
      });
    } });
    var id2;
    var policy = typename && this.getTypePolicy(typename);
    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
    while (keyFn) {
      var specifierOrId = keyFn(object2, context);
      if (isArray(specifierOrId)) {
        keyFn = keyFieldsFnFromSpecifier(specifierOrId);
      } else {
        id2 = specifierOrId;
        break;
      }
    }
    id2 = id2 ? String(id2) : void 0;
    return context.keyObject ? [id2, context.keyObject] : [id2];
  };
  Policies2.prototype.addTypePolicies = function(typePolicies) {
    var _this = this;
    Object.keys(typePolicies).forEach(function(typename) {
      var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest$1(_a2, ["queryType", "mutationType", "subscriptionType"]);
      if (queryType)
        _this.setRootTypename("Query", typename);
      if (mutationType)
        _this.setRootTypename("Mutation", typename);
      if (subscriptionType)
        _this.setRootTypename("Subscription", typename);
      if (hasOwn.call(_this.toBeAdded, typename)) {
        _this.toBeAdded[typename].push(incoming);
      } else {
        _this.toBeAdded[typename] = [incoming];
      }
    });
  };
  Policies2.prototype.updateTypePolicy = function(typename, incoming) {
    var _this = this;
    var existing = this.getTypePolicy(typename);
    var keyFields = incoming.keyFields, fields = incoming.fields;
    function setMerge(existing2, merge) {
      existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
    }
    setMerge(existing, incoming.merge);
    existing.keyFn = keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
    if (fields) {
      Object.keys(fields).forEach(function(fieldName) {
        var existing2 = _this.getFieldPolicy(typename, fieldName, true);
        var incoming2 = fields[fieldName];
        if (typeof incoming2 === "function") {
          existing2.read = incoming2;
        } else {
          var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
          existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
          if (typeof read === "function") {
            existing2.read = read;
          }
          setMerge(existing2, merge);
        }
        if (existing2.read && existing2.merge) {
          existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
        }
      });
    }
  };
  Policies2.prototype.setRootTypename = function(which, typename) {
    if (typename === void 0) {
      typename = which;
    }
    var rootId = "ROOT_" + which.toUpperCase();
    var old = this.rootTypenamesById[rootId];
    if (typename !== old) {
      __DEV__ ? invariant(!old || old === which, "Cannot change root ".concat(which, " __typename more than once")) : invariant(!old || old === which, 3);
      if (old)
        delete this.rootIdsByTypename[old];
      this.rootIdsByTypename[typename] = rootId;
      this.rootTypenamesById[rootId] = typename;
    }
  };
  Policies2.prototype.addPossibleTypes = function(possibleTypes) {
    var _this = this;
    this.usingPossibleTypes = true;
    Object.keys(possibleTypes).forEach(function(supertype) {
      _this.getSupertypeSet(supertype, true);
      possibleTypes[supertype].forEach(function(subtype) {
        _this.getSupertypeSet(subtype, true).add(supertype);
        var match2 = subtype.match(TypeOrFieldNameRegExp);
        if (!match2 || match2[0] !== subtype) {
          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
        }
      });
    });
  };
  Policies2.prototype.getTypePolicy = function(typename) {
    var _this = this;
    if (!hasOwn.call(this.typePolicies, typename)) {
      var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
      policy_1.fields = /* @__PURE__ */ Object.create(null);
      var supertypes = this.supertypeMap.get(typename);
      if (supertypes && supertypes.size) {
        supertypes.forEach(function(supertype) {
          var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest$1(_a2, ["fields"]);
          Object.assign(policy_1, rest);
          Object.assign(policy_1.fields, fields);
        });
      }
    }
    var inbox = this.toBeAdded[typename];
    if (inbox && inbox.length) {
      inbox.splice(0).forEach(function(policy) {
        _this.updateTypePolicy(typename, policy);
      });
    }
    return this.typePolicies[typename];
  };
  Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
    if (typename) {
      var fieldPolicies = this.getTypePolicy(typename).fields;
      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
    }
  };
  Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
    var supertypeSet = this.supertypeMap.get(subtype);
    if (!supertypeSet && createIfMissing) {
      this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
    }
    return supertypeSet;
  };
  Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
    var _this = this;
    if (!fragment.typeCondition)
      return true;
    if (!typename)
      return false;
    var supertype = fragment.typeCondition.name.value;
    if (typename === supertype)
      return true;
    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
      var typenameSupertypeSet = this.getSupertypeSet(typename, true);
      var workQueue_1 = [typenameSupertypeSet];
      var maybeEnqueue_1 = function(subtype) {
        var supertypeSet2 = _this.getSupertypeSet(subtype, false);
        if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
          workQueue_1.push(supertypeSet2);
        }
      };
      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
      var checkingFuzzySubtypes = false;
      for (var i2 = 0; i2 < workQueue_1.length; ++i2) {
        var supertypeSet = workQueue_1[i2];
        if (supertypeSet.has(supertype)) {
          if (!typenameSupertypeSet.has(supertype)) {
            if (checkingFuzzySubtypes) {
              __DEV__ && invariant.warn("Inferring subtype ".concat(typename, " of supertype ").concat(supertype));
            }
            typenameSupertypeSet.add(supertype);
          }
          return true;
        }
        supertypeSet.forEach(maybeEnqueue_1);
        if (needToCheckFuzzySubtypes && i2 === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
          needToCheckFuzzySubtypes = false;
          checkingFuzzySubtypes = true;
          this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
            var match2 = typename.match(regExp);
            if (match2 && match2[0] === typename) {
              maybeEnqueue_1(fuzzyString);
            }
          });
        }
      }
    }
    return false;
  };
  Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
    var policy = this.getFieldPolicy(typename, fieldName, false);
    return !!(policy && policy.keyFn);
  };
  Policies2.prototype.getStoreFieldName = function(fieldSpec) {
    var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
    var policy = this.getFieldPolicy(typename, fieldName, false);
    var storeFieldName;
    var keyFn = policy && policy.keyFn;
    if (keyFn && typename) {
      var context = {
        typename,
        fieldName,
        field: fieldSpec.field || null,
        variables: fieldSpec.variables
      };
      var args = argsFromFieldSpecifier(fieldSpec);
      while (keyFn) {
        var specifierOrString = keyFn(args, context);
        if (isArray(specifierOrString)) {
          keyFn = keyArgsFnFromSpecifier(specifierOrString);
        } else {
          storeFieldName = specifierOrString || fieldName;
          break;
        }
      }
    }
    if (storeFieldName === void 0) {
      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
    }
    if (storeFieldName === false) {
      return fieldName;
    }
    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
  };
  Policies2.prototype.readField = function(options, context) {
    var objectOrReference = options.from;
    if (!objectOrReference)
      return;
    var nameOrField = options.field || options.fieldName;
    if (!nameOrField)
      return;
    if (options.typename === void 0) {
      var typename = context.store.getFieldValue(objectOrReference, "__typename");
      if (typename)
        options.typename = typename;
    }
    var storeFieldName = this.getStoreFieldName(options);
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
    var policy = this.getFieldPolicy(options.typename, fieldName, false);
    var read = policy && policy.read;
    if (read) {
      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);
    }
    return existing;
  };
  Policies2.prototype.getReadFunction = function(typename, fieldName) {
    var policy = this.getFieldPolicy(typename, fieldName, false);
    return policy && policy.read;
  };
  Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
    var policy = this.getFieldPolicy(parentTypename, fieldName, false);
    var merge = policy && policy.merge;
    if (!merge && childTypename) {
      policy = this.getTypePolicy(childTypename);
      merge = policy && policy.merge;
    }
    return merge;
  };
  Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
    var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
    if (merge === mergeTrueFn) {
      return makeMergeObjectsFunction(context.store)(existing, incoming);
    }
    if (merge === mergeFalseFn) {
      return incoming;
    }
    if (context.overwrite) {
      existing = void 0;
    }
    return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename, fieldName: field.name.value, field, variables: context.variables }, context, storage || /* @__PURE__ */ Object.create(null)));
  };
  return Policies2;
}();
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context.variables;
  var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      from: argc > 1 ? from : objectOrReference
    };
  } else {
    options = __assign$1({}, fieldNameOrOptions);
    if (!hasOwn.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (__DEV__ && options.from === void 0) {
    __DEV__ && invariant.warn("Undefined 'from' passed to readField with arguments ".concat(stringifyForDisplay(Array.from(readFieldArgs))));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw __DEV__ ? new InvariantError("Cannot automatically merge arrays") : new InvariantError(4);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign$1(__assign$1({}, existing), incoming);
      }
    }
    return incoming;
  };
}
function getContextFlavor(context, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context.flavors.get(key);
  if (!flavored) {
    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign$1(__assign$1({}, context), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = function() {
  function StoreWriter2(cache2, reader, fragments) {
    this.cache = cache2;
    this.reader = reader;
    this.fragments = fragments;
  }
  StoreWriter2.prototype.writeToStore = function(store, _a2) {
    var _this = this;
    var query = _a2.query, result = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
    var operationDefinition = getOperationDefinition(query);
    var merger = makeProcessedFieldsMerger();
    variables = __assign$1(__assign$1({}, getDefaultValues(operationDefinition)), variables);
    var context = __assign$1(__assign$1({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
      return merger.merge(existing, incoming);
    }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
    var ref = this.processSelectionSet({
      result: result || /* @__PURE__ */ Object.create(null),
      dataId,
      selectionSet: operationDefinition.selectionSet,
      mergeTree: { map: /* @__PURE__ */ new Map() },
      context
    });
    if (!isReference(ref)) {
      throw __DEV__ ? new InvariantError("Could not identify object ".concat(JSON.stringify(result))) : new InvariantError(7);
    }
    context.incomingById.forEach(function(_a3, dataId2) {
      var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
      var entityRef = makeReference(dataId2);
      if (mergeTree && mergeTree.map.size) {
        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
        if (isReference(applied)) {
          return;
        }
        storeObject = applied;
      }
      if (__DEV__ && !context.overwrite) {
        var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
        fieldNodeSet.forEach(function(field) {
          if (field.selectionSet) {
            fieldsWithSelectionSets_1[field.name.value] = true;
          }
        });
        var hasSelectionSet_1 = function(storeFieldName) {
          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
        };
        var hasMergeFunction_1 = function(storeFieldName) {
          var childTree = mergeTree && mergeTree.map.get(storeFieldName);
          return Boolean(childTree && childTree.info && childTree.info.merge);
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
          }
        });
      }
      store.merge(dataId2, storeObject);
    });
    store.retain(ref.__ref);
    return ref;
  };
  StoreWriter2.prototype.processSelectionSet = function(_a2) {
    var _this = this;
    var dataId = _a2.dataId, result = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
    var policies = this.cache.policies;
    var incoming = /* @__PURE__ */ Object.create(null);
    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
    if ("string" === typeof typename) {
      incoming.__typename = typename;
    }
    var readField = function() {
      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
      if (isReference(options.from)) {
        var info = context.incomingById.get(options.from.__ref);
        if (info) {
          var result_1 = policies.readField(__assign$1(__assign$1({}, options), { from: info.storeObject }), context);
          if (result_1 !== void 0) {
            return result_1;
          }
        }
      }
      return policies.readField(options, context);
    };
    var fieldNodeSet = /* @__PURE__ */ new Set();
    this.flattenFields(selectionSet, result, context, typename).forEach(function(context2, field) {
      var _a3;
      var resultFieldKey = resultKeyNameFromField(field);
      var value = result[resultFieldKey];
      fieldNodeSet.add(field);
      if (value !== void 0) {
        var storeFieldName = policies.getStoreFieldName({
          typename,
          fieldName: field.name.value,
          field,
          variables: context2.variables
        });
        var childTree = getChildMergeTree(mergeTree, storeFieldName);
        var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context2, false, false) : context2, childTree);
        var childTypename = void 0;
        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
          childTypename = readField("__typename", incomingValue);
        }
        var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
        if (merge) {
          childTree.info = {
            field,
            typename,
            merge
          };
        } else {
          maybeRecycleChildMergeTree(mergeTree, storeFieldName);
        }
        incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
      } else if (__DEV__ && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
        __DEV__ && invariant.error("Missing field '".concat(resultKeyNameFromField(field), "' while writing result ").concat(JSON.stringify(result, null, 2)).substring(0, 1e3));
      }
    });
    try {
      var _b = policies.identify(result, {
        typename,
        selectionSet,
        fragmentMap: context.fragmentMap,
        storeObject: incoming,
        readField
      }), id2 = _b[0], keyObject = _b[1];
      dataId = dataId || id2;
      if (keyObject) {
        incoming = context.merge(incoming, keyObject);
      }
    } catch (e3) {
      if (!dataId)
        throw e3;
    }
    if ("string" === typeof dataId) {
      var dataRef = makeReference(dataId);
      var sets = context.written[dataId] || (context.written[dataId] = []);
      if (sets.indexOf(selectionSet) >= 0)
        return dataRef;
      sets.push(selectionSet);
      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
        return dataRef;
      }
      var previous_1 = context.incomingById.get(dataId);
      if (previous_1) {
        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
        fieldNodeSet.forEach(function(field) {
          return previous_1.fieldNodeSet.add(field);
        });
      } else {
        context.incomingById.set(dataId, {
          storeObject: incoming,
          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
          fieldNodeSet
        });
      }
      return dataRef;
    }
    return incoming;
  };
  StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
    var _this = this;
    if (!field.selectionSet || value === null) {
      return __DEV__ ? cloneDeep(value) : value;
    }
    if (isArray(value)) {
      return value.map(function(item, i2) {
        var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i2));
        maybeRecycleChildMergeTree(mergeTree, i2);
        return value2;
      });
    }
    return this.processSelectionSet({
      result: value,
      selectionSet: field.selectionSet,
      context,
      mergeTree
    });
  };
  StoreWriter2.prototype.flattenFields = function(selectionSet, result, context, typename) {
    if (typename === void 0) {
      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);
    }
    var fieldMap = /* @__PURE__ */ new Map();
    var policies = this.cache.policies;
    var limitingTrie = new Trie(false);
    (function flatten(selectionSet2, inheritedContext) {
      var visitedNode = limitingTrie.lookup(selectionSet2, inheritedContext.clientOnly, inheritedContext.deferred);
      if (visitedNode.visited)
        return;
      visitedNode.visited = true;
      selectionSet2.selections.forEach(function(selection) {
        if (!shouldInclude(selection, context.variables))
          return;
        var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
        if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {
          selection.directives.forEach(function(dir) {
            var name = dir.name.value;
            if (name === "client")
              clientOnly = true;
            if (name === "defer") {
              var args = argumentsObjectFromField(dir, context.variables);
              if (!args || args.if !== false) {
                deferred = true;
              }
            }
          });
        }
        if (isField(selection)) {
          var existing = fieldMap.get(selection);
          if (existing) {
            clientOnly = clientOnly && existing.clientOnly;
            deferred = deferred && existing.deferred;
          }
          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
        } else {
          var fragment = getFragmentFromSelection(selection, context.lookupFragment);
          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
            throw __DEV__ ? new InvariantError("No fragment named ".concat(selection.name.value)) : new InvariantError(8);
          }
          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {
            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
          }
        }
      });
    })(selectionSet, context);
    return fieldMap;
  };
  StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
    var _a2;
    var _this = this;
    if (mergeTree.map.size && !isReference(incoming)) {
      var e_1 = !isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
      var i_1 = incoming;
      if (e_1 && !getStorageArgs) {
        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
      }
      var changedFields_1;
      var getValue_1 = function(from, name) {
        return isArray(from) ? typeof name === "number" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));
      };
      mergeTree.map.forEach(function(childTree, storeFieldName) {
        var eVal = getValue_1(e_1, storeFieldName);
        var iVal = getValue_1(i_1, storeFieldName);
        if (void 0 === iVal)
          return;
        if (getStorageArgs) {
          getStorageArgs.push(storeFieldName);
        }
        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
        if (aVal !== iVal) {
          changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
          changedFields_1.set(storeFieldName, aVal);
        }
        if (getStorageArgs) {
          invariant(getStorageArgs.pop() === storeFieldName);
        }
      });
      if (changedFields_1) {
        incoming = isArray(i_1) ? i_1.slice(0) : __assign$1({}, i_1);
        changedFields_1.forEach(function(value, name) {
          incoming[name] = value;
        });
      }
    }
    if (mergeTree.info) {
      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
    }
    return incoming;
  };
  return StoreWriter2;
}();
var emptyMergeTreePool = [];
function getChildMergeTree(_a2, name) {
  var map2 = _a2.map;
  if (!map2.has(name)) {
    map2.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map2.get(name);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign$1(__assign$1({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map2 = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map: map2 };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a2, name) {
  var map2 = _a2.map;
  var childTree = map2.get(name);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map2.delete(name);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  __DEV__ && invariant.warn("Cache data may be lost when replacing the ".concat(fieldName, " field of a ").concat(parentType, " object.\n\nTo address this problem (which is not a bug in Apollo Client), ").concat(childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", "define a custom merge function for the ").concat(typeDotName, " field, so InMemoryCache can safely merge these objects:\n\n  existing: ").concat(JSON.stringify(existing).slice(0, 1e3), "\n  incoming: ").concat(JSON.stringify(incoming).slice(0, 1e3), "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n"));
}
var InMemoryCache = function(_super) {
  __extends(InMemoryCache2, _super);
  function InMemoryCache2(config) {
    if (config === void 0) {
      config = {};
    }
    var _this = _super.call(this) || this;
    _this.watches = /* @__PURE__ */ new Set();
    _this.typenameDocumentCache = /* @__PURE__ */ new Map();
    _this.makeVar = makeVar;
    _this.txCount = 0;
    _this.config = normalizeConfig(config);
    _this.addTypename = !!_this.config.addTypename;
    _this.policies = new Policies({
      cache: _this,
      dataIdFromObject: _this.config.dataIdFromObject,
      possibleTypes: _this.config.possibleTypes,
      typePolicies: _this.config.typePolicies
    });
    _this.init();
    return _this;
  }
  InMemoryCache2.prototype.init = function() {
    var rootStore = this.data = new EntityStore.Root({
      policies: this.policies,
      resultCaching: this.config.resultCaching
    });
    this.optimisticData = rootStore.stump;
    this.resetResultCache();
  };
  InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
    var _this = this;
    var previousReader = this.storeReader;
    var fragments = this.config.fragments;
    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
      cache: this,
      addTypename: this.addTypename,
      resultCacheMaxSize: this.config.resultCacheMaxSize,
      canonizeResults: shouldCanonizeResults(this.config),
      canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
      fragments
    }), fragments);
    this.maybeBroadcastWatch = wrap(function(c2, options) {
      return _this.broadcastWatch(c2, options);
    }, {
      max: this.config.resultCacheMaxSize,
      makeCacheKey: function(c2) {
        var store = c2.optimistic ? _this.optimisticData : _this.data;
        if (supportsResultCaching(store)) {
          var optimistic = c2.optimistic, id2 = c2.id, variables = c2.variables;
          return store.makeCacheKey(c2.query, c2.callback, canonicalStringify({ optimistic, id: id2, variables }));
        }
      }
    });
    (/* @__PURE__ */ new Set([
      this.data.group,
      this.optimisticData.group
    ])).forEach(function(group) {
      return group.resetCaching();
    });
  };
  InMemoryCache2.prototype.restore = function(data2) {
    this.init();
    if (data2)
      this.data.replace(data2);
    return this;
  };
  InMemoryCache2.prototype.extract = function(optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return (optimistic ? this.optimisticData : this.data).extract();
  };
  InMemoryCache2.prototype.read = function(options) {
    var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
    try {
      return this.storeReader.diffQueryAgainstStore(__assign$1(__assign$1({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
    } catch (e3) {
      if (e3 instanceof MissingFieldError) {
        return null;
      }
      throw e3;
    }
  };
  InMemoryCache2.prototype.write = function(options) {
    try {
      ++this.txCount;
      return this.storeWriter.writeToStore(this.data, options);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.modify = function(options) {
    if (hasOwn.call(options, "id") && !options.id) {
      return false;
    }
    var store = options.optimistic ? this.optimisticData : this.data;
    try {
      ++this.txCount;
      return store.modify(options.id || "ROOT_QUERY", options.fields);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.diff = function(options) {
    return this.storeReader.diffQueryAgainstStore(__assign$1(__assign$1({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
  };
  InMemoryCache2.prototype.watch = function(watch) {
    var _this = this;
    if (!this.watches.size) {
      recallCache(this);
    }
    this.watches.add(watch);
    if (watch.immediate) {
      this.maybeBroadcastWatch(watch);
    }
    return function() {
      if (_this.watches.delete(watch) && !_this.watches.size) {
        forgetCache(_this);
      }
      _this.maybeBroadcastWatch.forget(watch);
    };
  };
  InMemoryCache2.prototype.gc = function(options) {
    canonicalStringify.reset();
    var ids = this.optimisticData.gc();
    if (options && !this.txCount) {
      if (options.resetResultCache) {
        this.resetResultCache(options.resetResultIdentities);
      } else if (options.resetResultIdentities) {
        this.storeReader.resetCanon();
      }
    }
    return ids;
  };
  InMemoryCache2.prototype.retain = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).retain(rootId);
  };
  InMemoryCache2.prototype.release = function(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).release(rootId);
  };
  InMemoryCache2.prototype.identify = function(object2) {
    if (isReference(object2))
      return object2.__ref;
    try {
      return this.policies.identify(object2)[0];
    } catch (e3) {
      __DEV__ && invariant.warn(e3);
    }
  };
  InMemoryCache2.prototype.evict = function(options) {
    if (!options.id) {
      if (hasOwn.call(options, "id")) {
        return false;
      }
      options = __assign$1(__assign$1({}, options), { id: "ROOT_QUERY" });
    }
    try {
      ++this.txCount;
      return this.optimisticData.evict(options, this.data);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  };
  InMemoryCache2.prototype.reset = function(options) {
    var _this = this;
    this.init();
    canonicalStringify.reset();
    if (options && options.discardWatches) {
      this.watches.forEach(function(watch) {
        return _this.maybeBroadcastWatch.forget(watch);
      });
      this.watches.clear();
      forgetCache(this);
    } else {
      this.broadcastWatches();
    }
    return Promise.resolve();
  };
  InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
    if (newOptimisticData !== this.optimisticData) {
      this.optimisticData = newOptimisticData;
      this.broadcastWatches();
    }
  };
  InMemoryCache2.prototype.batch = function(options) {
    var _this = this;
    var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
    var updateResult;
    var perform = function(layer) {
      var _a3 = _this, data2 = _a3.data, optimisticData = _a3.optimisticData;
      ++_this.txCount;
      if (layer) {
        _this.data = _this.optimisticData = layer;
      }
      try {
        return updateResult = update(_this);
      } finally {
        --_this.txCount;
        _this.data = data2;
        _this.optimisticData = optimisticData;
      }
    };
    var alreadyDirty = /* @__PURE__ */ new Set();
    if (onWatchUpdated && !this.txCount) {
      this.broadcastWatches(__assign$1(__assign$1({}, options), { onWatchUpdated: function(watch) {
        alreadyDirty.add(watch);
        return false;
      } }));
    }
    if (typeof optimistic === "string") {
      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
    } else if (optimistic === false) {
      perform(this.data);
    } else {
      perform();
    }
    if (typeof removeOptimistic === "string") {
      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
    }
    if (onWatchUpdated && alreadyDirty.size) {
      this.broadcastWatches(__assign$1(__assign$1({}, options), { onWatchUpdated: function(watch, diff2) {
        var result = onWatchUpdated.call(this, watch, diff2);
        if (result !== false) {
          alreadyDirty.delete(watch);
        }
        return result;
      } }));
      if (alreadyDirty.size) {
        alreadyDirty.forEach(function(watch) {
          return _this.maybeBroadcastWatch.dirty(watch);
        });
      }
    } else {
      this.broadcastWatches(options);
    }
    return updateResult;
  };
  InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
    return this.batch({
      update,
      optimistic: optimisticId || optimisticId !== null
    });
  };
  InMemoryCache2.prototype.transformDocument = function(document2) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document2);
      if (!result) {
        result = addTypenameToDocument(document2);
        this.typenameDocumentCache.set(document2, result);
        this.typenameDocumentCache.set(result, result);
      }
      return result;
    }
    return document2;
  };
  InMemoryCache2.prototype.transformForLink = function(document2) {
    var fragments = this.config.fragments;
    return fragments ? fragments.transform(document2) : document2;
  };
  InMemoryCache2.prototype.broadcastWatches = function(options) {
    var _this = this;
    if (!this.txCount) {
      this.watches.forEach(function(c2) {
        return _this.maybeBroadcastWatch(c2, options);
      });
    }
  };
  InMemoryCache2.prototype.broadcastWatch = function(c2, options) {
    var lastDiff = c2.lastDiff;
    var diff2 = this.diff(c2);
    if (options) {
      if (c2.optimistic && typeof options.optimistic === "string") {
        diff2.fromOptimisticTransaction = true;
      }
      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c2, diff2, lastDiff) === false) {
        return;
      }
    }
    if (!lastDiff || !equal(lastDiff.result, diff2.result)) {
      c2.callback(c2.lastDiff = diff2, lastDiff);
    }
  };
  return InMemoryCache2;
}(ApolloCache);
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var message = "";
  if (isNonEmptyArray(err.graphQLErrors) || isNonEmptyArray(err.clientErrors)) {
    var errors2 = (err.graphQLErrors || []).concat(err.clientErrors || []);
    errors2.forEach(function(error) {
      var errorMessage = error ? error.message : "Error message not found.";
      message += "".concat(errorMessage, "\n");
    });
  }
  if (err.networkError) {
    message += "".concat(err.networkError.message, "\n");
  }
  message = message.replace(/\n$/, "");
  return message;
};
var ApolloError = function(_super) {
  __extends(ApolloError2, _super);
  function ApolloError2(_a2) {
    var graphQLErrors = _a2.graphQLErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
    var _this = _super.call(this, errorMessage) || this;
    _this.graphQLErrors = graphQLErrors || [];
    _this.clientErrors = clientErrors || [];
    _this.networkError = networkError || null;
    _this.message = errorMessage || generateErrorMessage(_this);
    _this.extraInfo = extraInfo;
    _this.__proto__ = ApolloError2.prototype;
    return _this;
  }
  return ApolloError2;
}(Error);
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}
var assign = Object.assign, hasOwnProperty$3 = Object.hasOwnProperty;
var ObservableQuery = function(_super) {
  __extends(ObservableQuery2, _super);
  function ObservableQuery2(_a2) {
    var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
    var _this = _super.call(this, function(observer) {
      try {
        var subObserver = observer._subscription._observer;
        if (subObserver && !subObserver.error) {
          subObserver.error = defaultSubscriptionObserverErrorCallback;
        }
      } catch (_a3) {
      }
      var first = !_this.observers.size;
      _this.observers.add(observer);
      var last = _this.last;
      if (last && last.error) {
        observer.error && observer.error(last.error);
      } else if (last && last.result) {
        observer.next && observer.next(last.result);
      }
      if (first) {
        _this.reobserve().catch(function() {
        });
      }
      return function() {
        if (_this.observers.delete(observer) && !_this.observers.size) {
          _this.tearDownQuery();
        }
      };
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.subscriptions = /* @__PURE__ */ new Set();
    _this.queryInfo = queryInfo;
    _this.queryManager = queryManager;
    _this.isTornDown = false;
    var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
    var _e2 = options.fetchPolicy, fetchPolicy = _e2 === void 0 ? defaultFetchPolicy : _e2, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
    _this.options = __assign$1(__assign$1({}, options), { initialFetchPolicy, fetchPolicy });
    _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
    var opDef = getOperationDefinition(_this.query);
    _this.queryName = opDef && opDef.name && opDef.name.value;
    return _this;
  }
  Object.defineProperty(ObservableQuery2.prototype, "query", {
    get: function() {
      return this.queryManager.transform(this.options.query).document;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObservableQuery2.prototype, "variables", {
    get: function() {
      return this.options.variables;
    },
    enumerable: false,
    configurable: true
  });
  ObservableQuery2.prototype.result = function() {
    var _this = this;
    return new Promise(function(resolve2, reject) {
      var observer = {
        next: function(result) {
          resolve2(result);
          _this.observers.delete(observer);
          if (!_this.observers.size) {
            _this.queryManager.removeQuery(_this.queryId);
          }
          setTimeout(function() {
            subscription.unsubscribe();
          }, 0);
        },
        error: reject
      };
      var subscription = _this.subscribe(observer);
    });
  };
  ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
    if (saveAsLastResult === void 0) {
      saveAsLastResult = true;
    }
    var lastResult = this.getLastResult(true);
    var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
    var result = __assign$1(__assign$1({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
    var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
    if (fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby" || this.queryManager.transform(this.options.query).hasForcedResolvers)
      ;
    else {
      var diff2 = this.queryInfo.getDiff();
      if (diff2.complete || this.options.returnPartialData) {
        result.data = diff2.result;
      }
      if (equal(result.data, {})) {
        result.data = void 0;
      }
      if (diff2.complete) {
        delete result.partial;
        if (diff2.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
          result.networkStatus = NetworkStatus.ready;
          result.loading = false;
        }
      } else {
        result.partial = true;
      }
      if (__DEV__ && !diff2.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
        logMissingFieldErrors(diff2.missing);
      }
    }
    if (saveAsLastResult) {
      this.updateLastResult(result);
    }
    return result;
  };
  ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
    return !this.last || !equal(this.last.result, newResult) || variables && !equal(this.last.variables, variables);
  };
  ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
    var last = this.last;
    if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
      return last[key];
    }
  };
  ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
    return this.getLast("result", variablesMustMatch);
  };
  ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
    return this.getLast("error", variablesMustMatch);
  };
  ObservableQuery2.prototype.resetLastResults = function() {
    delete this.last;
    this.isTornDown = false;
  };
  ObservableQuery2.prototype.resetQueryStoreErrors = function() {
    this.queryManager.resetErrors(this.queryId);
  };
  ObservableQuery2.prototype.refetch = function(variables) {
    var _a2;
    var reobserveOptions = {
      pollInterval: 0
    };
    var fetchPolicy = this.options.fetchPolicy;
    if (fetchPolicy === "cache-and-network") {
      reobserveOptions.fetchPolicy = fetchPolicy;
    } else if (fetchPolicy === "no-cache") {
      reobserveOptions.fetchPolicy = "no-cache";
    } else {
      reobserveOptions.fetchPolicy = "network-only";
    }
    if (__DEV__ && variables && hasOwnProperty$3.call(variables, "variables")) {
      var queryDef = getQueryDefinition(this.query);
      var vars = queryDef.variableDefinitions;
      if (!vars || !vars.some(function(v2) {
        return v2.variable.name.value === "variables";
      })) {
        __DEV__ && invariant.warn("Called refetch(".concat(JSON.stringify(variables), ") for query ").concat(((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || JSON.stringify(queryDef), ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"));
      }
    }
    if (variables && !equal(this.options.variables, variables)) {
      reobserveOptions.variables = this.options.variables = __assign$1(__assign$1({}, this.options.variables), variables);
    }
    this.queryInfo.resetLastWrite();
    return this.reobserve(reobserveOptions, NetworkStatus.refetch);
  };
  ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
    var _this = this;
    var combinedOptions = __assign$1(__assign$1({}, fetchMoreOptions.query ? fetchMoreOptions : __assign$1(__assign$1(__assign$1(__assign$1({}, this.options), { query: this.query }), fetchMoreOptions), { variables: __assign$1(__assign$1({}, this.options.variables), fetchMoreOptions.variables) })), { fetchPolicy: "no-cache" });
    var qid = this.queryManager.generateQueryId();
    var queryInfo = this.queryInfo;
    var originalNetworkStatus = queryInfo.networkStatus;
    queryInfo.networkStatus = NetworkStatus.fetchMore;
    if (combinedOptions.notifyOnNetworkStatusChange) {
      this.observe();
    }
    var updatedQuerySet = /* @__PURE__ */ new Set();
    return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
      _this.queryManager.removeQuery(qid);
      if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
        queryInfo.networkStatus = originalNetworkStatus;
      }
      _this.queryManager.cache.batch({
        update: function(cache2) {
          var updateQuery = fetchMoreOptions.updateQuery;
          if (updateQuery) {
            cache2.updateQuery({
              query: _this.query,
              variables: _this.variables,
              returnPartialData: true,
              optimistic: false
            }, function(previous) {
              return updateQuery(previous, {
                fetchMoreResult: fetchMoreResult.data,
                variables: combinedOptions.variables
              });
            });
          } else {
            cache2.writeQuery({
              query: combinedOptions.query,
              variables: combinedOptions.variables,
              data: fetchMoreResult.data
            });
          }
        },
        onWatchUpdated: function(watch) {
          updatedQuerySet.add(watch.query);
        }
      });
      return fetchMoreResult;
    }).finally(function() {
      if (!updatedQuerySet.has(_this.query)) {
        reobserveCacheFirst(_this);
      }
    });
  };
  ObservableQuery2.prototype.subscribeToMore = function(options) {
    var _this = this;
    var subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables,
      context: options.context
    }).subscribe({
      next: function(subscriptionData) {
        var updateQuery = options.updateQuery;
        if (updateQuery) {
          _this.updateQuery(function(previous, _a2) {
            var variables = _a2.variables;
            return updateQuery(previous, {
              subscriptionData,
              variables
            });
          });
        }
      },
      error: function(err) {
        if (options.onError) {
          options.onError(err);
          return;
        }
        __DEV__ && invariant.error("Unhandled GraphQL subscription error", err);
      }
    });
    this.subscriptions.add(subscription);
    return function() {
      if (_this.subscriptions.delete(subscription)) {
        subscription.unsubscribe();
      }
    };
  };
  ObservableQuery2.prototype.setOptions = function(newOptions) {
    return this.reobserve(newOptions);
  };
  ObservableQuery2.prototype.setVariables = function(variables) {
    if (equal(this.variables, variables)) {
      return this.observers.size ? this.result() : Promise.resolve();
    }
    this.options.variables = variables;
    if (!this.observers.size) {
      return Promise.resolve();
    }
    return this.reobserve({
      fetchPolicy: this.options.initialFetchPolicy,
      variables
    }, NetworkStatus.setVariables);
  };
  ObservableQuery2.prototype.updateQuery = function(mapFn) {
    var queryManager = this.queryManager;
    var result = queryManager.cache.diff({
      query: this.options.query,
      variables: this.variables,
      returnPartialData: true,
      optimistic: false
    }).result;
    var newResult = mapFn(result, {
      variables: this.variables
    });
    if (newResult) {
      queryManager.cache.writeQuery({
        query: this.options.query,
        data: newResult,
        variables: this.variables
      });
      queryManager.broadcastQueries();
    }
  };
  ObservableQuery2.prototype.startPolling = function(pollInterval) {
    this.options.pollInterval = pollInterval;
    this.updatePolling();
  };
  ObservableQuery2.prototype.stopPolling = function() {
    this.options.pollInterval = 0;
    this.updatePolling();
  };
  ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
    if (options.nextFetchPolicy) {
      var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
      if (fetchPolicy === "standby")
        ;
      else if (typeof options.nextFetchPolicy === "function") {
        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
          reason,
          options,
          observable: this,
          initialFetchPolicy
        });
      } else if (reason === "variables-changed") {
        options.fetchPolicy = initialFetchPolicy;
      } else {
        options.fetchPolicy = options.nextFetchPolicy;
      }
    }
    return options.fetchPolicy;
  };
  ObservableQuery2.prototype.fetch = function(options, newNetworkStatus) {
    this.queryManager.setObservableQuery(this);
    return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
  };
  ObservableQuery2.prototype.updatePolling = function() {
    var _this = this;
    if (this.queryManager.ssrMode) {
      return;
    }
    var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
    if (!pollInterval) {
      if (pollingInfo) {
        clearTimeout(pollingInfo.timeout);
        delete this.pollingInfo;
      }
      return;
    }
    if (pollingInfo && pollingInfo.interval === pollInterval) {
      return;
    }
    __DEV__ ? invariant(pollInterval, "Attempted to start a polling query without a polling interval.") : invariant(pollInterval, 12);
    var info = pollingInfo || (this.pollingInfo = {});
    info.interval = pollInterval;
    var maybeFetch = function() {
      if (_this.pollingInfo) {
        if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
          _this.reobserve({
            fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
          }, NetworkStatus.poll).then(poll, poll);
        } else {
          poll();
        }
      }
    };
    var poll = function() {
      var info2 = _this.pollingInfo;
      if (info2) {
        clearTimeout(info2.timeout);
        info2.timeout = setTimeout(maybeFetch, info2.interval);
      }
    };
    poll();
  };
  ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
    if (variables === void 0) {
      variables = this.variables;
    }
    this.last = __assign$1(__assign$1({}, this.last), { result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables });
    if (!isNonEmptyArray(newResult.errors)) {
      delete this.last.error;
    }
    return this.last;
  };
  ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
    var _this = this;
    this.isTornDown = false;
    var useDisposableConcast = newNetworkStatus === NetworkStatus.refetch || newNetworkStatus === NetworkStatus.fetchMore || newNetworkStatus === NetworkStatus.poll;
    var oldVariables = this.options.variables;
    var oldFetchPolicy = this.options.fetchPolicy;
    var mergedOptions = compact(this.options, newOptions || {});
    var options = useDisposableConcast ? mergedOptions : assign(this.options, mergedOptions);
    if (!useDisposableConcast) {
      this.updatePolling();
      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && options.fetchPolicy === oldFetchPolicy) {
        this.applyNextFetchPolicy("variables-changed", options);
        if (newNetworkStatus === void 0) {
          newNetworkStatus = NetworkStatus.setVariables;
        }
      }
    }
    var variables = options.variables && __assign$1({}, options.variables);
    var concast = this.fetch(options, newNetworkStatus);
    var observer = {
      next: function(result) {
        _this.reportResult(result, variables);
      },
      error: function(error) {
        _this.reportError(error, variables);
      }
    };
    if (!useDisposableConcast) {
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
      }
      this.concast = concast;
      this.observer = observer;
    }
    concast.addObserver(observer);
    return concast.promise;
  };
  ObservableQuery2.prototype.observe = function() {
    this.reportResult(this.getCurrentResult(false), this.variables);
  };
  ObservableQuery2.prototype.reportResult = function(result, variables) {
    var lastError = this.getLastError();
    if (lastError || this.isDifferentFromLastResult(result, variables)) {
      if (lastError || !result.partial || this.options.returnPartialData) {
        this.updateLastResult(result, variables);
      }
      iterateObserversSafely(this.observers, "next", result);
    }
  };
  ObservableQuery2.prototype.reportError = function(error, variables) {
    var errorResult = __assign$1(__assign$1({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
    this.updateLastResult(errorResult, variables);
    iterateObserversSafely(this.observers, "error", this.last.error = error);
  };
  ObservableQuery2.prototype.hasObservers = function() {
    return this.observers.size > 0;
  };
  ObservableQuery2.prototype.tearDownQuery = function() {
    if (this.isTornDown)
      return;
    if (this.concast && this.observer) {
      this.concast.removeObserver(this.observer);
      delete this.concast;
      delete this.observer;
    }
    this.stopPolling();
    this.subscriptions.forEach(function(sub) {
      return sub.unsubscribe();
    });
    this.subscriptions.clear();
    this.queryManager.stopQuery(this.queryId);
    this.observers.clear();
    this.isTornDown = true;
  };
  return ObservableQuery2;
}(Observable);
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      nextFetchPolicy: function() {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof nextFetchPolicy === "function") {
          return nextFetchPolicy.apply(this, arguments);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  __DEV__ && invariant.error("Unhandled error", error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (__DEV__ && missing) {
    __DEV__ && invariant.debug("Missing cache result fields: ".concat(JSON.stringify(missing)), missing);
  }
}
var LocalState = function() {
  function LocalState2(_a2) {
    var cache2 = _a2.cache, client2 = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
    this.cache = cache2;
    if (client2) {
      this.client = client2;
    }
    if (resolvers) {
      this.addResolvers(resolvers);
    }
    if (fragmentMatcher) {
      this.setFragmentMatcher(fragmentMatcher);
    }
  }
  LocalState2.prototype.addResolvers = function(resolvers) {
    var _this = this;
    this.resolvers = this.resolvers || {};
    if (Array.isArray(resolvers)) {
      resolvers.forEach(function(resolverGroup) {
        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
      });
    } else {
      this.resolvers = mergeDeep(this.resolvers, resolvers);
    }
  };
  LocalState2.prototype.setResolvers = function(resolvers) {
    this.resolvers = {};
    this.addResolvers(resolvers);
  };
  LocalState2.prototype.getResolvers = function() {
    return this.resolvers || {};
  };
  LocalState2.prototype.runResolvers = function(_a2) {
    var document2 = _a2.document, remoteResult = _a2.remoteResult, context = _a2.context, variables = _a2.variables, _b = _a2.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
    return __awaiter$2(this, void 0, void 0, function() {
      return __generator$1(this, function(_c) {
        if (document2) {
          return [2, this.resolveDocument(document2, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
            return __assign$1(__assign$1({}, remoteResult), { data: localResult.result });
          })];
        }
        return [2, remoteResult];
      });
    });
  };
  LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
    this.fragmentMatcher = fragmentMatcher;
  };
  LocalState2.prototype.getFragmentMatcher = function() {
    return this.fragmentMatcher;
  };
  LocalState2.prototype.clientQuery = function(document2) {
    if (hasDirectives(["client"], document2)) {
      if (this.resolvers) {
        return document2;
      }
    }
    return null;
  };
  LocalState2.prototype.serverQuery = function(document2) {
    return removeClientSetsFromDocument(document2);
  };
  LocalState2.prototype.prepareContext = function(context) {
    var cache2 = this.cache;
    return __assign$1(__assign$1({}, context), { cache: cache2, getCacheKey: function(obj) {
      return cache2.identify(obj);
    } });
  };
  LocalState2.prototype.addExportedVariables = function(document2, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (context === void 0) {
      context = {};
    }
    return __awaiter$2(this, void 0, void 0, function() {
      return __generator$1(this, function(_a2) {
        if (document2) {
          return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context), variables).then(function(data2) {
            return __assign$1(__assign$1({}, variables), data2.exportedVariables);
          })];
        }
        return [2, __assign$1({}, variables)];
      });
    });
  };
  LocalState2.prototype.shouldForceResolvers = function(document2) {
    var forceResolvers = false;
    visit(document2, {
      Directive: {
        enter: function(node) {
          if (node.name.value === "client" && node.arguments) {
            forceResolvers = node.arguments.some(function(arg) {
              return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
            });
            if (forceResolvers) {
              return BREAK;
            }
          }
        }
      }
    });
    return forceResolvers;
  };
  LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
    return this.cache.diff({
      query: buildQueryFromSelectionSet(document2),
      variables,
      returnPartialData: true,
      optimistic: false
    }).result;
  };
  LocalState2.prototype.resolveDocument = function(document2, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
    if (context === void 0) {
      context = {};
    }
    if (variables === void 0) {
      variables = {};
    }
    if (fragmentMatcher === void 0) {
      fragmentMatcher = function() {
        return true;
      };
    }
    if (onlyRunForcedResolvers === void 0) {
      onlyRunForcedResolvers = false;
    }
    return __awaiter$2(this, void 0, void 0, function() {
      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a2, cache2, client2, execContext;
      return __generator$1(this, function(_b) {
        mainDefinition = getMainDefinition(document2);
        fragments = getFragmentDefinitions(document2);
        fragmentMap = createFragmentMap(fragments);
        definitionOperation = mainDefinition.operation;
        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
        _a2 = this, cache2 = _a2.cache, client2 = _a2.client;
        execContext = {
          fragmentMap,
          context: __assign$1(__assign$1({}, context), { cache: cache2, client: client2 }),
          variables,
          fragmentMatcher,
          defaultOperationType,
          exportedVariables: {},
          onlyRunForcedResolvers
        };
        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result) {
          return {
            result,
            exportedVariables: execContext.exportedVariables
          };
        })];
      });
    });
  };
  LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
    return __awaiter$2(this, void 0, void 0, function() {
      var fragmentMap, context, variables, resultsToMerge, execute2;
      var _this = this;
      return __generator$1(this, function(_a2) {
        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
        resultsToMerge = [rootValue];
        execute2 = function(selection) {
          return __awaiter$2(_this, void 0, void 0, function() {
            var fragment, typeCondition;
            return __generator$1(this, function(_a3) {
              if (!shouldInclude(selection, variables)) {
                return [2];
              }
              if (isField(selection)) {
                return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                  var _a4;
                  if (typeof fieldResult !== "undefined") {
                    resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                  }
                })];
              }
              if (isInlineFragment(selection)) {
                fragment = selection;
              } else {
                fragment = fragmentMap[selection.name.value];
                __DEV__ ? invariant(fragment, "No fragment named ".concat(selection.name.value)) : invariant(fragment, 11);
              }
              if (fragment && fragment.typeCondition) {
                typeCondition = fragment.typeCondition.name.value;
                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                    resultsToMerge.push(fragmentResult);
                  })];
                }
              }
              return [2];
            });
          });
        };
        return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
          return mergeDeepArray(resultsToMerge);
        })];
      });
    });
  };
  LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
    return __awaiter$2(this, void 0, void 0, function() {
      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve2;
      var _this = this;
      return __generator$1(this, function(_a2) {
        variables = execContext.variables;
        fieldName = field.name.value;
        aliasedFieldName = resultKeyNameFromField(field);
        aliasUsed = fieldName !== aliasedFieldName;
        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
        resultPromise = Promise.resolve(defaultResult);
        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
          resolverType = rootValue.__typename || execContext.defaultOperationType;
          resolverMap = this.resolvers && this.resolvers[resolverType];
          if (resolverMap) {
            resolve2 = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
            if (resolve2) {
              resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve2, [
                rootValue,
                argumentsObjectFromField(field, variables),
                execContext.context,
                { field, fragmentMap: execContext.fragmentMap }
              ]));
            }
          }
        }
        return [2, resultPromise.then(function(result) {
          if (result === void 0) {
            result = defaultResult;
          }
          if (field.directives) {
            field.directives.forEach(function(directive) {
              if (directive.name.value === "export" && directive.arguments) {
                directive.arguments.forEach(function(arg) {
                  if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                    execContext.exportedVariables[arg.value.value] = result;
                  }
                });
              }
            });
          }
          if (!field.selectionSet) {
            return result;
          }
          if (result == null) {
            return result;
          }
          if (Array.isArray(result)) {
            return _this.resolveSubSelectedArray(field, result, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
          }
        })];
      });
    });
  };
  LocalState2.prototype.resolveSubSelectedArray = function(field, result, execContext) {
    var _this = this;
    return Promise.all(result.map(function(item) {
      if (item === null) {
        return null;
      }
      if (Array.isArray(item)) {
        return _this.resolveSubSelectedArray(field, item, execContext);
      }
      if (field.selectionSet) {
        return _this.resolveSelectionSet(field.selectionSet, item, execContext);
      }
    }));
  };
  return LocalState2;
}();
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(cache2, (destructiveMethodCounts.get(cache2) + 1) % 1e15);
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = function() {
  function QueryInfo2(queryManager, queryId) {
    if (queryId === void 0) {
      queryId = queryManager.generateQueryId();
    }
    this.queryId = queryId;
    this.listeners = /* @__PURE__ */ new Set();
    this.document = null;
    this.lastRequestId = 1;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.stopped = false;
    this.dirty = false;
    this.observableQuery = null;
    var cache2 = this.cache = queryManager.cache;
    if (!destructiveMethodCounts.has(cache2)) {
      destructiveMethodCounts.set(cache2, 0);
      wrapDestructiveCacheMethod(cache2, "evict");
      wrapDestructiveCacheMethod(cache2, "modify");
      wrapDestructiveCacheMethod(cache2, "reset");
    }
  }
  QueryInfo2.prototype.init = function(query) {
    var networkStatus = query.networkStatus || NetworkStatus.loading;
    if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
      networkStatus = NetworkStatus.setVariables;
    }
    if (!equal(query.variables, this.variables)) {
      this.lastDiff = void 0;
    }
    Object.assign(this, {
      document: query.document,
      variables: query.variables,
      networkError: null,
      graphQLErrors: this.graphQLErrors || [],
      networkStatus
    });
    if (query.observableQuery) {
      this.setObservableQuery(query.observableQuery);
    }
    if (query.lastRequestId) {
      this.lastRequestId = query.lastRequestId;
    }
    return this;
  };
  QueryInfo2.prototype.reset = function() {
    cancelNotifyTimeout(this);
    this.dirty = false;
  };
  QueryInfo2.prototype.getDiff = function(variables) {
    if (variables === void 0) {
      variables = this.variables;
    }
    var options = this.getDiffOptions(variables);
    if (this.lastDiff && equal(options, this.lastDiff.options)) {
      return this.lastDiff.diff;
    }
    this.updateWatch(this.variables = variables);
    var oq = this.observableQuery;
    if (oq && oq.options.fetchPolicy === "no-cache") {
      return { complete: false };
    }
    var diff2 = this.cache.diff(options);
    this.updateLastDiff(diff2, options);
    return diff2;
  };
  QueryInfo2.prototype.updateLastDiff = function(diff2, options) {
    this.lastDiff = diff2 ? {
      diff: diff2,
      options: options || this.getDiffOptions()
    } : void 0;
  };
  QueryInfo2.prototype.getDiffOptions = function(variables) {
    var _a2;
    if (variables === void 0) {
      variables = this.variables;
    }
    return {
      query: this.document,
      variables,
      returnPartialData: true,
      optimistic: true,
      canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
    };
  };
  QueryInfo2.prototype.setDiff = function(diff2) {
    var _this = this;
    var oldDiff = this.lastDiff && this.lastDiff.diff;
    this.updateLastDiff(diff2);
    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff2 && diff2.result)) {
      this.dirty = true;
      if (!this.notifyTimeout) {
        this.notifyTimeout = setTimeout(function() {
          return _this.notify();
        }, 0);
      }
    }
  };
  QueryInfo2.prototype.setObservableQuery = function(oq) {
    var _this = this;
    if (oq === this.observableQuery)
      return;
    if (this.oqListener) {
      this.listeners.delete(this.oqListener);
    }
    this.observableQuery = oq;
    if (oq) {
      oq["queryInfo"] = this;
      this.listeners.add(this.oqListener = function() {
        var diff2 = _this.getDiff();
        if (diff2.fromOptimisticTransaction) {
          oq["observe"]();
        } else {
          reobserveCacheFirst(oq);
        }
      });
    } else {
      delete this.oqListener;
    }
  };
  QueryInfo2.prototype.notify = function() {
    var _this = this;
    cancelNotifyTimeout(this);
    if (this.shouldNotify()) {
      this.listeners.forEach(function(listener) {
        return listener(_this);
      });
    }
    this.dirty = false;
  };
  QueryInfo2.prototype.shouldNotify = function() {
    if (!this.dirty || !this.listeners.size) {
      return false;
    }
    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
      var fetchPolicy = this.observableQuery.options.fetchPolicy;
      if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
        return false;
      }
    }
    return true;
  };
  QueryInfo2.prototype.stop = function() {
    if (!this.stopped) {
      this.stopped = true;
      this.reset();
      this.cancel();
      this.cancel = QueryInfo2.prototype.cancel;
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      var oq = this.observableQuery;
      if (oq)
        oq.stopPolling();
    }
  };
  QueryInfo2.prototype.cancel = function() {
  };
  QueryInfo2.prototype.updateWatch = function(variables) {
    var _this = this;
    if (variables === void 0) {
      variables = this.variables;
    }
    var oq = this.observableQuery;
    if (oq && oq.options.fetchPolicy === "no-cache") {
      return;
    }
    var watchOptions = __assign$1(__assign$1({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff2) {
      return _this.setDiff(diff2);
    } });
    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
      this.cancel();
      this.cancel = this.cache.watch(this.lastWatch = watchOptions);
    }
  };
  QueryInfo2.prototype.resetLastWrite = function() {
    this.lastWrite = void 0;
  };
  QueryInfo2.prototype.shouldWrite = function(result, variables) {
    var lastWrite = this.lastWrite;
    return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));
  };
  QueryInfo2.prototype.markResult = function(result, document2, options, cacheWriteBehavior) {
    var _this = this;
    var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
    this.reset();
    if ("incremental" in result && isNonEmptyArray(result.incremental)) {
      var mergedData_1 = this.getDiff().result;
      var merger_1 = new DeepMerger();
      result.incremental.forEach(function(_a2) {
        var data2 = _a2.data, path = _a2.path, errors2 = _a2.errors;
        for (var i2 = path.length - 1; i2 >= 0; --i2) {
          var key = path[i2];
          var isNumericKey = !isNaN(+key);
          var parent_1 = isNumericKey ? [] : {};
          parent_1[key] = data2;
          data2 = parent_1;
        }
        if (errors2) {
          graphQLErrors.push.apply(graphQLErrors, errors2);
        }
        mergedData_1 = merger_1.merge(mergedData_1, data2);
      });
      result.data = mergedData_1;
    }
    this.graphQLErrors = graphQLErrors;
    if (options.fetchPolicy === "no-cache") {
      this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
    } else if (cacheWriteBehavior !== 0) {
      if (shouldWriteResult(result, options.errorPolicy)) {
        this.cache.performTransaction(function(cache2) {
          if (_this.shouldWrite(result, options.variables)) {
            cache2.writeQuery({
              query: document2,
              data: result.data,
              variables: options.variables,
              overwrite: cacheWriteBehavior === 1
            });
            _this.lastWrite = {
              result,
              variables: options.variables,
              dmCount: destructiveMethodCounts.get(_this.cache)
            };
          } else {
            if (_this.lastDiff && _this.lastDiff.diff.complete) {
              result.data = _this.lastDiff.diff.result;
              return;
            }
          }
          var diffOptions = _this.getDiffOptions(options.variables);
          var diff2 = cache2.diff(diffOptions);
          if (!_this.stopped) {
            _this.updateWatch(options.variables);
          }
          _this.updateLastDiff(diff2, diffOptions);
          if (diff2.complete) {
            result.data = diff2.result;
          }
        });
      } else {
        this.lastWrite = void 0;
      }
    }
  };
  QueryInfo2.prototype.markReady = function() {
    this.networkError = null;
    return this.networkStatus = NetworkStatus.ready;
  };
  QueryInfo2.prototype.markError = function(error) {
    this.networkStatus = NetworkStatus.error;
    this.lastWrite = void 0;
    this.reset();
    if (error.graphQLErrors) {
      this.graphQLErrors = error.graphQLErrors;
    }
    if (error.networkError) {
      this.networkError = error.networkError;
    }
    return error;
  };
  return QueryInfo2;
}();
function shouldWriteResult(result, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var QueryManager = function() {
  function QueryManager2(_a2) {
    var cache2 = _a2.cache, link = _a2.link, defaultOptions2 = _a2.defaultOptions, _b = _a2.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a2.onBroadcast, _c = _a2.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a2.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a2.localState, assumeImmutableResults = _a2.assumeImmutableResults;
    this.clientAwareness = {};
    this.queries = /* @__PURE__ */ new Map();
    this.fetchCancelFns = /* @__PURE__ */ new Map();
    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
    this.queryIdCounter = 1;
    this.requestIdCounter = 1;
    this.mutationIdCounter = 1;
    this.inFlightLinkObservables = /* @__PURE__ */ new Map();
    this.cache = cache2;
    this.link = link;
    this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
    this.queryDeduplication = queryDeduplication;
    this.clientAwareness = clientAwareness;
    this.localState = localState || new LocalState({ cache: cache2 });
    this.ssrMode = ssrMode;
    this.assumeImmutableResults = !!assumeImmutableResults;
    if (this.onBroadcast = onBroadcast) {
      this.mutationStore = /* @__PURE__ */ Object.create(null);
    }
  }
  QueryManager2.prototype.stop = function() {
    var _this = this;
    this.queries.forEach(function(_info, queryId) {
      _this.stopQueryNoBroadcast(queryId);
    });
    this.cancelPendingFetches(__DEV__ ? new InvariantError("QueryManager stopped while query was in flight") : new InvariantError(13));
  };
  QueryManager2.prototype.cancelPendingFetches = function(error) {
    this.fetchCancelFns.forEach(function(cancel) {
      return cancel(error);
    });
    this.fetchCancelFns.clear();
  };
  QueryManager2.prototype.mutate = function(_a2) {
    var _b, _c;
    var mutation = _a2.mutation, variables = _a2.variables, optimisticResponse = _a2.optimisticResponse, updateQueries = _a2.updateQueries, _d = _a2.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e2 = _a2.awaitRefetchQueries, awaitRefetchQueries = _e2 === void 0 ? false : _e2, updateWithProxyFn = _a2.update, onQueryUpdated = _a2.onQueryUpdated, _f = _a2.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a2.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a2.keepRootFields, context = _a2.context;
    return __awaiter$2(this, void 0, void 0, function() {
      var mutationId, _h, document2, hasClientExports2, mutationStoreValue, self2;
      return __generator$1(this, function(_j) {
        switch (_j.label) {
          case 0:
            __DEV__ ? invariant(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.") : invariant(mutation, 14);
            __DEV__ ? invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 15);
            mutationId = this.generateMutationId();
            _h = this.transform(mutation), document2 = _h.document, hasClientExports2 = _h.hasClientExports;
            mutation = this.cache.transformForLink(document2);
            variables = this.getVariables(mutation, variables);
            if (!hasClientExports2)
              return [3, 2];
            return [4, this.localState.addExportedVariables(mutation, variables, context)];
          case 1:
            variables = _j.sent();
            _j.label = 2;
          case 2:
            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
              mutation,
              variables,
              loading: true,
              error: null
            });
            if (optimisticResponse) {
              this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
            }
            this.broadcastQueries();
            self2 = this;
            return [2, new Promise(function(resolve2, reject) {
              return asyncMap(self2.getObservableFromLink(mutation, __assign$1(__assign$1({}, context), { optimisticResponse }), variables, false), function(result) {
                if (graphQLResultHasError(result) && errorPolicy === "none") {
                  throw new ApolloError({
                    graphQLErrors: result.errors
                  });
                }
                if (mutationStoreValue) {
                  mutationStoreValue.loading = false;
                  mutationStoreValue.error = null;
                }
                var storeResult = __assign$1({}, result);
                if (typeof refetchQueries === "function") {
                  refetchQueries = refetchQueries(storeResult);
                }
                if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                  delete storeResult.errors;
                }
                return self2.markMutationResult({
                  mutationId,
                  result: storeResult,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context,
                  update: updateWithProxyFn,
                  updateQueries,
                  awaitRefetchQueries,
                  refetchQueries,
                  removeOptimistic: optimisticResponse ? mutationId : void 0,
                  onQueryUpdated,
                  keepRootFields
                });
              }).subscribe({
                next: function(storeResult) {
                  self2.broadcastQueries();
                  resolve2(storeResult);
                },
                error: function(err) {
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = err;
                  }
                  if (optimisticResponse) {
                    self2.cache.removeOptimistic(mutationId);
                  }
                  self2.broadcastQueries();
                  reject(err instanceof ApolloError ? err : new ApolloError({
                    networkError: err
                  }));
                }
              });
            })];
        }
      });
    });
  };
  QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
    var _this = this;
    if (cache2 === void 0) {
      cache2 = this.cache;
    }
    var result = mutation.result;
    var cacheWrites = [];
    var skipCache = mutation.fetchPolicy === "no-cache";
    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
      cacheWrites.push({
        result: result.data,
        dataId: "ROOT_MUTATION",
        query: mutation.document,
        variables: mutation.variables
      });
      var updateQueries_1 = mutation.updateQueries;
      if (updateQueries_1) {
        this.queries.forEach(function(_a2, queryId) {
          var observableQuery = _a2.observableQuery;
          var queryName = observableQuery && observableQuery.queryName;
          if (!queryName || !hasOwnProperty$2.call(updateQueries_1, queryName)) {
            return;
          }
          var updater = updateQueries_1[queryName];
          var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
          var _c = cache2.diff({
            query: document2,
            variables,
            returnPartialData: true,
            optimistic: false
          }), currentQueryResult = _c.result, complete = _c.complete;
          if (complete && currentQueryResult) {
            var nextQueryResult = updater(currentQueryResult, {
              mutationResult: result,
              queryName: document2 && getOperationName(document2) || void 0,
              queryVariables: variables
            });
            if (nextQueryResult) {
              cacheWrites.push({
                result: nextQueryResult,
                dataId: "ROOT_QUERY",
                query: document2,
                variables
              });
            }
          }
        });
      }
    }
    if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
      var results_1 = [];
      this.refetchQueries({
        updateCache: function(cache3) {
          if (!skipCache) {
            cacheWrites.forEach(function(write) {
              return cache3.write(write);
            });
          }
          var update = mutation.update;
          if (update) {
            if (!skipCache) {
              var diff2 = cache3.diff({
                id: "ROOT_MUTATION",
                query: _this.transform(mutation.document).asQuery,
                variables: mutation.variables,
                optimistic: false,
                returnPartialData: true
              });
              if (diff2.complete && !isExecutionPatchIncrementalResult(result)) {
                result = __assign$1(__assign$1({}, result), { data: diff2.result });
              }
            }
            update(cache3, result, {
              context: mutation.context,
              variables: mutation.variables
            });
          }
          if (!skipCache && !mutation.keepRootFields) {
            cache3.modify({
              id: "ROOT_MUTATION",
              fields: function(value, _a2) {
                var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                return fieldName === "__typename" ? value : DELETE2;
              }
            });
          }
        },
        include: mutation.refetchQueries,
        optimistic: false,
        removeOptimistic: mutation.removeOptimistic,
        onQueryUpdated: mutation.onQueryUpdated || null
      }).forEach(function(result2) {
        return results_1.push(result2);
      });
      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
        return Promise.all(results_1).then(function() {
          return result;
        });
      }
    }
    return Promise.resolve(result);
  };
  QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
    var _this = this;
    var data2 = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
    return this.cache.recordOptimisticTransaction(function(cache2) {
      try {
        _this.markMutationResult(__assign$1(__assign$1({}, mutation), { result: { data: data2 } }), cache2);
      } catch (error) {
        __DEV__ && invariant.error(error);
      }
    }, mutation.mutationId);
  };
  QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
    return this.fetchQueryObservable(queryId, options, networkStatus).promise;
  };
  QueryManager2.prototype.getQueryStore = function() {
    var store = /* @__PURE__ */ Object.create(null);
    this.queries.forEach(function(info, queryId) {
      store[queryId] = {
        variables: info.variables,
        networkStatus: info.networkStatus,
        networkError: info.networkError,
        graphQLErrors: info.graphQLErrors
      };
    });
    return store;
  };
  QueryManager2.prototype.resetErrors = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo) {
      queryInfo.networkError = void 0;
      queryInfo.graphQLErrors = [];
    }
  };
  QueryManager2.prototype.transform = function(document2) {
    var transformCache = this.transformCache;
    if (!transformCache.has(document2)) {
      var transformed = this.cache.transformDocument(document2);
      var noConnection = removeConnectionDirectiveFromDocument(transformed);
      var clientQuery = this.localState.clientQuery(transformed);
      var serverQuery = noConnection && this.localState.serverQuery(noConnection);
      var cacheEntry_1 = {
        document: transformed,
        hasClientExports: hasClientExports(transformed),
        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
        clientQuery,
        serverQuery,
        defaultVars: getDefaultValues(getOperationDefinition(transformed)),
        asQuery: __assign$1(__assign$1({}, transformed), { definitions: transformed.definitions.map(function(def) {
          if (def.kind === "OperationDefinition" && def.operation !== "query") {
            return __assign$1(__assign$1({}, def), { operation: "query" });
          }
          return def;
        }) })
      };
      var add = function(doc) {
        if (doc && !transformCache.has(doc)) {
          transformCache.set(doc, cacheEntry_1);
        }
      };
      add(document2);
      add(transformed);
      add(clientQuery);
      add(serverQuery);
    }
    return transformCache.get(document2);
  };
  QueryManager2.prototype.getVariables = function(document2, variables) {
    return __assign$1(__assign$1({}, this.transform(document2).defaultVars), variables);
  };
  QueryManager2.prototype.watchQuery = function(options) {
    options = __assign$1(__assign$1({}, options), { variables: this.getVariables(options.query, options.variables) });
    if (typeof options.notifyOnNetworkStatusChange === "undefined") {
      options.notifyOnNetworkStatusChange = false;
    }
    var queryInfo = new QueryInfo(this);
    var observable = new ObservableQuery({
      queryManager: this,
      queryInfo,
      options
    });
    this.queries.set(observable.queryId, queryInfo);
    queryInfo.init({
      document: observable.query,
      observableQuery: observable,
      variables: observable.variables
    });
    return observable;
  };
  QueryManager2.prototype.query = function(options, queryId) {
    var _this = this;
    if (queryId === void 0) {
      queryId = this.generateQueryId();
    }
    __DEV__ ? invariant(options.query, "query option is required. You must specify your GraphQL document in the query option.") : invariant(options.query, 16);
    __DEV__ ? invariant(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.') : invariant(options.query.kind === "Document", 17);
    __DEV__ ? invariant(!options.returnPartialData, "returnPartialData option only supported on watchQuery.") : invariant(!options.returnPartialData, 18);
    __DEV__ ? invariant(!options.pollInterval, "pollInterval option only supported on watchQuery.") : invariant(!options.pollInterval, 19);
    return this.fetchQuery(queryId, options).finally(function() {
      return _this.stopQuery(queryId);
    });
  };
  QueryManager2.prototype.generateQueryId = function() {
    return String(this.queryIdCounter++);
  };
  QueryManager2.prototype.generateRequestId = function() {
    return this.requestIdCounter++;
  };
  QueryManager2.prototype.generateMutationId = function() {
    return String(this.mutationIdCounter++);
  };
  QueryManager2.prototype.stopQueryInStore = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
    var queryInfo = this.queries.get(queryId);
    if (queryInfo)
      queryInfo.stop();
  };
  QueryManager2.prototype.clearStore = function(options) {
    if (options === void 0) {
      options = {
        discardWatches: true
      };
    }
    this.cancelPendingFetches(__DEV__ ? new InvariantError("Store reset while query was in flight (not completed in link chain)") : new InvariantError(20));
    this.queries.forEach(function(queryInfo) {
      if (queryInfo.observableQuery) {
        queryInfo.networkStatus = NetworkStatus.loading;
      } else {
        queryInfo.stop();
      }
    });
    if (this.mutationStore) {
      this.mutationStore = /* @__PURE__ */ Object.create(null);
    }
    return this.cache.reset(options);
  };
  QueryManager2.prototype.getObservableQueries = function(include) {
    var _this = this;
    if (include === void 0) {
      include = "active";
    }
    var queries = /* @__PURE__ */ new Map();
    var queryNamesAndDocs = /* @__PURE__ */ new Map();
    var legacyQueryOptions = /* @__PURE__ */ new Set();
    if (Array.isArray(include)) {
      include.forEach(function(desc) {
        if (typeof desc === "string") {
          queryNamesAndDocs.set(desc, false);
        } else if (isDocumentNode(desc)) {
          queryNamesAndDocs.set(_this.transform(desc).document, false);
        } else if (isNonNullObject(desc) && desc.query) {
          legacyQueryOptions.add(desc);
        }
      });
    }
    this.queries.forEach(function(_a2, queryId) {
      var oq = _a2.observableQuery, document2 = _a2.document;
      if (oq) {
        if (include === "all") {
          queries.set(queryId, oq);
          return;
        }
        var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
        if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
          return;
        }
        if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
          queries.set(queryId, oq);
          if (queryName)
            queryNamesAndDocs.set(queryName, true);
          if (document2)
            queryNamesAndDocs.set(document2, true);
        }
      }
    });
    if (legacyQueryOptions.size) {
      legacyQueryOptions.forEach(function(options) {
        var queryId = makeUniqueId("legacyOneTimeQuery");
        var queryInfo = _this.getQuery(queryId).init({
          document: options.query,
          variables: options.variables
        });
        var oq = new ObservableQuery({
          queryManager: _this,
          queryInfo,
          options: __assign$1(__assign$1({}, options), { fetchPolicy: "network-only" })
        });
        invariant(oq.queryId === queryId);
        queryInfo.setObservableQuery(oq);
        queries.set(queryId, oq);
      });
    }
    if (__DEV__ && queryNamesAndDocs.size) {
      queryNamesAndDocs.forEach(function(included, nameOrDoc) {
        if (!included) {
          __DEV__ && invariant.warn("Unknown query ".concat(typeof nameOrDoc === "string" ? "named " : "").concat(JSON.stringify(nameOrDoc, null, 2), " requested in refetchQueries options.include array"));
        }
      });
    }
    return queries;
  };
  QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
    var _this = this;
    if (includeStandby === void 0) {
      includeStandby = false;
    }
    var observableQueryPromises = [];
    this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
      var fetchPolicy = observableQuery.options.fetchPolicy;
      observableQuery.resetLastResults();
      if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
        observableQueryPromises.push(observableQuery.refetch());
      }
      _this.getQuery(queryId).setDiff(null);
    });
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  };
  QueryManager2.prototype.setObservableQuery = function(observableQuery) {
    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
  };
  QueryManager2.prototype.startGraphQLSubscription = function(_a2) {
    var _this = this;
    var query = _a2.query, fetchPolicy = _a2.fetchPolicy, errorPolicy = _a2.errorPolicy, variables = _a2.variables, _b = _a2.context, context = _b === void 0 ? {} : _b;
    query = this.transform(query).document;
    variables = this.getVariables(query, variables);
    var makeObservable = function(variables2) {
      return _this.getObservableFromLink(query, context, variables2).map(function(result) {
        if (fetchPolicy !== "no-cache") {
          if (shouldWriteResult(result, errorPolicy)) {
            _this.cache.write({
              query,
              result: result.data,
              dataId: "ROOT_SUBSCRIPTION",
              variables: variables2
            });
          }
          _this.broadcastQueries();
        }
        if (graphQLResultHasError(result)) {
          throw new ApolloError({
            graphQLErrors: result.errors
          });
        }
        return result;
      });
    };
    if (this.transform(query).hasClientExports) {
      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
      return new Observable(function(observer) {
        var sub = null;
        observablePromise_1.then(function(observable) {
          return sub = observable.subscribe(observer);
        }, observer.error);
        return function() {
          return sub && sub.unsubscribe();
        };
      });
    }
    return makeObservable(variables);
  };
  QueryManager2.prototype.stopQuery = function(queryId) {
    this.stopQueryNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.removeQuery(queryId);
  };
  QueryManager2.prototype.removeQuery = function(queryId) {
    this.fetchCancelFns.delete(queryId);
    if (this.queries.has(queryId)) {
      this.getQuery(queryId).stop();
      this.queries.delete(queryId);
    }
  };
  QueryManager2.prototype.broadcastQueries = function() {
    if (this.onBroadcast)
      this.onBroadcast();
    this.queries.forEach(function(info) {
      return info.notify();
    });
  };
  QueryManager2.prototype.getLocalState = function() {
    return this.localState;
  };
  QueryManager2.prototype.getObservableFromLink = function(query, context, variables, deduplication) {
    var _this = this;
    var _a2;
    if (deduplication === void 0) {
      deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
    }
    var observable;
    var serverQuery = this.transform(query).serverQuery;
    if (serverQuery) {
      var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
      var operation = {
        query: serverQuery,
        variables,
        operationName: getOperationName(serverQuery) || void 0,
        context: this.prepareContext(__assign$1(__assign$1({}, context), { forceFetch: !deduplication }))
      };
      context = operation.context;
      if (deduplication) {
        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || /* @__PURE__ */ new Map();
        inFlightLinkObservables_1.set(serverQuery, byVariables_1);
        var varJson_1 = canonicalStringify(variables);
        observable = byVariables_1.get(varJson_1);
        if (!observable) {
          var concast = new Concast([
            execute(link, operation)
          ]);
          byVariables_1.set(varJson_1, observable = concast);
          concast.beforeNext(function() {
            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
              inFlightLinkObservables_1.delete(serverQuery);
            }
          });
        }
      } else {
        observable = new Concast([
          execute(link, operation)
        ]);
      }
    } else {
      observable = new Concast([
        Observable.of({ data: {} })
      ]);
      context = this.prepareContext(context);
    }
    var clientQuery = this.transform(query).clientQuery;
    if (clientQuery) {
      observable = asyncMap(observable, function(result) {
        return _this.localState.runResolvers({
          document: clientQuery,
          remoteResult: result,
          context,
          variables
        });
      });
    }
    return observable;
  };
  QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
    var requestId = queryInfo.lastRequestId = this.generateRequestId();
    options = cloneDeep(options);
    var linkDocument = this.cache.transformForLink(this.transform(queryInfo.document).document);
    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {
      var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
      if ("incremental" in result && isNonEmptyArray(result.incremental)) {
        result.incremental.forEach(function(incrementalResult) {
          if (incrementalResult.errors) {
            graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
          }
        });
      }
      var hasErrors = isNonEmptyArray(graphQLErrors);
      if (requestId >= queryInfo.lastRequestId) {
        if (hasErrors && options.errorPolicy === "none") {
          throw queryInfo.markError(new ApolloError({
            graphQLErrors
          }));
        }
        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);
        queryInfo.markReady();
      }
      var aqr = {
        data: result.data,
        loading: false,
        networkStatus: NetworkStatus.ready
      };
      if (hasErrors && options.errorPolicy !== "ignore") {
        aqr.errors = graphQLErrors;
        aqr.networkStatus = NetworkStatus.error;
      }
      return aqr;
    }, function(networkError) {
      var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
      if (requestId >= queryInfo.lastRequestId) {
        queryInfo.markError(error);
      }
      throw error;
    });
  };
  QueryManager2.prototype.fetchQueryObservable = function(queryId, options, networkStatus) {
    var _this = this;
    if (networkStatus === void 0) {
      networkStatus = NetworkStatus.loading;
    }
    var query = this.transform(options.query).document;
    var variables = this.getVariables(query, options.variables);
    var queryInfo = this.getQuery(queryId);
    var defaults = this.defaultOptions.watchQuery;
    var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e2 = options.context, context = _e2 === void 0 ? {} : _e2;
    var normalized = Object.assign({}, options, {
      query,
      variables,
      fetchPolicy,
      errorPolicy,
      returnPartialData,
      notifyOnNetworkStatusChange,
      context
    });
    var fromVariables = function(variables2) {
      normalized.variables = variables2;
      var concastSources = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
      if (normalized.fetchPolicy !== "standby" && concastSources.length > 0 && queryInfo.observableQuery) {
        queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
      }
      return concastSources;
    };
    var cleanupCancelFn = function() {
      return _this.fetchCancelFns.delete(queryId);
    };
    this.fetchCancelFns.set(queryId, function(reason) {
      cleanupCancelFn();
      setTimeout(function() {
        return concast.cancel(reason);
      });
    });
    var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
    concast.promise.then(cleanupCancelFn, cleanupCancelFn);
    return concast;
  };
  QueryManager2.prototype.refetchQueries = function(_a2) {
    var _this = this;
    var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
    var includedQueriesById = /* @__PURE__ */ new Map();
    if (include) {
      this.getObservableQueries(include).forEach(function(oq, queryId) {
        includedQueriesById.set(queryId, {
          oq,
          lastDiff: _this.getQuery(queryId).getDiff()
        });
      });
    }
    var results = /* @__PURE__ */ new Map();
    if (updateCache) {
      this.cache.batch({
        update: updateCache,
        optimistic: optimistic && removeOptimistic || false,
        removeOptimistic,
        onWatchUpdated: function(watch, diff2, lastDiff) {
          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
          if (oq) {
            if (onQueryUpdated) {
              includedQueriesById.delete(oq.queryId);
              var result = onQueryUpdated(oq, diff2, lastDiff);
              if (result === true) {
                result = oq.refetch();
              }
              if (result !== false) {
                results.set(oq, result);
              }
              return result;
            }
            if (onQueryUpdated !== null) {
              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff: diff2 });
            }
          }
        }
      });
    }
    if (includedQueriesById.size) {
      includedQueriesById.forEach(function(_a3, queryId) {
        var oq = _a3.oq, lastDiff = _a3.lastDiff, diff2 = _a3.diff;
        var result;
        if (onQueryUpdated) {
          if (!diff2) {
            var info = oq["queryInfo"];
            info.reset();
            diff2 = info.getDiff();
          }
          result = onQueryUpdated(oq, diff2, lastDiff);
        }
        if (!onQueryUpdated || result === true) {
          result = oq.refetch();
        }
        if (result !== false) {
          results.set(oq, result);
        }
        if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
          _this.stopQueryNoBroadcast(queryId);
        }
      });
    }
    if (removeOptimistic) {
      this.cache.removeOptimistic(removeOptimistic);
    }
    return results;
  };
  QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
    var _this = this;
    var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
    var oldNetworkStatus = queryInfo.networkStatus;
    queryInfo.init({
      document: this.transform(query).document,
      variables,
      networkStatus
    });
    var readCache = function() {
      return queryInfo.getDiff(variables);
    };
    var resultsFromCache = function(diff3, networkStatus2) {
      if (networkStatus2 === void 0) {
        networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
      }
      var data2 = diff3.result;
      if (__DEV__ && !returnPartialData && !equal(data2, {})) {
        logMissingFieldErrors(diff3.missing);
      }
      var fromData = function(data3) {
        return Observable.of(__assign$1({ data: data3, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff3.complete ? null : { partial: true }));
      };
      if (data2 && _this.transform(query).hasForcedResolvers) {
        return _this.localState.runResolvers({
          document: query,
          remoteResult: { data: data2 },
          context,
          variables,
          onlyRunForcedResolvers: true
        }).then(function(resolved) {
          return fromData(resolved.data || void 0);
        });
      }
      return fromData(data2);
    };
    var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
    var resultsFromLink = function() {
      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
        variables,
        context,
        fetchPolicy,
        errorPolicy
      });
    };
    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
    switch (fetchPolicy) {
      default:
      case "cache-first": {
        var diff2 = readCache();
        if (diff2.complete) {
          return [
            resultsFromCache(diff2, queryInfo.markReady())
          ];
        }
        if (returnPartialData || shouldNotify) {
          return [
            resultsFromCache(diff2),
            resultsFromLink()
          ];
        }
        return [
          resultsFromLink()
        ];
      }
      case "cache-and-network": {
        var diff2 = readCache();
        if (diff2.complete || returnPartialData || shouldNotify) {
          return [
            resultsFromCache(diff2),
            resultsFromLink()
          ];
        }
        return [
          resultsFromLink()
        ];
      }
      case "cache-only":
        return [
          resultsFromCache(readCache(), queryInfo.markReady())
        ];
      case "network-only":
        if (shouldNotify) {
          return [
            resultsFromCache(readCache()),
            resultsFromLink()
          ];
        }
        return [resultsFromLink()];
      case "no-cache":
        if (shouldNotify) {
          return [
            resultsFromCache(queryInfo.getDiff()),
            resultsFromLink()
          ];
        }
        return [resultsFromLink()];
      case "standby":
        return [];
    }
  };
  QueryManager2.prototype.getQuery = function(queryId) {
    if (queryId && !this.queries.has(queryId)) {
      this.queries.set(queryId, new QueryInfo(this, queryId));
    }
    return this.queries.get(queryId);
  };
  QueryManager2.prototype.prepareContext = function(context) {
    if (context === void 0) {
      context = {};
    }
    var newContext = this.localState.prepareContext(context);
    return __assign$1(__assign$1({}, newContext), { clientAwareness: this.clientAwareness });
  };
  return QueryManager2;
}();
var hasSuggestedDevtools = false;
var ApolloClient = function() {
  function ApolloClient2(options) {
    var _this = this;
    this.resetStoreCallbacks = [];
    this.clearStoreCallbacks = [];
    var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions2 = options.defaultOptions, _e2 = options.assumeImmutableResults, assumeImmutableResults = _e2 === void 0 ? false : _e2, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
    var link = options.link;
    if (!link) {
      link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
    }
    if (!cache2) {
      throw __DEV__ ? new InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs") : new InvariantError(9);
    }
    this.link = link;
    this.cache = cache2;
    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
    this.queryDeduplication = queryDeduplication;
    this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
    this.typeDefs = typeDefs;
    if (ssrForceFetchDelay) {
      setTimeout(function() {
        return _this.disableNetworkFetches = false;
      }, ssrForceFetchDelay);
    }
    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
    if (connectToDevTools && typeof window === "object") {
      window.__APOLLO_CLIENT__ = this;
    }
    if (!hasSuggestedDevtools && __DEV__) {
      hasSuggestedDevtools = true;
      if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
        var nav = window.navigator;
        var ua2 = nav && nav.userAgent;
        var url = void 0;
        if (typeof ua2 === "string") {
          if (ua2.indexOf("Chrome/") > -1) {
            url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
          } else if (ua2.indexOf("Firefox/") > -1) {
            url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
          }
        }
        if (url) {
          __DEV__ && invariant.log("Download the Apollo DevTools for a better development experience: " + url);
        }
      }
    }
    this.version = version;
    this.localState = new LocalState({
      cache: cache2,
      client: this,
      resolvers,
      fragmentMatcher
    });
    this.queryManager = new QueryManager({
      cache: this.cache,
      link: this.link,
      defaultOptions: this.defaultOptions,
      queryDeduplication,
      ssrMode,
      clientAwareness: {
        name: clientAwarenessName,
        version: clientAwarenessVersion
      },
      localState: this.localState,
      assumeImmutableResults,
      onBroadcast: connectToDevTools ? function() {
        if (_this.devToolsHookCb) {
          _this.devToolsHookCb({
            action: {},
            state: {
              queries: _this.queryManager.getQueryStore(),
              mutations: _this.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: _this.cache.extract(true)
          });
        }
      } : void 0
    });
  }
  ApolloClient2.prototype.stop = function() {
    this.queryManager.stop();
  };
  ApolloClient2.prototype.watchQuery = function(options) {
    if (this.defaultOptions.watchQuery) {
      options = mergeOptions(this.defaultOptions.watchQuery, options);
    }
    if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
      options = __assign$1(__assign$1({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.watchQuery(options);
  };
  ApolloClient2.prototype.query = function(options) {
    if (this.defaultOptions.query) {
      options = mergeOptions(this.defaultOptions.query, options);
    }
    __DEV__ ? invariant(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.") : invariant(options.fetchPolicy !== "cache-and-network", 10);
    if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
      options = __assign$1(__assign$1({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.query(options);
  };
  ApolloClient2.prototype.mutate = function(options) {
    if (this.defaultOptions.mutate) {
      options = mergeOptions(this.defaultOptions.mutate, options);
    }
    return this.queryManager.mutate(options);
  };
  ApolloClient2.prototype.subscribe = function(options) {
    return this.queryManager.startGraphQLSubscription(options);
  };
  ApolloClient2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readQuery(options, optimistic);
  };
  ApolloClient2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readFragment(options, optimistic);
  };
  ApolloClient2.prototype.writeQuery = function(options) {
    this.cache.writeQuery(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.writeFragment = function(options) {
    this.cache.writeFragment(options);
    this.queryManager.broadcastQueries();
  };
  ApolloClient2.prototype.__actionHookForDevTools = function(cb2) {
    this.devToolsHookCb = cb2;
  };
  ApolloClient2.prototype.__requestRaw = function(payload) {
    return execute(this.link, payload);
  };
  ApolloClient2.prototype.resetStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore({
        discardWatches: false
      });
    }).then(function() {
      return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
        return fn();
      }));
    }).then(function() {
      return _this.reFetchObservableQueries();
    });
  };
  ApolloClient2.prototype.clearStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore({
        discardWatches: true
      });
    }).then(function() {
      return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
        return fn();
      }));
    });
  };
  ApolloClient2.prototype.onResetStore = function(cb2) {
    var _this = this;
    this.resetStoreCallbacks.push(cb2);
    return function() {
      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c2) {
        return c2 !== cb2;
      });
    };
  };
  ApolloClient2.prototype.onClearStore = function(cb2) {
    var _this = this;
    this.clearStoreCallbacks.push(cb2);
    return function() {
      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c2) {
        return c2 !== cb2;
      });
    };
  };
  ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
    return this.queryManager.reFetchObservableQueries(includeStandby);
  };
  ApolloClient2.prototype.refetchQueries = function(options) {
    var map2 = this.queryManager.refetchQueries(options);
    var queries = [];
    var results = [];
    map2.forEach(function(result2, obsQuery) {
      queries.push(obsQuery);
      results.push(result2);
    });
    var result = Promise.all(results);
    result.queries = queries;
    result.results = results;
    result.catch(function(error) {
      __DEV__ && invariant.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(error));
    });
    return result;
  };
  ApolloClient2.prototype.getObservableQueries = function(include) {
    if (include === void 0) {
      include = "active";
    }
    return this.queryManager.getObservableQueries(include);
  };
  ApolloClient2.prototype.extract = function(optimistic) {
    return this.cache.extract(optimistic);
  };
  ApolloClient2.prototype.restore = function(serializedState) {
    return this.cache.restore(serializedState);
  };
  ApolloClient2.prototype.addResolvers = function(resolvers) {
    this.localState.addResolvers(resolvers);
  };
  ApolloClient2.prototype.setResolvers = function(resolvers) {
    this.localState.setResolvers(resolvers);
  };
  ApolloClient2.prototype.getResolvers = function() {
    return this.localState.getResolvers();
  };
  ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
    this.localState.setFragmentMatcher(fragmentMatcher);
  };
  ApolloClient2.prototype.setLink = function(newLink) {
    this.link = this.queryManager.link = newLink;
  };
  return ApolloClient2;
}();
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  var context = react.exports.createContext[contextKey];
  if (!context) {
    Object.defineProperty(react.exports.createContext, contextKey, {
      value: context = react.exports.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context.displayName = "ApolloContext";
  }
  return context;
}
var ApolloProvider = function(_a2) {
  var client2 = _a2.client, children = _a2.children;
  var ApolloContext = getApolloContext();
  return /* @__PURE__ */ jsx(ApolloContext.Consumer, {
    children: function(context) {
      if (context === void 0) {
        context = {};
      }
      if (client2 && context.client !== client2) {
        context = Object.assign({}, context, {
          client: client2
        });
      }
      __DEV__ ? invariant(context.client, 'ApolloProvider was not passed a client instance. Make sure you pass in your client via the "client" prop.') : invariant(context.client, 28);
      return /* @__PURE__ */ jsx(ApolloContext.Provider, {
        value: context,
        children
      });
    }
  });
};
function useApolloClient(override) {
  var context = react.exports.useContext(getApolloContext());
  var client2 = override || context.client;
  __DEV__ ? invariant(!!client2, 'Could not find "client" in the context or passed in as an option. Wrap the root component in an <ApolloProvider>, or pass an ApolloClient instance in via options.') : invariant(!!client2, 31);
  return client2;
}
var didWarnUncachedGetSnapshot = false;
var uSESKey = "useSyncExternalStore";
var realHook = React$1[uSESKey];
var useSyncExternalStore = realHook || function(subscribe, getSnapshot, getServerSnapshot) {
  var value = getSnapshot();
  if (__DEV__ && !didWarnUncachedGetSnapshot && value !== getSnapshot()) {
    didWarnUncachedGetSnapshot = true;
    __DEV__ && invariant.error("The result of getSnapshot should be cached to avoid an infinite loop");
  }
  var _a2 = react.exports.useState({ inst: { value, getSnapshot } }), inst = _a2[0].inst, forceUpdate = _a2[1];
  if (canUseLayoutEffect) {
    react.exports.useLayoutEffect(function() {
      Object.assign(inst, { value, getSnapshot });
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    }, [subscribe, value, getSnapshot]);
  } else {
    Object.assign(inst, { value, getSnapshot });
  }
  react.exports.useEffect(function() {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({ inst });
    }
    return subscribe(function handleStoreChange() {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    });
  }, [subscribe]);
  return value;
};
function checkIfSnapshotChanged(_a2) {
  var value = _a2.value, getSnapshot = _a2.getSnapshot;
  try {
    return value !== getSnapshot();
  } catch (_b) {
    return true;
  }
}
var DocumentType;
(function(DocumentType2) {
  DocumentType2[DocumentType2["Query"] = 0] = "Query";
  DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
  DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache = /* @__PURE__ */ new Map();
function operationName(type) {
  var name;
  switch (type) {
    case DocumentType.Query:
      name = "Query";
      break;
    case DocumentType.Mutation:
      name = "Mutation";
      break;
    case DocumentType.Subscription:
      name = "Subscription";
      break;
  }
  return name;
}
function parser(document2) {
  var cached = cache.get(document2);
  if (cached)
    return cached;
  var variables, type, name;
  __DEV__ ? invariant(!!document2 && !!document2.kind, "Argument of ".concat(document2, " passed to parser was not a valid GraphQL ") + "DocumentNode. You may need to use 'graphql-tag' or another method to convert your operation into a document") : invariant(!!document2 && !!document2.kind, 32);
  var fragments = [];
  var queries = [];
  var mutations = [];
  var subscriptions = [];
  for (var _i = 0, _a2 = document2.definitions; _i < _a2.length; _i++) {
    var x2 = _a2[_i];
    if (x2.kind === "FragmentDefinition") {
      fragments.push(x2);
      continue;
    }
    if (x2.kind === "OperationDefinition") {
      switch (x2.operation) {
        case "query":
          queries.push(x2);
          break;
        case "mutation":
          mutations.push(x2);
          break;
        case "subscription":
          subscriptions.push(x2);
          break;
      }
    }
  }
  __DEV__ ? invariant(!fragments.length || (queries.length || mutations.length || subscriptions.length), "Passing only a fragment to 'graphql' is not yet supported. You must include a query, subscription or mutation as well") : invariant(!fragments.length || (queries.length || mutations.length || subscriptions.length), 33);
  __DEV__ ? invariant(queries.length + mutations.length + subscriptions.length <= 1, "react-apollo only supports a query, subscription, or a mutation per HOC. " + "".concat(document2, " had ").concat(queries.length, " queries, ").concat(subscriptions.length, " ") + "subscriptions and ".concat(mutations.length, " mutations. ") + "You can use 'compose' to join multiple operation types to a component") : invariant(queries.length + mutations.length + subscriptions.length <= 1, 34);
  type = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type = DocumentType.Subscription;
  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
  __DEV__ ? invariant(definitions.length === 1, "react-apollo only supports one definition per HOC. ".concat(document2, " had ") + "".concat(definitions.length, " definitions. ") + "You can use 'compose' to join multiple operation types to a component") : invariant(definitions.length === 1, 35);
  var definition = definitions[0];
  variables = definition.variableDefinitions || [];
  if (definition.name && definition.name.kind === "Name") {
    name = definition.name.value;
  } else {
    name = "data";
  }
  var payload = { name, type, variables };
  cache.set(document2, payload);
  return payload;
}
function verifyDocumentType(document2, type) {
  var operation = parser(document2);
  var requiredOperationName = operationName(type);
  var usedOperationName = operationName(operation.type);
  __DEV__ ? invariant(operation.type === type, "Running a ".concat(requiredOperationName, " requires a graphql ") + "".concat(requiredOperationName, ", but a ").concat(usedOperationName, " was used instead.")) : invariant(operation.type === type, 36);
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function useQuery(query, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  return useInternalState(useApolloClient(options.client), query).useQuery(options);
}
function useInternalState(client2, query) {
  var stateRef = react.exports.useRef();
  if (!stateRef.current || client2 !== stateRef.current.client || query !== stateRef.current.query) {
    stateRef.current = new InternalState(client2, query, stateRef.current);
  }
  var state = stateRef.current;
  var _a2 = react.exports.useState(0);
  _a2[0];
  var setTick = _a2[1];
  state.forceUpdate = function() {
    setTick(function(tick) {
      return tick + 1;
    });
  };
  return state;
}
var InternalState = function() {
  function InternalState2(client2, query, previous) {
    this.client = client2;
    this.query = query;
    this.asyncResolveFns = /* @__PURE__ */ new Set();
    this.optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)();
    this.ssrDisabledResult = maybeDeepFreeze({
      loading: true,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.loading
    });
    this.skipStandbyResult = maybeDeepFreeze({
      loading: false,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.ready
    });
    this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();
    verifyDocumentType(query, DocumentType.Query);
    var previousResult = previous && previous.result;
    var previousData = previousResult && previousResult.data;
    if (previousData) {
      this.previousData = previousData;
    }
  }
  InternalState2.prototype.forceUpdate = function() {
    __DEV__ && invariant.warn("Calling default no-op implementation of InternalState#forceUpdate");
  };
  InternalState2.prototype.asyncUpdate = function() {
    var _this = this;
    return new Promise(function(resolve2) {
      _this.asyncResolveFns.add(resolve2);
      _this.optionsToIgnoreOnce.add(_this.watchQueryOptions);
      _this.forceUpdate();
    });
  };
  InternalState2.prototype.useQuery = function(options) {
    var _this = this;
    this.renderPromises = react.exports.useContext(getApolloContext()).renderPromises;
    this.useOptions(options);
    var obsQuery = this.useObservableQuery();
    var result = useSyncExternalStore(react.exports.useCallback(function() {
      if (_this.renderPromises) {
        return function() {
        };
      }
      var onNext = function() {
        var previousResult = _this.result;
        var result2 = obsQuery.getCurrentResult();
        if (previousResult && previousResult.loading === result2.loading && previousResult.networkStatus === result2.networkStatus && equal(previousResult.data, result2.data)) {
          return;
        }
        _this.setResult(result2);
      };
      var onError = function(error) {
        var last = obsQuery["last"];
        subscription.unsubscribe();
        try {
          obsQuery.resetLastResults();
          subscription = obsQuery.subscribe(onNext, onError);
        } finally {
          obsQuery["last"] = last;
        }
        if (!hasOwnProperty$1.call(error, "graphQLErrors")) {
          throw error;
        }
        var previousResult = _this.result;
        if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {
          _this.setResult({
            data: previousResult && previousResult.data,
            error,
            loading: false,
            networkStatus: NetworkStatus.error
          });
        }
      };
      var subscription = obsQuery.subscribe(onNext, onError);
      return function() {
        return subscription.unsubscribe();
      };
    }, [
      obsQuery,
      this.renderPromises,
      this.client.disableNetworkFetches
    ]), function() {
      return _this.getCurrentResult();
    }, function() {
      return _this.getCurrentResult();
    });
    this.unsafeHandlePartialRefetch(result);
    var queryResult = this.toQueryResult(result);
    if (!queryResult.loading && this.asyncResolveFns.size) {
      this.asyncResolveFns.forEach(function(resolve2) {
        return resolve2(queryResult);
      });
      this.asyncResolveFns.clear();
    }
    return queryResult;
  };
  InternalState2.prototype.useOptions = function(options) {
    var _a2;
    var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);
    var currentWatchQueryOptions = this.watchQueryOptions;
    if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) || !equal(watchQueryOptions, currentWatchQueryOptions)) {
      this.watchQueryOptions = watchQueryOptions;
      if (currentWatchQueryOptions && this.observable) {
        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);
        this.observable.reobserve(this.getObsQueryOptions());
        this.previousData = ((_a2 = this.result) === null || _a2 === void 0 ? void 0 : _a2.data) || this.previousData;
        this.result = void 0;
      }
    }
    this.onCompleted = options.onCompleted || InternalState2.prototype.onCompleted;
    this.onError = options.onError || InternalState2.prototype.onError;
    if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {
      this.result = this.ssrDisabledResult;
    } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === "standby") {
      this.result = this.skipStandbyResult;
    } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {
      this.result = void 0;
    }
  };
  InternalState2.prototype.getObsQueryOptions = function() {
    var toMerge = [];
    var globalDefaults = this.client.defaultOptions.watchQuery;
    if (globalDefaults)
      toMerge.push(globalDefaults);
    if (this.queryHookOptions.defaultOptions) {
      toMerge.push(this.queryHookOptions.defaultOptions);
    }
    toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));
    return toMerge.reduce(mergeOptions);
  };
  InternalState2.prototype.createWatchQueryOptions = function(_a2) {
    var _b;
    if (_a2 === void 0) {
      _a2 = {};
    }
    var skip = _a2.skip;
    _a2.ssr;
    _a2.onCompleted;
    _a2.onError;
    _a2.defaultOptions;
    var otherOptions = __rest$1(_a2, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
    var watchQueryOptions = Object.assign(otherOptions, { query: this.query });
    if (this.renderPromises && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
      watchQueryOptions.fetchPolicy = "cache-first";
    }
    if (!watchQueryOptions.variables) {
      watchQueryOptions.variables = {};
    }
    if (skip) {
      var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;
      Object.assign(watchQueryOptions, {
        initialFetchPolicy,
        fetchPolicy: "standby"
      });
    } else if (!watchQueryOptions.fetchPolicy) {
      watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();
    }
    return watchQueryOptions;
  };
  InternalState2.prototype.getDefaultFetchPolicy = function() {
    var _a2, _b;
    return ((_a2 = this.queryHookOptions.defaultOptions) === null || _a2 === void 0 ? void 0 : _a2.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "cache-first";
  };
  InternalState2.prototype.onCompleted = function(data2) {
  };
  InternalState2.prototype.onError = function(error) {
  };
  InternalState2.prototype.useObservableQuery = function() {
    var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || this.client.watchQuery(this.getObsQueryOptions());
    this.obsQueryFields = react.exports.useMemo(function() {
      return {
        refetch: obsQuery.refetch.bind(obsQuery),
        reobserve: obsQuery.reobserve.bind(obsQuery),
        fetchMore: obsQuery.fetchMore.bind(obsQuery),
        updateQuery: obsQuery.updateQuery.bind(obsQuery),
        startPolling: obsQuery.startPolling.bind(obsQuery),
        stopPolling: obsQuery.stopPolling.bind(obsQuery),
        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)
      };
    }, [obsQuery]);
    var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);
    if (this.renderPromises && ssrAllowed) {
      this.renderPromises.registerSSRObservable(obsQuery);
      if (obsQuery.getCurrentResult().loading) {
        this.renderPromises.addObservableQueryPromise(obsQuery);
      }
    }
    return obsQuery;
  };
  InternalState2.prototype.setResult = function(nextResult) {
    var previousResult = this.result;
    if (previousResult && previousResult.data) {
      this.previousData = previousResult.data;
    }
    this.result = nextResult;
    this.forceUpdate();
    this.handleErrorOrCompleted(nextResult);
  };
  InternalState2.prototype.handleErrorOrCompleted = function(result) {
    var _this = this;
    if (!result.loading) {
      Promise.resolve().then(function() {
        if (result.error) {
          _this.onError(result.error);
        } else if (result.data) {
          _this.onCompleted(result.data);
        }
      }).catch(function(error) {
        __DEV__ && invariant.warn(error);
      });
    }
  };
  InternalState2.prototype.getCurrentResult = function() {
    if (!this.result) {
      this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());
    }
    return this.result;
  };
  InternalState2.prototype.toQueryResult = function(result) {
    var queryResult = this.toQueryResultCache.get(result);
    if (queryResult)
      return queryResult;
    var data2 = result.data;
    result.partial;
    var resultWithoutPartial = __rest$1(result, ["data", "partial"]);
    this.toQueryResultCache.set(result, queryResult = __assign$1(__assign$1(__assign$1({ data: data2 }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));
    if (!queryResult.error && isNonEmptyArray(result.errors)) {
      queryResult.error = new ApolloError({ graphQLErrors: result.errors });
    }
    return queryResult;
  };
  InternalState2.prototype.unsafeHandlePartialRefetch = function(result) {
    if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== "cache-only") {
      Object.assign(result, {
        loading: true,
        networkStatus: NetworkStatus.refetch
      });
      this.observable.refetch();
    }
  };
  return InternalState2;
}();
function useMutation(mutation, options) {
  var client2 = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  verifyDocumentType(mutation, DocumentType.Mutation);
  var _a2 = react.exports.useState({
    called: false,
    loading: false,
    client: client2
  }), result = _a2[0], setResult = _a2[1];
  var ref = react.exports.useRef({
    result,
    mutationId: 0,
    isMounted: true,
    client: client2,
    mutation,
    options
  });
  {
    Object.assign(ref.current, { client: client2, options, mutation });
  }
  var execute2 = react.exports.useCallback(function(executeOptions) {
    if (executeOptions === void 0) {
      executeOptions = {};
    }
    var _a3 = ref.current, client3 = _a3.client, options2 = _a3.options, mutation2 = _a3.mutation;
    var baseOptions = __assign$1(__assign$1({}, options2), { mutation: mutation2 });
    if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {
      setResult(ref.current.result = {
        loading: true,
        error: void 0,
        data: void 0,
        called: true,
        client: client3
      });
    }
    var mutationId = ++ref.current.mutationId;
    var clientOptions = mergeOptions(baseOptions, executeOptions);
    return client3.mutate(clientOptions).then(function(response) {
      var _a4, _b, _c;
      var data2 = response.data, errors2 = response.errors;
      var error = errors2 && errors2.length > 0 ? new ApolloError({ graphQLErrors: errors2 }) : void 0;
      if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
        var result_1 = {
          called: true,
          loading: false,
          data: data2,
          error,
          client: client3
        };
        if (ref.current.isMounted && !equal(ref.current.result, result_1)) {
          setResult(ref.current.result = result_1);
        }
      }
      (_b = (_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a4, response.data, clientOptions);
      (_c = executeOptions.onCompleted) === null || _c === void 0 ? void 0 : _c.call(executeOptions, response.data, clientOptions);
      return response;
    }).catch(function(error) {
      var _a4, _b, _c, _d;
      if (mutationId === ref.current.mutationId && ref.current.isMounted) {
        var result_2 = {
          loading: false,
          error,
          data: void 0,
          called: true,
          client: client3
        };
        if (!equal(ref.current.result, result_2)) {
          setResult(ref.current.result = result_2);
        }
      }
      if (((_a4 = ref.current.options) === null || _a4 === void 0 ? void 0 : _a4.onError) || clientOptions.onError) {
        (_c = (_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onError) === null || _c === void 0 ? void 0 : _c.call(_b, error, clientOptions);
        (_d = executeOptions.onError) === null || _d === void 0 ? void 0 : _d.call(executeOptions, error, clientOptions);
        return { data: void 0, errors: error };
      }
      throw error;
    });
  }, []);
  var reset = react.exports.useCallback(function() {
    if (ref.current.isMounted) {
      setResult({ called: false, loading: false, client: client2 });
    }
  }, []);
  react.exports.useEffect(function() {
    ref.current.isMounted = true;
    return function() {
      ref.current.isMounted = false;
    };
  }, []);
  return [execute2, __assign$1({ reset }, result)];
}
function useSubscription(subscription, options) {
  var hasIssuedDeprecationWarningRef = react.exports.useRef(false);
  var client2 = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  verifyDocumentType(subscription, DocumentType.Subscription);
  var _a2 = react.exports.useState({
    loading: !(options === null || options === void 0 ? void 0 : options.skip),
    error: void 0,
    data: void 0,
    variables: options === null || options === void 0 ? void 0 : options.variables
  }), result = _a2[0], setResult = _a2[1];
  if (!hasIssuedDeprecationWarningRef.current) {
    hasIssuedDeprecationWarningRef.current = true;
    if (options === null || options === void 0 ? void 0 : options.onSubscriptionData) {
      __DEV__ && invariant.warn(options.onData ? "'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used." : "'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.");
    }
    if (options === null || options === void 0 ? void 0 : options.onSubscriptionComplete) {
      __DEV__ && invariant.warn(options.onComplete ? "'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used." : "'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.");
    }
  }
  var _b = react.exports.useState(function() {
    if (options === null || options === void 0 ? void 0 : options.skip) {
      return null;
    }
    return client2.subscribe({
      query: subscription,
      variables: options === null || options === void 0 ? void 0 : options.variables,
      fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
      context: options === null || options === void 0 ? void 0 : options.context
    });
  }), observable = _b[0], setObservable = _b[1];
  var canResetObservableRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    return function() {
      canResetObservableRef.current = true;
    };
  }, []);
  var ref = react.exports.useRef({ client: client2, subscription, options });
  react.exports.useEffect(function() {
    var _a3, _b2, _c, _d;
    var shouldResubscribe = options === null || options === void 0 ? void 0 : options.shouldResubscribe;
    if (typeof shouldResubscribe === "function") {
      shouldResubscribe = !!shouldResubscribe(options);
    }
    if (options === null || options === void 0 ? void 0 : options.skip) {
      if (!(options === null || options === void 0 ? void 0 : options.skip) !== !((_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.skip) || canResetObservableRef.current) {
        setResult({
          loading: false,
          data: void 0,
          error: void 0,
          variables: options === null || options === void 0 ? void 0 : options.variables
        });
        setObservable(null);
        canResetObservableRef.current = false;
      }
    } else if (shouldResubscribe !== false && (client2 !== ref.current.client || subscription !== ref.current.subscription || (options === null || options === void 0 ? void 0 : options.fetchPolicy) !== ((_b2 = ref.current.options) === null || _b2 === void 0 ? void 0 : _b2.fetchPolicy) || !(options === null || options === void 0 ? void 0 : options.skip) !== !((_c = ref.current.options) === null || _c === void 0 ? void 0 : _c.skip) || !equal(options === null || options === void 0 ? void 0 : options.variables, (_d = ref.current.options) === null || _d === void 0 ? void 0 : _d.variables)) || canResetObservableRef.current) {
      setResult({
        loading: true,
        data: void 0,
        error: void 0,
        variables: options === null || options === void 0 ? void 0 : options.variables
      });
      setObservable(client2.subscribe({
        query: subscription,
        variables: options === null || options === void 0 ? void 0 : options.variables,
        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
        context: options === null || options === void 0 ? void 0 : options.context
      }));
      canResetObservableRef.current = false;
    }
    Object.assign(ref.current, { client: client2, subscription, options });
  }, [client2, subscription, options, canResetObservableRef.current]);
  react.exports.useEffect(function() {
    if (!observable) {
      return;
    }
    var subscription2 = observable.subscribe({
      next: function(fetchResult) {
        var _a3, _b2;
        var result2 = {
          loading: false,
          data: fetchResult.data,
          error: void 0,
          variables: options === null || options === void 0 ? void 0 : options.variables
        };
        setResult(result2);
        if ((_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.onData) {
          ref.current.options.onData({
            client: client2,
            data: result2
          });
        } else if ((_b2 = ref.current.options) === null || _b2 === void 0 ? void 0 : _b2.onSubscriptionData) {
          ref.current.options.onSubscriptionData({
            client: client2,
            subscriptionData: result2
          });
        }
      },
      error: function(error) {
        var _a3, _b2;
        setResult({
          loading: false,
          data: void 0,
          error,
          variables: options === null || options === void 0 ? void 0 : options.variables
        });
        (_b2 = (_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.onError) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, error);
      },
      complete: function() {
        var _a3, _b2;
        if ((_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.onComplete) {
          ref.current.options.onComplete();
        } else if ((_b2 = ref.current.options) === null || _b2 === void 0 ? void 0 : _b2.onSubscriptionComplete) {
          ref.current.options.onSubscriptionComplete();
        }
      }
    });
    return function() {
      subscription2.unsubscribe();
    };
  }, [observable]);
  return result;
}
var dist$2 = {};
var WalletProviders = {};
var WalletProvider$1 = {};
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(jsxRuntime);
var errors = {};
Object.defineProperty(errors, "__esModule", { value: true });
errors.WalletWindowClosedError = errors.WalletWindowBlockedError = errors.WalletTimeoutError = errors.WalletSignTransactionError = errors.WalletSignAndSubmitMessageError = errors.WalletSignMessageError = errors.WalletSendTransactionError = errors.WalletNotConnectedError = errors.WalletKeypairError = errors.WalletPublicKeyError = errors.WalletNetworkChangeError = errors.WalletAccountChangeError = errors.WalletGetNetworkError = errors.WalletAccountError = errors.WalletDisconnectionError = errors.WalletDisconnectedError = errors.WalletConnectionError = errors.WalletConfigError = errors.WalletLoadError = errors.WalletNotReadyError = errors.WalletNotSelectedError = errors.WalletError = void 0;
class WalletError extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
}
errors.WalletError = WalletError;
class WalletNotSelectedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
}
errors.WalletNotSelectedError = WalletNotSelectedError;
class WalletNotReadyError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
}
errors.WalletNotReadyError = WalletNotReadyError;
class WalletLoadError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletLoadError";
  }
}
errors.WalletLoadError = WalletLoadError;
class WalletConfigError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConfigError";
  }
}
errors.WalletConfigError = WalletConfigError;
class WalletConnectionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
}
errors.WalletConnectionError = WalletConnectionError;
class WalletDisconnectedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectedError";
  }
}
errors.WalletDisconnectedError = WalletDisconnectedError;
class WalletDisconnectionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
}
errors.WalletDisconnectionError = WalletDisconnectionError;
class WalletAccountError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
}
errors.WalletAccountError = WalletAccountError;
class WalletGetNetworkError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
}
errors.WalletGetNetworkError = WalletGetNetworkError;
class WalletAccountChangeError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
}
errors.WalletAccountChangeError = WalletAccountChangeError;
class WalletNetworkChangeError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
}
errors.WalletNetworkChangeError = WalletNetworkChangeError;
class WalletPublicKeyError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletPublicKeyError";
  }
}
errors.WalletPublicKeyError = WalletPublicKeyError;
class WalletKeypairError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletKeypairError";
  }
}
errors.WalletKeypairError = WalletKeypairError;
class WalletNotConnectedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
}
errors.WalletNotConnectedError = WalletNotConnectedError;
class WalletSendTransactionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSendTransactionError";
  }
}
errors.WalletSendTransactionError = WalletSendTransactionError;
class WalletSignMessageError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
}
errors.WalletSignMessageError = WalletSignMessageError;
class WalletSignAndSubmitMessageError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
}
errors.WalletSignAndSubmitMessageError = WalletSignAndSubmitMessageError;
class WalletSignTransactionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
}
errors.WalletSignTransactionError = WalletSignTransactionError;
class WalletTimeoutError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletTimeoutError";
  }
}
errors.WalletTimeoutError = WalletTimeoutError;
class WalletWindowBlockedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletWindowBlockedError";
  }
}
errors.WalletWindowBlockedError = WalletWindowBlockedError;
class WalletWindowClosedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletWindowClosedError";
  }
}
errors.WalletWindowClosedError = WalletWindowClosedError;
var useLocalStorage$1 = {};
Object.defineProperty(useLocalStorage$1, "__esModule", { value: true });
useLocalStorage$1.useLocalStorage = void 0;
const react_1$1 = react.exports;
function useLocalStorage(key, defaultState) {
  const state = (0, react_1$1.useState)(() => {
    try {
      const value2 = localStorage.getItem(key);
      if (value2)
        return JSON.parse(value2);
    } catch (error) {
      if (typeof window !== "undefined") {
        console.error(error);
      }
    }
    return defaultState;
  });
  const value = state[0];
  const isFirstRender = (0, react_1$1.useRef)(true);
  (0, react_1$1.useEffect)(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    try {
      if (value === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, JSON.stringify(value));
      }
    } catch (error) {
      if (typeof window !== "undefined") {
        console.error(error);
      }
    }
  }, [value, key]);
  return state;
}
useLocalStorage$1.useLocalStorage = useLocalStorage;
var BaseAdapter = {};
var eventemitter3 = { exports: {} };
(function(module2) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names2 = [], events, name;
    if (this._eventsCount === 0)
      return names2;
    for (name in events = this._events) {
      if (has.call(events, name))
        names2.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers[i2].fn;
    }
    return ee2;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j2;
      for (i2 = 0; i2 < length; i2++) {
        if (listeners[i2].once)
          this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
        if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
          events.push(listeners[i2]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  {
    module2.exports = EventEmitter;
  }
})(eventemitter3);
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scopePollingDetectionStrategy = exports.BaseWalletAdapter = exports.WalletAdapterNetwork = exports.WalletReadyState = exports.EventEmitter = void 0;
  const eventemitter3_1 = __importDefault2(eventemitter3.exports);
  exports.EventEmitter = eventemitter3_1.default;
  (function(WalletReadyState) {
    WalletReadyState["Installed"] = "Installed";
    WalletReadyState["NotDetected"] = "NotDetected";
    WalletReadyState["Loadable"] = "Loadable";
    WalletReadyState["Unsupported"] = "Unsupported";
  })(exports.WalletReadyState || (exports.WalletReadyState = {}));
  (function(WalletAdapterNetwork) {
    WalletAdapterNetwork["Mainnet"] = "mainnet";
    WalletAdapterNetwork["Testnet"] = "testnet";
    WalletAdapterNetwork["Devnet"] = "devnet";
  })(exports.WalletAdapterNetwork || (exports.WalletAdapterNetwork = {}));
  class BaseWalletAdapter extends eventemitter3_1.default {
    get connected() {
      return !!this.publicAccount.publicKey;
    }
  }
  exports.BaseWalletAdapter = BaseWalletAdapter;
  function scopePollingDetectionStrategy(detect) {
    if (typeof window === "undefined" || typeof document === "undefined")
      return;
    const disposers = [];
    function detectAndDispose() {
      const detected = detect();
      if (detected) {
        for (const dispose of disposers) {
          dispose();
        }
      }
    }
    const interval = setInterval(detectAndDispose, 1e3);
    disposers.push(() => clearInterval(interval));
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", detectAndDispose, { once: true });
      disposers.push(() => document.removeEventListener("DOMContentLoaded", detectAndDispose));
    }
    if (document.readyState !== "complete") {
      window.addEventListener("load", detectAndDispose, { once: true });
      disposers.push(() => window.removeEventListener("load", detectAndDispose));
    }
    detectAndDispose();
  }
  exports.scopePollingDetectionStrategy = scopePollingDetectionStrategy;
})(BaseAdapter);
var useWallet = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.useWallet = exports.WalletContext = void 0;
  const react_12 = react.exports;
  const DEFAULT_CONTEXT = {
    autoConnect: false,
    connecting: false,
    connected: false,
    disconnecting: false
  };
  exports.WalletContext = (0, react_12.createContext)(DEFAULT_CONTEXT);
  function useWallet2() {
    return (0, react_12.useContext)(exports.WalletContext);
  }
  exports.useWallet = useWallet2;
})(useWallet);
var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(WalletProvider$1, "__esModule", { value: true });
WalletProvider$1.WalletProvider = void 0;
const jsx_runtime_1 = require$$0$1;
const react_1 = react.exports;
const errors_1 = errors;
const useLocalStorage_1 = useLocalStorage$1;
const BaseAdapter_1 = BaseAdapter;
const useWallet_1 = useWallet;
const initialState = {
  wallet: null,
  adapter: null,
  account: null,
  connected: false,
  network: null
};
const WalletProvider = ({ children, wallets: adapters, autoConnect = false, onError, localStorageKey = "walletName" }) => {
  const [name, setName] = (0, useLocalStorage_1.useLocalStorage)(localStorageKey, null);
  const [{ wallet, adapter, account, connected, network }, setState] = (0, react_1.useState)(initialState);
  const readyState = (adapter === null || adapter === void 0 ? void 0 : adapter.readyState) || BaseAdapter_1.WalletReadyState.Unsupported;
  const [connecting, setConnecting] = (0, react_1.useState)(false);
  const [disconnecting, setDisconnecting] = (0, react_1.useState)(false);
  const isConnecting = (0, react_1.useRef)(false);
  const isDisconnecting = (0, react_1.useRef)(false);
  const isUnloading = (0, react_1.useRef)(false);
  const [wallets, setWallets] = (0, react_1.useState)(() => adapters.map((adpt) => ({
    adapter: adpt,
    readyState: adpt.readyState
  })));
  (0, react_1.useEffect)(() => {
    function handleReadyStateChange(wReadyState) {
      setWallets((prevWallets) => {
        const index2 = prevWallets.findIndex(({ adapter: wAdapter2 }) => wAdapter2 === this);
        if (index2 === -1)
          return prevWallets;
        const { adapter: wAdapter } = prevWallets[index2];
        return [
          ...prevWallets.slice(0, index2),
          { adapter: wAdapter, readyState: wReadyState },
          ...prevWallets.slice(index2 + 1)
        ];
      });
    }
    adapters.forEach((wAdapter) => wAdapter.on("readyStateChange", handleReadyStateChange, wAdapter));
    return () => adapters.forEach((wAdapter) => wAdapter.off("readyStateChange", handleReadyStateChange, wAdapter));
  }, [adapters]);
  (0, react_1.useEffect)(() => {
    if (!autoConnect)
      return;
    const selectedWallet = wallets.find((wAdapter) => wAdapter.adapter.name === name);
    if (selectedWallet) {
      setState({
        wallet: selectedWallet,
        adapter: selectedWallet.adapter,
        connected: selectedWallet.adapter.connected,
        account: selectedWallet.adapter.publicAccount,
        network: selectedWallet.adapter.network
      });
    } else {
      setState(initialState);
    }
  }, [name, wallets, autoConnect]);
  (0, react_1.useEffect)(() => {
    function listener() {
      if (!autoConnect) {
        setName(null);
      }
      isUnloading.current = true;
    }
    window.addEventListener("beforeunload", listener);
    return () => window.removeEventListener("beforeunload", listener);
  }, [isUnloading, autoConnect]);
  const handleConnect = (0, react_1.useCallback)(() => {
    if (!adapter)
      return;
    setState((state) => {
      return Object.assign(Object.assign({}, state), { connected: adapter.connected, account: adapter.publicAccount, network: adapter.network });
    });
  }, [adapter]);
  const handleNetworkChange = (0, react_1.useCallback)(() => {
    if (!adapter)
      return;
    setState((state) => {
      return Object.assign(Object.assign({}, state), { network: adapter.network });
    });
  }, [adapter]);
  const handleAccountChange = (0, react_1.useCallback)(() => {
    if (!adapter)
      return;
    setState((state) => {
      return Object.assign(Object.assign({}, state), { account: adapter.publicAccount });
    });
  }, [adapter]);
  const handleDisconnect = (0, react_1.useCallback)(() => {
    if (!isUnloading.current) {
      setName(null);
      setState(initialState);
    }
  }, [isUnloading, setName]);
  const handleError2 = (0, react_1.useCallback)((error) => {
    if (!isUnloading.current)
      (onError || console.error)(error);
    return error;
  }, [isUnloading, onError]);
  (0, react_1.useEffect)(() => {
    if (adapter && connected) {
      adapter.onAccountChange();
      adapter.onNetworkChange();
    }
  }, [adapter, connected]);
  (0, react_1.useEffect)(() => {
    if (adapter) {
      adapter.on("connect", handleConnect);
      adapter.on("networkChange", handleNetworkChange);
      adapter.on("accountChange", handleAccountChange);
      adapter.on("disconnect", handleDisconnect);
      adapter.on("error", handleError2);
      return () => {
        adapter.off("connect", handleConnect);
        adapter.off("networkChange", handleNetworkChange);
        adapter.off("accountChange", handleAccountChange);
        adapter.off("disconnect", handleDisconnect);
        adapter.off("error", handleError2);
      };
    }
  }, [
    adapter,
    handleAccountChange,
    handleConnect,
    handleDisconnect,
    handleError2,
    handleNetworkChange
  ]);
  (0, react_1.useEffect)(() => {
    return () => {
      adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();
    };
  }, [adapter]);
  const connect = (0, react_1.useCallback)((walletName) => __awaiter$1(void 0, void 0, void 0, function* () {
    if (isConnecting.current || isDisconnecting.current || connected || !walletName)
      return;
    let walletToConnect = initialState;
    if (!adapter || walletName !== (adapter === null || adapter === void 0 ? void 0 : adapter.name)) {
      const selectedWallet = wallets.find((wAdapter) => wAdapter.adapter.name === walletName);
      if (selectedWallet) {
        walletToConnect = {
          wallet: selectedWallet,
          adapter: selectedWallet.adapter,
          connected: selectedWallet.adapter.connected,
          account: selectedWallet.adapter.publicAccount,
          network: selectedWallet.adapter.network
        };
      }
      setState(walletToConnect);
      setName(walletName);
    } else {
      walletToConnect = {
        wallet,
        adapter,
        connected,
        account,
        network
      };
    }
    if (!walletToConnect.adapter)
      throw handleError2(new errors_1.WalletNotSelectedError());
    if (!(walletToConnect.adapter.readyState === BaseAdapter_1.WalletReadyState.Installed || walletToConnect.adapter.readyState === BaseAdapter_1.WalletReadyState.Loadable)) {
      setName(null);
      if (typeof window !== "undefined") {
        window.open(walletToConnect.adapter.url, "_blank");
      }
      throw handleError2(new errors_1.WalletNotReadyError("Wallet Not Ready"));
    }
    isConnecting.current = true;
    setConnecting(true);
    try {
      yield walletToConnect.adapter.connect();
    } catch (error) {
      setName(null);
      throw error;
    } finally {
      setConnecting(false);
      isConnecting.current = false;
    }
  }), [connected, adapter, handleError2, wallets, setName, wallet, account, network]);
  (0, react_1.useEffect)(() => {
    if (isConnecting.current || connected || !autoConnect || !name || !adapter || !(readyState === BaseAdapter_1.WalletReadyState.Installed || readyState === BaseAdapter_1.WalletReadyState.Loadable))
      return;
    connect(name);
  }, [isConnecting, connected, autoConnect, name, connect, adapter, readyState]);
  const disconnect = (0, react_1.useCallback)(() => __awaiter$1(void 0, void 0, void 0, function* () {
    if (isDisconnecting.current)
      return;
    if (!adapter)
      return setName(null);
    isDisconnecting.current = true;
    setDisconnecting(true);
    try {
      yield adapter.disconnect();
    } catch (error) {
      setName(null);
      throw error;
    } finally {
      setDisconnecting(false);
      isDisconnecting.current = false;
    }
  }), [isDisconnecting, setName, adapter]);
  const signAndSubmitTransaction = (0, react_1.useCallback)((transaction, option) => __awaiter$1(void 0, void 0, void 0, function* () {
    if (!adapter)
      throw handleError2(new errors_1.WalletNotSelectedError());
    if (!connected)
      throw handleError2(new errors_1.WalletNotConnectedError());
    const response = yield adapter.signAndSubmitTransaction(transaction, option);
    return response;
  }), [adapter, handleError2, connected]);
  const signTransaction = (0, react_1.useCallback)((transaction, option) => __awaiter$1(void 0, void 0, void 0, function* () {
    if (!adapter)
      throw handleError2(new errors_1.WalletNotSelectedError());
    if (!connected)
      throw handleError2(new errors_1.WalletNotConnectedError());
    return adapter.signTransaction(transaction, option);
  }), [adapter, handleError2, connected]);
  const signMessage = (0, react_1.useCallback)((msgPayload) => __awaiter$1(void 0, void 0, void 0, function* () {
    if (!adapter)
      throw handleError2(new errors_1.WalletNotSelectedError());
    if (!connected)
      throw handleError2(new errors_1.WalletNotConnectedError());
    return adapter.signMessage(msgPayload);
  }), [adapter, handleError2, connected]);
  return (0, jsx_runtime_1.jsx)(useWallet_1.WalletContext.Provider, Object.assign({ value: {
    wallets,
    wallet,
    account,
    connected,
    connecting,
    disconnecting,
    autoConnect,
    select: connect,
    connect,
    disconnect,
    signAndSubmitTransaction,
    signTransaction,
    signMessage,
    network
  } }, { children }));
};
WalletProvider$1.WalletProvider = WalletProvider;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(WalletProvider$1, exports);
  __exportStar(errors, exports);
  __exportStar(useWallet, exports);
})(WalletProviders);
var WalletAdapters = {};
var PetraWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AptosWalletAdapter = exports.AptosWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.AptosWalletName = "Petra";
  class AptosWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.AptosWalletName;
      this.url = "https://chrome.google.com/webstore/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci";
      this.icon = "https://raw.githubusercontent.com/hippospace/aptos-wallet-adapter/main/logos/petra.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.aptos : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.aptos) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.aptos;
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          this._wallet = {
            address: response === null || response === void 0 ? void 0 : response.address,
            publicKey: response === null || response === void 0 ? void 0 : response.publicKey,
            isConnected: true
          };
          try {
            const name = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
            const chainId = null;
            const api = null;
            this._network = name;
            this._chainId = chainId;
            this._api = api;
          } catch (error) {
            const errMsg = error.message;
            this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
            throw error;
          }
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || window.aptos;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signAndSubmitTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(errMsg));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleAccountChange = (newAccount) => __awaiter2(this, void 0, void 0, function* () {
            var _a2, _b, _c, _d, _e2, _f;
            if (newAccount === null || newAccount === void 0 ? void 0 : newAccount.publicKey) {
              this._wallet = Object.assign(Object.assign({}, this._wallet), { publicKey: newAccount.publicKey || ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey), authKey: newAccount.authKey || ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.authKey), address: newAccount.address || ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.address) });
            } else {
              const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
              this._wallet = Object.assign(Object.assign({}, this._wallet), { authKey: (response === null || response === void 0 ? void 0 : response.authKey) || ((_d = this._wallet) === null || _d === void 0 ? void 0 : _d.authKey), address: (response === null || response === void 0 ? void 0 : response.address) || ((_e2 = this._wallet) === null || _e2 === void 0 ? void 0 : _e2.address), publicKey: (response === null || response === void 0 ? void 0 : response.publicKey) || ((_f = this._wallet) === null || _f === void 0 ? void 0 : _f.publicKey) });
            }
            this.emit("accountChange", newAccount.publicKey);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onAccountChange(handleAccountChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleNetworkChange = (newNetwork) => __awaiter2(this, void 0, void 0, function* () {
            this._network = newNetwork.networkName;
            this.emit("networkChange", this._network);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onNetworkChange(handleNetworkChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.AptosWalletAdapter = AptosWalletAdapter;
})(PetraWallet);
var HippoExtensionWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HippoExtensionWalletAdapter = exports.HippoExtensionWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.HippoExtensionWalletName = "Hippo";
  class HippoExtensionWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.HippoExtensionWalletName;
      this.url = "https://github.com/hippospace/hippo-wallet";
      this.icon = "https://ui-test1-22e7c.web.app/static/media/hippo_logo.ecded6bf411652de9b7f.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.hippoWallet : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.hippoWallet) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.hippoWallet;
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          this._wallet = Object.assign(Object.assign({}, response), { isConnected: true });
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        if (wallet) {
          this._wallet = null;
          try {
            const provider2 = this._provider || window.hippoWallet;
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          try {
            const provider2 = this._provider || window.hippoWallet;
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(transaction);
            if (response) {
              return response;
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          try {
            const provider2 = this._provider || window.hippoWallet;
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(transaction);
            if (response) {
              return response.detail.hash;
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignAndSubmitMessageError(error.message || error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hippoWallet;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(message);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hippoWallet;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hippoWallet;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.HippoExtensionWalletAdapter = HippoExtensionWalletAdapter;
})(HippoExtensionWallet);
var HippoWallet = {};
var aptosConstants = {};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module2) {
  (function(nacl) {
    var gf = function(init) {
      var i2, r2 = new Float64Array(16);
      if (init)
        for (i2 = 0; i2 < init.length; i2++)
          r2[i2] = init[i2];
      return r2;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x2, i2, h2, l2) {
      x2[i2] = h2 >> 24 & 255;
      x2[i2 + 1] = h2 >> 16 & 255;
      x2[i2 + 2] = h2 >> 8 & 255;
      x2[i2 + 3] = h2 & 255;
      x2[i2 + 4] = l2 >> 24 & 255;
      x2[i2 + 5] = l2 >> 16 & 255;
      x2[i2 + 6] = l2 >> 8 & 255;
      x2[i2 + 7] = l2 & 255;
    }
    function vn(x2, xi2, y2, yi2, n2) {
      var i2, d2 = 0;
      for (i2 = 0; i2 < n2; i2++)
        d2 |= x2[xi2 + i2] ^ y2[yi2 + i2];
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x2, xi2, y2, yi2) {
      return vn(x2, xi2, y2, yi2, 16);
    }
    function crypto_verify_32(x2, xi2, y2, yi2) {
      return vn(x2, xi2, y2, yi2, 32);
    }
    function core_salsa20(o2, p2, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i2 = 0; i2 < 20; i2 += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o2[0] = x0 >>> 0 & 255;
      o2[1] = x0 >>> 8 & 255;
      o2[2] = x0 >>> 16 & 255;
      o2[3] = x0 >>> 24 & 255;
      o2[4] = x1 >>> 0 & 255;
      o2[5] = x1 >>> 8 & 255;
      o2[6] = x1 >>> 16 & 255;
      o2[7] = x1 >>> 24 & 255;
      o2[8] = x2 >>> 0 & 255;
      o2[9] = x2 >>> 8 & 255;
      o2[10] = x2 >>> 16 & 255;
      o2[11] = x2 >>> 24 & 255;
      o2[12] = x3 >>> 0 & 255;
      o2[13] = x3 >>> 8 & 255;
      o2[14] = x3 >>> 16 & 255;
      o2[15] = x3 >>> 24 & 255;
      o2[16] = x4 >>> 0 & 255;
      o2[17] = x4 >>> 8 & 255;
      o2[18] = x4 >>> 16 & 255;
      o2[19] = x4 >>> 24 & 255;
      o2[20] = x5 >>> 0 & 255;
      o2[21] = x5 >>> 8 & 255;
      o2[22] = x5 >>> 16 & 255;
      o2[23] = x5 >>> 24 & 255;
      o2[24] = x6 >>> 0 & 255;
      o2[25] = x6 >>> 8 & 255;
      o2[26] = x6 >>> 16 & 255;
      o2[27] = x6 >>> 24 & 255;
      o2[28] = x7 >>> 0 & 255;
      o2[29] = x7 >>> 8 & 255;
      o2[30] = x7 >>> 16 & 255;
      o2[31] = x7 >>> 24 & 255;
      o2[32] = x8 >>> 0 & 255;
      o2[33] = x8 >>> 8 & 255;
      o2[34] = x8 >>> 16 & 255;
      o2[35] = x8 >>> 24 & 255;
      o2[36] = x9 >>> 0 & 255;
      o2[37] = x9 >>> 8 & 255;
      o2[38] = x9 >>> 16 & 255;
      o2[39] = x9 >>> 24 & 255;
      o2[40] = x10 >>> 0 & 255;
      o2[41] = x10 >>> 8 & 255;
      o2[42] = x10 >>> 16 & 255;
      o2[43] = x10 >>> 24 & 255;
      o2[44] = x11 >>> 0 & 255;
      o2[45] = x11 >>> 8 & 255;
      o2[46] = x11 >>> 16 & 255;
      o2[47] = x11 >>> 24 & 255;
      o2[48] = x12 >>> 0 & 255;
      o2[49] = x12 >>> 8 & 255;
      o2[50] = x12 >>> 16 & 255;
      o2[51] = x12 >>> 24 & 255;
      o2[52] = x13 >>> 0 & 255;
      o2[53] = x13 >>> 8 & 255;
      o2[54] = x13 >>> 16 & 255;
      o2[55] = x13 >>> 24 & 255;
      o2[56] = x14 >>> 0 & 255;
      o2[57] = x14 >>> 8 & 255;
      o2[58] = x14 >>> 16 & 255;
      o2[59] = x14 >>> 24 & 255;
      o2[60] = x15 >>> 0 & 255;
      o2[61] = x15 >>> 8 & 255;
      o2[62] = x15 >>> 16 & 255;
      o2[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o2, p2, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i2 = 0; i2 < 20; i2 += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      o2[0] = x0 >>> 0 & 255;
      o2[1] = x0 >>> 8 & 255;
      o2[2] = x0 >>> 16 & 255;
      o2[3] = x0 >>> 24 & 255;
      o2[4] = x5 >>> 0 & 255;
      o2[5] = x5 >>> 8 & 255;
      o2[6] = x5 >>> 16 & 255;
      o2[7] = x5 >>> 24 & 255;
      o2[8] = x10 >>> 0 & 255;
      o2[9] = x10 >>> 8 & 255;
      o2[10] = x10 >>> 16 & 255;
      o2[11] = x10 >>> 24 & 255;
      o2[12] = x15 >>> 0 & 255;
      o2[13] = x15 >>> 8 & 255;
      o2[14] = x15 >>> 16 & 255;
      o2[15] = x15 >>> 24 & 255;
      o2[16] = x6 >>> 0 & 255;
      o2[17] = x6 >>> 8 & 255;
      o2[18] = x6 >>> 16 & 255;
      o2[19] = x6 >>> 24 & 255;
      o2[20] = x7 >>> 0 & 255;
      o2[21] = x7 >>> 8 & 255;
      o2[22] = x7 >>> 16 & 255;
      o2[23] = x7 >>> 24 & 255;
      o2[24] = x8 >>> 0 & 255;
      o2[25] = x8 >>> 8 & 255;
      o2[26] = x8 >>> 16 & 255;
      o2[27] = x8 >>> 24 & 255;
      o2[28] = x9 >>> 0 & 255;
      o2[29] = x9 >>> 8 & 255;
      o2[30] = x9 >>> 16 & 255;
      o2[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c2) {
      core_salsa20(out, inp, k2, c2);
    }
    function crypto_core_hsalsa20(out, inp, k2, c2) {
      core_hsalsa20(out, inp, k2, c2);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c2, cpos, m2, mpos, b2, n2, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u2, i2;
      for (i2 = 0; i2 < 16; i2++)
        z2[i2] = 0;
      for (i2 = 0; i2 < 8; i2++)
        z2[i2] = n2[i2];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i2 = 0; i2 < 64; i2++)
          c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
        u2 = 1;
        for (i2 = 8; i2 < 16; i2++) {
          u2 = u2 + (z2[i2] & 255) | 0;
          z2[i2] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i2 = 0; i2 < b2; i2++)
          c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
      }
      return 0;
    }
    function crypto_stream_salsa20(c2, cpos, b2, n2, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u2, i2;
      for (i2 = 0; i2 < 16; i2++)
        z2[i2] = 0;
      for (i2 = 0; i2 < 8; i2++)
        z2[i2] = n2[i2];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i2 = 0; i2 < 64; i2++)
          c2[cpos + i2] = x2[i2];
        u2 = 1;
        for (i2 = 8; i2 < 16; i2++) {
          u2 = u2 + (z2[i2] & 255) | 0;
          z2[i2] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i2 = 0; i2 < b2; i2++)
          c2[cpos + i2] = x2[i2];
      }
      return 0;
    }
    function crypto_stream(c2, cpos, d2, n2, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n2, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i2 = 0; i2 < 8; i2++)
        sn[i2] = n2[i2 + 16];
      return crypto_stream_salsa20(c2, cpos, d2, sn, s2);
    }
    function crypto_stream_xor(c2, cpos, m2, mpos, d2, n2, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n2, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i2 = 0; i2 < 8; i2++)
        sn[i2] = n2[i2 + 16];
      return crypto_stream_salsa20_xor(c2, cpos, m2, mpos, d2, sn, s2);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m2, mpos, bytes2) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c2;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes2 >= 16) {
        t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c2 = 0;
        d0 = c2;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c2 = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c2 += d0 >>> 13;
        d0 &= 8191;
        d1 = c2;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c2 = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c2 += d1 >>> 13;
        d1 &= 8191;
        d2 = c2;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c2 = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c2 += d2 >>> 13;
        d2 &= 8191;
        d3 = c2;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c2 = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c2 += d3 >>> 13;
        d3 &= 8191;
        d4 = c2;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c2 = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c2 += d4 >>> 13;
        d4 &= 8191;
        d5 = c2;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c2 = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c2 += d5 >>> 13;
        d5 &= 8191;
        d6 = c2;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c2 = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c2 += d6 >>> 13;
        d6 &= 8191;
        d7 = c2;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c2 = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c2 += d7 >>> 13;
        d7 &= 8191;
        d8 = c2;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c2 = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c2 += d8 >>> 13;
        d8 &= 8191;
        d9 = c2;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c2 = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c2 += d9 >>> 13;
        d9 &= 8191;
        c2 = (c2 << 2) + c2 | 0;
        c2 = c2 + d0 | 0;
        d0 = c2 & 8191;
        c2 = c2 >>> 13;
        d1 += c2;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes2 -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c2, mask, f2, i2;
      if (this.leftover) {
        i2 = this.leftover;
        this.buffer[i2++] = 1;
        for (; i2 < 16; i2++)
          this.buffer[i2] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i2 = 2; i2 < 10; i2++) {
        this.h[i2] += c2;
        c2 = this.h[i2] >>> 13;
        this.h[i2] &= 8191;
      }
      this.h[0] += c2 * 5;
      c2 = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c2;
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c2;
      g[0] = this.h[0] + 5;
      c2 = g[0] >>> 13;
      g[0] &= 8191;
      for (i2 = 1; i2 < 10; i2++) {
        g[i2] = this.h[i2] + c2;
        c2 = g[i2] >>> 13;
        g[i2] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c2 ^ 1) - 1;
      for (i2 = 0; i2 < 10; i2++)
        g[i2] &= mask;
      mask = ~mask;
      for (i2 = 0; i2 < 10; i2++)
        this.h[i2] = this.h[i2] & mask | g[i2];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f2 = this.h[0] + this.pad[0];
      this.h[0] = f2 & 65535;
      for (i2 = 1; i2 < 8; i2++) {
        f2 = (this.h[i2] + this.pad[i2] | 0) + (f2 >>> 16) | 0;
        this.h[i2] = f2 & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m2, mpos, bytes2) {
      var i2, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes2)
          want = bytes2;
        for (i2 = 0; i2 < want; i2++)
          this.buffer[this.leftover + i2] = m2[mpos + i2];
        bytes2 -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes2 >= 16) {
        want = bytes2 - bytes2 % 16;
        this.blocks(m2, mpos, want);
        mpos += want;
        bytes2 -= want;
      }
      if (bytes2) {
        for (i2 = 0; i2 < bytes2; i2++)
          this.buffer[this.leftover + i2] = m2[mpos + i2];
        this.leftover += bytes2;
      }
    };
    function crypto_onetimeauth(out, outpos, m2, mpos, n2, k2) {
      var s2 = new poly1305(k2);
      s2.update(m2, mpos, n2);
      s2.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n2, k2) {
      var x2 = new Uint8Array(16);
      crypto_onetimeauth(x2, 0, m2, mpos, n2, k2);
      return crypto_verify_16(h2, hpos, x2, 0);
    }
    function crypto_secretbox(c2, m2, d2, n2, k2) {
      var i2;
      if (d2 < 32)
        return -1;
      crypto_stream_xor(c2, 0, m2, 0, d2, n2, k2);
      crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
      for (i2 = 0; i2 < 16; i2++)
        c2[i2] = 0;
      return 0;
    }
    function crypto_secretbox_open(m2, c2, d2, n2, k2) {
      var i2;
      var x2 = new Uint8Array(32);
      if (d2 < 32)
        return -1;
      crypto_stream(x2, 0, 32, n2, k2);
      if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x2) !== 0)
        return -1;
      crypto_stream_xor(m2, 0, c2, 0, d2, n2, k2);
      for (i2 = 0; i2 < 32; i2++)
        m2[i2] = 0;
      return 0;
    }
    function set25519(r2, a2) {
      var i2;
      for (i2 = 0; i2 < 16; i2++)
        r2[i2] = a2[i2] | 0;
    }
    function car25519(o2) {
      var i2, v2, c2 = 1;
      for (i2 = 0; i2 < 16; i2++) {
        v2 = o2[i2] + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        o2[i2] = v2 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q2, b2) {
      var t2, c2 = ~(b2 - 1);
      for (var i2 = 0; i2 < 16; i2++) {
        t2 = c2 & (p2[i2] ^ q2[i2]);
        p2[i2] ^= t2;
        q2[i2] ^= t2;
      }
    }
    function pack25519(o2, n2) {
      var i2, j2, b2;
      var m2 = gf(), t2 = gf();
      for (i2 = 0; i2 < 16; i2++)
        t2[i2] = n2[i2];
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j2 = 0; j2 < 2; j2++) {
        m2[0] = t2[0] - 65517;
        for (i2 = 1; i2 < 15; i2++) {
          m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
          m2[i2 - 1] &= 65535;
        }
        m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t2, m2, 1 - b2);
      }
      for (i2 = 0; i2 < 16; i2++) {
        o2[2 * i2] = t2[i2] & 255;
        o2[2 * i2 + 1] = t2[i2] >> 8;
      }
    }
    function neq25519(a2, b2) {
      var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
      pack25519(c2, a2);
      pack25519(d2, b2);
      return crypto_verify_32(c2, 0, d2, 0);
    }
    function par25519(a2) {
      var d2 = new Uint8Array(32);
      pack25519(d2, a2);
      return d2[0] & 1;
    }
    function unpack25519(o2, n2) {
      var i2;
      for (i2 = 0; i2 < 16; i2++)
        o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
      o2[15] &= 32767;
    }
    function A2(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; i2++)
        o2[i2] = a2[i2] + b2[i2];
    }
    function Z2(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; i2++)
        o2[i2] = a2[i2] - b2[i2];
    }
    function M2(o2, a2, b2) {
      var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t0;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
    function S2(o2, a2) {
      M2(o2, a2, a2);
    }
    function inv25519(o2, i2) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; a2++)
        c2[a2] = i2[a2];
      for (a2 = 253; a2 >= 0; a2--) {
        S2(c2, c2);
        if (a2 !== 2 && a2 !== 4)
          M2(c2, c2, i2);
      }
      for (a2 = 0; a2 < 16; a2++)
        o2[a2] = c2[a2];
    }
    function pow2523(o2, i2) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; a2++)
        c2[a2] = i2[a2];
      for (a2 = 250; a2 >= 0; a2--) {
        S2(c2, c2);
        if (a2 !== 1)
          M2(c2, c2, i2);
      }
      for (a2 = 0; a2 < 16; a2++)
        o2[a2] = c2[a2];
    }
    function crypto_scalarmult(q2, n2, p2) {
      var z2 = new Uint8Array(32);
      var x2 = new Float64Array(80), r2, i2;
      var a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e3 = gf(), f2 = gf();
      for (i2 = 0; i2 < 31; i2++)
        z2[i2] = n2[i2];
      z2[31] = n2[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x2, p2);
      for (i2 = 0; i2 < 16; i2++) {
        b2[i2] = x2[i2];
        d2[i2] = a2[i2] = c2[i2] = 0;
      }
      a2[0] = d2[0] = 1;
      for (i2 = 254; i2 >= 0; --i2) {
        r2 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
        sel25519(a2, b2, r2);
        sel25519(c2, d2, r2);
        A2(e3, a2, c2);
        Z2(a2, a2, c2);
        A2(c2, b2, d2);
        Z2(b2, b2, d2);
        S2(d2, e3);
        S2(f2, a2);
        M2(a2, c2, a2);
        M2(c2, b2, e3);
        A2(e3, a2, c2);
        Z2(a2, a2, c2);
        S2(b2, a2);
        Z2(c2, d2, f2);
        M2(a2, c2, _121665);
        A2(a2, a2, d2);
        M2(c2, c2, a2);
        M2(a2, d2, f2);
        M2(d2, b2, x2);
        S2(b2, e3);
        sel25519(a2, b2, r2);
        sel25519(c2, d2, r2);
      }
      for (i2 = 0; i2 < 16; i2++) {
        x2[i2 + 16] = a2[i2];
        x2[i2 + 32] = c2[i2];
        x2[i2 + 48] = b2[i2];
        x2[i2 + 64] = d2[i2];
      }
      var x32 = x2.subarray(32);
      var x16 = x2.subarray(16);
      inv25519(x32, x32);
      M2(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n2) {
      return crypto_scalarmult(q2, n2, _9);
    }
    function crypto_box_keypair(y2, x2) {
      randombytes(x2, 32);
      return crypto_scalarmult_base(y2, x2);
    }
    function crypto_box_beforenm(k2, y2, x2) {
      var s2 = new Uint8Array(32);
      crypto_scalarmult(s2, x2, y2);
      return crypto_core_hsalsa20(k2, _0, s2, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c2, m2, d2, n2, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_afternm(c2, m2, d2, n2, k2);
    }
    function crypto_box_open(m2, c2, d2, n2, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_open_afternm(m2, c2, d2, n2, k2);
    }
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh2, hl2, m2, n2) {
      var wh2 = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th2, tl2, i2, j2, h2, l2, a2, b2, c2, d2;
      var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
      var pos = 0;
      while (n2 >= 128) {
        for (i2 = 0; i2 < 16; i2++) {
          j2 = 8 * i2 + pos;
          wh2[i2] = m2[j2 + 0] << 24 | m2[j2 + 1] << 16 | m2[j2 + 2] << 8 | m2[j2 + 3];
          wl[i2] = m2[j2 + 4] << 24 | m2[j2 + 5] << 16 | m2[j2 + 6] << 8 | m2[j2 + 7];
        }
        for (i2 = 0; i2 < 80; i2++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l2 = al7;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = K2[i2 * 2];
          l2 = K2[i2 * 2 + 1];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = wh2[i2 % 16];
          l2 = wl[i2 % 16];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          th2 = c2 & 65535 | d2 << 16;
          tl2 = a2 & 65535 | b2 << 16;
          h2 = th2;
          l2 = tl2;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          bh7 = c2 & 65535 | d2 << 16;
          bl7 = a2 & 65535 | b2 << 16;
          h2 = bh3;
          l2 = bl3;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = th2;
          l2 = tl2;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          bh3 = c2 & 65535 | d2 << 16;
          bl3 = a2 & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i2 % 16 === 15) {
            for (j2 = 0; j2 < 16; j2++) {
              h2 = wh2[j2];
              l2 = wl[j2];
              a2 = l2 & 65535;
              b2 = l2 >>> 16;
              c2 = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = wh2[(j2 + 9) % 16];
              l2 = wl[(j2 + 9) % 16];
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j2 + 1) % 16];
              tl2 = wl[(j2 + 1) % 16];
              h2 = (th2 >>> 1 | tl2 << 32 - 1) ^ (th2 >>> 8 | tl2 << 32 - 8) ^ th2 >>> 7;
              l2 = (tl2 >>> 1 | th2 << 32 - 1) ^ (tl2 >>> 8 | th2 << 32 - 8) ^ (tl2 >>> 7 | th2 << 32 - 7);
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j2 + 14) % 16];
              tl2 = wl[(j2 + 14) % 16];
              h2 = (th2 >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th2 << 32 - (61 - 32)) ^ th2 >>> 6;
              l2 = (tl2 >>> 19 | th2 << 32 - 19) ^ (th2 >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th2 << 32 - 6);
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a2 >>> 16;
              c2 += b2 >>> 16;
              d2 += c2 >>> 16;
              wh2[j2] = c2 & 65535 | d2 << 16;
              wl[j2] = a2 & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l2 = al0;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[0];
        l2 = hl2[0];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[0] = ah0 = c2 & 65535 | d2 << 16;
        hl2[0] = al0 = a2 & 65535 | b2 << 16;
        h2 = ah1;
        l2 = al1;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[1];
        l2 = hl2[1];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[1] = ah1 = c2 & 65535 | d2 << 16;
        hl2[1] = al1 = a2 & 65535 | b2 << 16;
        h2 = ah2;
        l2 = al2;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[2];
        l2 = hl2[2];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[2] = ah2 = c2 & 65535 | d2 << 16;
        hl2[2] = al2 = a2 & 65535 | b2 << 16;
        h2 = ah3;
        l2 = al3;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[3];
        l2 = hl2[3];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[3] = ah3 = c2 & 65535 | d2 << 16;
        hl2[3] = al3 = a2 & 65535 | b2 << 16;
        h2 = ah4;
        l2 = al4;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[4];
        l2 = hl2[4];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[4] = ah4 = c2 & 65535 | d2 << 16;
        hl2[4] = al4 = a2 & 65535 | b2 << 16;
        h2 = ah5;
        l2 = al5;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[5];
        l2 = hl2[5];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[5] = ah5 = c2 & 65535 | d2 << 16;
        hl2[5] = al5 = a2 & 65535 | b2 << 16;
        h2 = ah6;
        l2 = al6;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[6];
        l2 = hl2[6];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[6] = ah6 = c2 & 65535 | d2 << 16;
        hl2[6] = al6 = a2 & 65535 | b2 << 16;
        h2 = ah7;
        l2 = al7;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[7];
        l2 = hl2[7];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[7] = ah7 = c2 & 65535 | d2 << 16;
        hl2[7] = al7 = a2 & 65535 | b2 << 16;
        pos += 128;
        n2 -= 128;
      }
      return n2;
    }
    function crypto_hash(out, m2, n2) {
      var hh2 = new Int32Array(8), hl2 = new Int32Array(8), x2 = new Uint8Array(256), i2, b2 = n2;
      hh2[0] = 1779033703;
      hh2[1] = 3144134277;
      hh2[2] = 1013904242;
      hh2[3] = 2773480762;
      hh2[4] = 1359893119;
      hh2[5] = 2600822924;
      hh2[6] = 528734635;
      hh2[7] = 1541459225;
      hl2[0] = 4089235720;
      hl2[1] = 2227873595;
      hl2[2] = 4271175723;
      hl2[3] = 1595750129;
      hl2[4] = 2917565137;
      hl2[5] = 725511199;
      hl2[6] = 4215389547;
      hl2[7] = 327033209;
      crypto_hashblocks_hl(hh2, hl2, m2, n2);
      n2 %= 128;
      for (i2 = 0; i2 < n2; i2++)
        x2[i2] = m2[b2 - n2 + i2];
      x2[n2] = 128;
      n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
      x2[n2 - 9] = 0;
      ts64(x2, n2 - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh2, hl2, x2, n2);
      for (i2 = 0; i2 < 8; i2++)
        ts64(out, 8 * i2, hh2[i2], hl2[i2]);
      return 0;
    }
    function add(p2, q2) {
      var a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e3 = gf(), f2 = gf(), g = gf(), h2 = gf(), t2 = gf();
      Z2(a2, p2[1], p2[0]);
      Z2(t2, q2[1], q2[0]);
      M2(a2, a2, t2);
      A2(b2, p2[0], p2[1]);
      A2(t2, q2[0], q2[1]);
      M2(b2, b2, t2);
      M2(c2, p2[3], q2[3]);
      M2(c2, c2, D22);
      M2(d2, p2[2], q2[2]);
      A2(d2, d2, d2);
      Z2(e3, b2, a2);
      Z2(f2, d2, c2);
      A2(g, d2, c2);
      A2(h2, b2, a2);
      M2(p2[0], e3, f2);
      M2(p2[1], h2, g);
      M2(p2[2], g, f2);
      M2(p2[3], e3, h2);
    }
    function cswap(p2, q2, b2) {
      var i2;
      for (i2 = 0; i2 < 4; i2++) {
        sel25519(p2[i2], q2[i2], b2);
      }
    }
    function pack(r2, p2) {
      var tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p2[2]);
      M2(tx, p2[0], zi2);
      M2(ty, p2[1], zi2);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p2, q2, s2) {
      var b2, i2;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i2 = 255; i2 >= 0; --i2) {
        b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p2, q2, b2);
        add(q2, p2);
        add(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s2) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p2, q2, s2);
    }
    function crypto_sign_keypair(pk2, sk2, seeded) {
      var d2 = new Uint8Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      var i2;
      if (!seeded)
        randombytes(sk2, 32);
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk2, p2);
      for (i2 = 0; i2 < 32; i2++)
        sk2[i2 + 32] = pk2[i2];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r2, x2) {
      var carry, i2, j2, k2;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j2 = i2 - 32, k2 = i2 - 12; j2 < k2; ++j2) {
          x2[j2] += carry - 16 * x2[i2] * L2[j2 - (i2 - 32)];
          carry = Math.floor((x2[j2] + 128) / 256);
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i2] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; j2++) {
        x2[j2] += carry - (x2[31] >> 4) * L2[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; j2++)
        x2[j2] -= carry * L2[j2];
      for (i2 = 0; i2 < 32; i2++) {
        x2[i2 + 1] += x2[i2] >> 8;
        r2[i2] = x2[i2] & 255;
      }
    }
    function reduce(r2) {
      var x2 = new Float64Array(64), i2;
      for (i2 = 0; i2 < 64; i2++)
        x2[i2] = r2[i2];
      for (i2 = 0; i2 < 64; i2++)
        r2[i2] = 0;
      modL(r2, x2);
    }
    function crypto_sign(sm, m2, n2, sk2) {
      var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r2 = new Uint8Array(64);
      var i2, j2, x2 = new Float64Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n2 + 64;
      for (i2 = 0; i2 < n2; i2++)
        sm[64 + i2] = m2[i2];
      for (i2 = 0; i2 < 32; i2++)
        sm[32 + i2] = d2[32 + i2];
      crypto_hash(r2, sm.subarray(32), n2 + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack(sm, p2);
      for (i2 = 32; i2 < 64; i2++)
        sm[i2] = sk2[i2];
      crypto_hash(h2, sm, n2 + 64);
      reduce(h2);
      for (i2 = 0; i2 < 64; i2++)
        x2[i2] = 0;
      for (i2 = 0; i2 < 32; i2++)
        x2[i2] = r2[i2];
      for (i2 = 0; i2 < 32; i2++) {
        for (j2 = 0; j2 < 32; j2++) {
          x2[i2 + j2] += h2[i2] * d2[j2];
        }
      }
      modL(sm.subarray(32), x2);
      return smlen;
    }
    function unpackneg(r2, p2) {
      var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S2(num, r2[1]);
      M2(den, num, D2);
      Z2(num, num, r2[2]);
      A2(den, r2[2], den);
      S2(den2, den);
      S2(den4, den2);
      M2(den6, den4, den2);
      M2(t2, den6, num);
      M2(t2, t2, den);
      pow2523(t2, t2);
      M2(t2, t2, num);
      M2(t2, t2, den);
      M2(t2, t2, den);
      M2(r2[0], t2, den);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        M2(r2[0], r2[0], I2);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r2[0]) === p2[31] >> 7)
        Z2(r2[0], gf0, r2[0]);
      M2(r2[3], r2[0], r2[1]);
      return 0;
    }
    function crypto_sign_open(m2, sm, n2, pk2) {
      var i2;
      var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
      var p2 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      if (n2 < 64)
        return -1;
      if (unpackneg(q2, pk2))
        return -1;
      for (i2 = 0; i2 < n2; i2++)
        m2[i2] = sm[i2];
      for (i2 = 0; i2 < 32; i2++)
        m2[i2 + 32] = pk2[i2];
      crypto_hash(h2, m2, n2);
      reduce(h2);
      scalarmult(p2, q2, h2);
      scalarbase(q2, sm.subarray(32));
      add(p2, q2);
      pack(t2, p2);
      n2 -= 64;
      if (crypto_verify_32(sm, 0, t2, 0)) {
        for (i2 = 0; i2 < n2; i2++)
          m2[i2] = 0;
        return -1;
      }
      for (i2 = 0; i2 < n2; i2++)
        m2[i2] = sm[i2 + 64];
      return n2;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M: M2,
      A: A2,
      S: S2,
      Z: Z2,
      pow2523,
      add,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n2) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n2.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk2, sk2) {
      if (pk2.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk2.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i2 = 0; i2 < arguments.length; i2++) {
        if (!(arguments[i2] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i2 = 0; i2 < arr.length; i2++)
        arr[i2] = 0;
    }
    nacl.randomBytes = function(n2) {
      var b2 = new Uint8Array(n2);
      randombytes(b2, n2);
      return b2;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c2 = new Uint8Array(m2.length);
      for (var i2 = 0; i2 < msg.length; i2++)
        m2[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
      crypto_secretbox(c2, m2, m2.length, nonce, key);
      return c2.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m2 = new Uint8Array(c2.length);
      for (var i2 = 0; i2 < box.length; i2++)
        c2[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
      if (c2.length < 32)
        return null;
      if (crypto_secretbox_open(m2, c2, c2.length, nonce, key) !== 0)
        return null;
      return m2.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n2, p2) {
      checkArrayTypes(n2, p2);
      if (n2.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p2.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n2, p2);
      return q2;
    };
    nacl.scalarMult.base = function(n2) {
      checkArrayTypes(n2);
      if (n2.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n2);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k2);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k2);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk2, secretKey);
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m2 = new Uint8Array(mlen);
      for (var i2 = 0; i2 < m2.length; i2++)
        m2[i2] = tmp[i2];
      return m2;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i2 = 0; i2 < sig.length; i2++)
        sig[i2] = signedMsg[i2];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i2;
      for (i2 = 0; i2 < crypto_sign_BYTES; i2++)
        sm[i2] = sig[i2];
      for (i2 = 0; i2 < msg.length; i2++)
        sm[i2 + crypto_sign_BYTES] = msg[i2];
      return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i2 = 0; i2 < pk2.length; i2++)
        pk2[i2] = secretKey[32 + i2];
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i2 = 0; i2 < 32; i2++)
        sk2[i2] = seed[i2];
      crypto_sign_keypair(pk2, sk2, true);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x2, y2) {
      checkArrayTypes(x2, y2);
      if (x2.length === 0 || y2.length === 0)
        return false;
      if (x2.length !== y2.length)
        return false;
      return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x2, n2) {
          var i2, v2 = new Uint8Array(n2);
          for (i2 = 0; i2 < n2; i2 += QUOTA) {
            crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
          }
          for (i2 = 0; i2 < n2; i2++)
            x2[i2] = v2[i2];
          cleanup(v2);
        });
      } else if (typeof commonjsRequire !== "undefined") {
        crypto2 = require$$0;
        if (crypto2 && crypto2.randomBytes) {
          nacl.setPRNG(function(x2, n2) {
            var i2, v2 = crypto2.randomBytes(n2);
            for (i2 = 0; i2 < n2; i2++)
              x2[i2] = v2[i2];
            cleanup(v2);
          });
        }
      }
    })();
  })(module2.exports ? module2.exports : self.nacl = self.nacl || {});
})(naclFast);
var sha3$1 = {};
var _assert = {};
Object.defineProperty(_assert, "__esModule", { value: true });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
_assert.number = number;
function bool(b2) {
  if (typeof b2 !== "boolean")
    throw new Error(`Expected boolean, not ${b2}`);
}
_assert.bool = bool;
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
_assert.bytes = bytes;
function hash$2(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
_assert.hash = hash$2;
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
_assert.output = output;
const assert = {
  number,
  bool,
  bytes,
  hash: hash$2,
  exists,
  output
};
_assert.default = assert;
var _u64 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
  const U32_MASK64 = BigInt(2 ** 32 - 1);
  const _32n = BigInt(32);
  function fromBig(n2, le2 = false) {
    if (le2)
      return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
    return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
  }
  exports.fromBig = fromBig;
  function split2(lst, le2 = false) {
    let Ah2 = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i2 = 0; i2 < lst.length; i2++) {
      const { h: h2, l: l2 } = fromBig(lst[i2], le2);
      [Ah2[i2], Al[i2]] = [h2, l2];
    }
    return [Ah2, Al];
  }
  exports.split = split2;
  const toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
  exports.toBig = toBig;
  const shrSH = (h2, l2, s2) => h2 >>> s2;
  const shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
  const rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
  const rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
  const rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
  const rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
  const rotr32H = (h2, l2) => l2;
  const rotr32L = (h2, l2) => h2;
  const rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
  const rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
  const rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
  const rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
  function add(Ah2, Al, Bh2, Bl) {
    const l2 = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah2 + Bh2 + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
  }
  exports.add = add;
  const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  const add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
  const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  const add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
  const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  const add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
  const u64 = {
    fromBig,
    split: split2,
    toBig: exports.toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64;
})(_u64);
var utils$4 = {};
var cryptoBrowser = {};
Object.defineProperty(cryptoBrowser, "__esModule", { value: true });
cryptoBrowser.crypto = void 0;
cryptoBrowser.crypto = {
  node: void 0,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
(function(exports) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
  const crypto_1 = cryptoBrowser;
  const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u32;
  const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView;
  const rotr = (word, shift2) => word << 32 - shift2 | word >>> shift2;
  exports.rotr = rotr;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!exports.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const hexes = Array.from({ length: 256 }, (v2, i2) => i2.toString(16).padStart(2, "0"));
  function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    let hex2 = "";
    for (let i2 = 0; i2 < uint8a.length; i2++) {
      hex2 += hexes[uint8a[i2]];
    }
    return hex2;
  }
  exports.bytesToHex = bytesToHex;
  function hexToBytes(hex2) {
    if (typeof hex2 !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
    }
    if (hex2.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex2.length / 2);
    for (let i2 = 0; i2 < array.length; i2++) {
      const j2 = i2 * 2;
      const hexByte = hex2.slice(j2, j2 + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i2] = byte;
    }
    return array;
  }
  exports.hexToBytes = hexToBytes;
  const nextTick = async () => {
  };
  exports.nextTick = nextTick;
  async function asyncLoop(iters, tick, cb2) {
    let ts = Date.now();
    for (let i2 = 0; i2 < iters; i2++) {
      cb2(i2);
      const diff2 = Date.now() - ts;
      if (diff2 >= 0 && diff2 < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff2;
    }
  }
  exports.asyncLoop = asyncLoop;
  function utf8ToBytes(str) {
    if (typeof str !== "string") {
      throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  exports.utf8ToBytes = utf8ToBytes;
  function toBytes(data2) {
    if (typeof data2 === "string")
      data2 = utf8ToBytes(data2);
    if (!(data2 instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof data2})`);
    return data2;
  }
  exports.toBytes = toBytes;
  function concatBytes(...arrays) {
    if (!arrays.every((a2) => a2 instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a2, arr) => a2 + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
      const arr = arrays[i2];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  }
  exports.concatBytes = concatBytes;
  class Hash {
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash;
  const isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
      throw new TypeError("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  exports.checkOpts = checkOpts;
  function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
  }
  exports.wrapConstructor = wrapConstructor;
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
      return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto_1.crypto.node) {
      return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  }
  exports.randomBytes = randomBytes;
})(utils$4);
Object.defineProperty(sha3$1, "__esModule", { value: true });
sha3$1.shake256 = sha3$1.shake128 = sha3$1.keccak_512 = sha3$1.keccak_384 = sha3$1.keccak_256 = sha3$1.keccak_224 = sha3$1.sha3_512 = sha3$1.sha3_384 = sha3$1.sha3_256 = sha3$1.sha3_224 = sha3$1.Keccak = sha3$1.keccakP = void 0;
const _assert_js_1$2 = _assert;
const _u64_js_1$1 = _u64;
const utils_js_1$4 = utils$4;
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(113);
for (let round2 = 0, R2 = _1n, x2 = 1, y2 = 0; round2 < 24; round2++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x2));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n)
      t2 ^= _1n << (_1n << BigInt(j2)) - _1n;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1$1.default.split(_SHA3_IOTA, true);
const rotlH = (h2, l2, s2) => s2 > 32 ? _u64_js_1$1.default.rotlBH(h2, l2, s2) : _u64_js_1$1.default.rotlSH(h2, l2, s2);
const rotlL = (h2, l2, s2) => s2 > 32 ? _u64_js_1$1.default.rotlBL(h2, l2, s2) : _u64_js_1$1.default.rotlSL(h2, l2, s2);
function keccakP(s2, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x2 + y2] ^= Th2;
        s2[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift2 = SHA3_ROTL[t2];
      const Th2 = rotlH(curH, curL, shift2);
      const Tl = rotlL(curH, curL, shift2);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th2;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s2[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round2];
    s2[1] ^= SHA3_IOTA_L[round2];
  }
  B2.fill(0);
}
sha3$1.keccakP = keccakP;
class Keccak extends utils_js_1$4.Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    _assert_js_1$2.default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = (0, utils_js_1$4.u32)(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    _assert_js_1$2.default.exists(this);
    const { blockLen, state } = this;
    data2 = (0, utils_js_1$4.toBytes)(data2);
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    _assert_js_1$2.default.exists(this, false);
    _assert_js_1$2.default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    _assert_js_1$2.default.number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    _assert_js_1$2.default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
sha3$1.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1$4.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
sha3$1.sha3_224 = gen(6, 144, 224 / 8);
sha3$1.sha3_256 = gen(6, 136, 256 / 8);
sha3$1.sha3_384 = gen(6, 104, 384 / 8);
sha3$1.sha3_512 = gen(6, 72, 512 / 8);
sha3$1.keccak_224 = gen(1, 144, 224 / 8);
sha3$1.keccak_256 = gen(1, 136, 256 / 8);
sha3$1.keccak_384 = gen(1, 104, 384 / 8);
sha3$1.keccak_512 = gen(1, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1$4.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
sha3$1.shake128 = genShake(31, 168, 128 / 8);
sha3$1.shake256 = genShake(31, 136, 256 / 8);
var bip39$1 = {};
var pbkdf2$1 = {};
var hmac = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = void 0;
  const _assert_js_12 = _assert;
  const utils_js_12 = utils$4;
  class HMAC extends utils_js_12.Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      _assert_js_12.default.hash(hash2);
      const key = (0, utils_js_12.toBytes)(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new TypeError("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i2 = 0; i2 < pad.length; i2++)
        pad[i2] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i2 = 0; i2 < pad.length; i2++)
        pad[i2] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      _assert_js_12.default.exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      _assert_js_12.default.exists(this);
      _assert_js_12.default.bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }
  const hmac2 = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
  exports.hmac = hmac2;
  exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
})(hmac);
Object.defineProperty(pbkdf2$1, "__esModule", { value: true });
pbkdf2$1.pbkdf2Async = pbkdf2$1.pbkdf2 = void 0;
const _assert_js_1$1 = _assert;
const hmac_js_1 = hmac;
const utils_js_1$3 = utils$4;
function pbkdf2Init(hash2, _password, _salt, _opts) {
  _assert_js_1$1.default.hash(hash2);
  const opts = (0, utils_js_1$3.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  _assert_js_1$1.default.number(c2);
  _assert_js_1$1.default.number(dkLen);
  _assert_js_1$1.default.number(asyncTick);
  if (c2 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = (0, utils_js_1$3.toBytes)(_password);
  const salt2 = (0, utils_js_1$3.toBytes)(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac_js_1.hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt2);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u2.fill(0);
  return DK;
}
function pbkdf2(hash2, password, salt2, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt2, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = (0, utils_js_1$3.createView)(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
    const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti2, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti2.set(u2.subarray(0, Ti2.length));
    for (let ui2 = 1; ui2 < c2; ui2++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i2 = 0; i2 < Ti2.length; i2++)
        Ti2[i2] ^= u2[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}
pbkdf2$1.pbkdf2 = pbkdf2;
async function pbkdf2Async(hash2, password, salt2, opts) {
  const { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt2, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = (0, utils_js_1$3.createView)(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
    const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti2, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti2.set(u2.subarray(0, Ti2.length));
    await (0, utils_js_1$3.asyncLoop)(c2 - 1, asyncTick, (i2) => {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i3 = 0; i3 < Ti2.length; i3++)
        Ti2[i3] ^= u2[i3];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}
pbkdf2$1.pbkdf2Async = pbkdf2Async;
var sha256 = {};
var _sha2 = {};
Object.defineProperty(_sha2, "__esModule", { value: true });
_sha2.SHA2 = void 0;
const _assert_js_1 = _assert;
const utils_js_1$2 = utils$4;
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE ? 4 : 0;
  const l2 = isLE ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE);
  view.setUint32(byteOffset + l2, wl, isLE);
}
class SHA2 extends utils_js_1$2.Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = (0, utils_js_1$2.createView)(this.buffer);
  }
  update(data2) {
    _assert_js_1.default.exists(this);
    const { view, buffer, blockLen } = this;
    data2 = (0, utils_js_1$2.toBytes)(data2);
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = (0, utils_js_1$2.createView)(data2);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    _assert_js_1.default.exists(this);
    _assert_js_1.default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = (0, utils_js_1$2.createView)(out);
    this.get().forEach((v2, i2) => oview.setUint32(4 * i2, v2, isLE));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}
_sha2.SHA2 = SHA2;
Object.defineProperty(sha256, "__esModule", { value: true });
sha256.sha256 = void 0;
const _sha2_js_1$1 = _sha2;
const utils_js_1$1 = utils$4;
const Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
const SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1$1.SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i2 = 0; i2 < 16; i2++, offset2 += 4)
      SHA256_W[i2] = view.getUint32(offset2, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = (0, utils_js_1$1.rotr)(W15, 7) ^ (0, utils_js_1$1.rotr)(W15, 18) ^ W15 >>> 3;
      const s1 = (0, utils_js_1$1.rotr)(W2, 17) ^ (0, utils_js_1$1.rotr)(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = (0, utils_js_1$1.rotr)(E2, 6) ^ (0, utils_js_1$1.rotr)(E2, 11) ^ (0, utils_js_1$1.rotr)(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = (0, utils_js_1$1.rotr)(A2, 2) ^ (0, utils_js_1$1.rotr)(A2, 13) ^ (0, utils_js_1$1.rotr)(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
sha256.sha256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA256());
var sha512 = {};
Object.defineProperty(sha512, "__esModule", { value: true });
sha512.sha384 = sha512.sha512_256 = sha512.sha512 = sha512.SHA512 = void 0;
const _sha2_js_1 = _sha2;
const _u64_js_1 = _u64;
const utils_js_1 = utils$4;
const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2)));
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  get() {
    const { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    return [Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl];
  }
  set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl) {
    this.Ah = Ah2 | 0;
    this.Al = Al | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh2 | 0;
    this.El = El | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i2 = 0; i2 < 16; i2++, offset2 += 4) {
      SHA512_W_H[i2] = view.getUint32(offset2);
      SHA512_W_L[i2] = view.getUint32(offset2 += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
      const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
      const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
      const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = _u64_js_1.default.rotrSH(Eh2, El, 14) ^ _u64_js_1.default.rotrSH(Eh2, El, 18) ^ _u64_js_1.default.rotrBH(Eh2, El, 41);
      const sigma1l = _u64_js_1.default.rotrSL(Eh2, El, 14) ^ _u64_js_1.default.rotrSL(Eh2, El, 18) ^ _u64_js_1.default.rotrBL(Eh2, El, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = _u64_js_1.default.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = _u64_js_1.default.rotrSH(Ah2, Al, 28) ^ _u64_js_1.default.rotrBH(Ah2, Al, 34) ^ _u64_js_1.default.rotrBH(Ah2, Al, 39);
      const sigma0l = _u64_js_1.default.rotrSL(Ah2, Al, 28) ^ _u64_js_1.default.rotrBL(Ah2, Al, 34) ^ _u64_js_1.default.rotrBL(Ah2, Al, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh2 = Gh2 | 0;
      Hl = Gl | 0;
      Gh2 = Fh2 | 0;
      Gl = Fl | 0;
      Fh2 = Eh2 | 0;
      Fl = El | 0;
      ({ h: Eh2, l: El } = _u64_js_1.default.add(Dh2 | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl = Cl | 0;
      Ch2 = Bh2 | 0;
      Cl = Bl | 0;
      Bh2 = Ah2 | 0;
      Bl = Al | 0;
      const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
      Ah2 = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah2, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al | 0));
    ({ h: Bh2, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl | 0));
    ({ h: Ch2, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl | 0));
    ({ h: Dh2, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl | 0));
    ({ h: Eh2, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh2 | 0, El | 0));
    ({ h: Fh2, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl | 0));
    ({ h: Gh2, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl | 0));
    ({ h: Hh2, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl | 0));
    this.set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
sha512.SHA512 = SHA512;
class SHA512_256 extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
}
class SHA384 extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
}
sha512.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
sha512.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
sha512.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
var lib = {};
(function(exports) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
  function assertNumber(n2) {
    if (!Number.isSafeInteger(n2))
      throw new Error(`Wrong integer: ${n2}`);
  }
  exports.assertNumber = assertNumber;
  function chain(...args) {
    const wrap2 = (a2, b2) => (c2) => a2(b2(c2));
    const encode = Array.from(args).reverse().reduce((acc, i2) => acc ? wrap2(acc, i2.encode) : i2.encode, void 0);
    const decode = args.reduce((acc, i2) => acc ? wrap2(acc, i2.decode) : i2.decode, void 0);
    return { encode, decode };
  }
  function alphabet(alphabet2) {
    return {
      encode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return digits.map((i2) => {
          assertNumber(i2);
          if (i2 < 0 || i2 >= alphabet2.length)
            throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet2.length})`);
          return alphabet2[i2];
        });
      },
      decode: (input) => {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("alphabet.decode input should be array of strings");
        return input.map((letter) => {
          if (typeof letter !== "string")
            throw new Error(`alphabet.decode: not string element=${letter}`);
          const index2 = alphabet2.indexOf(letter);
          if (index2 === -1)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
          return index2;
        });
      }
    };
  }
  function join2(separator = "") {
    if (typeof separator !== "string")
      throw new Error("join separator should be string");
    return {
      encode: (from) => {
        if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
          throw new Error("join.encode input should be array of strings");
        for (let i2 of from)
          if (typeof i2 !== "string")
            throw new Error(`join.encode: non-string input=${i2}`);
        return from.join(separator);
      },
      decode: (to) => {
        if (typeof to !== "string")
          throw new Error("join.decode input should be string");
        return to.split(separator);
      }
    };
  }
  function padding(bits, chr = "=") {
    assertNumber(bits);
    if (typeof chr !== "string")
      throw new Error("padding chr should be string");
    return {
      encode(data2) {
        if (!Array.isArray(data2) || data2.length && typeof data2[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i2 of data2)
          if (typeof i2 !== "string")
            throw new Error(`padding.encode: non-string input=${i2}`);
        while (data2.length * bits % 8)
          data2.push(chr);
        return data2;
      },
      decode(input) {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i2 of input)
          if (typeof i2 !== "string")
            throw new Error(`padding.decode: non-string input=${i2}`);
        let end = input.length;
        if (end * bits % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          if (!((end - 1) * bits % 8))
            throw new Error("Invalid padding: string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  function normalize2(fn) {
    if (typeof fn !== "function")
      throw new Error("normalize fn should be function");
    return { encode: (from) => from, decode: (to) => fn(to) };
  }
  function convertRadix(data2, from, to) {
    if (from < 2)
      throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2)
      throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data2))
      throw new Error("convertRadix: data should be array");
    if (!data2.length)
      return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data2);
    digits.forEach((d2) => {
      assertNumber(d2);
      if (d2 < 0 || d2 >= from)
        throw new Error(`Wrong integer: ${d2}`);
    });
    while (true) {
      let carry = 0;
      let done = true;
      for (let i2 = pos; i2 < digits.length; i2++) {
        const digit = digits[i2];
        const digitBase = from * carry + digit;
        if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
          throw new Error("convertRadix: carry overflow");
        }
        carry = digitBase % to;
        digits[i2] = Math.floor(digitBase / to);
        if (!Number.isSafeInteger(digits[i2]) || digits[i2] * to + carry !== digitBase)
          throw new Error("convertRadix: carry overflow");
        if (!done)
          continue;
        else if (!digits[i2])
          pos = i2;
        else
          done = false;
      }
      res.push(carry);
      if (done)
        break;
    }
    for (let i2 = 0; i2 < data2.length - 1 && data2[i2] === 0; i2++)
      res.push(0);
    return res.reverse();
  }
  const gcd = (a2, b2) => !b2 ? a2 : gcd(b2, a2 % b2);
  const radix2carry = (from, to) => from + (to - gcd(from, to));
  function convertRadix2(data2, from, to, padding2) {
    if (!Array.isArray(data2))
      throw new Error("convertRadix2: data should be array");
    if (from <= 0 || from > 32)
      throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
      throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
      throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0;
    const mask = 2 ** to - 1;
    const res = [];
    for (const n2 of data2) {
      assertNumber(n2);
      if (n2 >= 2 ** from)
        throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
      carry = carry << from | n2;
      if (pos + from > 32)
        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
      pos += from;
      for (; pos >= to; pos -= to)
        res.push((carry >> pos - to & mask) >>> 0);
      carry &= 2 ** pos - 1;
    }
    carry = carry << to - pos & mask;
    if (!padding2 && pos >= from)
      throw new Error("Excess padding");
    if (!padding2 && carry)
      throw new Error(`Non-zero padding: ${carry}`);
    if (padding2 && pos > 0)
      res.push(carry >>> 0);
    return res;
  }
  function radix(num) {
    assertNumber(num);
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return convertRadix(Array.from(bytes2), 2 ** 8, num);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
      }
    };
  }
  function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn) {
    if (typeof fn !== "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...args) {
      try {
        return fn.apply(null, args);
      } catch (e3) {
      }
    };
  }
  function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== "function")
      throw new Error("checksum fn should be function");
    return {
      encode(data2) {
        if (!(data2 instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const checksum2 = fn(data2).slice(0, len);
        const res = new Uint8Array(data2.length + len);
        res.set(data2);
        res.set(checksum2, data2.length);
        return res;
      },
      decode(data2) {
        if (!(data2 instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const payload = data2.slice(0, -len);
        const newChecksum = fn(payload).slice(0, len);
        const oldChecksum = data2.slice(-len);
        for (let i2 = 0; i2 < len; i2++)
          if (newChecksum[i2] !== oldChecksum[i2])
            throw new Error("Invalid checksum");
        return payload;
      }
    };
  }
  exports.utils = { alphabet, chain, checksum, radix, radix2, join: join2, padding };
  exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join2(""));
  exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join2(""));
  exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join2(""));
  exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
  exports.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join2(""));
  exports.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join2(""));
  const genBase58 = (abc) => chain(radix(58), alphabet(abc), join2(""));
  exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
  exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  exports.base58xmr = {
    encode(data2) {
      let res = "";
      for (let i2 = 0; i2 < data2.length; i2 += 8) {
        const block2 = data2.subarray(i2, i2 + 8);
        res += exports.base58.encode(block2).padStart(XMR_BLOCK_LEN[block2.length], "1");
      }
      return res;
    },
    decode(str) {
      let res = [];
      for (let i2 = 0; i2 < str.length; i2 += 11) {
        const slice2 = str.slice(i2, i2 + 11);
        const blockLen = XMR_BLOCK_LEN.indexOf(slice2.length);
        const block2 = exports.base58.decode(slice2);
        for (let j2 = 0; j2 < block2.length - blockLen; j2++) {
          if (block2[j2] !== 0)
            throw new Error("base58xmr: wrong padding");
        }
        res = res.concat(Array.from(block2.slice(block2.length - blockLen)));
      }
      return Uint8Array.from(res);
    }
  };
  const base58check = (sha2562) => chain(checksum(4, (data2) => sha2562(sha2562(data2))), exports.base58);
  exports.base58check = base58check;
  const BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
  const POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function bech32Polymod(pre) {
    const b2 = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
      if ((b2 >> i2 & 1) === 1)
        chk ^= POLYMOD_GENERATORS[i2];
    }
    return chk;
  }
  function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i2 = 0; i2 < len; i2++) {
      const c2 = prefix.charCodeAt(i2);
      if (c2 < 33 || c2 > 126)
        throw new Error(`Invalid prefix (${prefix})`);
      chk = bech32Polymod(chk) ^ c2 >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i2 = 0; i2 < len; i2++)
      chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
    for (let v2 of words)
      chk = bech32Polymod(chk) ^ v2;
    for (let i2 = 0; i2 < 6; i2++)
      chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
  }
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
      if (typeof prefix !== "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
      if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
      const actualLength = prefix.length + 7 + words.length;
      if (limit !== false && actualLength > limit)
        throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
      prefix = prefix.toLowerCase();
      return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
    }
    function decode(str, limit = 90) {
      if (typeof str !== "string")
        throw new Error(`bech32.decode input should be string, not ${typeof str}`);
      if (str.length < 8 || limit !== false && str.length > limit)
        throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase())
        throw new Error(`String must be lowercase or uppercase`);
      str = lowered;
      const sepIndex = str.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1)
        throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix = str.slice(0, sepIndex);
      const _words2 = str.slice(sepIndex + 1);
      if (_words2.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
      const sum2 = bechChecksum(prefix, words, ENCODING_CONST);
      if (!_words2.endsWith(sum2))
        throw new Error(`Invalid checksum in ${str}: expected "${sum2}"`);
      return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
      const { prefix, words } = decode(str, false);
      return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
  }
  exports.bech32 = genBech32("bech32");
  exports.bech32m = genBech32("bech32m");
  exports.utf8 = {
    encode: (data2) => new TextDecoder().decode(data2),
    decode: (str) => new TextEncoder().encode(str)
  };
  exports.hex = chain(radix2(4), alphabet("0123456789abcdef"), join2(""), normalize2((s2) => {
    if (typeof s2 !== "string" || s2.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
    return s2.toLowerCase();
  }));
  const CODERS = {
    utf8: exports.utf8,
    hex: exports.hex,
    base16: exports.base16,
    base32: exports.base32,
    base64: exports.base64,
    base64url: exports.base64url,
    base58: exports.base58,
    base58xmr: exports.base58xmr
  };
  const coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;
  const bytesToString = (type, bytes2) => {
    if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
      throw new TypeError(coderTypeError);
    if (!(bytes2 instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return CODERS[type].encode(bytes2);
  };
  exports.bytesToString = bytesToString;
  exports.str = exports.bytesToString;
  const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
      throw new TypeError(coderTypeError);
    if (typeof str !== "string")
      throw new TypeError("stringToBytes() expects string");
    return CODERS[type].decode(str);
  };
  exports.stringToBytes = stringToBytes;
  exports.bytes = exports.stringToBytes;
})(lib);
Object.defineProperty(bip39$1, "__esModule", { value: true });
bip39$1.mnemonicToSeedSync = bip39$1.mnemonicToSeed = bip39$1.validateMnemonic = bip39$1.entropyToMnemonic = bip39$1.mnemonicToEntropy = bip39$1.generateMnemonic = void 0;
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const _assert_1 = _assert;
const pbkdf2_1 = pbkdf2$1;
const sha256_1 = sha256;
const sha512_1 = sha512;
const utils_1 = utils$4;
const base_1 = lib;
const isJapanese = (wordlist) => wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
  return str.normalize("NFKD");
}
function normalize(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
function assertEntropy(entropy) {
  _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
}
function generateMnemonic(wordlist, strength = 128) {
  _assert_1.default.number(strength);
  if (strength % 32 !== 0 || strength > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
}
bip39$1.generateMnemonic = generateMnemonic;
const calcChecksum = (entropy) => {
  const bitsLeft = 8 - entropy.length / 4;
  return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
};
function getCoder(wordlist) {
  if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== "string")
    throw new Error("Worlist: expected array of 2048 strings");
  wordlist.forEach((i2) => {
    if (typeof i2 !== "string")
      throw new Error(`Wordlist: non-string element: ${i2}`);
  });
  return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
}
function mnemonicToEntropy(mnemonic, wordlist) {
  const { words } = normalize(mnemonic);
  const entropy = getCoder(wordlist).decode(words);
  assertEntropy(entropy);
  return entropy;
}
bip39$1.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
  assertEntropy(entropy);
  const words = getCoder(wordlist).encode(entropy);
  return words.join(isJapanese(wordlist) ? "\u3000" : " ");
}
bip39$1.entropyToMnemonic = entropyToMnemonic;
function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch (e3) {
    return false;
  }
  return true;
}
bip39$1.validateMnemonic = validateMnemonic;
const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
function mnemonicToSeed(mnemonic, passphrase = "") {
  return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
bip39$1.mnemonicToSeed = mnemonicToSeed;
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
bip39$1.mnemonicToSeedSync = mnemonicToSeedSync;
var axios$1 = { exports: {} };
var axios = { exports: {} };
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind)
    return bind;
  hasRequiredBind = 1;
  bind = function bind2(fn, thisArg) {
    return function wrap2() {
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      return fn.apply(thisArg, args);
    };
  };
  return bind;
}
var utils$3;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$3;
  hasRequiredUtils = 1;
  var bind2 = requireBind();
  var toString2 = Object.prototype.toString;
  var kindOf = function(cache2) {
    return function(thing) {
      var str = toString2.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    };
  }(/* @__PURE__ */ Object.create(null));
  function kindOfTest(type) {
    type = type.toLowerCase();
    return function isKindOf(thing) {
      return kindOf(thing) === type;
    };
  }
  function isArray2(val) {
    return Array.isArray(val);
  }
  function isUndefined2(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  function isString2(val) {
    return typeof val === "string";
  }
  function isNumber2(val) {
    return typeof val === "number";
  }
  function isObject2(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (kindOf(val) !== "object") {
      return false;
    }
    var prototype2 = Object.getPrototypeOf(val);
    return prototype2 === null || prototype2 === Object.prototype;
  }
  var isDate2 = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob2 = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  function isFunction2(val) {
    return toString2.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject2(val) && isFunction2(val.pipe);
  }
  function isFormData2(thing) {
    var pattern = "[object FormData]";
    return thing && (typeof FormData === "function" && thing instanceof FormData || toString2.call(thing) === pattern || isFunction2(thing.toString) && thing.toString() === pattern);
  }
  var isURLSearchParams = kindOfTest("URLSearchParams");
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach2(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray2(obj)) {
      for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray2(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      forEach2(arguments[i2], assignValue);
    }
    return result;
  }
  function extend2(a2, b2, thisArg) {
    forEach2(b2, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a2[key] = bind2(val, thisArg);
      } else {
        a2[key] = val;
      }
    });
    return a2;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  function inherits(constructor, superConstructor, props, descriptors) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    props && Object.assign(constructor.prototype, props);
  }
  function toFlatObject(sourceObj, destObj, filter2) {
    var props;
    var i2;
    var prop;
    var merged = {};
    destObj = destObj || {};
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if (!merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = Object.getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  }
  function endsWith2(str, searchString, position) {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  }
  function toArray2(thing) {
    if (!thing)
      return null;
    var i2 = thing.length;
    if (isUndefined2(i2))
      return null;
    var arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  }
  var isTypedArray = function(TypedArray) {
    return function(thing) {
      return TypedArray && thing instanceof TypedArray;
    };
  }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
  utils$3 = {
    isArray: isArray2,
    isArrayBuffer,
    isBuffer,
    isFormData: isFormData2,
    isArrayBufferView,
    isString: isString2,
    isNumber: isNumber2,
    isObject: isObject2,
    isPlainObject,
    isUndefined: isUndefined2,
    isDate: isDate2,
    isFile,
    isBlob: isBlob2,
    isFunction: isFunction2,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach: forEach2,
    merge,
    extend: extend2,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith: endsWith2,
    toArray: toArray2,
    isTypedArray,
    isFileList
  };
  return utils$3;
}
var buildURL;
var hasRequiredBuildURL;
function requireBuildURL() {
  if (hasRequiredBuildURL)
    return buildURL;
  hasRequiredBuildURL = 1;
  var utils2 = requireUtils();
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  buildURL = function buildURL2(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils2.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils2.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils2.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils2.forEach(val, function parseValue(v2) {
          if (utils2.isDate(v2)) {
            v2 = v2.toISOString();
          } else if (utils2.isObject(v2)) {
            v2 = JSON.stringify(v2);
          }
          parts.push(encode(key) + "=" + encode(v2));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  return buildURL;
}
var InterceptorManager_1;
var hasRequiredInterceptorManager;
function requireInterceptorManager() {
  if (hasRequiredInterceptorManager)
    return InterceptorManager_1;
  hasRequiredInterceptorManager = 1;
  var utils2 = requireUtils();
  function InterceptorManager() {
    this.handlers = [];
  }
  InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager.prototype.eject = function eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  };
  InterceptorManager.prototype.forEach = function forEach2(fn) {
    utils2.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  };
  InterceptorManager_1 = InterceptorManager;
  return InterceptorManager_1;
}
var normalizeHeaderName;
var hasRequiredNormalizeHeaderName;
function requireNormalizeHeaderName() {
  if (hasRequiredNormalizeHeaderName)
    return normalizeHeaderName;
  hasRequiredNormalizeHeaderName = 1;
  var utils2 = requireUtils();
  normalizeHeaderName = function normalizeHeaderName2(headers, normalizedName) {
    utils2.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  return normalizeHeaderName;
}
var AxiosError_1;
var hasRequiredAxiosError;
function requireAxiosError() {
  if (hasRequiredAxiosError)
    return AxiosError_1;
  hasRequiredAxiosError = 1;
  var utils2 = requireUtils();
  function AxiosError(message, code, config, request2, response) {
    Error.call(this);
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request2 && (this.request = request2);
    response && (this.response = response);
  }
  utils2.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  var prototype2 = AxiosError.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED"
  ].forEach(function(code) {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype2, "isAxiosError", { value: true });
  AxiosError.from = function(error, code, config, request2, response, customProps) {
    var axiosError = Object.create(prototype2);
    utils2.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    });
    AxiosError.call(axiosError, error.message, code, config, request2, response);
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  AxiosError_1 = AxiosError;
  return AxiosError_1;
}
var transitional;
var hasRequiredTransitional;
function requireTransitional() {
  if (hasRequiredTransitional)
    return transitional;
  hasRequiredTransitional = 1;
  transitional = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  return transitional;
}
var toFormData_1;
var hasRequiredToFormData;
function requireToFormData() {
  if (hasRequiredToFormData)
    return toFormData_1;
  hasRequiredToFormData = 1;
  var utils2 = requireUtils();
  function toFormData(obj, formData) {
    formData = formData || new FormData();
    var stack = [];
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils2.isDate(value)) {
        return value.toISOString();
      }
      if (utils2.isArrayBuffer(value) || utils2.isTypedArray(value)) {
        return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function build2(data2, parentKey) {
      if (utils2.isPlainObject(data2) || utils2.isArray(data2)) {
        if (stack.indexOf(data2) !== -1) {
          throw Error("Circular reference detected in " + parentKey);
        }
        stack.push(data2);
        utils2.forEach(data2, function each(value, key) {
          if (utils2.isUndefined(value))
            return;
          var fullKey = parentKey ? parentKey + "." + key : key;
          var arr;
          if (value && !parentKey && typeof value === "object") {
            if (utils2.endsWith(key, "{}")) {
              value = JSON.stringify(value);
            } else if (utils2.endsWith(key, "[]") && (arr = utils2.toArray(value))) {
              arr.forEach(function(el2) {
                !utils2.isUndefined(el2) && formData.append(fullKey, convertValue(el2));
              });
              return;
            }
          }
          build2(value, fullKey);
        });
        stack.pop();
      } else {
        formData.append(parentKey, convertValue(data2));
      }
    }
    build2(obj);
    return formData;
  }
  toFormData_1 = toFormData;
  return toFormData_1;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var AxiosError = requireAxiosError();
  settle = function settle2(resolve2, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = requireUtils();
  cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove2(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }();
  return cookies;
}
var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL)
    return isAbsoluteURL;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL = function isAbsoluteURL2(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  };
  return isAbsoluteURL;
}
var combineURLs;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs)
    return combineURLs;
  hasRequiredCombineURLs = 1;
  combineURLs = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs;
}
var buildFullPath;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL2 = requireIsAbsoluteURL();
  var combineURLs2 = requireCombineURLs();
  buildFullPath = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = requireUtils();
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser2(line) {
      i2 = line.indexOf(":");
      key = utils2.trim(line.substr(0, i2)).toLowerCase();
      val = utils2.trim(line.substr(i2 + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = requireUtils();
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError = requireAxiosError();
  var utils2 = requireUtils();
  function CanceledError(message) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol)
    return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url) {
    var match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match2 && match2[1] || "";
  };
  return parseProtocol;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = requireUtils();
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL2 = requireBuildURL();
  var buildFullPath2 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var transitionalDefaults = requireTransitional();
  var AxiosError = requireAxiosError();
  var CanceledError = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config.baseURL, config.url);
      request2.open(config.method.toUpperCase(), buildURL2(fullPath, config.params, config.paramsSerializer), true);
      request2.timeout = config.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config,
          request: request2
        };
        settle2(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
        request2 = null;
      };
      request2.onerror = function handleError2() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request2.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request2.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request2) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
          request2.abort();
          request2 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null)
    return _null;
  hasRequired_null = 1;
  _null = null;
  return _null;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1;
  hasRequiredDefaults = 1;
  var utils2 = requireUtils();
  var normalizeHeaderName2 = requireNormalizeHeaderName();
  var AxiosError = requireAxiosError();
  var transitionalDefaults = requireTransitional();
  var toFormData = requireToFormData();
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils2.isUndefined(headers) && utils2.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = requireXhr();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = requireXhr();
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils2.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils2.trim(rawValue);
      } catch (e3) {
        if (e3.name !== "SyntaxError") {
          throw e3;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults = {
    transitional: transitionalDefaults,
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data2, headers) {
      normalizeHeaderName2(headers, "Accept");
      normalizeHeaderName2(headers, "Content-Type");
      if (utils2.isFormData(data2) || utils2.isArrayBuffer(data2) || utils2.isBuffer(data2) || utils2.isStream(data2) || utils2.isFile(data2) || utils2.isBlob(data2)) {
        return data2;
      }
      if (utils2.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils2.isURLSearchParams(data2)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data2.toString();
      }
      var isObjectPayload = utils2.isObject(data2);
      var contentType = headers && headers["Content-Type"];
      var isFileList;
      if ((isFileList = utils2.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
        var _FormData = this.env && this.env.FormData;
        return toFormData(isFileList ? { "files[]": data2 } : data2, _FormData && new _FormData());
      } else if (isObjectPayload || contentType === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      var transitional2 = this.transitional || defaults.transitional;
      var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils2.isString(data2) && data2.length) {
        try {
          return JSON.parse(data2);
        } catch (e3) {
          if (strictJSONParsing) {
            if (e3.name === "SyntaxError") {
              throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e3;
          }
        }
      }
      return data2;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: require_null()
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils2.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults.headers[method] = utils2.merge(DEFAULT_CONTENT_TYPE);
  });
  defaults_1 = defaults;
  return defaults_1;
}
var transformData;
var hasRequiredTransformData;
function requireTransformData() {
  if (hasRequiredTransformData)
    return transformData;
  hasRequiredTransformData = 1;
  var utils2 = requireUtils();
  var defaults = requireDefaults();
  transformData = function transformData2(data2, headers, fns) {
    var context = this || defaults;
    utils2.forEach(fns, function transform(fn) {
      data2 = fn.call(context, data2, headers);
    });
    return data2;
  };
  return transformData;
}
var isCancel;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel;
  hasRequiredIsCancel = 1;
  isCancel = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel;
}
var dispatchRequest;
var hasRequiredDispatchRequest;
function requireDispatchRequest() {
  if (hasRequiredDispatchRequest)
    return dispatchRequest;
  hasRequiredDispatchRequest = 1;
  var utils2 = requireUtils();
  var transformData2 = requireTransformData();
  var isCancel2 = requireIsCancel();
  var defaults = requireDefaults();
  var CanceledError = requireCanceledError();
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError();
    }
  }
  dispatchRequest = function dispatchRequest2(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData2.call(
      config,
      config.data,
      config.headers,
      config.transformRequest
    );
    config.headers = utils2.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers
    );
    utils2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData2.call(
        config,
        response.data,
        response.headers,
        config.transformResponse
      );
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel2(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData2.call(
            config,
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }
      return Promise.reject(reason);
    });
  };
  return dispatchRequest;
}
var mergeConfig;
var hasRequiredMergeConfig;
function requireMergeConfig() {
  if (hasRequiredMergeConfig)
    return mergeConfig;
  hasRequiredMergeConfig = 1;
  var utils2 = requireUtils();
  mergeConfig = function mergeConfig2(config1, config2) {
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source) {
      if (utils2.isPlainObject(target) && utils2.isPlainObject(source)) {
        return utils2.merge(target, source);
      } else if (utils2.isPlainObject(source)) {
        return utils2.merge({}, source);
      } else if (utils2.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (!utils2.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function valueFromConfig2(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      }
    }
    function defaultToConfig2(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      } else if (!utils2.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function mergeDirectKeys(prop) {
      if (prop in config2) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    var mergeMap = {
      "url": valueFromConfig2,
      "method": valueFromConfig2,
      "data": valueFromConfig2,
      "baseURL": defaultToConfig2,
      "transformRequest": defaultToConfig2,
      "transformResponse": defaultToConfig2,
      "paramsSerializer": defaultToConfig2,
      "timeout": defaultToConfig2,
      "timeoutMessage": defaultToConfig2,
      "withCredentials": defaultToConfig2,
      "adapter": defaultToConfig2,
      "responseType": defaultToConfig2,
      "xsrfCookieName": defaultToConfig2,
      "xsrfHeaderName": defaultToConfig2,
      "onUploadProgress": defaultToConfig2,
      "onDownloadProgress": defaultToConfig2,
      "decompress": defaultToConfig2,
      "maxContentLength": defaultToConfig2,
      "maxBodyLength": defaultToConfig2,
      "beforeRedirect": defaultToConfig2,
      "transport": defaultToConfig2,
      "httpAgent": defaultToConfig2,
      "httpsAgent": defaultToConfig2,
      "cancelToken": defaultToConfig2,
      "socketPath": defaultToConfig2,
      "responseEncoding": defaultToConfig2,
      "validateStatus": mergeDirectKeys
    };
    utils2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
      var merge = mergeMap[prop] || mergeDeepProperties;
      var configValue = merge(prop);
      utils2.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  };
  return mergeConfig;
}
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.27.2"
  };
  return data;
}
var validator;
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator)
    return validator;
  hasRequiredValidator = 1;
  var VERSION = requireData().version;
  var AxiosError = requireAxiosError();
  var validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
    validators[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  validators.transitional = function transitional2(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    var keys = Object.keys(options);
    var i2 = keys.length;
    while (i2-- > 0) {
      var opt = keys[i2];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options[opt];
        var result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  validator = {
    assertOptions,
    validators
  };
  return validator;
}
var Axios_1;
var hasRequiredAxios$2;
function requireAxios$2() {
  if (hasRequiredAxios$2)
    return Axios_1;
  hasRequiredAxios$2 = 1;
  var utils2 = requireUtils();
  var buildURL2 = requireBuildURL();
  var InterceptorManager = requireInterceptorManager();
  var dispatchRequest2 = requireDispatchRequest();
  var mergeConfig2 = requireMergeConfig();
  var buildFullPath2 = requireBuildFullPath();
  var validator2 = requireValidator();
  var validators = validator2.validators;
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios.prototype.request = function request2(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig2(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var transitional2 = config.transitional;
    if (transitional2 !== void 0) {
      validator2.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest2, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise = Promise.resolve(config);
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    }
    var newConfig = config;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }
    try {
      promise = dispatchRequest2(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    while (responseInterceptorChain.length) {
      promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
  };
  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig2(this.defaults, config);
    var fullPath = buildFullPath2(config.baseURL, config.url);
    return buildURL2(fullPath, config.params, config.paramsSerializer);
  };
  utils2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig2(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data2, config) {
        return this.request(mergeConfig2(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data: data2
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  Axios_1 = Axios;
  return Axios_1;
}
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var CanceledError = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i2;
      var l2 = token._listeners.length;
      for (i2 = 0; i2 < l2; i2++) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve2) {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = requireUtils();
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var hasRequiredAxios$1;
function requireAxios$1() {
  if (hasRequiredAxios$1)
    return axios.exports;
  hasRequiredAxios$1 = 1;
  var utils2 = requireUtils();
  var bind2 = requireBind();
  var Axios = requireAxios$2();
  var mergeConfig2 = requireMergeConfig();
  var defaults = requireDefaults();
  function createInstance(defaultConfig2) {
    var context = new Axios(defaultConfig2);
    var instance = bind2(Axios.prototype.request, context);
    utils2.extend(instance, Axios.prototype, context);
    utils2.extend(instance, context);
    instance.create = function create2(instanceConfig) {
      return createInstance(mergeConfig2(defaultConfig2, instanceConfig));
    };
    return instance;
  }
  var axios$12 = createInstance(defaults);
  axios$12.Axios = Axios;
  axios$12.CanceledError = requireCanceledError();
  axios$12.CancelToken = requireCancelToken();
  axios$12.isCancel = requireIsCancel();
  axios$12.VERSION = requireData().version;
  axios$12.toFormData = requireToFormData();
  axios$12.AxiosError = requireAxiosError();
  axios$12.Cancel = axios$12.CanceledError;
  axios$12.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$12.spread = requireSpread();
  axios$12.isAxiosError = requireIsAxiosError();
  axios.exports = axios$12;
  axios.exports.default = axios$12;
  return axios.exports;
}
var hasRequiredAxios;
function requireAxios() {
  if (hasRequiredAxios)
    return axios$1.exports;
  hasRequiredAxios = 1;
  (function(module2) {
    module2.exports = requireAxios$1();
  })(axios$1);
  return axios$1.exports;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  browser = typeof self == "object" ? self.FormData : window.FormData;
  return browser;
}
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};
var src_exports = {};
__export(src_exports, {
  ApiError: () => ApiError2,
  AptosAccount: () => AptosAccount,
  AptosClient: () => AptosClient,
  BCS: () => bcs_exports,
  CoinClient: () => CoinClient,
  FailedTransactionError: () => FailedTransactionError,
  FaucetClient: () => FaucetClient,
  HexString: () => HexString,
  TokenClient: () => TokenClient,
  TokenTypes: () => token_types_exports,
  TransactionBuilder: () => TransactionBuilder,
  TransactionBuilderABI: () => TransactionBuilderABI,
  TransactionBuilderEd25519: () => TransactionBuilderEd25519,
  TransactionBuilderMultiEd25519: () => TransactionBuilderMultiEd25519,
  TransactionBuilderRemoteABI: () => TransactionBuilderRemoteABI,
  TxnBuilderTypes: () => aptos_types_exports,
  TypeTagParser: () => TypeTagParser,
  Types: () => generated_exports,
  WaitForTransactionError: () => WaitForTransactionError,
  derivePath: () => derivePath
});
var dist$1 = __toCommonJS(src_exports);
var import_tweetnacl2 = __toESM(naclFast.exports);
var import_sha3 = sha3$1;
var bip39 = __toESM(bip39$1);
var import_utils3 = utils$4;
__toESM(naclFast.exports);
var import_hmac = hmac;
var import_sha512 = sha512;
var import_utils = utils$4;
var pathRegex = /^m(\/[0-9]+')+$/;
var replaceDerive = (val) => val.replace("'", "");
var HMAC_KEY = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var getMasterKeyFromSeed = (seed) => {
  const h2 = import_hmac.hmac.create(import_sha512.sha512, HMAC_KEY);
  const I2 = h2.update((0, import_utils.hexToBytes)(seed)).digest();
  const IL = I2.slice(0, 32);
  const IR = I2.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index2) => {
  const buffer = new ArrayBuffer(4);
  new DataView(buffer).setUint32(0, index2);
  const indexBytes = new Uint8Array(buffer);
  const zero2 = new Uint8Array([0]);
  const data2 = new Uint8Array([...zero2, ...key, ...indexBytes]);
  const I2 = import_hmac.hmac.create(import_sha512.sha512, chainCode).update(data2).digest();
  const IL = I2.slice(0, 32);
  const IR = I2.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(Number.isNaN);
};
var derivePath = (path, seed, offset2 = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el2) => parseInt(el2, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset2), { key, chainCode });
};
var import_utils2 = utils$4;
var HexString = class {
  static fromBuffer(buffer) {
    return HexString.fromUint8Array(buffer);
  }
  static fromUint8Array(arr) {
    return new HexString((0, import_utils2.bytesToHex)(arr));
  }
  static ensure(hexString) {
    if (typeof hexString === "string") {
      return new HexString(hexString);
    }
    return hexString;
  }
  constructor(hexString) {
    if (hexString.startsWith("0x")) {
      this.hexString = hexString;
    } else {
      this.hexString = `0x${hexString}`;
    }
  }
  hex() {
    return this.hexString;
  }
  noPrefix() {
    return this.hexString.slice(2);
  }
  toString() {
    return this.hex();
  }
  toShortString() {
    const trimmed = this.hexString.replace(/^0x0*/, "");
    return `0x${trimmed}`;
  }
  toUint8Array() {
    return Uint8Array.from((0, import_utils2.hexToBytes)(this.noPrefix()));
  }
};
async function sleep(timeMs) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, timeMs);
  });
}
var DEFAULT_VERSION_PATH_BASE = "/v1";
function fixNodeUrl(nodeUrl) {
  let out = `${nodeUrl}`;
  if (out.endsWith("/")) {
    out = out.substring(0, out.length - 1);
  }
  if (!out.endsWith(DEFAULT_VERSION_PATH_BASE)) {
    out = `${out}${DEFAULT_VERSION_PATH_BASE}`;
  }
  return out;
}
var DEFAULT_MAX_GAS_AMOUNT = 2e5;
var DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;
var DEFAULT_TXN_TIMEOUT_SEC = 20;
var APTOS_COIN = "0x1::aptos_coin::AptosCoin";
function Memoize(args) {
  let hashFunction;
  let ttlMs;
  let tags;
  if (typeof args === "object") {
    hashFunction = args.hashFunction;
    ttlMs = args.ttlMs;
    tags = args.tags;
  } else {
    hashFunction = args;
  }
  return (target, propertyKey, descriptor) => {
    if (descriptor.value != null) {
      descriptor.value = getNewFunction(descriptor.value, hashFunction, ttlMs, tags);
    } else if (descriptor.get != null) {
      descriptor.get = getNewFunction(descriptor.get, hashFunction, ttlMs, tags);
    } else {
      throw new Error("Only put a Memoize() decorator on a method or get accessor.");
    }
  };
}
function MemoizeExpiring(ttlMs, hashFunction) {
  return Memoize({
    ttlMs,
    hashFunction
  });
}
var clearCacheTagsMap = /* @__PURE__ */ new Map();
function clear(tags) {
  const cleared = /* @__PURE__ */ new Set();
  for (const tag of tags) {
    const maps = clearCacheTagsMap.get(tag);
    if (maps) {
      for (const mp of maps) {
        if (!cleared.has(mp)) {
          mp.clear();
          cleared.add(mp);
        }
      }
    }
  }
  return cleared.size;
}
function getNewFunction(originalMethod, hashFunction, ttlMs = 0, tags) {
  const propMapName = Symbol("__memoized_map__");
  return function(...args) {
    let returnedValue;
    const that = this;
    if (!that.hasOwnProperty(propMapName)) {
      Object.defineProperty(that, propMapName, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: /* @__PURE__ */ new Map()
      });
    }
    const myMap = that[propMapName];
    if (Array.isArray(tags)) {
      for (const tag of tags) {
        if (clearCacheTagsMap.has(tag)) {
          clearCacheTagsMap.get(tag).push(myMap);
        } else {
          clearCacheTagsMap.set(tag, [myMap]);
        }
      }
    }
    if (hashFunction || args.length > 0 || ttlMs > 0) {
      let hashKey;
      if (hashFunction === true) {
        hashKey = args.map((a2) => a2.toString()).join("!");
      } else if (hashFunction) {
        hashKey = hashFunction.apply(that, args);
      } else {
        hashKey = args[0];
      }
      const timestampKey = `${hashKey}__timestamp`;
      let isExpired = false;
      if (ttlMs > 0) {
        if (!myMap.has(timestampKey)) {
          isExpired = true;
        } else {
          const timestamp = myMap.get(timestampKey);
          isExpired = Date.now() - timestamp > ttlMs;
        }
      }
      if (myMap.has(hashKey) && !isExpired) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(that, args);
        myMap.set(hashKey, returnedValue);
        if (ttlMs > 0) {
          myMap.set(timestampKey, Date.now());
        }
      }
    } else {
      const hashKey = that;
      if (myMap.has(hashKey)) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(that, args);
        myMap.set(hashKey, returnedValue);
      }
    }
    return returnedValue;
  };
}
var _AptosAccount = class {
  static fromAptosAccountObject(obj) {
    return new _AptosAccount(HexString.ensure(obj.privateKeyHex).toUint8Array(), obj.address);
  }
  static fromDerivePath(path, mnemonics) {
    if (!_AptosAccount.isValidPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const normalizeMnemonics = mnemonics.trim().split(/\s+/).map((part) => part.toLowerCase()).join(" ");
    const { key } = derivePath(path, (0, import_utils3.bytesToHex)(bip39.mnemonicToSeedSync(normalizeMnemonics)));
    return new _AptosAccount(key);
  }
  constructor(privateKeyBytes, address) {
    if (privateKeyBytes) {
      this.signingKey = import_tweetnacl2.default.sign.keyPair.fromSeed(privateKeyBytes.slice(0, 32));
    } else {
      this.signingKey = import_tweetnacl2.default.sign.keyPair();
    }
    this.accountAddress = HexString.ensure(address || this.authKey().hex());
  }
  address() {
    return this.accountAddress;
  }
  authKey() {
    const hash2 = import_sha3.sha3_256.create();
    hash2.update(this.signingKey.publicKey);
    hash2.update("\0");
    return HexString.fromUint8Array(hash2.digest());
  }
  pubKey() {
    return HexString.fromUint8Array(this.signingKey.publicKey);
  }
  signBuffer(buffer) {
    const signature = import_tweetnacl2.default.sign(buffer, this.signingKey.secretKey);
    return HexString.fromUint8Array(signature.slice(0, 64));
  }
  signHexString(hexString) {
    const toSign = HexString.ensure(hexString).toUint8Array();
    return this.signBuffer(toSign);
  }
  toPrivateKeyObject() {
    return {
      address: this.address().hex(),
      publicKeyHex: this.pubKey().hex(),
      privateKeyHex: HexString.fromUint8Array(this.signingKey.secretKey.slice(0, 32)).hex()
    };
  }
};
var AptosAccount = _AptosAccount;
AptosAccount.isValidPath = (path) => {
  if (!/^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'+$/.test(path)) {
    return false;
  }
  return true;
};
__decorateClass([
  Memoize()
], AptosAccount.prototype, "authKey", 1);
var generated_exports = {};
__export(generated_exports, {
  $AccountData: () => $AccountData,
  $AccountSignature: () => $AccountSignature,
  $AccountSignature_Ed25519Signature: () => $AccountSignature_Ed25519Signature,
  $AccountSignature_MultiEd25519Signature: () => $AccountSignature_MultiEd25519Signature,
  $Address: () => $Address,
  $AptosError: () => $AptosError,
  $AptosErrorCode: () => $AptosErrorCode,
  $Block: () => $Block,
  $BlockMetadataTransaction: () => $BlockMetadataTransaction,
  $DecodedTableData: () => $DecodedTableData,
  $DeleteModule: () => $DeleteModule,
  $DeleteResource: () => $DeleteResource,
  $DeleteTableItem: () => $DeleteTableItem,
  $DeletedTableData: () => $DeletedTableData,
  $DirectWriteSet: () => $DirectWriteSet,
  $Ed25519Signature: () => $Ed25519Signature,
  $EncodeSubmissionRequest: () => $EncodeSubmissionRequest,
  $EntryFunctionId: () => $EntryFunctionId,
  $EntryFunctionPayload: () => $EntryFunctionPayload,
  $Event: () => $Event,
  $EventGuid: () => $EventGuid,
  $GasEstimation: () => $GasEstimation,
  $GenesisPayload: () => $GenesisPayload,
  $GenesisPayload_WriteSetPayload: () => $GenesisPayload_WriteSetPayload,
  $GenesisTransaction: () => $GenesisTransaction,
  $HashValue: () => $HashValue,
  $HealthCheckSuccess: () => $HealthCheckSuccess,
  $HexEncodedBytes: () => $HexEncodedBytes,
  $IdentifierWrapper: () => $IdentifierWrapper,
  $IndexResponse: () => $IndexResponse,
  $ModuleBundlePayload: () => $ModuleBundlePayload,
  $MoveAbility: () => $MoveAbility,
  $MoveFunction: () => $MoveFunction,
  $MoveFunctionGenericTypeParam: () => $MoveFunctionGenericTypeParam,
  $MoveFunctionVisibility: () => $MoveFunctionVisibility,
  $MoveModule: () => $MoveModule,
  $MoveModuleBytecode: () => $MoveModuleBytecode,
  $MoveModuleId: () => $MoveModuleId,
  $MoveResource: () => $MoveResource,
  $MoveScriptBytecode: () => $MoveScriptBytecode,
  $MoveStruct: () => $MoveStruct,
  $MoveStructField: () => $MoveStructField,
  $MoveStructGenericTypeParam: () => $MoveStructGenericTypeParam,
  $MoveStructTag: () => $MoveStructTag,
  $MoveStructValue: () => $MoveStructValue,
  $MoveType: () => $MoveType,
  $MoveValue: () => $MoveValue,
  $MultiAgentSignature: () => $MultiAgentSignature,
  $MultiEd25519Signature: () => $MultiEd25519Signature,
  $PendingTransaction: () => $PendingTransaction,
  $RoleType: () => $RoleType,
  $ScriptPayload: () => $ScriptPayload,
  $ScriptWriteSet: () => $ScriptWriteSet,
  $StateCheckpointTransaction: () => $StateCheckpointTransaction,
  $SubmitTransactionRequest: () => $SubmitTransactionRequest,
  $TableItemRequest: () => $TableItemRequest,
  $Transaction: () => $Transaction,
  $TransactionPayload: () => $TransactionPayload,
  $TransactionPayload_EntryFunctionPayload: () => $TransactionPayload_EntryFunctionPayload,
  $TransactionPayload_ModuleBundlePayload: () => $TransactionPayload_ModuleBundlePayload,
  $TransactionPayload_ScriptPayload: () => $TransactionPayload_ScriptPayload,
  $TransactionSignature: () => $TransactionSignature,
  $TransactionSignature_Ed25519Signature: () => $TransactionSignature_Ed25519Signature,
  $TransactionSignature_MultiAgentSignature: () => $TransactionSignature_MultiAgentSignature,
  $TransactionSignature_MultiEd25519Signature: () => $TransactionSignature_MultiEd25519Signature,
  $Transaction_BlockMetadataTransaction: () => $Transaction_BlockMetadataTransaction,
  $Transaction_GenesisTransaction: () => $Transaction_GenesisTransaction,
  $Transaction_PendingTransaction: () => $Transaction_PendingTransaction,
  $Transaction_StateCheckpointTransaction: () => $Transaction_StateCheckpointTransaction,
  $Transaction_UserTransaction: () => $Transaction_UserTransaction,
  $TransactionsBatchSingleSubmissionFailure: () => $TransactionsBatchSingleSubmissionFailure,
  $TransactionsBatchSubmissionResult: () => $TransactionsBatchSubmissionResult,
  $U128: () => $U128,
  $U64: () => $U64,
  $UserTransaction: () => $UserTransaction,
  $VersionedEvent: () => $VersionedEvent,
  $WriteModule: () => $WriteModule,
  $WriteResource: () => $WriteResource,
  $WriteSet: () => $WriteSet,
  $WriteSetChange: () => $WriteSetChange,
  $WriteSetChange_DeleteModule: () => $WriteSetChange_DeleteModule,
  $WriteSetChange_DeleteResource: () => $WriteSetChange_DeleteResource,
  $WriteSetChange_DeleteTableItem: () => $WriteSetChange_DeleteTableItem,
  $WriteSetChange_WriteModule: () => $WriteSetChange_WriteModule,
  $WriteSetChange_WriteResource: () => $WriteSetChange_WriteResource,
  $WriteSetChange_WriteTableItem: () => $WriteSetChange_WriteTableItem,
  $WriteSetPayload: () => $WriteSetPayload,
  $WriteSet_DirectWriteSet: () => $WriteSet_DirectWriteSet,
  $WriteSet_ScriptWriteSet: () => $WriteSet_ScriptWriteSet,
  $WriteTableItem: () => $WriteTableItem,
  AccountsService: () => AccountsService,
  ApiError: () => ApiError,
  AptosErrorCode: () => AptosErrorCode,
  AptosGeneratedClient: () => AptosGeneratedClient,
  BaseHttpRequest: () => BaseHttpRequest,
  BlocksService: () => BlocksService,
  CancelError: () => CancelError,
  CancelablePromise: () => CancelablePromise,
  EventsService: () => EventsService,
  GeneralService: () => GeneralService,
  MoveFunctionVisibility: () => MoveFunctionVisibility,
  OpenAPI: () => OpenAPI,
  RoleType: () => RoleType,
  TablesService: () => TablesService,
  TransactionsService: () => TransactionsService
});
var BaseHttpRequest = class {
  constructor(config) {
    this.config = config;
  }
};
var import_axios = __toESM(requireAxios());
var import_form_data = __toESM(requireBrowser());
var ApiError = class extends Error {
  constructor(request2, response, message) {
    super(message);
    this.name = "ApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.body = response.body;
    this.request = request2;
  }
};
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
};
var CancelablePromise = class {
  constructor(executor) {
    this._isResolved = false;
    this._isRejected = false;
    this._isCancelled = false;
    this._cancelHandlers = [];
    this._promise = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
      const onResolve = (value) => {
        var _a2;
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isResolved = true;
        (_a2 = this._resolve) == null ? void 0 : _a2.call(this, value);
      };
      const onReject = (reason) => {
        var _a2;
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isRejected = true;
        (_a2 = this._reject) == null ? void 0 : _a2.call(this, reason);
      };
      const onCancel = (cancelHandler) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._cancelHandlers.push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => this._isResolved
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => this._isRejected
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => this._isCancelled
      });
      return executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel() {
    var _a2;
    if (this._isResolved || this._isRejected || this._isCancelled) {
      return;
    }
    this._isCancelled = true;
    if (this._cancelHandlers.length) {
      try {
        for (const cancelHandler of this._cancelHandlers) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    this._cancelHandlers.length = 0;
    (_a2 = this._reject) == null ? void 0 : _a2.call(this, new CancelError("Request aborted"));
  }
  get isCancelled() {
    return this._isCancelled;
  }
};
var CookieJar = class {
  constructor(jar2 = /* @__PURE__ */ new Map()) {
    this.jar = jar2;
  }
  setCookie(url, cookieStr) {
    var _a2;
    const key = url.origin.toLowerCase();
    if (!this.jar.has(key)) {
      this.jar.set(key, []);
    }
    const cookie = CookieJar.parse(cookieStr);
    this.jar.set(key, [...((_a2 = this.jar.get(key)) == null ? void 0 : _a2.filter((c2) => c2.name !== cookie.name)) || [], cookie]);
  }
  getCookies(url) {
    var _a2;
    const key = url.origin.toLowerCase();
    if (!this.jar.get(key)) {
      return [];
    }
    return ((_a2 = this.jar.get(key)) == null ? void 0 : _a2.filter((cookie) => !cookie.expires || cookie.expires > new Date())) || [];
  }
  static parse(str) {
    if (typeof str !== "string") {
      throw new Error("argument str must be a string");
    }
    const parts = str.split(";").map((part) => part.trim());
    let cookie;
    if (parts.length > 0) {
      const [name, value] = parts[0].split("=");
      if (!name || !value) {
        throw new Error("Invalid cookie");
      }
      cookie = {
        name,
        value
      };
    } else {
      throw new Error("Invalid cookie");
    }
    parts.slice(1).forEach((part) => {
      const [name, value] = part.split("=");
      if (!name.trim()) {
        throw new Error("Invalid cookie");
      }
      const nameLow = name.toLowerCase();
      const val = (value == null ? void 0 : value.charAt(0)) === "'" || (value == null ? void 0 : value.charAt(0)) === '"' ? value == null ? void 0 : value.slice(1, -1) : value;
      if (nameLow === "expires") {
        cookie.expires = new Date(val);
      }
      if (nameLow === "path") {
        cookie.path = val;
      }
      if (nameLow === "samesite") {
        if (val !== "Lax" && val !== "None" && val !== "Strict") {
          throw new Error("Invalid cookie SameSite value");
        }
        cookie.sameSite = val;
      }
      if (nameLow === "secure") {
        cookie.secure = true;
      }
    });
    return cookie;
  }
};
var jar = new CookieJar();
import_axios.default.interceptors.response.use((response) => {
  if (Array.isArray(response.headers["set-cookie"])) {
    response.headers["set-cookie"].forEach((c2) => {
      jar.setCookie(new URL(response.config.url), c2);
    });
  }
  return response;
});
import_axios.default.interceptors.request.use(function(config) {
  const cookies2 = jar.getCookies(new URL(config.url));
  if ((cookies2 == null ? void 0 : cookies2.length) > 0 && config.headers) {
    config.headers.cookie = cookies2.map((cookie) => `${cookie.name}=${cookie.value}`).join("; ");
  }
  return config;
});
var isDefined = (value) => {
  return value !== void 0 && value !== null;
};
var isString$1 = (value) => {
  return typeof value === "string";
};
var isStringWithValue = (value) => {
  return isString$1(value) && value !== "";
};
var isBlob = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
var isFormData = (value) => {
  return value instanceof import_form_data.default;
};
var isSuccess = (status) => {
  return status >= 200 && status < 300;
};
var base64 = (str) => {
  return btoa(str);
};
var getQueryString = (params) => {
  const qs = [];
  const append = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process2 = (key, value) => {
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach((v2) => {
          process2(key, v2);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k2, v2]) => {
          process2(`${key}[${k2}]`, v2);
        });
      } else {
        append(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process2(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
var getUrl = (config, options) => {
  const encoder = config.ENCODE_PATH || encodeURI;
  const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    var _a2;
    if ((_a2 = options.path) == null ? void 0 : _a2.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config.BASE}${path}`;
  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
};
var getFormData = (options) => {
  if (options.formData) {
    const formData = new import_form_data.default();
    const process2 = (key, value) => {
      if (isString$1(value) || isBlob(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_2, value]) => isDefined(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v2) => process2(key, v2));
      } else {
        process2(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
var resolve = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
var getHeaders = async (config, options, formData) => {
  const token = await resolve(options, config.TOKEN);
  const username = await resolve(options, config.USERNAME);
  const password = await resolve(options, config.PASSWORD);
  const additionalHeaders = await resolve(options, config.HEADERS);
  const formHeaders = typeof (formData == null ? void 0 : formData.getHeaders) === "function" && (formData == null ? void 0 : formData.getHeaders()) || {};
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers,
    ...formHeaders
  }).filter(([_2, value]) => isDefined(value)).reduce((headers2, [key, value]) => ({
    ...headers2,
    [key]: String(value)
  }), {});
  if (isStringWithValue(token)) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob(options.body)) {
      headers["Content-Type"] = options.body.type || "application/octet-stream";
    } else if (isString$1(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return headers;
};
var getRequestBody = (options) => {
  if (options.body) {
    return options.body;
  }
  return void 0;
};
var sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
  const source = import_axios.default.CancelToken.source();
  const requestConfig = {
    url,
    headers,
    data: body != null ? body : formData,
    method: options.method,
    withCredentials: config.WITH_CREDENTIALS,
    cancelToken: source.token
  };
  const isBCS = Object.keys(config.HEADERS || {}).filter((k2) => k2.toLowerCase() === "accept").map((k2) => config.HEADERS[k2]).includes("application/x-bcs");
  if (isBCS) {
    requestConfig.responseType = "arraybuffer";
  }
  onCancel(() => source.cancel("The user aborted a request."));
  try {
    return await import_axios.default.request(requestConfig);
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
};
var getResponseHeader = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers[responseHeader];
    if (isString$1(content)) {
      return content;
    }
  }
  return void 0;
};
var getResponseBody = (response) => {
  if (response.status !== 204) {
    return response.data;
  }
  return void 0;
};
var catchErrorCodes = (options, result) => {
  const errors2 = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors2[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    throw new ApiError(options, result, "Generic Error");
  }
};
var request = (config, options) => {
  return new CancelablePromise(async (resolve2, reject, onCancel) => {
    try {
      const url = getUrl(config, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      const headers = await getHeaders(config, options, formData);
      if (!onCancel.isCancelled) {
        const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
        const responseBody = getResponseBody(response);
        const responseHeader = getResponseHeader(response, options.responseHeader);
        const result = {
          url,
          ok: isSuccess(response.status),
          status: response.status,
          statusText: response.statusText,
          body: responseHeader != null ? responseHeader : responseBody
        };
        catchErrorCodes(options, result);
        resolve2(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};
var AxiosHttpRequest = class extends BaseHttpRequest {
  constructor(config) {
    super(config);
  }
  request(options) {
    return request(this.config, options);
  }
};
var AccountsService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  getAccount(address, ledgerVersion) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}",
      path: {
        "address": address
      },
      query: {
        "ledger_version": ledgerVersion
      }
    });
  }
  getAccountResources(address, ledgerVersion) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}/resources",
      path: {
        "address": address
      },
      query: {
        "ledger_version": ledgerVersion
      }
    });
  }
  getAccountModules(address, ledgerVersion) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}/modules",
      path: {
        "address": address
      },
      query: {
        "ledger_version": ledgerVersion
      }
    });
  }
  getAccountResource(address, resourceType, ledgerVersion) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}/resource/{resource_type}",
      path: {
        "address": address,
        "resource_type": resourceType
      },
      query: {
        "ledger_version": ledgerVersion
      }
    });
  }
  getAccountModule(address, moduleName, ledgerVersion) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}/module/{module_name}",
      path: {
        "address": address,
        "module_name": moduleName
      },
      query: {
        "ledger_version": ledgerVersion
      }
    });
  }
};
var BlocksService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  getBlockByHeight(blockHeight, withTransactions) {
    return this.httpRequest.request({
      method: "GET",
      url: "/blocks/by_height/{block_height}",
      path: {
        "block_height": blockHeight
      },
      query: {
        "with_transactions": withTransactions
      }
    });
  }
  getBlockByVersion(version2, withTransactions) {
    return this.httpRequest.request({
      method: "GET",
      url: "/blocks/by_version/{version}",
      path: {
        "version": version2
      },
      query: {
        "with_transactions": withTransactions
      }
    });
  }
};
var EventsService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  getEventsByCreationNumber(address, creationNumber, start, limit) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}/events/{creation_number}",
      path: {
        "address": address,
        "creation_number": creationNumber
      },
      query: {
        "start": start,
        "limit": limit
      }
    });
  }
  getEventsByEventHandle(address, eventHandle, fieldName, start, limit) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}/events/{event_handle}/{field_name}",
      path: {
        "address": address,
        "event_handle": eventHandle,
        "field_name": fieldName
      },
      query: {
        "start": start,
        "limit": limit
      }
    });
  }
};
var GeneralService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  spec() {
    return this.httpRequest.request({
      method: "GET",
      url: "/spec"
    });
  }
  healthy(durationSecs) {
    return this.httpRequest.request({
      method: "GET",
      url: "/-/healthy",
      query: {
        "duration_secs": durationSecs
      }
    });
  }
  getLedgerInfo() {
    return this.httpRequest.request({
      method: "GET",
      url: "/"
    });
  }
};
var TablesService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  getTableItem(tableHandle, requestBody, ledgerVersion) {
    return this.httpRequest.request({
      method: "POST",
      url: "/tables/{table_handle}/item",
      path: {
        "table_handle": tableHandle
      },
      query: {
        "ledger_version": ledgerVersion
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
};
var TransactionsService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  getTransactions(start, limit) {
    return this.httpRequest.request({
      method: "GET",
      url: "/transactions",
      query: {
        "start": start,
        "limit": limit
      }
    });
  }
  submitTransaction(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/transactions",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  getTransactionByHash(txnHash) {
    return this.httpRequest.request({
      method: "GET",
      url: "/transactions/by_hash/{txn_hash}",
      path: {
        "txn_hash": txnHash
      }
    });
  }
  getTransactionByVersion(txnVersion) {
    return this.httpRequest.request({
      method: "GET",
      url: "/transactions/by_version/{txn_version}",
      path: {
        "txn_version": txnVersion
      }
    });
  }
  getAccountTransactions(address, start, limit) {
    return this.httpRequest.request({
      method: "GET",
      url: "/accounts/{address}/transactions",
      path: {
        "address": address
      },
      query: {
        "start": start,
        "limit": limit
      }
    });
  }
  submitBatchTransactions(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/transactions/batch",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  simulateTransaction(requestBody, estimateMaxGasAmount, estimateGasUnitPrice, estimatePrioritizedGasUnitPrice) {
    return this.httpRequest.request({
      method: "POST",
      url: "/transactions/simulate",
      query: {
        "estimate_max_gas_amount": estimateMaxGasAmount,
        "estimate_gas_unit_price": estimateGasUnitPrice,
        "estimate_prioritized_gas_unit_price": estimatePrioritizedGasUnitPrice
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  encodeSubmission(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/transactions/encode_submission",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  estimateGasPrice() {
    return this.httpRequest.request({
      method: "GET",
      url: "/estimate_gas_price"
    });
  }
};
var AptosGeneratedClient = class {
  constructor(config, HttpRequest = AxiosHttpRequest) {
    var _a2, _b, _c, _d;
    this.request = new HttpRequest({
      BASE: (_a2 = config == null ? void 0 : config.BASE) != null ? _a2 : "/v1",
      VERSION: (_b = config == null ? void 0 : config.VERSION) != null ? _b : "1.2.0",
      WITH_CREDENTIALS: (_c = config == null ? void 0 : config.WITH_CREDENTIALS) != null ? _c : false,
      CREDENTIALS: (_d = config == null ? void 0 : config.CREDENTIALS) != null ? _d : "include",
      TOKEN: config == null ? void 0 : config.TOKEN,
      USERNAME: config == null ? void 0 : config.USERNAME,
      PASSWORD: config == null ? void 0 : config.PASSWORD,
      HEADERS: config == null ? void 0 : config.HEADERS,
      ENCODE_PATH: config == null ? void 0 : config.ENCODE_PATH
    });
    this.accounts = new AccountsService(this.request);
    this.blocks = new BlocksService(this.request);
    this.events = new EventsService(this.request);
    this.general = new GeneralService(this.request);
    this.tables = new TablesService(this.request);
    this.transactions = new TransactionsService(this.request);
  }
};
var OpenAPI = {
  BASE: "/v1",
  VERSION: "1.2.0",
  WITH_CREDENTIALS: false,
  CREDENTIALS: "include",
  TOKEN: void 0,
  USERNAME: void 0,
  PASSWORD: void 0,
  HEADERS: void 0,
  ENCODE_PATH: void 0
};
var AptosErrorCode = /* @__PURE__ */ ((AptosErrorCode2) => {
  AptosErrorCode2["ACCOUNT_NOT_FOUND"] = "account_not_found";
  AptosErrorCode2["RESOURCE_NOT_FOUND"] = "resource_not_found";
  AptosErrorCode2["MODULE_NOT_FOUND"] = "module_not_found";
  AptosErrorCode2["STRUCT_FIELD_NOT_FOUND"] = "struct_field_not_found";
  AptosErrorCode2["VERSION_NOT_FOUND"] = "version_not_found";
  AptosErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction_not_found";
  AptosErrorCode2["TABLE_ITEM_NOT_FOUND"] = "table_item_not_found";
  AptosErrorCode2["BLOCK_NOT_FOUND"] = "block_not_found";
  AptosErrorCode2["VERSION_PRUNED"] = "version_pruned";
  AptosErrorCode2["BLOCK_PRUNED"] = "block_pruned";
  AptosErrorCode2["INVALID_INPUT"] = "invalid_input";
  AptosErrorCode2["INVALID_TRANSACTION_UPDATE"] = "invalid_transaction_update";
  AptosErrorCode2["SEQUENCE_NUMBER_TOO_OLD"] = "sequence_number_too_old";
  AptosErrorCode2["VM_ERROR"] = "vm_error";
  AptosErrorCode2["HEALTH_CHECK_FAILED"] = "health_check_failed";
  AptosErrorCode2["MEMPOOL_IS_FULL"] = "mempool_is_full";
  AptosErrorCode2["INTERNAL_ERROR"] = "internal_error";
  AptosErrorCode2["WEB_FRAMEWORK_ERROR"] = "web_framework_error";
  AptosErrorCode2["BCS_NOT_SUPPORTED"] = "bcs_not_supported";
  AptosErrorCode2["API_DISABLED"] = "api_disabled";
  return AptosErrorCode2;
})(AptosErrorCode || {});
var MoveFunctionVisibility = /* @__PURE__ */ ((MoveFunctionVisibility2) => {
  MoveFunctionVisibility2["PRIVATE"] = "private";
  MoveFunctionVisibility2["PUBLIC"] = "public";
  MoveFunctionVisibility2["FRIEND"] = "friend";
  return MoveFunctionVisibility2;
})(MoveFunctionVisibility || {});
var RoleType = /* @__PURE__ */ ((RoleType2) => {
  RoleType2["VALIDATOR"] = "validator";
  RoleType2["FULL_NODE"] = "full_node";
  return RoleType2;
})(RoleType || {});
var $AccountData = {
  description: `Account data

    A simplified version of the onchain Account resource`,
  properties: {
    sequence_number: {
      type: "U64",
      isRequired: true
    },
    authentication_key: {
      type: "HexEncodedBytes",
      isRequired: true
    }
  }
};
var $AccountSignature = {
  type: "one-of",
  description: `Account signature scheme

    The account signature scheme allows you to have two types of accounts:

    1. A single Ed25519 key account, one private key
    2. A k-of-n multi-Ed25519 key account, multiple private keys, such that k-of-n must sign a transaction.`,
  contains: [{
    type: "AccountSignature_Ed25519Signature"
  }, {
    type: "AccountSignature_MultiEd25519Signature"
  }]
};
var $AccountSignature_Ed25519Signature = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "Ed25519Signature"
  }]
};
var $AccountSignature_MultiEd25519Signature = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "MultiEd25519Signature"
  }]
};
var $Address = {
  type: "string",
  description: `A hex encoded 32 byte Aptos account address.

    This is represented in a string as a 64 character hex string, sometimes
    shortened by stripping leading 0s, and adding a 0x.

    For example, address 0x0000000000000000000000000000000000000000000000000000000000000001 is represented as 0x1.
    `,
  format: "hex"
};
var $AptosError = {
  description: `This is the generic struct we use for all API errors, it contains a string
    message and an Aptos API specific error code.`,
  properties: {
    message: {
      type: "string",
      description: `A message describing the error`,
      isRequired: true
    },
    error_code: {
      type: "AptosErrorCode",
      isRequired: true
    },
    vm_error_code: {
      type: "number",
      description: `A code providing VM error details when submitting transactions to the VM`,
      format: "uint64"
    }
  }
};
var $AptosErrorCode = {
  type: "Enum"
};
var $Block = {
  description: `A Block with or without transactions

    This contains the information about a transactions along with
    associated transactions if requested`,
  properties: {
    block_height: {
      type: "U64",
      isRequired: true
    },
    block_hash: {
      type: "HashValue",
      isRequired: true
    },
    block_timestamp: {
      type: "U64",
      isRequired: true
    },
    first_version: {
      type: "U64",
      isRequired: true
    },
    last_version: {
      type: "U64",
      isRequired: true
    },
    transactions: {
      type: "array",
      contains: {
        type: "Transaction"
      }
    }
  }
};
var $BlockMetadataTransaction = {
  description: `A block metadata transaction

    This signifies the beginning of a block, and contains information
    about the specific block`,
  properties: {
    version: {
      type: "U64",
      isRequired: true
    },
    hash: {
      type: "HashValue",
      isRequired: true
    },
    state_change_hash: {
      type: "HashValue",
      isRequired: true
    },
    event_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    state_checkpoint_hash: {
      type: "HashValue"
    },
    gas_used: {
      type: "U64",
      isRequired: true
    },
    success: {
      type: "boolean",
      description: `Whether the transaction was successful`,
      isRequired: true
    },
    vm_status: {
      type: "string",
      description: `The VM status of the transaction, can tell useful information in a failure`,
      isRequired: true
    },
    accumulator_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    changes: {
      type: "array",
      contains: {
        type: "WriteSetChange"
      },
      isRequired: true
    },
    id: {
      type: "HashValue",
      isRequired: true
    },
    epoch: {
      type: "U64",
      isRequired: true
    },
    round: {
      type: "U64",
      isRequired: true
    },
    events: {
      type: "array",
      contains: {
        type: "Event"
      },
      isRequired: true
    },
    previous_block_votes_bitvec: {
      type: "array",
      contains: {
        type: "number",
        format: "uint8"
      },
      isRequired: true
    },
    proposer: {
      type: "Address",
      isRequired: true
    },
    failed_proposer_indices: {
      type: "array",
      contains: {
        type: "number",
        format: "uint32"
      },
      isRequired: true
    },
    timestamp: {
      type: "U64",
      isRequired: true
    }
  }
};
var $DecodedTableData = {
  description: `Decoded table data`,
  properties: {
    key: {
      description: `Key of table in JSON`,
      properties: {},
      isRequired: true
    },
    key_type: {
      type: "string",
      description: `Type of key`,
      isRequired: true
    },
    value: {
      description: `Value of table in JSON`,
      properties: {},
      isRequired: true
    },
    value_type: {
      type: "string",
      description: `Type of value`,
      isRequired: true
    }
  }
};
var $DeletedTableData = {
  description: `Deleted table data`,
  properties: {
    key: {
      description: `Deleted key`,
      properties: {},
      isRequired: true
    },
    key_type: {
      type: "string",
      description: `Deleted key type`,
      isRequired: true
    }
  }
};
var $DeleteModule = {
  description: `Delete a module`,
  properties: {
    address: {
      type: "Address",
      isRequired: true
    },
    state_key_hash: {
      type: "string",
      description: `State key hash`,
      isRequired: true
    },
    module: {
      type: "MoveModuleId",
      isRequired: true
    }
  }
};
var $DeleteResource = {
  description: `Delete a resource`,
  properties: {
    address: {
      type: "Address",
      isRequired: true
    },
    state_key_hash: {
      type: "string",
      description: `State key hash`,
      isRequired: true
    },
    resource: {
      type: "MoveStructTag",
      isRequired: true
    }
  }
};
var $DeleteTableItem = {
  description: `Delete a table item`,
  properties: {
    state_key_hash: {
      type: "string",
      isRequired: true
    },
    handle: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    key: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    data: {
      type: "DeletedTableData"
    }
  }
};
var $DirectWriteSet = {
  properties: {
    changes: {
      type: "array",
      contains: {
        type: "WriteSetChange"
      },
      isRequired: true
    },
    events: {
      type: "array",
      contains: {
        type: "Event"
      },
      isRequired: true
    }
  }
};
var $Ed25519Signature = {
  description: `A single Ed25519 signature`,
  properties: {
    public_key: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    signature: {
      type: "HexEncodedBytes",
      isRequired: true
    }
  }
};
var $EncodeSubmissionRequest = {
  description: `Request to encode a submission`,
  properties: {
    sender: {
      type: "Address",
      isRequired: true
    },
    sequence_number: {
      type: "U64",
      isRequired: true
    },
    max_gas_amount: {
      type: "U64",
      isRequired: true
    },
    gas_unit_price: {
      type: "U64",
      isRequired: true
    },
    expiration_timestamp_secs: {
      type: "U64",
      isRequired: true
    },
    payload: {
      type: "TransactionPayload",
      isRequired: true
    },
    secondary_signers: {
      type: "array",
      contains: {
        type: "Address"
      }
    }
  }
};
var $EntryFunctionId = {
  type: "string",
  description: `Entry function id is string representation of a entry function defined on-chain.

    Format: \`{address}::{module name}::{function name}\`

    Both \`module name\` and \`function name\` are case-sensitive.
    `
};
var $EntryFunctionPayload = {
  description: `Payload which runs a single entry function`,
  properties: {
    function: {
      type: "EntryFunctionId",
      isRequired: true
    },
    type_arguments: {
      type: "array",
      contains: {
        type: "MoveType"
      },
      isRequired: true
    },
    arguments: {
      type: "array",
      contains: {
        properties: {}
      },
      isRequired: true
    }
  }
};
var $Event = {
  description: `An event from a transaction`,
  properties: {
    guid: {
      type: "EventGuid",
      isRequired: true
    },
    sequence_number: {
      type: "U64",
      isRequired: true
    },
    type: {
      type: "MoveType",
      isRequired: true
    },
    data: {
      description: `The JSON representation of the event`,
      properties: {},
      isRequired: true
    }
  }
};
var $EventGuid = {
  properties: {
    creation_number: {
      type: "U64",
      isRequired: true
    },
    account_address: {
      type: "Address",
      isRequired: true
    }
  }
};
var $GasEstimation = {
  description: `Struct holding the outputs of the estimate gas API`,
  properties: {
    deprioritized_gas_estimate: {
      type: "number",
      description: `The deprioritized estimate for the gas unit price`,
      format: "uint64"
    },
    gas_estimate: {
      type: "number",
      description: `The current estimate for the gas unit price`,
      isRequired: true,
      format: "uint64"
    },
    prioritized_gas_estimate: {
      type: "number",
      description: `The prioritized estimate for the gas unit price`,
      format: "uint64"
    }
  }
};
var $GenesisPayload = {
  type: "one-of",
  description: `The writeset payload of the Genesis transaction`,
  contains: [{
    type: "GenesisPayload_WriteSetPayload"
  }]
};
var $GenesisPayload_WriteSetPayload = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "WriteSetPayload"
  }]
};
var $GenesisTransaction = {
  description: `The genesis transaction

    This only occurs at the genesis transaction (version 0)`,
  properties: {
    version: {
      type: "U64",
      isRequired: true
    },
    hash: {
      type: "HashValue",
      isRequired: true
    },
    state_change_hash: {
      type: "HashValue",
      isRequired: true
    },
    event_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    state_checkpoint_hash: {
      type: "HashValue"
    },
    gas_used: {
      type: "U64",
      isRequired: true
    },
    success: {
      type: "boolean",
      description: `Whether the transaction was successful`,
      isRequired: true
    },
    vm_status: {
      type: "string",
      description: `The VM status of the transaction, can tell useful information in a failure`,
      isRequired: true
    },
    accumulator_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    changes: {
      type: "array",
      contains: {
        type: "WriteSetChange"
      },
      isRequired: true
    },
    payload: {
      type: "GenesisPayload",
      isRequired: true
    },
    events: {
      type: "array",
      contains: {
        type: "Event"
      },
      isRequired: true
    }
  }
};
var $HashValue = {
  type: "string"
};
var $HealthCheckSuccess = {
  description: `Representation of a successful healthcheck`,
  properties: {
    message: {
      type: "string",
      isRequired: true
    }
  }
};
var $HexEncodedBytes = {
  type: "string",
  description: `All bytes (Vec<u8>) data is represented as hex-encoded string prefixed with \`0x\` and fulfilled with
    two hex digits per byte.

    Unlike the \`Address\` type, HexEncodedBytes will not trim any zeros.
    `,
  format: "hex"
};
var $IdentifierWrapper = {
  type: "string"
};
var $IndexResponse = {
  description: `The struct holding all data returned to the client by the
    index endpoint (i.e., GET "/").  Only for responding in JSON`,
  properties: {
    chain_id: {
      type: "number",
      description: `Chain ID of the current chain`,
      isRequired: true,
      format: "uint8"
    },
    epoch: {
      type: "U64",
      isRequired: true
    },
    ledger_version: {
      type: "U64",
      isRequired: true
    },
    oldest_ledger_version: {
      type: "U64",
      isRequired: true
    },
    ledger_timestamp: {
      type: "U64",
      isRequired: true
    },
    node_role: {
      type: "RoleType",
      isRequired: true
    },
    oldest_block_height: {
      type: "U64",
      isRequired: true
    },
    block_height: {
      type: "U64",
      isRequired: true
    },
    git_hash: {
      type: "string"
    }
  }
};
var $ModuleBundlePayload = {
  properties: {
    modules: {
      type: "array",
      contains: {
        type: "MoveModuleBytecode"
      },
      isRequired: true
    }
  }
};
var $MoveAbility = {
  type: "string"
};
var $MoveFunction = {
  description: `Move function`,
  properties: {
    name: {
      type: "IdentifierWrapper",
      isRequired: true
    },
    visibility: {
      type: "MoveFunctionVisibility",
      isRequired: true
    },
    is_entry: {
      type: "boolean",
      description: `Whether the function can be called as an entry function directly in a transaction`,
      isRequired: true
    },
    generic_type_params: {
      type: "array",
      contains: {
        type: "MoveFunctionGenericTypeParam"
      },
      isRequired: true
    },
    params: {
      type: "array",
      contains: {
        type: "MoveType"
      },
      isRequired: true
    },
    return: {
      type: "array",
      contains: {
        type: "MoveType"
      },
      isRequired: true
    }
  }
};
var $MoveFunctionGenericTypeParam = {
  description: `Move function generic type param`,
  properties: {
    constraints: {
      type: "array",
      contains: {
        type: "MoveAbility"
      },
      isRequired: true
    }
  }
};
var $MoveFunctionVisibility = {
  type: "Enum"
};
var $MoveModule = {
  description: `A Move module`,
  properties: {
    address: {
      type: "Address",
      isRequired: true
    },
    name: {
      type: "IdentifierWrapper",
      isRequired: true
    },
    friends: {
      type: "array",
      contains: {
        type: "MoveModuleId"
      },
      isRequired: true
    },
    exposed_functions: {
      type: "array",
      contains: {
        type: "MoveFunction"
      },
      isRequired: true
    },
    structs: {
      type: "array",
      contains: {
        type: "MoveStruct"
      },
      isRequired: true
    }
  }
};
var $MoveModuleBytecode = {
  description: `Move module bytecode along with it's ABI`,
  properties: {
    bytecode: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    abi: {
      type: "MoveModule"
    }
  }
};
var $MoveModuleId = {
  type: "string",
  description: `Move module id is a string representation of Move module.

    Format: \`{address}::{module name}\`

    \`address\` should be hex-encoded 32 byte account address that is prefixed with \`0x\`.

    Module name is case-sensitive.
    `
};
var $MoveResource = {
  description: `A parsed Move resource`,
  properties: {
    type: {
      type: "MoveStructTag",
      isRequired: true
    },
    data: {
      type: "MoveStructValue",
      isRequired: true
    }
  }
};
var $MoveScriptBytecode = {
  description: `Move script bytecode`,
  properties: {
    bytecode: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    abi: {
      type: "MoveFunction"
    }
  }
};
var $MoveStruct = {
  description: `A move struct`,
  properties: {
    name: {
      type: "IdentifierWrapper",
      isRequired: true
    },
    is_native: {
      type: "boolean",
      description: `Whether the struct is a native struct of Move`,
      isRequired: true
    },
    abilities: {
      type: "array",
      contains: {
        type: "MoveAbility"
      },
      isRequired: true
    },
    generic_type_params: {
      type: "array",
      contains: {
        type: "MoveStructGenericTypeParam"
      },
      isRequired: true
    },
    fields: {
      type: "array",
      contains: {
        type: "MoveStructField"
      },
      isRequired: true
    }
  }
};
var $MoveStructField = {
  description: `Move struct field`,
  properties: {
    name: {
      type: "IdentifierWrapper",
      isRequired: true
    },
    type: {
      type: "MoveType",
      isRequired: true
    }
  }
};
var $MoveStructGenericTypeParam = {
  description: `Move generic type param`,
  properties: {
    constraints: {
      type: "array",
      contains: {
        type: "MoveAbility"
      },
      isRequired: true
    }
  }
};
var $MoveStructTag = {
  type: "string",
  description: `String representation of a MoveStructTag (on-chain Move struct type). This exists so you
    can specify MoveStructTags as path / query parameters, e.g. for get_events_by_event_handle.

    It is a combination of:
    1. \`move_module_address\`, \`module_name\` and \`struct_name\`, all joined by \`::\`
    2. \`struct generic type parameters\` joined by \`, \`

    Examples:
     * \`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>\`
     * \`0x1::account::Account\`

    Note:
    1. Empty chars should be ignored when comparing 2 struct tag ids.
    2. When used in an URL path, should be encoded by url-encoding (AKA percent-encoding).

    See [doc](https://aptos.dev/concepts/basics-accounts) for more details.
    `,
  pattern: "^0x[0-9a-zA-Z:_<>]+$"
};
var $MoveStructValue = {
  description: `This is a JSON representation of some data within an account resource. More specifically,
    it is a map of strings to arbitrary JSON values / objects, where the keys are top level
    fields within the given resource.

    To clarify, you might query for 0x1::account::Account and see the example data.

    Move \`bool\` type value is serialized into \`boolean\`.

    Move \`u8\` type value is serialized into \`integer\`.

    Move \`u64\` and \`u128\` type value is serialized into \`string\`.

    Move \`address\` type value (32 byte Aptos account address) is serialized into a HexEncodedBytes string.
    For example:
    - \`0x1\`
    - \`0x1668f6be25668c1a17cd8caf6b8d2f25\`

    Move \`vector\` type value is serialized into \`array\`, except \`vector<u8>\` which is serialized into a
    HexEncodedBytes string with \`0x\` prefix.
    For example:
    - \`vector<u64>{255, 255}\` => \`["255", "255"]\`
    - \`vector<u8>{255, 255}\` => \`0xffff\`

    Move \`struct\` type value is serialized into \`object\` that looks like this (except some Move stdlib types, see the following section):
    \`\`\`json
    {
        field1_name: field1_value,
        field2_name: field2_value,
        ......
    }
    \`\`\`

    For example:
    \`{ "created": "0xa550c18", "role_id": "0" }\`

     **Special serialization for Move stdlib types**:
    - [0x1::string::String](https://github.com/aptos-labs/aptos-core/blob/main/language/move-stdlib/docs/ascii.md)
    is serialized into \`string\`. For example, struct value \`0x1::string::String{bytes: b"Hello World!"}\`
    is serialized as \`"Hello World!"\` in JSON.
    `,
  properties: {}
};
var $MoveType = {
  type: "string",
  description: `String representation of an on-chain Move type tag that is exposed in transaction payload.
    Values:
    - bool
    - u8
    - u64
    - u128
    - address
    - signer
    - vector: \`vector<{non-reference MoveTypeId}>\`
    - struct: \`{address}::{module_name}::{struct_name}::<{generic types}>\`

    Vector type value examples:
    - \`vector<u8>\`
    - \`vector<vector<u64>>\`
    - \`vector<0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>>\`

    Struct type value examples:
    - \`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>
    - \`0x1::account::Account\`

    Note:
    1. Empty chars should be ignored when comparing 2 struct tag ids.
    2. When used in an URL path, should be encoded by url-encoding (AKA percent-encoding).
    `,
  pattern: "^(bool|u8|u64|u128|address|signer|vector<.+>|0x[0-9a-zA-Z:_<, >]+)$"
};
var $MoveValue = {
  type: "any-of",
  description: `An enum of the possible Move value types`,
  contains: [{
    type: "number",
    format: "uint8"
  }, {
    type: "U64"
  }, {
    type: "U128"
  }, {
    type: "boolean"
  }, {
    type: "Address"
  }, {
    type: "array",
    contains: {
      type: "MoveValue"
    }
  }, {
    type: "HexEncodedBytes"
  }, {
    type: "MoveStructValue"
  }, {
    type: "string"
  }]
};
var $MultiAgentSignature = {
  description: `Multi agent signature for multi agent transactions

    This allows you to have transactions across multiple accounts`,
  properties: {
    sender: {
      type: "AccountSignature",
      isRequired: true
    },
    secondary_signer_addresses: {
      type: "array",
      contains: {
        type: "Address"
      },
      isRequired: true
    },
    secondary_signers: {
      type: "array",
      contains: {
        type: "AccountSignature"
      },
      isRequired: true
    }
  }
};
var $MultiEd25519Signature = {
  description: `A Ed25519 multi-sig signature

    This allows k-of-n signing for a transaction`,
  properties: {
    public_keys: {
      type: "array",
      contains: {
        type: "HexEncodedBytes"
      },
      isRequired: true
    },
    signatures: {
      type: "array",
      contains: {
        type: "HexEncodedBytes"
      },
      isRequired: true
    },
    threshold: {
      type: "number",
      description: `The number of signatures required for a successful transaction`,
      isRequired: true,
      format: "uint8"
    },
    bitmap: {
      type: "HexEncodedBytes",
      isRequired: true
    }
  }
};
var $PendingTransaction = {
  description: `A transaction waiting in mempool`,
  properties: {
    hash: {
      type: "HashValue",
      isRequired: true
    },
    sender: {
      type: "Address",
      isRequired: true
    },
    sequence_number: {
      type: "U64",
      isRequired: true
    },
    max_gas_amount: {
      type: "U64",
      isRequired: true
    },
    gas_unit_price: {
      type: "U64",
      isRequired: true
    },
    expiration_timestamp_secs: {
      type: "U64",
      isRequired: true
    },
    payload: {
      type: "TransactionPayload",
      isRequired: true
    },
    signature: {
      type: "TransactionSignature"
    }
  }
};
var $RoleType = {
  type: "Enum"
};
var $ScriptPayload = {
  description: `Payload which runs a script that can run multiple functions`,
  properties: {
    code: {
      type: "MoveScriptBytecode",
      isRequired: true
    },
    type_arguments: {
      type: "array",
      contains: {
        type: "MoveType"
      },
      isRequired: true
    },
    arguments: {
      type: "array",
      contains: {
        properties: {}
      },
      isRequired: true
    }
  }
};
var $ScriptWriteSet = {
  properties: {
    execute_as: {
      type: "Address",
      isRequired: true
    },
    script: {
      type: "ScriptPayload",
      isRequired: true
    }
  }
};
var $StateCheckpointTransaction = {
  description: `A state checkpoint transaction`,
  properties: {
    version: {
      type: "U64",
      isRequired: true
    },
    hash: {
      type: "HashValue",
      isRequired: true
    },
    state_change_hash: {
      type: "HashValue",
      isRequired: true
    },
    event_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    state_checkpoint_hash: {
      type: "HashValue"
    },
    gas_used: {
      type: "U64",
      isRequired: true
    },
    success: {
      type: "boolean",
      description: `Whether the transaction was successful`,
      isRequired: true
    },
    vm_status: {
      type: "string",
      description: `The VM status of the transaction, can tell useful information in a failure`,
      isRequired: true
    },
    accumulator_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    changes: {
      type: "array",
      contains: {
        type: "WriteSetChange"
      },
      isRequired: true
    },
    timestamp: {
      type: "U64",
      isRequired: true
    }
  }
};
var $SubmitTransactionRequest = {
  description: `A request to submit a transaction

    This requires a transaction and a signature of it`,
  properties: {
    sender: {
      type: "Address",
      isRequired: true
    },
    sequence_number: {
      type: "U64",
      isRequired: true
    },
    max_gas_amount: {
      type: "U64",
      isRequired: true
    },
    gas_unit_price: {
      type: "U64",
      isRequired: true
    },
    expiration_timestamp_secs: {
      type: "U64",
      isRequired: true
    },
    payload: {
      type: "TransactionPayload",
      isRequired: true
    },
    signature: {
      type: "TransactionSignature",
      isRequired: true
    }
  }
};
var $TableItemRequest = {
  description: `Table Item request for the GetTableItem API`,
  properties: {
    key_type: {
      type: "MoveType",
      isRequired: true
    },
    value_type: {
      type: "MoveType",
      isRequired: true
    },
    key: {
      description: `The value of the table item's key`,
      properties: {},
      isRequired: true
    }
  }
};
var $Transaction = {
  type: "one-of",
  description: `Enum of the different types of transactions in Aptos`,
  contains: [{
    type: "Transaction_PendingTransaction"
  }, {
    type: "Transaction_UserTransaction"
  }, {
    type: "Transaction_GenesisTransaction"
  }, {
    type: "Transaction_BlockMetadataTransaction"
  }, {
    type: "Transaction_StateCheckpointTransaction"
  }]
};
var $Transaction_BlockMetadataTransaction = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "BlockMetadataTransaction"
  }]
};
var $Transaction_GenesisTransaction = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "GenesisTransaction"
  }]
};
var $Transaction_PendingTransaction = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "PendingTransaction"
  }]
};
var $Transaction_StateCheckpointTransaction = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "StateCheckpointTransaction"
  }]
};
var $Transaction_UserTransaction = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "UserTransaction"
  }]
};
var $TransactionPayload = {
  type: "one-of",
  description: `An enum of the possible transaction payloads`,
  contains: [{
    type: "TransactionPayload_EntryFunctionPayload"
  }, {
    type: "TransactionPayload_ScriptPayload"
  }, {
    type: "TransactionPayload_ModuleBundlePayload"
  }]
};
var $TransactionPayload_EntryFunctionPayload = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "EntryFunctionPayload"
  }]
};
var $TransactionPayload_ModuleBundlePayload = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "ModuleBundlePayload"
  }]
};
var $TransactionPayload_ScriptPayload = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "ScriptPayload"
  }]
};
var $TransactionsBatchSingleSubmissionFailure = {
  description: `Information telling which batch submission transactions failed`,
  properties: {
    error: {
      type: "AptosError",
      isRequired: true
    },
    transaction_index: {
      type: "number",
      description: `The index of which transaction failed, same as submission order`,
      isRequired: true,
      format: "uint64"
    }
  }
};
var $TransactionsBatchSubmissionResult = {
  description: `Batch transaction submission result

    Tells which transactions failed`,
  properties: {
    transaction_failures: {
      type: "array",
      contains: {
        type: "TransactionsBatchSingleSubmissionFailure"
      },
      isRequired: true
    }
  }
};
var $TransactionSignature = {
  type: "one-of",
  description: `An enum representing the different transaction signatures available`,
  contains: [{
    type: "TransactionSignature_Ed25519Signature"
  }, {
    type: "TransactionSignature_MultiEd25519Signature"
  }, {
    type: "TransactionSignature_MultiAgentSignature"
  }]
};
var $TransactionSignature_Ed25519Signature = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "Ed25519Signature"
  }]
};
var $TransactionSignature_MultiAgentSignature = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "MultiAgentSignature"
  }]
};
var $TransactionSignature_MultiEd25519Signature = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "MultiEd25519Signature"
  }]
};
var $U128 = {
  type: "string",
  description: `A string containing a 128-bit unsigned integer.

    We represent u128 values as a string to ensure compatibility with languages such
    as JavaScript that do not parse u64s in JSON natively.
    `,
  format: "uint64"
};
var $U64 = {
  type: "string",
  description: `A string containing a 64-bit unsigned integer.

    We represent u64 values as a string to ensure compatibility with languages such
    as JavaScript that do not parse u64s in JSON natively.
    `,
  format: "uint64"
};
var $UserTransaction = {
  description: `A transaction submitted by a user to change the state of the blockchain`,
  properties: {
    version: {
      type: "U64",
      isRequired: true
    },
    hash: {
      type: "HashValue",
      isRequired: true
    },
    state_change_hash: {
      type: "HashValue",
      isRequired: true
    },
    event_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    state_checkpoint_hash: {
      type: "HashValue"
    },
    gas_used: {
      type: "U64",
      isRequired: true
    },
    success: {
      type: "boolean",
      description: `Whether the transaction was successful`,
      isRequired: true
    },
    vm_status: {
      type: "string",
      description: `The VM status of the transaction, can tell useful information in a failure`,
      isRequired: true
    },
    accumulator_root_hash: {
      type: "HashValue",
      isRequired: true
    },
    changes: {
      type: "array",
      contains: {
        type: "WriteSetChange"
      },
      isRequired: true
    },
    sender: {
      type: "Address",
      isRequired: true
    },
    sequence_number: {
      type: "U64",
      isRequired: true
    },
    max_gas_amount: {
      type: "U64",
      isRequired: true
    },
    gas_unit_price: {
      type: "U64",
      isRequired: true
    },
    expiration_timestamp_secs: {
      type: "U64",
      isRequired: true
    },
    payload: {
      type: "TransactionPayload",
      isRequired: true
    },
    signature: {
      type: "TransactionSignature"
    },
    events: {
      type: "array",
      contains: {
        type: "Event"
      },
      isRequired: true
    },
    timestamp: {
      type: "U64",
      isRequired: true
    }
  }
};
var $VersionedEvent = {
  description: `An event from a transaction with a version`,
  properties: {
    version: {
      type: "U64",
      isRequired: true
    },
    guid: {
      type: "EventGuid",
      isRequired: true
    },
    sequence_number: {
      type: "U64",
      isRequired: true
    },
    type: {
      type: "MoveType",
      isRequired: true
    },
    data: {
      description: `The JSON representation of the event`,
      properties: {},
      isRequired: true
    }
  }
};
var $WriteModule = {
  description: `Write a new module or update an existing one`,
  properties: {
    address: {
      type: "Address",
      isRequired: true
    },
    state_key_hash: {
      type: "string",
      description: `State key hash`,
      isRequired: true
    },
    data: {
      type: "MoveModuleBytecode",
      isRequired: true
    }
  }
};
var $WriteResource = {
  description: `Write a resource or update an existing one`,
  properties: {
    address: {
      type: "Address",
      isRequired: true
    },
    state_key_hash: {
      type: "string",
      description: `State key hash`,
      isRequired: true
    },
    data: {
      type: "MoveResource",
      isRequired: true
    }
  }
};
var $WriteSet = {
  type: "one-of",
  description: `The associated writeset with a payload`,
  contains: [{
    type: "WriteSet_ScriptWriteSet"
  }, {
    type: "WriteSet_DirectWriteSet"
  }]
};
var $WriteSet_DirectWriteSet = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "DirectWriteSet"
  }]
};
var $WriteSet_ScriptWriteSet = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "ScriptWriteSet"
  }]
};
var $WriteSetChange = {
  type: "one-of",
  description: `A final state change of a transaction on a resource or module`,
  contains: [{
    type: "WriteSetChange_DeleteModule"
  }, {
    type: "WriteSetChange_DeleteResource"
  }, {
    type: "WriteSetChange_DeleteTableItem"
  }, {
    type: "WriteSetChange_WriteModule"
  }, {
    type: "WriteSetChange_WriteResource"
  }, {
    type: "WriteSetChange_WriteTableItem"
  }]
};
var $WriteSetChange_DeleteModule = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "DeleteModule"
  }]
};
var $WriteSetChange_DeleteResource = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "DeleteResource"
  }]
};
var $WriteSetChange_DeleteTableItem = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "DeleteTableItem"
  }]
};
var $WriteSetChange_WriteModule = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "WriteModule"
  }]
};
var $WriteSetChange_WriteResource = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "WriteResource"
  }]
};
var $WriteSetChange_WriteTableItem = {
  type: "all-of",
  contains: [{
    properties: {
      type: {
        type: "string",
        isRequired: true
      }
    }
  }, {
    type: "WriteTableItem"
  }]
};
var $WriteSetPayload = {
  description: `A writeset payload, used only for genesis`,
  properties: {
    write_set: {
      type: "WriteSet",
      isRequired: true
    }
  }
};
var $WriteTableItem = {
  description: `Change set to write a table item`,
  properties: {
    state_key_hash: {
      type: "string",
      isRequired: true
    },
    handle: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    key: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    value: {
      type: "HexEncodedBytes",
      isRequired: true
    },
    data: {
      type: "DecodedTableData"
    }
  }
};
var import_sha34 = sha3$1;
var aptos_types_exports = {};
__export(aptos_types_exports, {
  AccountAddress: () => AccountAddress,
  AccountAuthenticator: () => AccountAuthenticator,
  AccountAuthenticatorEd25519: () => AccountAuthenticatorEd25519,
  AccountAuthenticatorMultiEd25519: () => AccountAuthenticatorMultiEd25519,
  AuthenticationKey: () => AuthenticationKey,
  ChainId: () => ChainId,
  ChangeSet: () => ChangeSet,
  Ed25519PublicKey: () => Ed25519PublicKey,
  Ed25519Signature: () => Ed25519Signature,
  EntryFunction: () => EntryFunction,
  Identifier: () => Identifier,
  Module: () => Module,
  ModuleId: () => ModuleId,
  MultiAgentRawTransaction: () => MultiAgentRawTransaction,
  MultiEd25519PublicKey: () => MultiEd25519PublicKey,
  MultiEd25519Signature: () => MultiEd25519Signature,
  RawTransaction: () => RawTransaction,
  RawTransactionWithData: () => RawTransactionWithData,
  RotationProofChallenge: () => RotationProofChallenge,
  Script: () => Script,
  SignedTransaction: () => SignedTransaction,
  StructTag: () => StructTag,
  Transaction: () => Transaction,
  TransactionArgument: () => TransactionArgument,
  TransactionArgumentAddress: () => TransactionArgumentAddress,
  TransactionArgumentBool: () => TransactionArgumentBool,
  TransactionArgumentU128: () => TransactionArgumentU128,
  TransactionArgumentU64: () => TransactionArgumentU64,
  TransactionArgumentU8: () => TransactionArgumentU8,
  TransactionArgumentU8Vector: () => TransactionArgumentU8Vector,
  TransactionAuthenticator: () => TransactionAuthenticator,
  TransactionAuthenticatorEd25519: () => TransactionAuthenticatorEd25519,
  TransactionAuthenticatorMultiAgent: () => TransactionAuthenticatorMultiAgent,
  TransactionAuthenticatorMultiEd25519: () => TransactionAuthenticatorMultiEd25519,
  TransactionPayload: () => TransactionPayload,
  TransactionPayloadEntryFunction: () => TransactionPayloadEntryFunction,
  TransactionPayloadScript: () => TransactionPayloadScript,
  TypeTag: () => TypeTag,
  TypeTagAddress: () => TypeTagAddress,
  TypeTagBool: () => TypeTagBool,
  TypeTagSigner: () => TypeTagSigner,
  TypeTagStruct: () => TypeTagStruct,
  TypeTagU128: () => TypeTagU128,
  TypeTagU64: () => TypeTagU64,
  TypeTagU8: () => TypeTagU8,
  TypeTagVector: () => TypeTagVector,
  UserTransaction: () => UserTransaction,
  WriteSet: () => WriteSet
});
var _AccountAddress = class {
  constructor(address) {
    if (address.length !== _AccountAddress.LENGTH) {
      throw new Error("Expected address of length 32");
    }
    this.address = address;
  }
  static fromHex(addr) {
    let address = HexString.ensure(addr);
    if (address.noPrefix().length % 2 !== 0) {
      address = new HexString(`0${address.noPrefix()}`);
    }
    const addressBytes = address.toUint8Array();
    if (addressBytes.length > _AccountAddress.LENGTH) {
      throw new Error("Hex string is too long. Address's length is 32 bytes.");
    } else if (addressBytes.length === _AccountAddress.LENGTH) {
      return new _AccountAddress(addressBytes);
    }
    const res = new Uint8Array(_AccountAddress.LENGTH);
    res.set(addressBytes, _AccountAddress.LENGTH - addressBytes.length);
    return new _AccountAddress(res);
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.address);
  }
  static deserialize(deserializer) {
    return new _AccountAddress(deserializer.deserializeFixedBytes(_AccountAddress.LENGTH));
  }
};
var AccountAddress = _AccountAddress;
AccountAddress.LENGTH = 32;
AccountAddress.CORE_CODE_ADDRESS = _AccountAddress.fromHex("0x1");
var bcs_exports = {};
__export(bcs_exports, {
  Deserializer: () => Deserializer,
  Serializer: () => Serializer,
  bcsSerializeBool: () => bcsSerializeBool,
  bcsSerializeBytes: () => bcsSerializeBytes,
  bcsSerializeFixedBytes: () => bcsSerializeFixedBytes,
  bcsSerializeStr: () => bcsSerializeStr,
  bcsSerializeU128: () => bcsSerializeU128,
  bcsSerializeU16: () => bcsSerializeU16,
  bcsSerializeU32: () => bcsSerializeU32,
  bcsSerializeU8: () => bcsSerializeU8,
  bcsSerializeUint64: () => bcsSerializeUint64,
  bcsToBytes: () => bcsToBytes,
  deserializeVector: () => deserializeVector,
  serializeVector: () => serializeVector,
  serializeVectorWithFunc: () => serializeVectorWithFunc
});
var MAX_U8_NUMBER = 2 ** 8 - 1;
var MAX_U16_NUMBER = 2 ** 16 - 1;
var MAX_U32_NUMBER = 2 ** 32 - 1;
var MAX_U64_BIG_INT = BigInt(2 ** 64) - BigInt(1);
var MAX_U128_BIG_INT = BigInt(2 ** 128) - BigInt(1);
var Serializer = class {
  constructor() {
    this.buffer = new ArrayBuffer(64);
    this.offset = 0;
  }
  ensureBufferWillHandleSize(bytes2) {
    while (this.buffer.byteLength < this.offset + bytes2) {
      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
      this.buffer = newBuffer;
    }
  }
  serialize(values) {
    this.ensureBufferWillHandleSize(values.length);
    new Uint8Array(this.buffer, this.offset).set(values);
    this.offset += values.length;
  }
  serializeWithFunction(fn, bytesLength, value) {
    this.ensureBufferWillHandleSize(bytesLength);
    const dv = new DataView(this.buffer, this.offset);
    fn.apply(dv, [0, value, true]);
    this.offset += bytesLength;
  }
  serializeStr(value) {
    const textEncoder = new TextEncoder();
    this.serializeBytes(textEncoder.encode(value));
  }
  serializeBytes(value) {
    this.serializeU32AsUleb128(value.length);
    this.serialize(value);
  }
  serializeFixedBytes(value) {
    this.serialize(value);
  }
  serializeBool(value) {
    if (typeof value !== "boolean") {
      throw new Error("Value needs to be a boolean");
    }
    const byteValue = value ? 1 : 0;
    this.serialize(new Uint8Array([byteValue]));
  }
  serializeU8(value) {
    this.serialize(new Uint8Array([value]));
  }
  serializeU16(value) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);
  }
  serializeU32(value) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);
  }
  serializeU64(value) {
    const low = BigInt(value.toString()) & BigInt(MAX_U32_NUMBER);
    const high = BigInt(value.toString()) >> BigInt(32);
    this.serializeU32(Number(low));
    this.serializeU32(Number(high));
  }
  serializeU128(value) {
    const low = BigInt(value.toString()) & MAX_U64_BIG_INT;
    const high = BigInt(value.toString()) >> BigInt(64);
    this.serializeU64(low);
    this.serializeU64(high);
  }
  serializeU32AsUleb128(val) {
    let value = val;
    const valueArray = [];
    while (value >>> 7 !== 0) {
      valueArray.push(value & 127 | 128);
      value >>>= 7;
    }
    valueArray.push(value);
    this.serialize(new Uint8Array(valueArray));
  }
  getBytes() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
};
__decorateClass([
  checkNumberRange(0, MAX_U8_NUMBER)
], Serializer.prototype, "serializeU8", 1);
__decorateClass([
  checkNumberRange(0, MAX_U16_NUMBER)
], Serializer.prototype, "serializeU16", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U64_BIG_INT)
], Serializer.prototype, "serializeU64", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U128_BIG_INT)
], Serializer.prototype, "serializeU128", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32AsUleb128", 1);
function checkNumberRange(minValue, maxValue, message) {
  return (target, propertyKey, descriptor) => {
    const childFunction = descriptor.value;
    descriptor.value = function deco(value) {
      const valueBigInt = BigInt(value.toString());
      if (valueBigInt > BigInt(maxValue.toString()) || valueBigInt < BigInt(minValue.toString())) {
        throw new Error(message || "Value is out of range");
      }
      childFunction.apply(this, [value]);
    };
    return descriptor;
  };
}
var Deserializer = class {
  constructor(data2) {
    this.buffer = new ArrayBuffer(data2.length);
    new Uint8Array(this.buffer).set(data2, 0);
    this.offset = 0;
  }
  read(length) {
    if (this.offset + length > this.buffer.byteLength) {
      throw new Error("Reached to the end of buffer");
    }
    const bytes2 = this.buffer.slice(this.offset, this.offset + length);
    this.offset += length;
    return bytes2;
  }
  deserializeStr() {
    const value = this.deserializeBytes();
    const textDecoder = new TextDecoder();
    return textDecoder.decode(value);
  }
  deserializeBytes() {
    const len = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(len));
  }
  deserializeFixedBytes(len) {
    return new Uint8Array(this.read(len));
  }
  deserializeBool() {
    const bool2 = new Uint8Array(this.read(1))[0];
    if (bool2 !== 1 && bool2 !== 0) {
      throw new Error("Invalid boolean value");
    }
    return bool2 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    const low = this.deserializeU32();
    const high = this.deserializeU32();
    return BigInt(BigInt(high) << BigInt(32) | BigInt(low));
  }
  deserializeU128() {
    const low = this.deserializeU64();
    const high = this.deserializeU64();
    return BigInt(high << BigInt(64) | low);
  }
  deserializeUleb128AsU32() {
    let value = BigInt(0);
    let shift2 = 0;
    while (value < MAX_U32_NUMBER) {
      const byte = this.deserializeU8();
      value |= BigInt(byte & 127) << BigInt(shift2);
      if ((byte & 128) === 0) {
        break;
      }
      shift2 += 7;
    }
    if (value > MAX_U32_NUMBER) {
      throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    }
    return Number(value);
  }
};
function serializeVector(value, serializer) {
  serializer.serializeU32AsUleb128(value.length);
  value.forEach((item) => {
    item.serialize(serializer);
  });
}
function serializeVectorWithFunc(value, func) {
  const serializer = new Serializer();
  serializer.serializeU32AsUleb128(value.length);
  const f2 = serializer[func];
  value.forEach((item) => {
    f2.call(serializer, item);
  });
  return serializer.getBytes();
}
function deserializeVector(deserializer, cls) {
  const length = deserializer.deserializeUleb128AsU32();
  const list = [];
  for (let i2 = 0; i2 < length; i2 += 1) {
    list.push(cls.deserialize(deserializer));
  }
  return list;
}
function bcsToBytes(value) {
  const serializer = new Serializer();
  value.serialize(serializer);
  return serializer.getBytes();
}
function bcsSerializeUint64(value) {
  const serializer = new Serializer();
  serializer.serializeU64(value);
  return serializer.getBytes();
}
function bcsSerializeU8(value) {
  const serializer = new Serializer();
  serializer.serializeU8(value);
  return serializer.getBytes();
}
function bcsSerializeU16(value) {
  const serializer = new Serializer();
  serializer.serializeU16(value);
  return serializer.getBytes();
}
function bcsSerializeU32(value) {
  const serializer = new Serializer();
  serializer.serializeU32(value);
  return serializer.getBytes();
}
function bcsSerializeU128(value) {
  const serializer = new Serializer();
  serializer.serializeU128(value);
  return serializer.getBytes();
}
function bcsSerializeBool(value) {
  const serializer = new Serializer();
  serializer.serializeBool(value);
  return serializer.getBytes();
}
function bcsSerializeStr(value) {
  const serializer = new Serializer();
  serializer.serializeStr(value);
  return serializer.getBytes();
}
function bcsSerializeBytes(value) {
  const serializer = new Serializer();
  serializer.serializeBytes(value);
  return serializer.getBytes();
}
function bcsSerializeFixedBytes(value) {
  const serializer = new Serializer();
  serializer.serializeFixedBytes(value);
  return serializer.getBytes();
}
var _Ed25519PublicKey = class {
  constructor(value) {
    if (value.length !== _Ed25519PublicKey.LENGTH) {
      throw new Error(`Ed25519PublicKey length should be ${_Ed25519PublicKey.LENGTH}`);
    }
    this.value = value;
  }
  toBytes() {
    return this.value;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeBytes();
    return new _Ed25519PublicKey(value);
  }
};
var Ed25519PublicKey = _Ed25519PublicKey;
Ed25519PublicKey.LENGTH = 32;
var _Ed25519Signature = class {
  constructor(value) {
    this.value = value;
    if (value.length !== _Ed25519Signature.LENGTH) {
      throw new Error(`Ed25519Signature length should be ${_Ed25519Signature.LENGTH}`);
    }
  }
  serialize(serializer) {
    serializer.serializeBytes(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeBytes();
    return new _Ed25519Signature(value);
  }
};
var Ed25519Signature = _Ed25519Signature;
Ed25519Signature.LENGTH = 64;
var MAX_SIGNATURES_SUPPORTED = 32;
var MultiEd25519PublicKey = class {
  constructor(public_keys, threshold) {
    this.public_keys = public_keys;
    this.threshold = threshold;
    if (threshold > MAX_SIGNATURES_SUPPORTED) {
      throw new Error(`"threshold" cannot be larger than ${MAX_SIGNATURES_SUPPORTED}`);
    }
  }
  toBytes() {
    const bytes2 = new Uint8Array(this.public_keys.length * Ed25519PublicKey.LENGTH + 1);
    this.public_keys.forEach((k2, i2) => {
      bytes2.set(k2.value, i2 * Ed25519PublicKey.LENGTH);
    });
    bytes2[this.public_keys.length * Ed25519PublicKey.LENGTH] = this.threshold;
    return bytes2;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toBytes());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    const threshold = bytes2[bytes2.length - 1];
    const keys = [];
    for (let i2 = 0; i2 < bytes2.length - 1; i2 += Ed25519PublicKey.LENGTH) {
      const begin = i2;
      keys.push(new Ed25519PublicKey(bytes2.subarray(begin, begin + Ed25519PublicKey.LENGTH)));
    }
    return new MultiEd25519PublicKey(keys, threshold);
  }
};
var _MultiEd25519Signature = class {
  constructor(signatures, bitmap) {
    this.signatures = signatures;
    this.bitmap = bitmap;
    if (bitmap.length !== _MultiEd25519Signature.BITMAP_LEN) {
      throw new Error(`"bitmap" length should be ${_MultiEd25519Signature.BITMAP_LEN}`);
    }
  }
  toBytes() {
    const bytes2 = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + _MultiEd25519Signature.BITMAP_LEN);
    this.signatures.forEach((k2, i2) => {
      bytes2.set(k2.value, i2 * Ed25519Signature.LENGTH);
    });
    bytes2.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);
    return bytes2;
  }
  static createBitmap(bits) {
    const firstBitInByte = 128;
    const bitmap = new Uint8Array([0, 0, 0, 0]);
    const dupCheckSet = /* @__PURE__ */ new Set();
    bits.forEach((bit) => {
      if (bit >= MAX_SIGNATURES_SUPPORTED) {
        throw new Error(`Invalid bit value ${bit}.`);
      }
      if (dupCheckSet.has(bit)) {
        throw new Error("Duplicated bits detected.");
      }
      dupCheckSet.add(bit);
      const byteOffset = Math.floor(bit / 8);
      let byte = bitmap[byteOffset];
      byte |= firstBitInByte >> bit % 8;
      bitmap[byteOffset] = byte;
    });
    return bitmap;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toBytes());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    const bitmap = bytes2.subarray(bytes2.length - 4);
    const sigs = [];
    for (let i2 = 0; i2 < bytes2.length - bitmap.length; i2 += Ed25519Signature.LENGTH) {
      const begin = i2;
      sigs.push(new Ed25519Signature(bytes2.subarray(begin, begin + Ed25519Signature.LENGTH)));
    }
    return new _MultiEd25519Signature(sigs, bitmap);
  }
};
var MultiEd25519Signature = _MultiEd25519Signature;
MultiEd25519Signature.BITMAP_LEN = 4;
var TransactionAuthenticator = class {
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return TransactionAuthenticatorEd25519.load(deserializer);
      case 1:
        return TransactionAuthenticatorMultiEd25519.load(deserializer);
      case 2:
        return TransactionAuthenticatorMultiAgent.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index2}`);
    }
  }
};
var TransactionAuthenticatorEd25519 = class extends TransactionAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new TransactionAuthenticatorEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiEd25519 = class extends TransactionAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new TransactionAuthenticatorMultiEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiAgent = class extends TransactionAuthenticator {
  constructor(sender, secondary_signer_addresses, secondary_signers) {
    super();
    this.sender = sender;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.secondary_signers = secondary_signers;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
    this.sender.serialize(serializer);
    serializeVector(this.secondary_signer_addresses, serializer);
    serializeVector(this.secondary_signers, serializer);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    const secondary_signer_addresses = deserializeVector(deserializer, AccountAddress);
    const secondary_signers = deserializeVector(deserializer, AccountAuthenticator);
    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);
  }
};
var AccountAuthenticator = class {
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return AccountAuthenticatorEd25519.load(deserializer);
      case 1:
        return AccountAuthenticatorMultiEd25519.load(deserializer);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${index2}`);
    }
  }
};
var AccountAuthenticatorEd25519 = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new AccountAuthenticatorEd25519(public_key, signature);
  }
};
var AccountAuthenticatorMultiEd25519 = class extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new AccountAuthenticatorMultiEd25519(public_key, signature);
  }
};
var import_sha32 = sha3$1;
var Identifier = class {
  constructor(value) {
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeStr(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeStr();
    return new Identifier(value);
  }
};
var TypeTag = class {
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return TypeTagBool.load(deserializer);
      case 1:
        return TypeTagU8.load(deserializer);
      case 2:
        return TypeTagU64.load(deserializer);
      case 3:
        return TypeTagU128.load(deserializer);
      case 4:
        return TypeTagAddress.load(deserializer);
      case 5:
        return TypeTagSigner.load(deserializer);
      case 6:
        return TypeTagVector.load(deserializer);
      case 7:
        return TypeTagStruct.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${index2}`);
    }
  }
};
var TypeTagBool = class extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
  }
  static load(deserializer) {
    return new TypeTagBool();
  }
};
var TypeTagU8 = class extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
  }
  static load(_deserializer) {
    return new TypeTagU8();
  }
};
var TypeTagU64 = class extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
  }
  static load(_deserializer) {
    return new TypeTagU64();
  }
};
var TypeTagU128 = class extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(3);
  }
  static load(_deserializer) {
    return new TypeTagU128();
  }
};
var TypeTagAddress = class extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(4);
  }
  static load(_deserializer) {
    return new TypeTagAddress();
  }
};
var TypeTagSigner = class extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(5);
  }
  static load(_deserializer) {
    return new TypeTagSigner();
  }
};
var TypeTagVector = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(6);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = TypeTag.deserialize(deserializer);
    return new TypeTagVector(value);
  }
};
var TypeTagStruct = class extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(7);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = StructTag.deserialize(deserializer);
    return new TypeTagStruct(value);
  }
};
var StructTag = class {
  constructor(address, module_name, name, type_args) {
    this.address = address;
    this.module_name = module_name;
    this.name = name;
    this.type_args = type_args;
  }
  static fromString(structTag) {
    if (structTag.includes("<")) {
      throw new Error("Not implemented");
    }
    const parts = structTag.split("::");
    if (parts.length !== 3) {
      throw new Error("Invalid struct tag string literal.");
    }
    return new StructTag(AccountAddress.fromHex(parts[0]), new Identifier(parts[1]), new Identifier(parts[2]), []);
  }
  serialize(serializer) {
    this.address.serialize(serializer);
    this.module_name.serialize(serializer);
    this.name.serialize(serializer);
    serializeVector(this.type_args, serializer);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const moduleName = Identifier.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    const typeArgs = deserializeVector(deserializer, TypeTag);
    return new StructTag(address, moduleName, name, typeArgs);
  }
};
var RawTransaction = class {
  constructor(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id) {
    this.sender = sender;
    this.sequence_number = sequence_number;
    this.payload = payload;
    this.max_gas_amount = max_gas_amount;
    this.gas_unit_price = gas_unit_price;
    this.expiration_timestamp_secs = expiration_timestamp_secs;
    this.chain_id = chain_id;
  }
  serialize(serializer) {
    this.sender.serialize(serializer);
    serializer.serializeU64(this.sequence_number);
    this.payload.serialize(serializer);
    serializer.serializeU64(this.max_gas_amount);
    serializer.serializeU64(this.gas_unit_price);
    serializer.serializeU64(this.expiration_timestamp_secs);
    this.chain_id.serialize(serializer);
  }
  static deserialize(deserializer) {
    const sender = AccountAddress.deserialize(deserializer);
    const sequence_number = deserializer.deserializeU64();
    const payload = TransactionPayload.deserialize(deserializer);
    const max_gas_amount = deserializer.deserializeU64();
    const gas_unit_price = deserializer.deserializeU64();
    const expiration_timestamp_secs = deserializer.deserializeU64();
    const chain_id = ChainId.deserialize(deserializer);
    return new RawTransaction(
      sender,
      sequence_number,
      payload,
      max_gas_amount,
      gas_unit_price,
      expiration_timestamp_secs,
      chain_id
    );
  }
};
var Script = class {
  constructor(code, ty_args, args) {
    this.code = code;
    this.ty_args = ty_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.code);
    serializeVector(this.ty_args, serializer);
    serializeVector(this.args, serializer);
  }
  static deserialize(deserializer) {
    const code = deserializer.deserializeBytes();
    const ty_args = deserializeVector(deserializer, TypeTag);
    const args = deserializeVector(deserializer, TransactionArgument);
    return new Script(code, ty_args, args);
  }
};
var EntryFunction = class {
  constructor(module_name, function_name, ty_args, args) {
    this.module_name = module_name;
    this.function_name = function_name;
    this.ty_args = ty_args;
    this.args = args;
  }
  static natural(module2, func, ty_args, args) {
    return new EntryFunction(ModuleId.fromStr(module2), new Identifier(func), ty_args, args);
  }
  static natual(module2, func, ty_args, args) {
    return EntryFunction.natural(module2, func, ty_args, args);
  }
  serialize(serializer) {
    this.module_name.serialize(serializer);
    this.function_name.serialize(serializer);
    serializeVector(this.ty_args, serializer);
    serializer.serializeU32AsUleb128(this.args.length);
    this.args.forEach((item) => {
      serializer.serializeBytes(item);
    });
  }
  static deserialize(deserializer) {
    const module_name = ModuleId.deserialize(deserializer);
    const function_name = Identifier.deserialize(deserializer);
    const ty_args = deserializeVector(deserializer, TypeTag);
    const length = deserializer.deserializeUleb128AsU32();
    const list = [];
    for (let i2 = 0; i2 < length; i2 += 1) {
      list.push(deserializer.deserializeBytes());
    }
    const args = list;
    return new EntryFunction(module_name, function_name, ty_args, args);
  }
};
var Module = class {
  constructor(code) {
    this.code = code;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.code);
  }
  static deserialize(deserializer) {
    const code = deserializer.deserializeBytes();
    return new Module(code);
  }
};
var ModuleId = class {
  constructor(address, name) {
    this.address = address;
    this.name = name;
  }
  static fromStr(moduleId) {
    const parts = moduleId.split("::");
    if (parts.length !== 2) {
      throw new Error("Invalid module id.");
    }
    return new ModuleId(AccountAddress.fromHex(new HexString(parts[0])), new Identifier(parts[1]));
  }
  serialize(serializer) {
    this.address.serialize(serializer);
    this.name.serialize(serializer);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    return new ModuleId(address, name);
  }
};
var ChangeSet = class {
  serialize(serializer) {
    throw new Error("Not implemented.");
  }
  static deserialize(deserializer) {
    throw new Error("Not implemented.");
  }
};
var WriteSet = class {
  serialize(serializer) {
    throw new Error("Not implmented.");
  }
  static deserialize(deserializer) {
    throw new Error("Not implmented.");
  }
};
var SignedTransaction = class {
  constructor(raw_txn, authenticator) {
    this.raw_txn = raw_txn;
    this.authenticator = authenticator;
  }
  serialize(serializer) {
    this.raw_txn.serialize(serializer);
    this.authenticator.serialize(serializer);
  }
  static deserialize(deserializer) {
    const raw_txn = RawTransaction.deserialize(deserializer);
    const authenticator = TransactionAuthenticator.deserialize(deserializer);
    return new SignedTransaction(raw_txn, authenticator);
  }
};
var RawTransactionWithData = class {
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return MultiAgentRawTransaction.load(deserializer);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${index2}`);
    }
  }
};
var MultiAgentRawTransaction = class extends RawTransactionWithData {
  constructor(raw_txn, secondary_signer_addresses) {
    super();
    this.raw_txn = raw_txn;
    this.secondary_signer_addresses = secondary_signer_addresses;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.raw_txn.serialize(serializer);
    serializeVector(this.secondary_signer_addresses, serializer);
  }
  static load(deserializer) {
    const rawTxn = RawTransaction.deserialize(deserializer);
    const secondarySignerAddresses = deserializeVector(deserializer, AccountAddress);
    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);
  }
};
var TransactionPayload = class {
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return TransactionPayloadScript.load(deserializer);
      case 2:
        return TransactionPayloadEntryFunction.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${index2}`);
    }
  }
};
var TransactionPayloadScript = class extends TransactionPayload {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = Script.deserialize(deserializer);
    return new TransactionPayloadScript(value);
  }
};
var TransactionPayloadEntryFunction = class extends TransactionPayload {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = EntryFunction.deserialize(deserializer);
    return new TransactionPayloadEntryFunction(value);
  }
};
var ChainId = class {
  constructor(value) {
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU8(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeU8();
    return new ChainId(value);
  }
};
var TransactionArgument = class {
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return TransactionArgumentU8.load(deserializer);
      case 1:
        return TransactionArgumentU64.load(deserializer);
      case 2:
        return TransactionArgumentU128.load(deserializer);
      case 3:
        return TransactionArgumentAddress.load(deserializer);
      case 4:
        return TransactionArgumentU8Vector.load(deserializer);
      case 5:
        return TransactionArgumentBool.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionArgument: ${index2}`);
    }
  }
};
var TransactionArgumentU8 = class extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    serializer.serializeU8(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU8();
    return new TransactionArgumentU8(value);
  }
};
var TransactionArgumentU64 = class extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    serializer.serializeU64(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU64();
    return new TransactionArgumentU64(value);
  }
};
var TransactionArgumentU128 = class extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
    serializer.serializeU128(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU128();
    return new TransactionArgumentU128(value);
  }
};
var TransactionArgumentAddress = class extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(3);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = AccountAddress.deserialize(deserializer);
    return new TransactionArgumentAddress(value);
  }
};
var TransactionArgumentU8Vector = class extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(4);
    serializer.serializeBytes(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeBytes();
    return new TransactionArgumentU8Vector(value);
  }
};
var TransactionArgumentBool = class extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(5);
    serializer.serializeBool(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeBool();
    return new TransactionArgumentBool(value);
  }
};
var Transaction = class {
  getHashSalt() {
    const hash2 = import_sha32.sha3_256.create();
    hash2.update("APTOS::Transaction");
    return hash2.digest();
  }
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return UserTransaction.load(deserializer);
      default:
        throw new Error(`Unknown variant index for Transaction: ${index2}`);
    }
  }
};
var UserTransaction = class extends Transaction {
  constructor(value) {
    super();
    this.value = value;
  }
  hash() {
    const hash2 = import_sha32.sha3_256.create();
    hash2.update(this.getHashSalt());
    hash2.update(bcsToBytes(this));
    return hash2.digest();
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    return new UserTransaction(SignedTransaction.deserialize(deserializer));
  }
};
var import_sha33 = sha3$1;
var _AuthenticationKey = class {
  constructor(bytes2) {
    if (bytes2.length !== _AuthenticationKey.LENGTH) {
      throw new Error("Expected a byte array of length 32");
    }
    this.bytes = bytes2;
  }
  static fromMultiEd25519PublicKey(publicKey) {
    const pubKeyBytes = publicKey.toBytes();
    const bytes2 = new Uint8Array(pubKeyBytes.length + 1);
    bytes2.set(pubKeyBytes);
    bytes2.set([_AuthenticationKey.MULTI_ED25519_SCHEME], pubKeyBytes.length);
    const hash2 = import_sha33.sha3_256.create();
    hash2.update(bytes2);
    return new _AuthenticationKey(hash2.digest());
  }
  derivedAddress() {
    return HexString.fromUint8Array(this.bytes);
  }
};
var AuthenticationKey = _AuthenticationKey;
AuthenticationKey.LENGTH = 32;
AuthenticationKey.MULTI_ED25519_SCHEME = 1;
var RotationProofChallenge = class {
  constructor(accountAddress, moduleName, structName, sequenceNumber, originator, currentAuthKey, newPublicKey) {
    this.accountAddress = accountAddress;
    this.moduleName = moduleName;
    this.structName = structName;
    this.sequenceNumber = sequenceNumber;
    this.originator = originator;
    this.currentAuthKey = currentAuthKey;
    this.newPublicKey = newPublicKey;
  }
  serialize(serializer) {
    this.accountAddress.serialize(serializer);
    serializer.serializeStr(this.moduleName);
    serializer.serializeStr(this.structName);
    serializer.serializeU64(this.sequenceNumber);
    this.originator.serialize(serializer);
    this.currentAuthKey.serialize(serializer);
    serializer.serializeBytes(this.newPublicKey);
  }
};
var TypeArgumentABI = class {
  constructor(name) {
    this.name = name;
  }
  serialize(serializer) {
    serializer.serializeStr(this.name);
  }
  static deserialize(deserializer) {
    const name = deserializer.deserializeStr();
    return new TypeArgumentABI(name);
  }
};
var ArgumentABI = class {
  constructor(name, type_tag) {
    this.name = name;
    this.type_tag = type_tag;
  }
  serialize(serializer) {
    serializer.serializeStr(this.name);
    this.type_tag.serialize(serializer);
  }
  static deserialize(deserializer) {
    const name = deserializer.deserializeStr();
    const typeTag = TypeTag.deserialize(deserializer);
    return new ArgumentABI(name, typeTag);
  }
};
var ScriptABI = class {
  static deserialize(deserializer) {
    const index2 = deserializer.deserializeUleb128AsU32();
    switch (index2) {
      case 0:
        return TransactionScriptABI.load(deserializer);
      case 1:
        return EntryFunctionABI.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${index2}`);
    }
  }
};
var TransactionScriptABI = class extends ScriptABI {
  constructor(name, doc, code, ty_args, args) {
    super();
    this.name = name;
    this.doc = doc;
    this.code = code;
    this.ty_args = ty_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    serializer.serializeStr(this.name);
    serializer.serializeStr(this.doc);
    serializer.serializeBytes(this.code);
    serializeVector(this.ty_args, serializer);
    serializeVector(this.args, serializer);
  }
  static load(deserializer) {
    const name = deserializer.deserializeStr();
    const doc = deserializer.deserializeStr();
    const code = deserializer.deserializeBytes();
    const tyArgs = deserializeVector(deserializer, TypeArgumentABI);
    const args = deserializeVector(deserializer, ArgumentABI);
    return new TransactionScriptABI(name, doc, code, tyArgs, args);
  }
};
var EntryFunctionABI = class extends ScriptABI {
  constructor(name, module_name, doc, ty_args, args) {
    super();
    this.name = name;
    this.module_name = module_name;
    this.doc = doc;
    this.ty_args = ty_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    serializer.serializeStr(this.name);
    this.module_name.serialize(serializer);
    serializer.serializeStr(this.doc);
    serializeVector(this.ty_args, serializer);
    serializeVector(this.args, serializer);
  }
  static load(deserializer) {
    const name = deserializer.deserializeStr();
    const moduleName = ModuleId.deserialize(deserializer);
    const doc = deserializer.deserializeStr();
    const tyArgs = deserializeVector(deserializer, TypeArgumentABI);
    const args = deserializeVector(deserializer, ArgumentABI);
    return new EntryFunctionABI(name, moduleName, doc, tyArgs, args);
  }
};
function assertType(val, types2, message) {
  if (!(types2 == null ? void 0 : types2.includes(typeof val))) {
    throw new Error(
      message || `Invalid arg: ${val} type should be ${types2 instanceof Array ? types2.join(" or ") : types2}`
    );
  }
}
function bail(message) {
  throw new Error(message);
}
function isWhiteSpace(c2) {
  if (c2.match(/\s/)) {
    return true;
  }
  return false;
}
function isValidAlphabetic(c2) {
  if (c2.match(/[_A-Za-z0-9]/g)) {
    return true;
  }
  return false;
}
function nextToken(tagStr, pos) {
  const c2 = tagStr[pos];
  if (c2 === ":") {
    if (tagStr.slice(pos, pos + 2) === "::") {
      return [["COLON", "::"], 2];
    }
    bail("Unrecognized token.");
  } else if (c2 === "<") {
    return [["LT", "<"], 1];
  } else if (c2 === ">") {
    return [["GT", ">"], 1];
  } else if (c2 === ",") {
    return [["COMMA", ","], 1];
  } else if (isWhiteSpace(c2)) {
    let res = "";
    for (let i2 = pos; i2 < tagStr.length; i2 += 1) {
      const char = tagStr[i2];
      if (isWhiteSpace(char)) {
        res = `${res}${char}`;
      } else {
        break;
      }
    }
    return [["SPACE", res], res.length];
  } else if (isValidAlphabetic(c2)) {
    let res = "";
    for (let i2 = pos; i2 < tagStr.length; i2 += 1) {
      const char = tagStr[i2];
      if (isValidAlphabetic(char)) {
        res = `${res}${char}`;
      } else {
        break;
      }
    }
    return [["IDENT", res], res.length];
  }
  throw new Error("Unrecognized token.");
}
function tokenize(tagStr) {
  let pos = 0;
  const tokens = [];
  while (pos < tagStr.length) {
    const [token, size] = nextToken(tagStr, pos);
    if (token[0] !== "SPACE") {
      tokens.push(token);
    }
    pos += size;
  }
  return tokens;
}
var TypeTagParser = class {
  constructor(tagStr) {
    this.tokens = tokenize(tagStr);
  }
  consume(targetToken) {
    const token = this.tokens.shift();
    if (!token || token[1] !== targetToken) {
      bail("Invalid type tag.");
    }
  }
  parseCommaList(endToken, allowTraillingComma) {
    const res = [];
    if (this.tokens.length <= 0) {
      bail("Invalid type tag.");
    }
    while (this.tokens[0][1] !== endToken) {
      res.push(this.parseTypeTag());
      if (this.tokens.length > 0 && this.tokens[0][1] === endToken) {
        break;
      }
      this.consume(",");
      if (this.tokens.length > 0 && this.tokens[0][1] === endToken && allowTraillingComma) {
        break;
      }
      if (this.tokens.length <= 0) {
        bail("Invalid type tag.");
      }
    }
    return res;
  }
  parseTypeTag() {
    if (this.tokens.length === 0) {
      bail("Invalid type tag.");
    }
    const [tokenTy, tokenVal] = this.tokens.shift();
    if (tokenVal === "u8") {
      return new TypeTagU8();
    }
    if (tokenVal === "u64") {
      return new TypeTagU64();
    }
    if (tokenVal === "u128") {
      return new TypeTagU128();
    }
    if (tokenVal === "bool") {
      return new TypeTagBool();
    }
    if (tokenVal === "address") {
      return new TypeTagAddress();
    }
    if (tokenVal === "vector") {
      this.consume("<");
      const res = this.parseTypeTag();
      this.consume(">");
      return new TypeTagVector(res);
    }
    if (tokenTy === "IDENT" && (tokenVal.startsWith("0x") || tokenVal.startsWith("0X"))) {
      const address = tokenVal;
      this.consume("::");
      const [moduleTokenTy, module2] = this.tokens.shift();
      if (moduleTokenTy !== "IDENT") {
        bail("Invalid type tag.");
      }
      this.consume("::");
      const [nameTokenTy, name] = this.tokens.shift();
      if (nameTokenTy !== "IDENT") {
        bail("Invalid type tag.");
      }
      let tyTags = [];
      if (this.tokens.length > 0 && this.tokens[0][1] === "<") {
        this.consume("<");
        tyTags = this.parseCommaList(">", true);
        this.consume(">");
      }
      const structTag = new StructTag(
        AccountAddress.fromHex(address),
        new Identifier(module2),
        new Identifier(name),
        tyTags
      );
      return new TypeTagStruct(structTag);
    }
    throw new Error("Invalid type tag.");
  }
};
function ensureBoolean(val) {
  assertType(val, ["boolean", "string"]);
  if (typeof val === "boolean") {
    return val;
  }
  if (val === "true") {
    return true;
  }
  if (val === "false") {
    return false;
  }
  throw new Error("Invalid boolean string.");
}
function ensureNumber(val) {
  assertType(val, ["number", "string"]);
  if (typeof val === "number") {
    return val;
  }
  const res = Number.parseInt(val, 10);
  if (Number.isNaN(res)) {
    throw new Error("Invalid number string.");
  }
  return res;
}
function ensureBigInt(val) {
  assertType(val, ["number", "bigint", "string"]);
  return BigInt(val);
}
function serializeArg(argVal, argType, serializer) {
  if (argType instanceof TypeTagBool) {
    serializer.serializeBool(ensureBoolean(argVal));
    return;
  }
  if (argType instanceof TypeTagU8) {
    serializer.serializeU8(ensureNumber(argVal));
    return;
  }
  if (argType instanceof TypeTagU64) {
    serializer.serializeU64(ensureBigInt(argVal));
    return;
  }
  if (argType instanceof TypeTagU128) {
    serializer.serializeU128(ensureBigInt(argVal));
    return;
  }
  if (argType instanceof TypeTagAddress) {
    let addr;
    if (typeof argVal === "string" || argVal instanceof HexString) {
      addr = AccountAddress.fromHex(argVal);
    } else if (argVal instanceof AccountAddress) {
      addr = argVal;
    } else {
      throw new Error("Invalid account address.");
    }
    addr.serialize(serializer);
    return;
  }
  if (argType instanceof TypeTagVector) {
    if (argType.value instanceof TypeTagU8) {
      if (argVal instanceof Uint8Array) {
        serializer.serializeBytes(argVal);
        return;
      }
      if (typeof argVal === "string") {
        serializer.serializeStr(argVal);
        return;
      }
    }
    if (!(argVal instanceof Array)) {
      throw new Error("Invalid vector args.");
    }
    serializer.serializeU32AsUleb128(argVal.length);
    argVal.forEach((arg) => serializeArg(arg, argType.value, serializer));
    return;
  }
  if (argType instanceof TypeTagStruct) {
    const { address, module_name: moduleName, name } = argType.value;
    if (`${HexString.fromUint8Array(address.address).toShortString()}::${moduleName.value}::${name.value}` !== "0x1::string::String") {
      throw new Error("The only supported struct arg is of type 0x1::string::String");
    }
    assertType(argVal, ["string"]);
    serializer.serializeStr(argVal);
    return;
  }
  throw new Error("Unsupported arg type.");
}
function argToTransactionArgument(argVal, argType) {
  if (argType instanceof TypeTagBool) {
    return new TransactionArgumentBool(ensureBoolean(argVal));
  }
  if (argType instanceof TypeTagU8) {
    return new TransactionArgumentU8(ensureNumber(argVal));
  }
  if (argType instanceof TypeTagU64) {
    return new TransactionArgumentU64(ensureBigInt(argVal));
  }
  if (argType instanceof TypeTagU128) {
    return new TransactionArgumentU128(ensureBigInt(argVal));
  }
  if (argType instanceof TypeTagAddress) {
    let addr;
    if (typeof argVal === "string" || argVal instanceof HexString) {
      addr = AccountAddress.fromHex(argVal);
    } else if (argVal instanceof AccountAddress) {
      addr = argVal;
    } else {
      throw new Error("Invalid account address.");
    }
    return new TransactionArgumentAddress(addr);
  }
  if (argType instanceof TypeTagVector && argType.value instanceof TypeTagU8) {
    if (!(argVal instanceof Uint8Array)) {
      throw new Error(`${argVal} should be an instance of Uint8Array`);
    }
    return new TransactionArgumentU8Vector(argVal);
  }
  throw new Error("Unknown type for TransactionArgument.");
}
var RAW_TRANSACTION_SALT = "APTOS::RawTransaction";
var RAW_TRANSACTION_WITH_DATA_SALT = "APTOS::RawTransactionWithData";
var TransactionBuilder = class {
  constructor(signingFunction, rawTxnBuilder) {
    this.rawTxnBuilder = rawTxnBuilder;
    this.signingFunction = signingFunction;
  }
  build(func, ty_tags, args) {
    if (!this.rawTxnBuilder) {
      throw new Error("this.rawTxnBuilder doesn't exist.");
    }
    return this.rawTxnBuilder.build(func, ty_tags, args);
  }
  static getSigningMessage(rawTxn) {
    const hash2 = import_sha34.sha3_256.create();
    if (rawTxn instanceof RawTransaction) {
      hash2.update(RAW_TRANSACTION_SALT);
    } else if (rawTxn instanceof MultiAgentRawTransaction) {
      hash2.update(RAW_TRANSACTION_WITH_DATA_SALT);
    } else {
      throw new Error("Unknown transaction type.");
    }
    const prefix = hash2.digest();
    const body = bcsToBytes(rawTxn);
    const mergedArray = new Uint8Array(prefix.length + body.length);
    mergedArray.set(prefix);
    mergedArray.set(body, prefix.length);
    return mergedArray;
  }
};
var TransactionBuilderEd25519 = class extends TransactionBuilder {
  constructor(signingFunction, publicKey, rawTxnBuilder) {
    super(signingFunction, rawTxnBuilder);
    this.publicKey = publicKey;
  }
  rawToSigned(rawTxn) {
    const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
    const signature = this.signingFunction(signingMessage);
    const authenticator = new TransactionAuthenticatorEd25519(
      new Ed25519PublicKey(this.publicKey),
      signature
    );
    return new SignedTransaction(rawTxn, authenticator);
  }
  sign(rawTxn) {
    return bcsToBytes(this.rawToSigned(rawTxn));
  }
};
var TransactionBuilderMultiEd25519 = class extends TransactionBuilder {
  constructor(signingFunction, publicKey) {
    super(signingFunction);
    this.publicKey = publicKey;
  }
  rawToSigned(rawTxn) {
    const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
    const signature = this.signingFunction(signingMessage);
    const authenticator = new TransactionAuthenticatorMultiEd25519(this.publicKey, signature);
    return new SignedTransaction(rawTxn, authenticator);
  }
  sign(rawTxn) {
    return bcsToBytes(this.rawToSigned(rawTxn));
  }
};
var TransactionBuilderABI = class {
  constructor(abis, builderConfig) {
    this.abiMap = /* @__PURE__ */ new Map();
    abis.forEach((abi) => {
      const deserializer = new Deserializer(abi);
      const scriptABI = ScriptABI.deserialize(deserializer);
      let k2;
      if (scriptABI instanceof EntryFunctionABI) {
        const funcABI = scriptABI;
        const { address: addr, name: moduleName } = funcABI.module_name;
        k2 = `${HexString.fromUint8Array(addr.address).toShortString()}::${moduleName.value}::${funcABI.name}`;
      } else {
        const funcABI = scriptABI;
        k2 = funcABI.name;
      }
      if (this.abiMap.has(k2)) {
        throw new Error("Found conflicting ABI interfaces");
      }
      this.abiMap.set(k2, scriptABI);
    });
    this.builderConfig = {
      maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
      expSecFromNow: DEFAULT_TXN_EXP_SEC_FROM_NOW,
      ...builderConfig
    };
  }
  static toBCSArgs(abiArgs, args) {
    if (abiArgs.length !== args.length) {
      throw new Error("Wrong number of args provided.");
    }
    return args.map((arg, i2) => {
      const serializer = new Serializer();
      serializeArg(arg, abiArgs[i2].type_tag, serializer);
      return serializer.getBytes();
    });
  }
  static toTransactionArguments(abiArgs, args) {
    if (abiArgs.length !== args.length) {
      throw new Error("Wrong number of args provided.");
    }
    return args.map((arg, i2) => argToTransactionArgument(arg, abiArgs[i2].type_tag));
  }
  setSequenceNumber(seqNumber) {
    this.builderConfig.sequenceNumber = BigInt(seqNumber);
  }
  buildTransactionPayload(func, ty_tags, args) {
    const typeTags = ty_tags.map((ty_arg) => new TypeTagParser(ty_arg).parseTypeTag());
    let payload;
    if (!this.abiMap.has(func)) {
      throw new Error(`Cannot find function: ${func}`);
    }
    const scriptABI = this.abiMap.get(func);
    if (scriptABI instanceof EntryFunctionABI) {
      const funcABI = scriptABI;
      const bcsArgs = TransactionBuilderABI.toBCSArgs(funcABI.args, args);
      payload = new TransactionPayloadEntryFunction(
        new EntryFunction(funcABI.module_name, new Identifier(funcABI.name), typeTags, bcsArgs)
      );
    } else if (scriptABI instanceof TransactionScriptABI) {
      const funcABI = scriptABI;
      const scriptArgs = TransactionBuilderABI.toTransactionArguments(funcABI.args, args);
      payload = new TransactionPayloadScript(new Script(funcABI.code, typeTags, scriptArgs));
    } else {
      throw new Error("Unknown ABI format.");
    }
    return payload;
  }
  build(func, ty_tags, args) {
    const { sender, sequenceNumber, gasUnitPrice, maxGasAmount, expSecFromNow, chainId } = this.builderConfig;
    if (!gasUnitPrice) {
      throw new Error("No gasUnitPrice provided.");
    }
    const senderAccount = sender instanceof AccountAddress ? sender : AccountAddress.fromHex(sender);
    const expTimestampSec = BigInt(Math.floor(Date.now() / 1e3) + Number(expSecFromNow));
    const payload = this.buildTransactionPayload(func, ty_tags, args);
    if (payload) {
      return new RawTransaction(
        senderAccount,
        BigInt(sequenceNumber),
        payload,
        BigInt(maxGasAmount),
        BigInt(gasUnitPrice),
        expTimestampSec,
        new ChainId(Number(chainId))
      );
    }
    throw new Error("Invalid ABI.");
  }
};
var TransactionBuilderRemoteABI = class {
  constructor(aptosClient, builderConfig) {
    this.aptosClient = aptosClient;
    this.builderConfig = builderConfig;
  }
  async fetchABI(addr) {
    const modules = await this.aptosClient.getAccountModules(addr);
    const abis = modules.map((module2) => module2.abi).flatMap(
      (abi) => abi.exposed_functions.filter((ef2) => ef2.is_entry).map(
        (ef2) => ({
          fullName: `${abi.address}::${abi.name}::${ef2.name}`,
          ...ef2
        })
      )
    );
    const abiMap = /* @__PURE__ */ new Map();
    abis.forEach((abi) => {
      abiMap.set(abi.fullName, abi);
    });
    return abiMap;
  }
  async build(func, ty_tags, args) {
    const normlize = (s2) => s2.replace(/^0[xX]0*/g, "0x");
    func = normlize(func);
    const funcNameParts = func.split("::");
    if (funcNameParts.length !== 3) {
      throw new Error(
        "'func' needs to be a fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coins::transfer"
      );
    }
    const [addr, module2] = func.split("::");
    const abiMap = await this.fetchABI(addr);
    if (!abiMap.has(func)) {
      throw new Error(`${func} doesn't exist.`);
    }
    const funcAbi = abiMap.get(func);
    const originalArgs = funcAbi.params.filter((param) => param !== "signer" && param !== "&signer");
    const typeArgABIs = originalArgs.map((arg, i2) => new ArgumentABI(`var${i2}`, new TypeTagParser(arg).parseTypeTag()));
    const entryFunctionABI = new EntryFunctionABI(
      funcAbi.name,
      ModuleId.fromStr(`${addr}::${module2}`),
      "",
      funcAbi.generic_type_params.map((_2, i2) => new TypeArgumentABI(`${i2}`)),
      typeArgABIs
    );
    const { sender, ...rest } = this.builderConfig;
    const senderAddress = sender instanceof AccountAddress ? HexString.fromUint8Array(sender.address) : sender;
    const [{ sequence_number: sequenceNumber }, chainId, { gas_estimate: gasUnitPrice }] = await Promise.all([
      (rest == null ? void 0 : rest.sequenceNumber) ? Promise.resolve({ sequence_number: rest == null ? void 0 : rest.sequenceNumber }) : this.aptosClient.getAccount(senderAddress),
      (rest == null ? void 0 : rest.chainId) ? Promise.resolve(rest == null ? void 0 : rest.chainId) : this.aptosClient.getChainId(),
      (rest == null ? void 0 : rest.gasUnitPrice) ? Promise.resolve({ gas_estimate: rest == null ? void 0 : rest.gasUnitPrice }) : this.aptosClient.estimateGasPrice()
    ]);
    const builderABI = new TransactionBuilderABI([bcsToBytes(entryFunctionABI)], {
      sender,
      sequenceNumber,
      chainId,
      gasUnitPrice: BigInt(gasUnitPrice),
      ...rest
    });
    return builderABI.build(func, ty_tags, args);
  }
};
__decorateClass([
  MemoizeExpiring(10 * 60 * 1e3)
], TransactionBuilderRemoteABI.prototype, "fetchABI", 1);
var _AptosClient = class {
  constructor(nodeUrl, config, doNotFixNodeUrl = false) {
    if (!nodeUrl) {
      throw new Error("Node URL cannot be empty.");
    }
    const conf = config === void 0 || config === null ? {} : { ...config };
    if (doNotFixNodeUrl) {
      this.nodeUrl = nodeUrl;
    } else {
      this.nodeUrl = fixNodeUrl(nodeUrl);
    }
    conf.BASE = this.nodeUrl;
    if ((config == null ? void 0 : config.WITH_CREDENTIALS) === false) {
      conf.WITH_CREDENTIALS = false;
    } else {
      conf.WITH_CREDENTIALS = true;
    }
    this.client = new AptosGeneratedClient(conf);
  }
  async getAccount(accountAddress) {
    return this.client.accounts.getAccount(HexString.ensure(accountAddress).hex());
  }
  async getAccountTransactions(accountAddress, query) {
    var _a2;
    return this.client.transactions.getAccountTransactions(
      HexString.ensure(accountAddress).hex(),
      (_a2 = query == null ? void 0 : query.start) == null ? void 0 : _a2.toString(),
      query == null ? void 0 : query.limit
    );
  }
  async getAccountModules(accountAddress, query) {
    var _a2;
    return this.client.accounts.getAccountModules(
      HexString.ensure(accountAddress).hex(),
      (_a2 = query == null ? void 0 : query.ledgerVersion) == null ? void 0 : _a2.toString()
    );
  }
  async getAccountModule(accountAddress, moduleName, query) {
    var _a2;
    return this.client.accounts.getAccountModule(
      HexString.ensure(accountAddress).hex(),
      moduleName,
      (_a2 = query == null ? void 0 : query.ledgerVersion) == null ? void 0 : _a2.toString()
    );
  }
  async getAccountResources(accountAddress, query) {
    var _a2;
    return this.client.accounts.getAccountResources(
      HexString.ensure(accountAddress).hex(),
      (_a2 = query == null ? void 0 : query.ledgerVersion) == null ? void 0 : _a2.toString()
    );
  }
  async getAccountResource(accountAddress, resourceType, query) {
    var _a2;
    return this.client.accounts.getAccountResource(
      HexString.ensure(accountAddress).hex(),
      resourceType,
      (_a2 = query == null ? void 0 : query.ledgerVersion) == null ? void 0 : _a2.toString()
    );
  }
  static generateBCSTransaction(accountFrom, rawTxn) {
    const txnBuilder = new TransactionBuilderEd25519((signingMessage) => {
      const sigHexStr = accountFrom.signBuffer(signingMessage);
      return new aptos_types_exports.Ed25519Signature(sigHexStr.toUint8Array());
    }, accountFrom.pubKey().toUint8Array());
    return txnBuilder.sign(rawTxn);
  }
  static generateBCSSimulation(accountFrom, rawTxn) {
    const txnBuilder = new TransactionBuilderEd25519((_signingMessage) => {
      const invalidSigBytes = new Uint8Array(64);
      return new aptos_types_exports.Ed25519Signature(invalidSigBytes);
    }, accountFrom.pubKey().toUint8Array());
    return txnBuilder.sign(rawTxn);
  }
  async generateTransaction(sender, payload, options) {
    const config = { sender };
    if (options == null ? void 0 : options.sequence_number) {
      config.sequenceNumber = options.sequence_number;
    }
    if (options == null ? void 0 : options.gas_unit_price) {
      config.gasUnitPrice = options.gas_unit_price;
    }
    if (options == null ? void 0 : options.max_gas_amount) {
      config.maxGasAmount = options.max_gas_amount;
    }
    if (options == null ? void 0 : options.expiration_timestamp_secs) {
      const timestamp = Number.parseInt(options.expiration_timestamp_secs, 10);
      config.expSecFromNow = timestamp - Math.floor(Date.now() / 1e3);
    }
    const builder = new TransactionBuilderRemoteABI(this, config);
    return builder.build(payload.function, payload.type_arguments, payload.arguments);
  }
  async signTransaction(accountFrom, rawTransaction) {
    return Promise.resolve(_AptosClient.generateBCSTransaction(accountFrom, rawTransaction));
  }
  async getEventsByCreationNumber(address, creationNumber, query) {
    var _a2;
    return this.client.events.getEventsByCreationNumber(
      HexString.ensure(address).hex(),
      creationNumber.toString(),
      (_a2 = query == null ? void 0 : query.start) == null ? void 0 : _a2.toString(),
      query == null ? void 0 : query.limit
    );
  }
  async getEventsByEventHandle(address, eventHandleStruct, fieldName, query) {
    var _a2;
    return this.client.events.getEventsByEventHandle(
      HexString.ensure(address).hex(),
      eventHandleStruct,
      fieldName,
      (_a2 = query == null ? void 0 : query.start) == null ? void 0 : _a2.toString(),
      query == null ? void 0 : query.limit
    );
  }
  async submitTransaction(signedTxn) {
    return this.submitSignedBCSTransaction(signedTxn);
  }
  async simulateTransaction(accountOrPubkey, rawTransaction, query) {
    let signedTxn;
    if (accountOrPubkey instanceof AptosAccount) {
      signedTxn = _AptosClient.generateBCSSimulation(accountOrPubkey, rawTransaction);
    } else {
      const txnBuilder = new TransactionBuilderEd25519(() => {
        const invalidSigBytes = new Uint8Array(64);
        return new aptos_types_exports.Ed25519Signature(invalidSigBytes);
      }, accountOrPubkey.toBytes());
      signedTxn = txnBuilder.sign(rawTransaction);
    }
    return this.submitBCSSimulation(signedTxn, query);
  }
  async submitSignedBCSTransaction(signedTxn) {
    return this.client.request.request({
      url: "/transactions",
      method: "POST",
      body: signedTxn,
      mediaType: "application/x.aptos.signed_transaction+bcs"
    });
  }
  async submitBCSSimulation(bcsBody, query) {
    var _a2, _b, _c;
    const queryParams = {
      estimate_gas_unit_price: (_a2 = query == null ? void 0 : query.estimateGasUnitPrice) != null ? _a2 : false,
      estimate_max_gas_amount: (_b = query == null ? void 0 : query.estimateMaxGasAmount) != null ? _b : false,
      estimate_prioritized_gas_unit_price: (_c = query == null ? void 0 : query.estimatePrioritizedGasUnitPrice) != null ? _c : false
    };
    return this.client.request.request({
      url: "/transactions/simulate",
      query: queryParams,
      method: "POST",
      body: bcsBody,
      mediaType: "application/x.aptos.signed_transaction+bcs"
    });
  }
  async getTransactions(query) {
    var _a2;
    return this.client.transactions.getTransactions((_a2 = query == null ? void 0 : query.start) == null ? void 0 : _a2.toString(), query == null ? void 0 : query.limit);
  }
  async getTransactionByHash(txnHash) {
    return this.client.transactions.getTransactionByHash(txnHash);
  }
  async getTransactionByVersion(txnVersion) {
    return this.client.transactions.getTransactionByVersion(txnVersion.toString());
  }
  async transactionPending(txnHash) {
    try {
      const response = await this.client.transactions.getTransactionByHash(txnHash);
      return response.type === "pending_transaction";
    } catch (e3) {
      if ((e3 == null ? void 0 : e3.status) === 404) {
        return true;
      }
      throw e3;
    }
  }
  async waitForTransactionWithResult(txnHash, extraArgs) {
    var _a2, _b;
    const timeoutSecs = (_a2 = extraArgs == null ? void 0 : extraArgs.timeoutSecs) != null ? _a2 : DEFAULT_TXN_TIMEOUT_SEC;
    const checkSuccess = (_b = extraArgs == null ? void 0 : extraArgs.checkSuccess) != null ? _b : false;
    let isPending = true;
    let count2 = 0;
    let lastTxn;
    while (isPending) {
      if (count2 >= timeoutSecs) {
        break;
      }
      try {
        lastTxn = await this.client.transactions.getTransactionByHash(txnHash);
        isPending = lastTxn.type === "pending_transaction";
        if (!isPending) {
          break;
        }
      } catch (e3) {
        const isApiError = e3 instanceof ApiError;
        const isRequestError = isApiError && e3.status !== 404 && e3.status >= 400 && e3.status < 500;
        if (!isApiError || isRequestError) {
          throw e3;
        }
      }
      await sleep(1e3);
      count2 += 1;
    }
    if (lastTxn === void 0) {
      throw new Error(`Waiting for transaction ${txnHash} failed`);
    }
    if (isPending) {
      throw new WaitForTransactionError(
        `Waiting for transaction ${txnHash} timed out after ${timeoutSecs} seconds`,
        lastTxn
      );
    }
    if (!checkSuccess) {
      return lastTxn;
    }
    if (!(lastTxn == null ? void 0 : lastTxn.success)) {
      throw new FailedTransactionError(
        `Transaction ${txnHash} committed to the blockchain but execution failed`,
        lastTxn
      );
    }
    return lastTxn;
  }
  async waitForTransaction(txnHash, extraArgs) {
    await this.waitForTransactionWithResult(txnHash, extraArgs);
  }
  async getLedgerInfo() {
    return this.client.general.getLedgerInfo();
  }
  async getChainId() {
    const result = await this.getLedgerInfo();
    return result.chain_id;
  }
  async getTableItem(handle, data2, query) {
    var _a2;
    const tableItem = await this.client.tables.getTableItem(handle, data2, (_a2 = query == null ? void 0 : query.ledgerVersion) == null ? void 0 : _a2.toString());
    return tableItem;
  }
  async generateRawTransaction(accountFrom, payload, extraArgs) {
    const [{ sequence_number: sequenceNumber }, chainId, { gas_estimate: gasEstimate }] = await Promise.all([
      this.getAccount(accountFrom),
      this.getChainId(),
      (extraArgs == null ? void 0 : extraArgs.gasUnitPrice) ? Promise.resolve({ gas_estimate: extraArgs.gasUnitPrice }) : this.estimateGasPrice()
    ]);
    const { maxGasAmount, gasUnitPrice, expireTimestamp } = {
      maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
      gasUnitPrice: BigInt(gasEstimate),
      expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + DEFAULT_TXN_EXP_SEC_FROM_NOW),
      ...extraArgs
    };
    return new aptos_types_exports.RawTransaction(
      aptos_types_exports.AccountAddress.fromHex(accountFrom),
      BigInt(sequenceNumber),
      payload,
      maxGasAmount,
      gasUnitPrice,
      expireTimestamp,
      new aptos_types_exports.ChainId(chainId)
    );
  }
  async generateSignSubmitTransaction(sender, payload, extraArgs) {
    const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
    const bcsTxn = _AptosClient.generateBCSTransaction(sender, rawTransaction);
    const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
    return pendingTransaction.hash;
  }
  async publishPackage(sender, packageMetadata, modules, extraArgs) {
    const codeSerializer = new Serializer();
    serializeVector(modules, codeSerializer);
    const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
      aptos_types_exports.EntryFunction.natural(
        "0x1::code",
        "publish_package_txn",
        [],
        [bcsSerializeBytes(packageMetadata), codeSerializer.getBytes()]
      )
    );
    return this.generateSignSubmitTransaction(sender, payload, extraArgs);
  }
  async generateSignSubmitWaitForTransaction(sender, payload, extraArgs) {
    const txnHash = await this.generateSignSubmitTransaction(sender, payload, extraArgs);
    return this.waitForTransactionWithResult(txnHash, extraArgs);
  }
  async estimateGasPrice() {
    return this.client.transactions.estimateGasPrice();
  }
  async estimateMaxGasAmount(forAccount) {
    const typeTag = `0x1::coin::CoinStore<${APTOS_COIN}>`;
    const [{ gas_estimate: gasUnitPrice }, resources] = await Promise.all([
      this.estimateGasPrice(),
      this.getAccountResources(forAccount)
    ]);
    const accountResource = resources.find((r2) => r2.type === typeTag);
    const balance = BigInt(accountResource.data.coin.value);
    return balance / BigInt(gasUnitPrice);
  }
  async rotateAuthKeyEd25519(forAccount, toPrivateKeyBytes, extraArgs) {
    const { sequence_number: sequenceNumber, authentication_key: authKey } = await this.getAccount(
      forAccount.address()
    );
    const helperAccount = new AptosAccount(toPrivateKeyBytes);
    const challenge = new aptos_types_exports.RotationProofChallenge(
      aptos_types_exports.AccountAddress.CORE_CODE_ADDRESS,
      "account",
      "RotationProofChallenge",
      BigInt(sequenceNumber),
      aptos_types_exports.AccountAddress.fromHex(forAccount.address()),
      new aptos_types_exports.AccountAddress(new HexString(authKey).toUint8Array()),
      helperAccount.pubKey().toUint8Array()
    );
    const challengeHex = HexString.fromUint8Array(bcsToBytes(challenge));
    const proofSignedByCurrentPrivateKey = forAccount.signHexString(challengeHex);
    const proofSignedByNewPrivateKey = helperAccount.signHexString(challengeHex);
    const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
      aptos_types_exports.EntryFunction.natural(
        "0x1::account",
        "rotate_authentication_key",
        [],
        [
          bcsSerializeU8(0),
          bcsSerializeBytes(forAccount.pubKey().toUint8Array()),
          bcsSerializeU8(0),
          bcsSerializeBytes(helperAccount.pubKey().toUint8Array()),
          bcsSerializeBytes(proofSignedByCurrentPrivateKey.toUint8Array()),
          bcsSerializeBytes(proofSignedByNewPrivateKey.toUint8Array())
        ]
      )
    );
    const rawTransaction = await this.generateRawTransaction(forAccount.address(), payload, extraArgs);
    const bcsTxn = _AptosClient.generateBCSTransaction(forAccount, rawTransaction);
    return this.submitSignedBCSTransaction(bcsTxn);
  }
  async lookupOriginalAddress(addressOrAuthKey) {
    const resource = await this.getAccountResource("0x1", "0x1::account::OriginatingAddress");
    const {
      address_map: { handle }
    } = resource.data;
    const origAddress = await this.getTableItem(handle, {
      key_type: "address",
      value_type: "address",
      key: HexString.ensure(addressOrAuthKey).hex()
    });
    return new HexString(origAddress);
  }
  async getBlockByHeight(blockHeight, withTransactions) {
    return this.client.blocks.getBlockByHeight(blockHeight, withTransactions);
  }
  async getBlockByVersion(version2, withTransactions) {
    return this.client.blocks.getBlockByVersion(version2, withTransactions);
  }
  clearCache(tags) {
    clear(tags);
  }
};
var AptosClient = _AptosClient;
__decorateClass([
  parseApiError
], AptosClient.prototype, "getAccount", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getAccountTransactions", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getAccountModules", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getAccountModule", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getAccountResources", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getAccountResource", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getEventsByCreationNumber", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getEventsByEventHandle", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "submitSignedBCSTransaction", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "submitBCSSimulation", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getTransactions", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getTransactionByHash", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getTransactionByVersion", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getLedgerInfo", 1);
__decorateClass([
  Memoize()
], AptosClient.prototype, "getChainId", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getTableItem", 1);
__decorateClass([
  parseApiError,
  Memoize({
    ttlMs: 5 * 60 * 1e3,
    tags: ["gas_estimates"]
  })
], AptosClient.prototype, "estimateGasPrice", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "estimateMaxGasAmount", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getBlockByHeight", 1);
__decorateClass([
  parseApiError
], AptosClient.prototype, "getBlockByVersion", 1);
var ApiError2 = class extends Error {
  constructor(status, message, errorCode, vmErrorCode) {
    super(message);
    this.status = status;
    this.message = message;
    this.errorCode = errorCode;
    this.vmErrorCode = vmErrorCode;
  }
};
var WaitForTransactionError = class extends Error {
  constructor(message, lastSubmittedTransaction) {
    super(message);
    this.lastSubmittedTransaction = lastSubmittedTransaction;
  }
};
var FailedTransactionError = class extends Error {
  constructor(message, transaction) {
    super(message);
    this.transaction = transaction;
  }
};
function parseApiError(target, propertyKey, descriptor) {
  const childFunction = descriptor.value;
  descriptor.value = async function wrapper(...args) {
    var _a2, _b;
    try {
      const res = await childFunction.apply(this, [...args]);
      return res;
    } catch (e3) {
      if (e3 instanceof ApiError) {
        throw new ApiError2(
          e3.status,
          JSON.stringify({ message: e3.message, ...e3.body }),
          (_a2 = e3.body) == null ? void 0 : _a2.error_code,
          (_b = e3.body) == null ? void 0 : _b.vm_error_code
        );
      }
      throw e3;
    }
  };
  return descriptor;
}
var TOKEN_ABIS = [
  "01186372656174655F636F6C6C656374696F6E5F736372697074000000000000000000000000000000000000000000000000000000000000000305746F6B656E3020637265617465206120656D70747920746F6B656E20636F6C6C656374696F6E207769746820706172616D65746572730005046E616D6507000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67000B6465736372697074696F6E07000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67000375726907000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E6700076D6178696D756D020E6D75746174655F73657474696E670600",
  "01136372656174655F746F6B656E5F736372697074000000000000000000000000000000000000000000000000000000000000000305746F6B656E1D2063726561746520746F6B656E20776974682072617720696E70757473000D0A636F6C6C656374696F6E07000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E6700046E616D6507000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67000B6465736372697074696F6E07000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67000762616C616E636502076D6178696D756D020375726907000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E670015726F79616C74795F70617965655F61646472657373041A726F79616C74795F706F696E74735F64656E6F6D696E61746F720218726F79616C74795F706F696E74735F6E756D657261746F72020E6D75746174655F73657474696E6706000D70726F70657274795F6B6579730607000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67000F70726F70657274795F76616C7565730606010E70726F70657274795F74797065730607000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E6700",
  "01166469726563745f7472616e736665725f736372697074000000000000000000000000000000000000000000000000000000000000000305746f6b656e0000051063726561746f72735f61646472657373040a636f6c6c656374696f6e07000000000000000000000000000000000000000000000000000000000000000106737472696e6706537472696e6700046e616d6507000000000000000000000000000000000000000000000000000000000000000106737472696e6706537472696e67001070726f70657274795f76657273696f6e0206616d6f756e7402",
  "010C6F666665725F73637269707400000000000000000000000000000000000000000000000000000000000000030F746F6B656E5F7472616E7366657273000006087265636569766572040763726561746F72040A636F6C6C656374696F6E07000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E6700046E616D6507000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67001070726F70657274795F76657273696F6E0206616D6F756E7402",
  "010C636C61696D5F73637269707400000000000000000000000000000000000000000000000000000000000000030F746F6B656E5F7472616E73666572730000050673656E646572040763726561746F72040A636F6C6C656374696F6E07000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E6700046E616D6507000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67001070726F70657274795F76657273696F6E02",
  "011363616E63656C5F6F666665725F73637269707400000000000000000000000000000000000000000000000000000000000000030F746F6B656E5F7472616E7366657273000005087265636569766572040763726561746F72040A636F6C6C656374696F6E07000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E6700046E616D6507000000000000000000000000000000000000000000000000000000000000000106737472696E6706537472696E67001070726F70657274795F76657273696F6E02"
];
var COIN_ABIS = [
  "01087472616E73666572000000000000000000000000000000000000000000000000000000000000000104636F696E3C205472616E73666572732060616D6F756E7460206F6620636F696E732060436F696E54797065602066726F6D206066726F6D6020746F2060746F602E0109636F696E5F747970650202746F0406616D6F756E7402"
];
var CoinClient = class {
  constructor(aptosClient) {
    this.aptosClient = aptosClient;
    this.transactionBuilder = new TransactionBuilderABI(COIN_ABIS.map((abi) => new HexString(abi).toUint8Array()));
  }
  async transfer(from, to, amount, extraArgs) {
    var _a2;
    const coinTypeToTransfer = (_a2 = extraArgs == null ? void 0 : extraArgs.coinType) != null ? _a2 : APTOS_COIN;
    const payload = this.transactionBuilder.buildTransactionPayload(
      "0x1::coin::transfer",
      [coinTypeToTransfer],
      [to.address(), amount]
    );
    return this.aptosClient.generateSignSubmitTransaction(from, payload, extraArgs);
  }
  async checkBalance(account, extraArgs) {
    var _a2;
    const coinType = (_a2 = extraArgs == null ? void 0 : extraArgs.coinType) != null ? _a2 : APTOS_COIN;
    const typeTag = `0x1::coin::CoinStore<${coinType}>`;
    const resources = await this.aptosClient.getAccountResources(account.address());
    const accountResource = resources.find((r2) => r2.type === typeTag);
    return BigInt(accountResource.data.coin.value);
  }
};
var FaucetClient = class extends AptosClient {
  constructor(nodeUrl, faucetUrl, config) {
    var _a2, _b, _c;
    super(nodeUrl, config);
    if (!faucetUrl) {
      throw new Error("Faucet URL cannot be empty.");
    }
    this.faucetRequester = new AxiosHttpRequest({
      BASE: faucetUrl,
      VERSION: (_a2 = config == null ? void 0 : config.VERSION) != null ? _a2 : "0.1.0",
      WITH_CREDENTIALS: (_b = config == null ? void 0 : config.WITH_CREDENTIALS) != null ? _b : false,
      CREDENTIALS: (_c = config == null ? void 0 : config.CREDENTIALS) != null ? _c : "include",
      TOKEN: config == null ? void 0 : config.TOKEN,
      USERNAME: config == null ? void 0 : config.USERNAME,
      PASSWORD: config == null ? void 0 : config.PASSWORD,
      HEADERS: config == null ? void 0 : config.HEADERS,
      ENCODE_PATH: config == null ? void 0 : config.ENCODE_PATH
    });
  }
  async fundAccount(address, amount, timeoutSecs = DEFAULT_TXN_TIMEOUT_SEC) {
    const tnxHashes = await this.faucetRequester.request({
      method: "POST",
      url: "/mint",
      query: {
        address: HexString.ensure(address).noPrefix(),
        amount
      }
    });
    const promises = [];
    for (let i2 = 0; i2 < tnxHashes.length; i2 += 1) {
      const tnxHash = tnxHashes[i2];
      promises.push(this.waitForTransaction(tnxHash, { timeoutSecs }));
    }
    await Promise.all(promises);
    return tnxHashes;
  }
};
var TokenClient = class {
  constructor(aptosClient) {
    this.aptosClient = aptosClient;
    this.transactionBuilder = new TransactionBuilderABI(TOKEN_ABIS.map((abi) => new HexString(abi).toUint8Array()));
  }
  async createCollection(account, name, description, uri, maxAmount = MAX_U64_BIG_INT, extraArgs) {
    const payload = this.transactionBuilder.buildTransactionPayload(
      "0x3::token::create_collection_script",
      [],
      [name, description, uri, maxAmount, [false, false, false]]
    );
    return this.aptosClient.generateSignSubmitTransaction(account, payload, extraArgs);
  }
  async createToken(account, collectionName, name, description, supply, uri, max2 = MAX_U64_BIG_INT, royalty_payee_address = account.address(), royalty_points_denominator = 0, royalty_points_numerator = 0, property_keys = [], property_values = [], property_types = [], extraArgs) {
    const payload = this.transactionBuilder.buildTransactionPayload(
      "0x3::token::create_token_script",
      [],
      [
        collectionName,
        name,
        description,
        supply,
        max2,
        uri,
        royalty_payee_address,
        royalty_points_denominator,
        royalty_points_numerator,
        [false, false, false, false, false],
        property_keys,
        property_values,
        property_types
      ]
    );
    return this.aptosClient.generateSignSubmitTransaction(account, payload, extraArgs);
  }
  async offerToken(account, receiver, creator, collectionName, name, amount, property_version = 0, extraArgs) {
    const payload = this.transactionBuilder.buildTransactionPayload(
      "0x3::token_transfers::offer_script",
      [],
      [receiver, creator, collectionName, name, property_version, amount]
    );
    return this.aptosClient.generateSignSubmitTransaction(account, payload, extraArgs);
  }
  async claimToken(account, sender, creator, collectionName, name, property_version = 0, extraArgs) {
    const payload = this.transactionBuilder.buildTransactionPayload(
      "0x3::token_transfers::claim_script",
      [],
      [sender, creator, collectionName, name, property_version]
    );
    return this.aptosClient.generateSignSubmitTransaction(account, payload, extraArgs);
  }
  async cancelTokenOffer(account, receiver, creator, collectionName, name, property_version = 0, extraArgs) {
    const payload = this.transactionBuilder.buildTransactionPayload(
      "0x3::token_transfers::cancel_offer_script",
      [],
      [receiver, creator, collectionName, name, property_version]
    );
    return this.aptosClient.generateSignSubmitTransaction(account, payload, extraArgs);
  }
  async directTransferToken(sender, receiver, creator, collectionName, name, amount, propertyVersion = 0, extraArgs) {
    const payload = this.transactionBuilder.buildTransactionPayload(
      "0x3::token::direct_transfer_script",
      [],
      [creator, collectionName, name, propertyVersion, amount]
    );
    const rawTxn = await this.aptosClient.generateRawTransaction(sender.address(), payload, extraArgs);
    const multiAgentTxn = new aptos_types_exports.MultiAgentRawTransaction(rawTxn, [
      aptos_types_exports.AccountAddress.fromHex(receiver.address())
    ]);
    const senderSignature = new aptos_types_exports.Ed25519Signature(
      sender.signBuffer(TransactionBuilder.getSigningMessage(multiAgentTxn)).toUint8Array()
    );
    const senderAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
      new aptos_types_exports.Ed25519PublicKey(sender.signingKey.publicKey),
      senderSignature
    );
    const receiverSignature = new aptos_types_exports.Ed25519Signature(
      receiver.signBuffer(TransactionBuilder.getSigningMessage(multiAgentTxn)).toUint8Array()
    );
    const receiverAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
      new aptos_types_exports.Ed25519PublicKey(receiver.signingKey.publicKey),
      receiverSignature
    );
    const multiAgentAuthenticator = new aptos_types_exports.TransactionAuthenticatorMultiAgent(
      senderAuthenticator,
      [aptos_types_exports.AccountAddress.fromHex(receiver.address())],
      [receiverAuthenticator]
    );
    const bcsTxn = bcsToBytes(new aptos_types_exports.SignedTransaction(rawTxn, multiAgentAuthenticator));
    const transactionRes = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
    return transactionRes.hash;
  }
  async getCollectionData(creator, collectionName) {
    const resources = await this.aptosClient.getAccountResources(creator);
    const accountResource = resources.find(
      (r2) => r2.type === "0x3::token::Collections"
    );
    const { handle } = accountResource.data.collection_data;
    const getCollectionTableItemRequest = {
      key_type: "0x1::string::String",
      value_type: "0x3::token::CollectionData",
      key: collectionName
    };
    const collectionTable = await this.aptosClient.getTableItem(handle, getCollectionTableItemRequest);
    return collectionTable;
  }
  async getTokenData(creator, collectionName, tokenName) {
    const creatorHex = creator instanceof HexString ? creator.hex() : creator;
    const collection = await this.aptosClient.getAccountResource(
      creatorHex,
      "0x3::token::Collections"
    );
    const { handle } = collection.data.token_data;
    const tokenDataId = {
      creator: creatorHex,
      collection: collectionName,
      name: tokenName
    };
    const getTokenTableItemRequest = {
      key_type: "0x3::token::TokenDataId",
      value_type: "0x3::token::TokenData",
      key: tokenDataId
    };
    return this.aptosClient.getTableItem(handle, getTokenTableItemRequest);
  }
  async getToken(creator, collectionName, tokenName, property_version = "0") {
    const tokenDataId = {
      creator: creator instanceof HexString ? creator.hex() : creator,
      collection: collectionName,
      name: tokenName
    };
    return this.getTokenForAccount(creator, {
      token_data_id: tokenDataId,
      property_version
    });
  }
  async getTokenForAccount(account, tokenId) {
    const tokenStore = await this.aptosClient.getAccountResource(
      account instanceof HexString ? account.hex() : account,
      "0x3::token::TokenStore"
    );
    const { handle } = tokenStore.data.tokens;
    const getTokenTableItemRequest = {
      key_type: "0x3::token::TokenId",
      value_type: "0x3::token::Token",
      key: tokenId
    };
    try {
      return await this.aptosClient.getTableItem(handle, getTokenTableItemRequest);
    } catch (error) {
      if ((error == null ? void 0 : error.status) === 404) {
        return {
          id: tokenId,
          amount: "0"
        };
      }
      return error;
    }
  }
};
var token_types_exports = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.faucetClient = exports.aptosClient = exports.FAUCET_URL = exports.NODE_URL = exports.DEVNET_FAUCET_URL = exports.LOCAL_FAUCET_URL = exports.DEVNET_NODE_URL = exports.LOCAL_NODE_URL = exports.WEBWALLET_URL = void 0;
  const aptos_1 = dist$1;
  exports.WEBWALLET_URL = "https://hippo-wallet-test.web.app";
  exports.LOCAL_NODE_URL = "http://127.0.0.1:8080";
  exports.DEVNET_NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1";
  exports.LOCAL_FAUCET_URL = "http://127.0.0.1:8081";
  exports.DEVNET_FAUCET_URL = "https://faucet.devnet.aptoslabs.com";
  exports.NODE_URL = exports.DEVNET_NODE_URL;
  exports.FAUCET_URL = exports.DEVNET_FAUCET_URL;
  exports.aptosClient = new aptos_1.AptosClient(exports.NODE_URL);
  exports.faucetClient = new aptos_1.FaucetClient(exports.NODE_URL, exports.FAUCET_URL);
})(aptosConstants);
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HippoWalletAdapter = exports.HippoWalletName = void 0;
  const aptosConstants_1 = aptosConstants;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.HippoWalletName = "Hippo Web";
  class HippoWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.HippoWalletName;
      this.url = "https://hippo-wallet-test.web.app";
      this.icon = "https://ui-test1-22e7c.web.app/static/media/hippo_logo.ecded6bf411652de9b7f.png";
      this._readyState = BaseAdapter_12.WalletReadyState.Installed;
      this.handleMessage = (e3) => {
        var _a2;
        if (e3.origin === this._provider) {
          if (e3.data.method === "account") {
            this._wallet = {
              connected: true,
              publicKey: e3.data.publicKey || null,
              address: e3.data.address || null,
              authKey: e3.data.authKey || null
            };
            this.emit("connect", this._wallet);
          } else if (e3.data.method === "success") {
            this.emit("success", (_a2 = e3.data.detail) === null || _a2 === void 0 ? void 0 : _a2.hash);
          } else if (e3.data.method === "fail") {
            this.emit("error", new errors_12.WalletSignAndSubmitMessageError(e3.data.error));
          } else if (e3.data.method === "disconnected") {
            this.disconnect();
          }
        }
      };
      this._beforeUnload = () => {
        void this.disconnect();
      };
      this._provider = aptosConstants_1.WEBWALLET_URL || "https://hippo-wallet-test.web.app";
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      this._readyState = BaseAdapter_12.WalletReadyState.Installed;
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.connected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          window.addEventListener("message", this.handleMessage);
          window.addEventListener("beforeunload", this._beforeUnload);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        window.removeEventListener("message", this.handleMessage);
        window.removeEventListener("beforeunload", this._beforeUnload);
        this._wallet = null;
        this.emit("disconnect");
      });
    }
    signTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const request2 = new URLSearchParams({
            request: JSON.stringify({
              method: "signTransaction",
              payload: transaction
            }),
            origin: window.location.origin,
            isPopUp: "true"
          }).toString();
          const popup = window.open(`${aptosConstants_1.WEBWALLET_URL}?${request2}`, "Transaction Confirmation", "scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,width=440,height=700");
          if (!popup)
            throw new errors_12.WalletNotConnectedError();
          const promise = yield new Promise((resolve2, reject) => {
            this.once("success", resolve2);
            this.once("error", reject);
          });
          return promise;
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const request2 = new URLSearchParams({
            request: JSON.stringify({
              method: "signAndSubmit",
              payload: transaction
            }),
            origin: window.location.origin
          }).toString();
          const popup = window.open(`${aptosConstants_1.WEBWALLET_URL}?${request2}`, "Transaction Confirmation", "scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,width=440,height=700");
          if (!popup)
            throw new errors_12.WalletNotConnectedError();
          const promise = yield new Promise((resolve2, reject) => {
            this.once("success", resolve2);
            this.once("error", reject);
          });
          return promise;
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const request2 = new URLSearchParams({
            request: JSON.stringify({
              method: "signMessage",
              payload: message
            }),
            origin: window.location.origin
          }).toString();
          const popup = window.open(`${aptosConstants_1.WEBWALLET_URL}?${request2}`, "Transaction Confirmation", "scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,width=440,height=700");
          if (!popup)
            throw new errors_12.WalletNotConnectedError();
          const promise = yield new Promise((resolve2, reject) => {
            this.once("success", resolve2);
            this.once("error", reject);
          });
          return promise;
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
      });
    }
  }
  exports.HippoWalletAdapter = HippoWalletAdapter;
})(HippoWallet);
var MartianWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MartianWalletAdapter = exports.MartianWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.MartianWalletName = "Martian";
  class MartianWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.MartianWalletName;
      this.url = "https://chrome.google.com/webstore/detail/martian-wallet/efbglgofoippbgcjepnhiblaibcnclgk";
      this.icon = "https://raw.githubusercontent.com/hippospace/aptos-wallet-adapter/main/logos/martian.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.martian : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.martian) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.martian;
          const isConnected = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          if (isConnected) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if (!response) {
            throw new errors_12.WalletNotConnectedError("No connect response");
          }
          const walletAccount = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.account();
          if (walletAccount) {
            this._wallet = Object.assign(Object.assign({}, walletAccount), { isConnected: true });
            try {
              const name = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
              const { chainId } = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.getChainId();
              const api = null;
              this._network = name;
              this._chainId = chainId.toString();
              this._api = api;
            } catch (error) {
              const errMsg = error.message;
              this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
              throw error;
            }
          }
          this.emit("connect", ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.address) || "");
        } catch (error) {
          this.emit("error", new Error(error));
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || window.martian;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.martian;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const tx = yield provider2.generateTransaction(wallet.address || "", transactionPyld, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(tx);
          if (!response) {
            throw new Error("No response");
          }
          return response;
        } catch (error) {
          this.emit("error", new errors_12.WalletSignTransactionError(error));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.martian;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const tx = yield provider2.generateTransaction(wallet.address || "", transactionPyld, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(tx);
          if (!response) {
            throw new Error("No response");
          }
          return { hash: response };
        } catch (error) {
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(error));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.martian;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.martian;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleChangeAccount = (newAccount) => __awaiter2(this, void 0, void 0, function* () {
            const { publicKey } = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.account();
            this._wallet = Object.assign(Object.assign({}, this._wallet), { address: newAccount, publicKey });
            this.emit("accountChange", newAccount);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onAccountChange(handleChangeAccount);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.martian;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleNetworkChange = (newNetwork) => __awaiter2(this, void 0, void 0, function* () {
            this._network = newNetwork;
            this.emit("networkChange", this._network);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onNetworkChange(handleNetworkChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.MartianWalletAdapter = MartianWalletAdapter;
})(MartianWallet);
var FewchaWallet = {};
var dist = {};
var utils$2 = {};
var bigInt = {};
Object.defineProperty(bigInt, "__esModule", { value: true });
bigInt.toDecimal = bigInt.toHuman = void 0;
const toHuman = (input, decimal, fractionDigit = 3, delimiter = ",") => {
  if (input.length < decimal) {
    if (input.length + fractionDigit < decimal) {
      return "0";
    } else {
      return `0${delimiter}${input.slice(0, Math.min(fractionDigit, decimal))}`;
    }
  } else {
    const fractionPositon = input.length - decimal;
    const decimalNumber = `${input.slice(fractionPositon, Math.min(fractionDigit, decimal))}`;
    if (decimalNumber !== "") {
      return `${input.slice(0, fractionPositon)}${delimiter}${decimalNumber}`;
    } else {
      return `${input.slice(0, fractionPositon)}`;
    }
  }
};
bigInt.toHuman = toHuman;
const toDecimal = (input, decimal, delimiter = ".") => {
  var splitInput = input.split(delimiter);
  if (splitInput.length !== 2) {
    throw new Error("Invalid number");
  }
  const integral = splitInput[0] === "0" ? "" : splitInput[0];
  const _decimal = splitInput[1].length <= decimal ? `${splitInput[1]}${"0".repeat(decimal - splitInput[1].length)}` : `${splitInput[1].slice(0, decimal)}`;
  return integral + _decimal;
};
bigInt.toDecimal = toDecimal;
var isUrl$1 = {};
Object.defineProperty(isUrl$1, "__esModule", { value: true });
isUrl$1.isUrl = void 0;
const isUrl = (url) => {
  const pattern = new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
  return !!pattern.test(url);
};
isUrl$1.isUrl = isUrl;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(bigInt, exports);
  __exportStar(isUrl$1, exports);
})(utils$2);
var provider = {};
Object.defineProperty(provider, "__esModule", { value: true });
class Web3Provider {
  constructor(provider2) {
    __publicField(this, "provider");
    this.provider = provider2;
    return this;
  }
}
provider.default = Web3Provider;
var martina_mask = {};
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
types.createReponse = void 0;
const createReponse = (method, status, data2) => {
  return {
    method,
    status,
    data: data2
  };
};
types.createReponse = createReponse;
Object.defineProperty(martina_mask, "__esModule", { value: true });
martina_mask.MartianMask = void 0;
const types_1 = types;
class MartianMask {
  constructor(provider2) {
    __publicField(this, "provider");
    this.provider = provider2;
  }
  async generateTransaction(payload, options) {
    const response = await this.provider.connect();
    const sender = response.address;
    const res = await this.provider.generateTransaction(sender, payload);
    return (0, types_1.createReponse)("generateTransaction", 200, res);
  }
  async signTransaction(txnRequest) {
    const res = await this.provider.signTransaction(txnRequest);
    return (0, types_1.createReponse)("signTransaction", 200, res);
  }
  async submitTransaction(signedTxnRequest) {
    const res = await this.provider.submitTransaction(signedTxnRequest);
    return (0, types_1.createReponse)("submitTransaction", 200, res);
  }
  async signAndSubmitTransaction(txnRequest) {
    const res = await this.provider.signAndSubmitTransaction(txnRequest);
    return (0, types_1.createReponse)("signAndSubmit", 200, res);
  }
  async signMessage(message) {
    const res = await this.provider.signMessage(message);
    return (0, types_1.createReponse)("signMessage", 200, res);
  }
  async createCollection(name, description, uri, maxAmount) {
    const res = await this.provider.createCollection(name, description, uri, maxAmount);
    return (0, types_1.createReponse)("createCollection", 200, res);
  }
  async createToken(collectionName, name, description, supply, uri, max2, royalty_payee_address, royalty_points_denominator, royalty_points_numerator, property_keys, property_values, property_types) {
    const res = await this.provider.createToken(collectionName, name, description, supply, uri, max2, royalty_payee_address, royalty_points_denominator, royalty_points_numerator, property_keys, property_values, property_types);
    return (0, types_1.createReponse)("createToken", 200, res);
  }
  async getTransactions(query) {
    let res = null;
    if (query) {
      res = await this.provider.getTransactions(query);
    } else {
      res = await this.provider.provider.getTransactions();
    }
    return (0, types_1.createReponse)("getTransactions", 200, res);
  }
  async getTransactionByHash(txnHash) {
    const res = await this.provider.getTransaction(txnHash);
    return (0, types_1.createReponse)("getTransactionByHash", 200, res);
  }
  async getAccountTransactions(accountAddress, query) {
    const res = await this.provider.getAccountTransactions(accountAddress);
    return (0, types_1.createReponse)("getAccountTransactions", 200, res);
  }
  async getAccountResources(accountAddress, query) {
    const res = await this.provider.getAccountResources(accountAddress);
    return (0, types_1.createReponse)("getAccountResources", 200, res);
  }
  async getAccount(accountAddress) {
    const res = await this.provider.getAccount(accountAddress);
    return (0, types_1.createReponse)("getAccount", 200, res);
  }
  async getChainId() {
    const res = await this.provider.getChainId();
    return (0, types_1.createReponse)("getChainId", 200, res);
  }
  async getLedgerInfo() {
    const res = await this.provider.getLedgerInfo();
    return (0, types_1.createReponse)("getLedgerInfo", 200, res);
  }
}
martina_mask.MartianMask = MartianMask;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist, "__esModule", { value: true });
dist.Web3Provider = dist.utils = dist.Aptos = void 0;
const Aptos = __importStar(dist$1);
dist.Aptos = Aptos;
const utils$1 = __importStar(utils$2);
dist.utils = utils$1;
const provider_1 = __importDefault(provider);
dist.Web3Provider = provider_1.default;
const martina_mask_1 = martina_mask;
class Web3 {
  constructor(provider2) {
    __publicField(this, "action");
    if (provider2) {
      if (provider2.isFewcha) {
        this.action = new provider_1.default(provider2).provider;
      } else {
        this.action = new martina_mask_1.MartianMask(provider2);
      }
    } else {
      this.action = new provider_1.default(window.fewcha).provider;
      window.addEventListener("fewcha#initialized", () => {
        this.action = new provider_1.default(window.fewcha).provider;
      });
      window.addEventListener("martian#initialized", () => {
        this.action = new provider_1.default(window.martian).provider;
      });
    }
    return this;
  }
  setProvider(provider2) {
    this.action = provider2.provider;
    return this;
  }
}
dist.default = Web3;
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FewchaWalletAdapter = exports.FewchaWalletName = void 0;
  const errors_12 = errors;
  const web3_1 = __importDefault2(dist);
  const BaseAdapter_12 = BaseAdapter;
  exports.FewchaWalletName = "Fewcha";
  class FewchaWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.FewchaWalletName;
      this.url = "https://fewcha.app/";
      this.icon = "https://miro.medium.com/fit/c/176/176/1*a0WaY-q7gjCRiuryRG6TkQ.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._network = void 0;
      this._provider = typeof window !== "undefined" ? new web3_1.default().action : void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.fewcha) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.connected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.fewcha;
          const isConnected = yield provider2.isConnected();
          if ((isConnected === null || isConnected === void 0 ? void 0 : isConnected.data) === true) {
            yield provider2.disconnect();
          }
          const response = yield provider2.connect();
          if (response.status === 401) {
            throw new errors_12.WalletConnectionError("User has rejected the connection");
          } else if (response.status !== 200) {
            throw new errors_12.WalletConnectionError("Wallet connect issue");
          }
          let accountDetail = Object.assign({}, response.data);
          if (!accountDetail.publicKey) {
            const accountResp = yield provider2.account();
            if (!accountResp.data.publicKey) {
              throw new errors_12.WalletConnectionError("Wallet connect issue", response.data);
            }
            accountDetail = Object.assign({}, accountResp.data);
          }
          this._wallet = Object.assign({ connected: true }, accountDetail);
          try {
            const { data: name } = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.getNetwork();
            const chainId = null;
            const api = null;
            this._network = name;
            this._chainId = chainId;
            this._api = api;
          } catch (error) {
            const errMsg = error.message;
            this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
            throw error;
          }
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const provider2 = this._provider || window.fewcha;
        if (provider2) {
          try {
            const isDisconnected = yield provider2.disconnect();
            if (isDisconnected.data === true) {
              this._provider = void 0;
              this._wallet = null;
            } else {
              throw new Error("Disconnect failed");
            }
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
            throw error;
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          const provider2 = this._provider || window.fewcha;
          const tx = yield provider2.generateTransaction(transaction, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(tx.data);
          if (!response || response.status !== 200) {
            throw new Error("No response");
          }
          return response.data;
        } catch (error) {
          const errMsg = error instanceof Error ? error.message : error.response.data.message;
          this.emit("error", new errors_12.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          const provider2 = this._provider || window.fewcha;
          const tx = yield provider2.generateTransaction(transaction, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(tx.data);
          if (response.status === 401) {
            throw new Error("User has rejected the transaction");
          } else if (response.status !== 200) {
            throw new Error("Transaction issue");
          }
          return {
            hash: response.data
          };
        } catch (error) {
          const errMsg = error instanceof Error ? error.message : error.response.data.message;
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(errMsg));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fewcha;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response.data;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fewcha;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fewcha;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.FewchaWalletAdapter = FewchaWalletAdapter;
})(FewchaWallet);
var PontemWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PontemWalletAdapter = exports.PontemWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.PontemWalletName = "Pontem";
  class PontemWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.PontemWalletName;
      this.url = "https://chrome.google.com/webstore/detail/pontem-wallet/phkbamefinggmakgklpkljjmgibohnba";
      this.icon = "https://www.gitbook.com/cdn-cgi/image/width=20,height=20,fit=contain,dpr=2,format=auto/https%3A%2F%2F736486047-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-MVVJKmKQGx983dZy_jr%252Favatar-1619180126965.png%3Fgeneration%3D1619180127194239%26alt%3Dmedia";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.pontem : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.pontem) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.pontem;
          const isConnected = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          if (isConnected) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if (!response) {
            throw new errors_12.WalletNotConnectedError("No connect response");
          }
          const walletAccount = response.address;
          const publicKey = response.publicKey;
          if (walletAccount) {
            this._wallet = {
              address: walletAccount,
              publicKey,
              isConnected: true
            };
            try {
              const networkInfo = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
              this._network = networkInfo.name;
              this._chainId = networkInfo.chainId;
              this._api = networkInfo.api;
            } catch (error) {
              const errMsg = error.message;
              this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
              throw error;
            }
          }
          this.emit("connect", ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.address) || "");
        } catch (error) {
          this.emit("error", new Error("User has rejected the connection"));
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || window.pontem;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.pontem;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(transactionPyld, options);
          return response;
        } catch (error) {
          this.emit("error", new errors_12.WalletSignTransactionError(error));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.pontem;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmit(transactionPyld, options);
          if (!response || !response.success) {
            throw new Error("No response");
          }
          return { hash: response.result.hash };
        } catch (error) {
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(error.message));
          throw error;
        }
      });
    }
    signMessage(messagePayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.pontem;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(messagePayload);
          if (response.success) {
            return response.result;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.pontem;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleAccountChange = (newAccount) => __awaiter2(this, void 0, void 0, function* () {
            if (newAccount === void 0) {
              if (this.connected) {
                yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
              }
              return;
            }
            const newPublicKey = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.publicKey();
            this._wallet = Object.assign(Object.assign({}, this._wallet), { address: newAccount, publicKey: newPublicKey });
            this.emit("accountChange", newAccount);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onAccountChange(handleAccountChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.pontem;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleNetworkChange = (network) => {
            this._network = network.name;
            this._api = network.api;
            this._chainId = network.chainId;
            this.emit("networkChange", this._network);
          };
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onNetworkChange(handleNetworkChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.PontemWalletAdapter = PontemWalletAdapter;
})(PontemWallet);
var NightlyWallet = {};
var sha3 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module2) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root2 = WINDOW ? window : {};
    if (root2.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root2 = commonjsGlobal;
    } else if (WEB_WORKER) {
      root2 = self;
    }
    var COMMON_JS = !root2.JS_SHA3_NO_COMMON_JS && true && module2.exports;
    var ARRAY_BUFFER = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding, outputType) {
      return function(message) {
        return new Keccak2(bits2, padding, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding, outputType) {
      return function(message, outputBits) {
        return new Keccak2(bits2, padding, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding, outputType) {
      return function(message, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding, outputType) {
      return function(key, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding) {
      for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
        var type = OUTPUT_TYPES[i3];
        method[type] = createMethod2(bits2, padding, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding) {
      var method = createOutputMethod(bits2, padding, "hex");
      method.create = function() {
        return new Keccak2(bits2, padding, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding);
    };
    var createShakeMethod = function(bits2, padding) {
      var method = createShakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits) {
        return new Keccak2(bits2, padding, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
    };
    var createCshakeMethod = function(bits2, padding) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits, n2, s2) {
        if (!n2 && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak2(bits2, padding, outputBits).bytepad([n2, s2], w2);
        }
      };
      method.update = function(message, outputBits, n2, s2) {
        return method.create(outputBits, n2, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
    };
    var createKmacMethod = function(bits2, padding) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding, "hex");
      method.create = function(key, outputBits, s2) {
        return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s2], w2).bytepad([key], w2);
      };
      method.update = function(key, message, outputBits, s2) {
        return method.create(key, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i2 = 0; i2 < algorithms.length; ++i2) {
      var algorithm = algorithms[i2];
      var bits = algorithm.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak2(bits2, padding, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i3 = 0; i3 < 50; ++i3) {
        this.s[i3] = 0;
      }
    }
    Keccak2.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i3, code;
      while (index2 < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        if (notString) {
          for (i3 = this.start; index2 < length && i3 < byteCount; ++index2) {
            blocks[i3 >> 2] |= message[index2] << SHIFT[i3++ & 3];
          }
        } else {
          for (i3 = this.start; index2 < length && i3 < byteCount; ++index2) {
            code = message.charCodeAt(index2);
            if (code < 128) {
              blocks[i3 >> 2] |= code << SHIFT[i3++ & 3];
            } else if (code < 2048) {
              blocks[i3 >> 2] |= (192 | code >> 6) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks[i3 >> 2] |= (224 | code >> 12) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i3 >> 2] |= (240 | code >> 18) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
            }
          }
        }
        this.lastByteIndex = i3;
        if (i3 >= byteCount) {
          this.start = i3 - byteCount;
          this.block = blocks[blockCount];
          for (i3 = 0; i3 < blockCount; ++i3) {
            s2[i3] ^= blocks[i3];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i3;
        }
      }
      return this;
    };
    Keccak2.prototype.encode = function(x2, right) {
      var o2 = x2 & 255, n2 = 1;
      var bytes2 = [o2];
      x2 = x2 >> 8;
      o2 = x2 & 255;
      while (o2 > 0) {
        bytes2.unshift(o2);
        x2 = x2 >> 8;
        o2 = x2 & 255;
        ++n2;
      }
      if (right) {
        bytes2.push(n2);
      } else {
        bytes2.unshift(n2);
      }
      this.update(bytes2);
      return bytes2.length;
    };
    Keccak2.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes2 = 0, length = str.length;
      if (notString) {
        bytes2 = length;
      } else {
        for (var i3 = 0; i3 < str.length; ++i3) {
          var code = str.charCodeAt(i3);
          if (code < 128) {
            bytes2 += 1;
          } else if (code < 2048) {
            bytes2 += 2;
          } else if (code < 55296 || code >= 57344) {
            bytes2 += 3;
          } else {
            code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i3) & 1023);
            bytes2 += 4;
          }
        }
      }
      bytes2 += this.encode(bytes2 * 8);
      this.update(str);
      return bytes2;
    };
    Keccak2.prototype.bytepad = function(strs, w2) {
      var bytes2 = this.encode(w2);
      for (var i3 = 0; i3 < strs.length; ++i3) {
        bytes2 += this.encodeString(strs[i3]);
      }
      var paddingBytes = w2 - bytes2 % w2;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak2.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i3 >> 2] |= this.padding[i3 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i3 = 1; i3 < blockCount + 1; ++i3) {
          blocks[i3] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i3 = 0; i3 < blockCount; ++i3) {
        s2[i3] ^= blocks[i3];
      }
      f2(s2);
    };
    Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var hex2 = "", block2;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          block2 = s2[i3];
          hex2 += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15] + HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15] + HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15] + HEX_CHARS[block2 >> 28 & 15] + HEX_CHARS[block2 >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
          i3 = 0;
        }
      }
      if (extraBytes) {
        block2 = s2[i3];
        hex2 += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15];
        if (extraBytes > 1) {
          hex2 += HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex2 += HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15];
        }
      }
      return hex2;
    };
    Keccak2.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var bytes2 = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes2);
      }
      var array = new Uint32Array(buffer);
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          array[j3] = s2[i3];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array[i3] = s2[i3];
        buffer = buffer.slice(0, bytes2);
      }
      return buffer;
    };
    Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
    Keccak2.prototype.digest = Keccak2.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var array = [], offset2, block2;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          offset2 = j3 << 2;
          block2 = s2[i3];
          array[offset2] = block2 & 255;
          array[offset2 + 1] = block2 >> 8 & 255;
          array[offset2 + 2] = block2 >> 16 & 255;
          array[offset2 + 3] = block2 >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset2 = j3 << 2;
        block2 = s2[i3];
        array[offset2] = block2 & 255;
        if (extraBytes > 1) {
          array[offset2 + 1] = block2 >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset2 + 2] = block2 >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding, outputBits) {
      Keccak2.call(this, bits2, padding, outputBits);
    }
    Kmac.prototype = new Keccak2();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak2.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS) {
      module2.exports = methods;
    } else {
      for (i2 = 0; i2 < methodNames.length; ++i2) {
        root2[methodNames[i2]] = methods[methodNames[i2]];
      }
    }
  })();
})(sha3);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NightlyWalletAdapter = exports.NightlyWalletName = exports.AptosPublicKey = exports.NightlyWallet = void 0;
  const NightlyWallet2 = () => {
  };
  exports.NightlyWallet = NightlyWallet2;
  const SHA3 = __importStar2(sha3.exports);
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  class AptosPublicKey {
    constructor(hexString) {
      if (hexString.startsWith("0x")) {
        this.hexString = hexString;
      } else {
        this.hexString = `0x${hexString}`;
      }
    }
    static default() {
      return new AptosPublicKey("0".repeat(64));
    }
    address() {
      const hash2 = SHA3.sha3_256.create();
      hash2.update(Buffer.from(this.asPureHex(), "hex"));
      hash2.update("\0");
      return "0x" + hash2.hex();
    }
    asUint8Array() {
      return new Uint8Array(Buffer.from(this.asPureHex(), "hex"));
    }
    asString() {
      return this.hexString;
    }
    asPureHex() {
      return this.hexString.substr(2);
    }
  }
  exports.AptosPublicKey = AptosPublicKey;
  exports.NightlyWalletName = "Nightly";
  class NightlyWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      var _a2;
      super();
      this.name = exports.NightlyWalletName;
      this.url = "https://chrome.google.com/webstore/detail/nightly/fiikommddbeccaoicoejoniammnalkfa/related?hl=en&authuser=0";
      this.icon = "https://lh3.googleusercontent.com/_feXM9qulMM5w9BYMLzMpZrxW2WlBmdyg3SbETIoRsHdAD9PANnLCEPabC7lzEK0N8fOyyvFkY3746jk8l73zUErxhU=w128-h128-e365-rj-sc0x00ffffff";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = (_a2 = window.nightly) === null || _a2 === void 0 ? void 0 : _a2.aptos;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          var _a3;
          if ((_a3 = window.nightly) === null || _a3 === void 0 ? void 0 : _a3.aptos) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || ((_a2 = window.nightly) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          const publicKey = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect(() => {
            this._wallet = null;
            this.emit("disconnect");
          });
          this._wallet = {
            publicKey: publicKey === null || publicKey === void 0 ? void 0 : publicKey.asString(),
            address: publicKey === null || publicKey === void 0 ? void 0 : publicKey.address(),
            isConnected: true
          };
          this.emit("connect", this._wallet.publicKey || "");
          const networkData = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
          this._chainId = networkData === null || networkData === void 0 ? void 0 : networkData.chainId.toString();
          this._api = networkData === null || networkData === void 0 ? void 0 : networkData.api;
          this._network = networkData === null || networkData === void 0 ? void 0 : networkData.network.toLocaleLowerCase();
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        if (wallet) {
          this._wallet = null;
          try {
            const provider2 = this._provider || ((_a2 = window.nightly) === null || _a2 === void 0 ? void 0 : _a2.aptos);
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(payload) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          try {
            const provider2 = this._provider || ((_a2 = window.nightly) === null || _a2 === void 0 ? void 0 : _a2.aptos);
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(payload, false);
            if (response) {
              return response;
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signAllTransaction(payload) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          try {
            const provider2 = this._provider || ((_a2 = window.nightly) === null || _a2 === void 0 ? void 0 : _a2.aptos);
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAllTransactions(payload);
            if (response) {
              return response;
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signAndSubmitTransaction(tx) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          try {
            const provider2 = this._provider || ((_a2 = window.nightly) === null || _a2 === void 0 ? void 0 : _a2.aptos);
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(tx, true);
            if (response) {
              return response;
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            const errMsg = error instanceof Error ? error.message : error.response.data.message;
            throw new errors_12.WalletSignTransactionError(errMsg);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.nightly.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(message);
          if (response) {
            return Buffer.from(response).toString("hex");
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.nightly.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.nightly.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.NightlyWalletAdapter = NightlyWalletAdapter;
})(NightlyWallet);
var RiseWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RiseWalletAdapter = exports.RiseWalletName = void 0;
  const WalletProviders_1 = WalletProviders;
  const BaseAdapter_12 = BaseAdapter;
  exports.RiseWalletName = "Rise Wallet";
  class RiseWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.RiseWalletName;
      this.url = "https://risewallet.io";
      this.icon = "https://static.risewallet.io/logo.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.rise : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.rise) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new WalletProviders_1.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.rise;
          const isConnected = yield (_a2 = this._provider) === null || _a2 === void 0 ? void 0 : _a2.isConnected();
          if (isConnected === true) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if (!response) {
            throw new WalletProviders_1.WalletNotConnectedError("User has rejected the request");
          }
          if (provider2 === null || provider2 === void 0 ? void 0 : provider2.network) {
            try {
              const { chainId, api, name } = yield provider2.network();
              this._network = name;
              this._chainId = chainId;
              this._api = api;
            } catch (error) {
              const errMsg = error.message;
              this.emit("error", new WalletProviders_1.WalletGetNetworkError(errMsg));
              throw error;
            }
          }
          const account = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.account();
          if (account) {
            const { publicKey, address, authKey } = account;
            this._wallet = {
              publicKey,
              address,
              authKey,
              isConnected: true
            };
            this.emit("connect", this._wallet.publicKey);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        if (wallet) {
          this._wallet = null;
          try {
            const provider2 = this._provider || window.rise;
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new WalletProviders_1.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.rise;
          if (!wallet || !provider2)
            throw new WalletProviders_1.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(transaction);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Transaction failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new WalletProviders_1.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.rise;
          if (!wallet || !provider2)
            throw new WalletProviders_1.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(transaction);
          if (response) {
            return response;
          } else {
            throw new Error("Transaction failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new WalletProviders_1.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.rise;
          if (!wallet || !provider2)
            throw new WalletProviders_1.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new WalletProviders_1.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new WalletProviders_1.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.rise;
          if (!wallet || !provider2)
            throw new WalletProviders_1.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new WalletProviders_1.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.rise;
          if (!wallet || !provider2)
            throw new WalletProviders_1.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new WalletProviders_1.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.RiseWalletAdapter = RiseWalletAdapter;
})(RiseWallet);
var SpikaWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpikaWalletAdapter = exports.SpikaWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.SpikaWalletName = "Spika";
  class SpikaWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.SpikaWalletName;
      this.url = "https://chrome.google.com/webstore/detail/spika/fadkojdgchhfkdkklllhcphknohbmjmb";
      this.icon = "https://spika.app/assets/logo_400_nb.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.spika : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.spika) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting) {
            return;
          }
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.spika;
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if ((response === null || response === void 0 ? void 0 : response.publicKey) !== void 0) {
            this._wallet = {
              publicKey: response === null || response === void 0 ? void 0 : response.publicKey,
              address: response === null || response === void 0 ? void 0 : response.account,
              authKey: response === null || response === void 0 ? void 0 : response.authKey,
              isConnected: true
            };
          } else {
            this._wallet = {
              isConnected: false
            };
          }
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        if (wallet) {
          this._wallet = null;
          try {
            const provider2 = this._provider || window.spika;
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.spika;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(transaction, options);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Transaction failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.spika;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(transaction, options);
          if (response) {
            return response;
          } else {
            throw new Error("Transaction failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(errMsg));
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.spika;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(message);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.spika;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.spika;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.SpikaWalletAdapter = SpikaWalletAdapter;
})(SpikaWallet);
var HyperPayWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HyperPayWalletAdapter = exports.HyperPayWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.HyperPayWalletName = "HyperPay";
  class HyperPayWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.HyperPayWalletName;
      this.url = "https://www.hyperpay.tech/";
      this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMjE1IDEyMTUiPjxwYXRoIGQ9Ik02MDcuNSAwQzk0My4wMTMgMCAxMjE1IDI3MS45ODcgMTIxNSA2MDcuNVM5NDMuMDEzIDEyMTUgNjA3LjUgMTIxNSAwIDk0My4wMTMgMCA2MDcuNSAyNzEuOTg3IDAgNjA3LjUgMHpNMzUxLjY4IDM3MS4zMTVzMy43MDgtNzIuOSA3Ny43Ni03Mi45aDIwNC4xMnMxMTkuNDM3LS4xIDIwNC4xMiA3NS4zM2MwIDAgMTExLjg0MyA5My42MTIgMTE2LjY0IDIzNS43MSAwIDAgMS45NjIgMTE5LjA0NS03Mi45IDIxMS40MSAwIDAtNzcuOTMxIDEyMS41LTI2Mi40NCAxMjEuNUg0NDEuNTlzLTg5LjkxIDExLjA0OS04OS45MS04NS4wNXYtNDg2ek0xMTkuMzQ0IDU1My42NTlzLjkwNi0xNy44MiAxOS4wMDgtMTcuODJoNDkuOXMyOS4yLS4wMjMgNDkuOSAxOC40MTRjMCAwIDI3LjMzOSAyMi44ODMgMjguNTEyIDU3LjYxOCAwIDAgLjQ4IDI5LjEtMTcuODIgNTEuNjc4IDAgMC0xOS4wNSAyOS43LTY0LjE1MiAyOS43aC00My4zN3MtMjEuOTc4IDIuNy0yMS45NzgtMjAuNzl2LTExOC44eiIgZmlsbD0iIzE1N0VGQiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.hyperpay : void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.hyperpay) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.hyperpay;
          const isConnected = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          if (isConnected) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if (!response) {
            throw new errors_12.WalletNotConnectedError("No connect response");
          }
          const walletAccount = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.account();
          if (walletAccount) {
            this._wallet = Object.assign(Object.assign({}, walletAccount), { isConnected: true });
          }
          this.emit("connect", ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.address) || "");
        } catch (error) {
          this.emit("error", new Error(error));
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || window.hyperpay;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hyperpay;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const tx = yield provider2.generateTransaction(wallet.address || "", transactionPyld, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(tx);
          if (!response) {
            throw new Error("No response");
          }
          return response;
        } catch (error) {
          this.emit("error", new errors_12.WalletSignTransactionError(error));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hyperpay;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const tx = yield provider2.generateTransaction(wallet.address || "", transactionPyld, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(tx);
          if (!response) {
            throw new Error("No response");
          }
          return { hash: response };
        } catch (error) {
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(error));
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hyperpay;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(message);
          if (response === null || response === void 0 ? void 0 : response.signature) {
            return response === null || response === void 0 ? void 0 : response.signature;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hyperpay;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.hyperpay;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.HyperPayWalletAdapter = HyperPayWalletAdapter;
})(HyperPayWallet);
var FletchWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FletchWalletAdapter = exports.FletchWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.FletchWalletName = "Fletch";
  class FletchWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.FletchWalletName;
      this.url = "http://fletchwallet.io";
      this.icon = "http://fletchwallet.io/img/fletch-white.svg";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.fletch : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.fletch) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.fletch;
          const isConnected = yield (_a2 = this._provider) === null || _a2 === void 0 ? void 0 : _a2.isConnected();
          if (isConnected === true) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if (response.code != 200) {
            throw response.error;
          }
          this._wallet = {
            address: response === null || response === void 0 ? void 0 : response.Address,
            publicKey: response === null || response === void 0 ? void 0 : response.PublicKey,
            isConnected: true
          };
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || window.fletch;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fletch;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signTransaction(transaction);
          if (response.code != 200) {
            throw response.error;
          }
          return response.tx;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fletch;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signAndSubmitTransaction(transaction);
          if (response.code == 200) {
            return { hash: response.hash };
          }
          throw response.error;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(errMsg));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fletch;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response.code == 200) {
            return response.signedMessage;
          }
          throw response.error;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fletch;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.fletch;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.FletchWalletAdapter = FletchWalletAdapter;
})(FletchWallet);
var AptosSnap = {};
var build = {};
var utils = {};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(utils, "__esModule", { value: true });
utils.getConfigurationByNetwork = utils.isSnapInstalled = utils.isMetamaskSnapsSupported = utils.hasMetaMask = void 0;
function hasMetaMask() {
  if (!window.ethereum) {
    return false;
  }
  return window.ethereum.isMetaMask;
}
utils.hasMetaMask = hasMetaMask;
function getWalletSnaps() {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, window.ethereum.request({
            method: "wallet_getSnaps"
          })];
        case 1:
          return [2, _a2.sent()];
      }
    });
  });
}
function isMetamaskSnapsSupported() {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          _a2.trys.push([0, 2, , 3]);
          return [4, getWalletSnaps()];
        case 1:
          _a2.sent();
          return [2, true];
        case 2:
          _a2.sent();
          return [2, false];
        case 3:
          return [2];
      }
    });
  });
}
utils.isMetamaskSnapsSupported = isMetamaskSnapsSupported;
function isSnapInstalled(snapOrigin, version2) {
  return __awaiter(this, void 0, void 0, function() {
    var _a2, _b, _c, _d, e_2;
    return __generator(this, function(_e2) {
      switch (_e2.label) {
        case 0:
          _b = (_a2 = console).log;
          return [4, getWalletSnaps()];
        case 1:
          _b.apply(_a2, [_e2.sent()]);
          _e2.label = 2;
        case 2:
          _e2.trys.push([2, 4, , 5]);
          _d = (_c = Object).values;
          return [4, getWalletSnaps()];
        case 3:
          return [2, !!_d.apply(_c, [_e2.sent()]).find(function(permission) {
            return permission.id === snapOrigin && (!version2 || permission.version === version2);
          })];
        case 4:
          e_2 = _e2.sent();
          console.log("Failed to obtain installed snaps", e_2);
          return [2, false];
        case 5:
          return [2];
      }
    });
  });
}
utils.isSnapInstalled = isSnapInstalled;
function getConfigurationByNetwork(network) {
  return {
    mainnet: {
      rpc: {
        node: "https://fullnode.devnet.aptoslabs.com",
        faucet: "https://faucet.devnet.aptoslabs.com/"
      }
    },
    devnet: {
      rpc: {
        node: "https://fullnode.devnet.aptoslabs.com",
        faucet: "https://faucet.devnet.aptoslabs.com/"
      }
    },
    testnet: {
      rpc: {
        node: "https://fullnode.testnet.aptoslabs.com",
        faucet: "https://faucet.testnet.aptoslabs.com/"
      }
    }
  }[network];
}
utils.getConfigurationByNetwork = getConfigurationByNetwork;
(function(exports) {
  var __assign2 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign2 = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign2.apply(this, arguments);
  };
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e3) {
          op = [6, e3];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_12 = utils;
  var aptos_1 = dist$1;
  var defaultSnapOrigin = "npm:@keystonehq/aptossnap";
  __exportStar(utils, exports);
  var WalletAdapter = function() {
    function WalletAdapter2(config, snapOrigin, snapInstallationParams) {
      if (snapInstallationParams === void 0) {
        snapInstallationParams = {
          version: "latest"
        };
      }
      this._connecting = false;
      this.config = config;
      this.snapId = snapOrigin !== null && snapOrigin !== void 0 ? snapOrigin : defaultSnapOrigin;
      this.snapInstallationParams = snapInstallationParams;
    }
    Object.defineProperty(WalletAdapter2.prototype, "connecting", {
      get: function() {
        return this._connecting;
      },
      enumerable: false,
      configurable: true
    });
    WalletAdapter2.prototype.isConnected = function() {
      var _a2;
      return Promise.resolve(!!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected));
    };
    WalletAdapter2.prototype.account = function() {
      var _a2, _b;
      if (this.connecting) {
        throw new Error("Already in connecting status");
      }
      if (!this.isConnected()) {
        throw new Error("Connect first");
      } else {
        return Promise.resolve({
          publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
          address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null
        });
      }
    };
    WalletAdapter2.prototype.connect = function() {
      return __awaiter2(this, void 0, void 0, function() {
        var isInstalled, result;
        var _a2;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, , 9, 10]);
              if (this.connecting) {
                throw new Error("Already in connecting status");
              }
              this._connecting = true;
              if (!utils_12.hasMetaMask()) {
                throw new Error("Metamask is not installed");
              }
              return [4, utils_12.isMetamaskSnapsSupported()];
            case 1:
              if (!_b.sent()) {
                throw new Error("Current Metamask version doesn't support snaps");
              }
              this._connecting = true;
              return [4, utils_12.isSnapInstalled(this.snapId)];
            case 2:
              isInstalled = _b.sent();
              if (!!isInstalled)
                return [3, 4];
              return [4, window.ethereum.request({
                method: "wallet_enable",
                params: [
                  {
                    wallet_snap: (_a2 = {}, _a2[this.snapId] = this.snapInstallationParams, _a2)
                  }
                ]
              })];
            case 3:
              _b.sent();
              _b.label = 4;
            case 4:
              if (!!this.config.network)
                return [3, 5];
              throw new Error("Configuration must at least define network type");
            case 5:
              return [4, window.ethereum.request({
                method: "wallet_invokeSnap",
                params: [this.snapId, {
                  method: "aptos_configure",
                  params: {
                    configuration: {
                      network: this.config.network
                    }
                  }
                }]
              })];
            case 6:
              _b.sent();
              _b.label = 7;
            case 7:
              return [4, window.ethereum.request({
                method: "wallet_invokeSnap",
                params: [
                  this.snapId,
                  {
                    method: "aptos_getAccount"
                  }
                ]
              })];
            case 8:
              result = _b.sent();
              this._wallet = {
                address: result.address,
                publicKey: result.publicKey,
                isConnected: true
              };
              return [2, result];
            case 9:
              this._connecting = false;
              return [7];
            case 10:
              return [2];
          }
        });
      });
    };
    WalletAdapter2.prototype.disconnect = function() {
      return __awaiter2(this, void 0, void 0, function() {
        var wallet;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              wallet = this._wallet;
              return [4, window.ethereum.request({
                method: "wallet_invokeSnap",
                params: [
                  this.snapId,
                  {
                    method: "aptos_disconnect"
                  }
                ]
              })];
            case 1:
              _a2.sent();
              if (wallet) {
                this._wallet = null;
              }
              return [2];
          }
        });
      });
    };
    WalletAdapter2.prototype.getClient = function() {
      var nodeUrl = utils_12.getConfigurationByNetwork(this.config.network).rpc.node;
      return new aptos_1.AptosClient(nodeUrl);
    };
    WalletAdapter2.prototype.signAndSubmitTransaction = function(transactionPayload, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var client2, rawTransaction, s2, signedTx;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              client2 = this.getClient();
              return [4, client2.generateTransaction(this._wallet.address, transactionPayload, options)];
            case 1:
              rawTransaction = _a2.sent();
              s2 = new aptos_1.BCS.Serializer();
              rawTransaction.serialize(s2);
              return [4, window.ethereum.request({
                method: "wallet_invokeSnap",
                params: [
                  this.snapId,
                  {
                    method: "aptos_signTransaction",
                    params: { rawTransaction: s2.getBytes() }
                  }
                ]
              })];
            case 2:
              signedTx = _a2.sent();
              return [2, client2.submitTransaction(new Uint8Array(Object.values(signedTx)))];
          }
        });
      });
    };
    WalletAdapter2.prototype.signTransaction = function(transactionPayload) {
      return __awaiter2(this, void 0, void 0, function() {
        var client2, rawTransaction, s2, signedTx;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              client2 = this.getClient();
              return [4, client2.generateTransaction(this._wallet.address, transactionPayload)];
            case 1:
              rawTransaction = _a2.sent();
              s2 = new aptos_1.BCS.Serializer();
              rawTransaction.serialize(s2);
              return [4, window.ethereum.request({
                method: "wallet_invokeSnap",
                params: [
                  this.snapId,
                  {
                    method: "aptos_signTransaction",
                    params: { rawTransaction: s2.getBytes() }
                  }
                ]
              })];
            case 2:
              signedTx = _a2.sent();
              return [2, new Uint8Array(Object.values(signedTx))];
          }
        });
      });
    };
    WalletAdapter2.prototype.signMessage = function(payload) {
      return __awaiter2(this, void 0, void 0, function() {
        var client2, prefix, fullMessage, address, chainId, _a2, application, rawMessage, signature;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              client2 = this.getClient();
              prefix = "APTOS";
              fullMessage = prefix;
              address = payload.address ? this._wallet.address : void 0;
              if (!payload.chainId)
                return [3, 2];
              return [4, client2.getChainId()];
            case 1:
              _a2 = _b.sent();
              return [3, 3];
            case 2:
              _a2 = void 0;
              _b.label = 3;
            case 3:
              chainId = _a2;
              application = payload.application ? window.location.hostname : void 0;
              if (address) {
                fullMessage += "\naddress: " + address;
              }
              if (chainId) {
                fullMessage += "\nchainId: " + chainId;
              }
              if (application) {
                fullMessage += "\napplication: " + application;
              }
              fullMessage += "\nmessage: " + payload.message;
              fullMessage += "\nnonce: " + payload.nonce;
              rawMessage = {
                prefix,
                address,
                chainId,
                application,
                nonce: payload.nonce,
                message: payload.message,
                fullMessage
              };
              Object.keys(rawMessage).forEach(function(key) {
                return rawMessage[key] === void 0 && delete rawMessage[key];
              });
              return [4, window.ethereum.request({
                method: "wallet_invokeSnap",
                params: [
                  this.snapId,
                  {
                    method: "aptos_signMessage",
                    params: { message: rawMessage }
                  }
                ]
              })];
            case 4:
              signature = _b.sent();
              return [2, __assign2(__assign2({}, rawMessage), { signature: "" + signature + Buffer.from(fullMessage).toString("hex") })];
          }
        });
      });
    };
    return WalletAdapter2;
  }();
  exports.default = WalletAdapter;
})(build);
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AptosSnapAdapter = exports.AptosSnapName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  const aptossnap_adapter_1 = __importDefault2(build);
  exports.AptosSnapName = "Snap";
  class AptosSnapAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      network,
      timeout = 1e4
    } = { network: BaseAdapter_12.WalletAdapterNetwork.Devnet }) {
      super();
      this.name = exports.AptosSnapName;
      this.url = "https://chrome.google.com/webstore/detail/metamask-flask-developmen/ljfoeinjpaedjfecbmggjgodbgkmjkjk";
      this.icon = "https://metamask.zendesk.com/hc/article_attachments/6974707389467/mceclip1.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = new aptossnap_adapter_1.default({ network }, "npm:@keystonehq/aptossnap");
      this._network = network;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window.ethereum) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider;
          const isConnected = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          if (isConnected) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          this._wallet = Object.assign(Object.assign({}, response), { isConnected: true });
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          try {
            const provider2 = this._provider;
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(transaction);
            if (response) {
              return new Uint8Array([]);
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          if (!wallet)
            throw new errors_12.WalletNotConnectedError();
          try {
            const provider2 = this._provider;
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(transaction, options);
            if (response) {
              return { hash: response.hash };
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignAndSubmitMessageError(error.message || error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(message);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.AptosSnapAdapter = AptosSnapAdapter;
})(AptosSnap);
var BitkeepWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BitkeepWalletAdapter = exports.BitkeepWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.BitkeepWalletName = "BitKeep";
  class BitkeepWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      var _a2;
      super();
      this.name = exports.BitkeepWalletName;
      this.url = "https://chrome.google.com/webstore/detail/bitkeep-bitcoin-crypto-wa/jiidiaalihmmhddjgbnbgdfflelocpak";
      this.icon = "https://raw.githubusercontent.com/bitkeepwallet/download/main/logo-png/BitKeep_logo_circle.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? (_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          var _a3;
          if ((_a3 = window.bitkeep) === null || _a3 === void 0 ? void 0 : _a3.aptos) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || ((_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          this._wallet = {
            address: response === null || response === void 0 ? void 0 : response.address,
            publicKey: response === null || response === void 0 ? void 0 : response.publicKey,
            isConnected: true
          };
          try {
            const name = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
            const chainId = null;
            const api = null;
            this._network = name;
            this._chainId = chainId;
            this._api = api;
          } catch (error) {
            const errMsg = error.message;
            this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
            throw error;
          }
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || ((_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos);
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction, options) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signAndSubmitTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(errMsg));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleAccountChange = (newAccount) => __awaiter2(this, void 0, void 0, function* () {
            var _b, _c, _d;
            console.log("account Changed >>>", newAccount);
            this._wallet = Object.assign(Object.assign({}, this._wallet), { publicKey: newAccount.publicKey || ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.publicKey), authKey: newAccount.authKey || ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey), address: newAccount.address || ((_d = this._wallet) === null || _d === void 0 ? void 0 : _d.address) });
            this.emit("accountChange", newAccount.publicKey);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onAccountChange(handleAccountChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.bitkeep) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleNetworkChange = (newNetwork) => __awaiter2(this, void 0, void 0, function* () {
            console.log("network Changed >>>", newNetwork);
            this._network = newNetwork.networkName;
            this.emit("networkChange", this._network);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onNetworkChange(handleNetworkChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.BitkeepWalletAdapter = BitkeepWalletAdapter;
})(BitkeepWallet);
var TokenPocketWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenPocketWalletAdapter = exports.TokenPocketWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.TokenPocketWalletName = "TokenPocket";
  class TokenPocketWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.TokenPocketWalletName;
      this.url = "https://tokenpocket.pro";
      this.icon = "https://tp-statics.tokenpocket.pro/logo/tokenpocket.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.aptos : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          var _a2;
          if (window.aptos && ((_a2 = window.aptos) === null || _a2 === void 0 ? void 0 : _a2.isTokenPocket)) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.aptos;
          const isConnected = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          if (isConnected) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if (!response) {
            throw new errors_12.WalletNotConnectedError("No connect response");
          }
          this._wallet = {
            address: response === null || response === void 0 ? void 0 : response.address,
            publicKey: response === null || response === void 0 ? void 0 : response.publicKey,
            isConnected: true
          };
          try {
            const network = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
            const chainId = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.getChainId();
            const api = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.getNodeUrl();
            this._network = network;
            this._chainId = chainId;
            this._api = api;
          } catch (error) {
            const errMsg = error.message;
            this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
            throw error;
          }
          this.emit("connect", this._wallet.address);
        } catch (error) {
          this.emit("error", new Error(error));
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || window.aptos;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signTransaction(transaction, options);
          if (!response) {
            throw new Error("No response");
          }
          return response;
        } catch (error) {
          this.emit("error", new errors_12.WalletSignTransactionError(error));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signAndSubmitTransaction(transaction, options);
          if (!response) {
            throw new Error("No response");
          }
          return response;
        } catch (error) {
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(error));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.aptos;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
      });
    }
  }
  exports.TokenPocketWalletAdapter = TokenPocketWalletAdapter;
})(TokenPocketWallet);
var ONTOWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ONTOWalletAdapter = exports.ONTOWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.ONTOWalletName = "ONTO";
  class ONTOWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      var _a2;
      super();
      this.name = exports.ONTOWalletName;
      this.url = "https://onto.app";
      this.icon = "https://app.ont.io/onto/ONTO_logo.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? (_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          var _a3;
          if ((_a3 = window.onto) === null || _a3 === void 0 ? void 0 : _a3.aptos) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || ((_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          this._wallet = {
            address: response === null || response === void 0 ? void 0 : response.address,
            publicKey: response === null || response === void 0 ? void 0 : response.publicKey,
            isConnected: true
          };
          try {
            const name = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
            const chainId = null;
            const api = null;
            this._network = name;
            this._chainId = chainId;
            this._api = api;
          } catch (error) {
            const errMsg = error.message;
            this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
            throw error;
          }
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || ((_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos);
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction, options) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signAndSubmitTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(errMsg));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleAccountChange = (newAccount) => __awaiter2(this, void 0, void 0, function* () {
            var _b, _c, _d;
            console.log("account Changed >>>", newAccount);
            this._wallet = Object.assign(Object.assign({}, this._wallet), { publicKey: newAccount.publicKey || ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.publicKey), authKey: newAccount.authKey || ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey), address: newAccount.address || ((_d = this._wallet) === null || _d === void 0 ? void 0 : _d.address) });
            this.emit("accountChange", newAccount.publicKey);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onAccountChange(handleAccountChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.onto) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleNetworkChange = (newNetwork) => __awaiter2(this, void 0, void 0, function* () {
            console.log("network Changed >>>", newNetwork);
            this._network = newNetwork.networkName;
            this.emit("networkChange", this._network);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onNetworkChange(handleNetworkChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.ONTOWalletAdapter = ONTOWalletAdapter;
})(ONTOWallet);
var BloctoWallet = {};
var bloctoSdk_umd = { exports: {} };
(function(module2, exports) {
  !function(t2, e3) {
    module2.exports = e3();
  }(commonjsGlobal, function() {
    var t2 = "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
    function e3() {
      throw new Error("setTimeout has not been defined");
    }
    function r2() {
      throw new Error("clearTimeout has not been defined");
    }
    var n2 = e3, i2 = r2;
    function o2(t3) {
      if (n2 === setTimeout)
        return setTimeout(t3, 0);
      if ((n2 === e3 || !n2) && setTimeout)
        return n2 = setTimeout, setTimeout(t3, 0);
      try {
        return n2(t3, 0);
      } catch (e4) {
        try {
          return n2.call(null, t3, 0);
        } catch (e6) {
          return n2.call(this, t3, 0);
        }
      }
    }
    "function" == typeof t2.setTimeout && (n2 = setTimeout), "function" == typeof t2.clearTimeout && (i2 = clearTimeout);
    var s2, a2 = [], h2 = false, f2 = -1;
    function u2() {
      h2 && s2 && (h2 = false, s2.length ? a2 = s2.concat(a2) : f2 = -1, a2.length && c2());
    }
    function c2() {
      if (!h2) {
        var t3 = o2(u2);
        h2 = true;
        for (var e4 = a2.length; e4; ) {
          for (s2 = a2, a2 = []; ++f2 < e4; )
            s2 && s2[f2].run();
          f2 = -1, e4 = a2.length;
        }
        s2 = null, h2 = false, function(t4) {
          if (i2 === clearTimeout)
            return clearTimeout(t4);
          if ((i2 === r2 || !i2) && clearTimeout)
            return i2 = clearTimeout, clearTimeout(t4);
          try {
            i2(t4);
          } catch (e6) {
            try {
              return i2.call(null, t4);
            } catch (e7) {
              return i2.call(this, t4);
            }
          }
        }(t3);
      }
    }
    function d2(t3, e4) {
      this.fun = t3, this.array = e4;
    }
    d2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    function l2() {
    }
    var p2 = l2, b2 = l2, m2 = l2, y2 = l2, g = l2, v2 = l2, w2 = l2;
    var M2 = t2.performance || {}, _2 = M2.now || M2.mozNow || M2.msNow || M2.oNow || M2.webkitNow || function() {
      return new Date().getTime();
    };
    var A2 = new Date();
    var S2 = { nextTick: function(t3) {
      var e4 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r3 = 1; r3 < arguments.length; r3++)
          e4[r3 - 1] = arguments[r3];
      a2.push(new d2(t3, e4)), 1 !== a2.length || h2 || o2(c2);
    }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: p2, addListener: b2, once: m2, off: y2, removeListener: g, removeAllListeners: v2, emit: w2, binding: function(t3) {
      throw new Error("process.binding is not supported");
    }, cwd: function() {
      return "/";
    }, chdir: function(t3) {
      throw new Error("process.chdir is not supported");
    }, umask: function() {
      return 0;
    }, hrtime: function(t3) {
      var e4 = 1e-3 * _2.call(M2), r3 = Math.floor(e4), n3 = Math.floor(e4 % 1 * 1e9);
      return t3 && (r3 -= t3[0], (n3 -= t3[1]) < 0 && (r3--, n3 += 1e9)), [r3, n3];
    }, platform: "browser", release: {}, config: {}, uptime: function() {
      return (new Date() - A2) / 1e3;
    } }, E2 = function(t3, e4, r3, n3, i3, o3, s3, a3) {
      if ("production" !== S2.env.NODE_ENV && void 0 === e4)
        throw new Error("invariant requires an error message argument");
      if (!t3) {
        var h3;
        if (void 0 === e4)
          h3 = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
          var f3 = [r3, n3, i3, o3, s3, a3], u3 = 0;
          (h3 = new Error(e4.replace(/%s/g, function() {
            return f3[u3++];
          }))).name = "Invariant Violation";
        }
        throw h3.framesToPop = 1, h3;
      }
    };
    const x2 = { 56: "https://bsc-dataseed1.binance.org", 97: "https://data-seed-prebsc-1-s1.binance.org:8545", 137: "https://rpc-mainnet.maticvigil.com/", 80001: "https://rpc-mumbai.matic.today/", 43114: "https://api.avax.network/ext/bc/C/rpc", 43113: "https://api.avax-test.network/ext/bc/C/rpc" }, I2 = { 1: "ethereum", 4: "ethereum", 56: "bsc", 97: "bsc", 137: "polygon", 80001: "polygon", 43114: "avalanche", 43113: "avalanche" }, k2 = { 1: "mainnet", 4: "rinkeby", 56: "mainnet", 97: "testnet", 137: "mainnet", 80001: "testnet", 43114: "mainnet", 43113: "testnet" }, R2 = { 1: "https://wallet.blocto.app", 4: "https://wallet-testnet.blocto.app", 56: "https://wallet.blocto.app", 97: "https://wallet-testnet.blocto.app", 137: "https://wallet.blocto.app", 80001: "https://wallet-testnet.blocto.app", 43114: "https://wallet.blocto.app", 43113: "https://wallet-testnet.blocto.app" }, T2 = { devnet: "https://wallet-testnet.blocto.app", testnet: "https://wallet-testnet.blocto.app", "mainnet-beta": "https://wallet.blocto.app" }, B2 = ["devnet", "testnet", "mainnet-beta"], P2 = { 1: "https://wallet.blocto.app", 2: "https://wallet-testnet.blocto.app", 3: "https://wallet-testnet.blocto.app", 4: "https://wallet-testnet.blocto.app", 5: "https://wallet.blocto.app" };
    var O2;
    !function(t3) {
      t3.Mainnet = "mainnet", t3.Testnet = "testnet", t3.Devnet = "devnet", t3.Testing = "testing", t3.Premainnet = "premainnet";
    }(O2 || (O2 = {}));
    const U2 = { 1: O2.Mainnet, 2: O2.Testnet, 3: O2.Devnet, 4: O2.Testing, 5: O2.Premainnet }, L2 = { 1: "https://fullnode.mainnet.aptoslabs.com/v1", 2: "https://fullnode.testnet.aptoslabs.com/v1", 3: "https://fullnode.devnet.aptoslabs.com/v1", 4: "", 5: "https://premainnet.aptosdev.com/v1" }, N2 = ["connect", "disconnect", "message", "chainChanged", "accountsChanged"], z2 = 864e5;
    class C2 {
      constructor() {
        this.isBlocto = true, this.isConnecting = false, this.connected = false, this.eventListeners = {}, this.code = null, this.sessionKey = "sdk.session", this.off = this.removeListener, N2.forEach((t3) => {
          this.eventListeners[t3] = [];
        });
      }
      async request(t3) {
      }
      on(t3, e4) {
        N2.includes(t3) && this.eventListeners[t3].push(e4);
      }
      once() {
      }
      removeListener(t3, e4) {
        const r3 = this.eventListeners[t3].findIndex((t4) => t4 === e4);
        -1 !== r3 && this.eventListeners[t3].splice(r3, 1);
      }
    }
    function q2(t3) {
      const e4 = document.createElement("iframe");
      return e4.setAttribute("src", t3), e4.setAttribute("style", "width:100vw;height:100%;position:fixed;top:0;left:0;z-index:20000;border:none;"), e4;
    }
    function j2(t3) {
      document.body.appendChild(t3);
    }
    function D2(t3) {
      const e4 = t3 && t3.parentNode;
      e4 && e4.removeChild instanceof Function && e4.removeChild(t3);
    }
    var F2 = (t3, e4, r3 = window) => {
      r3.addEventListener(t3, function n3(i3) {
        e4(i3, () => r3.removeEventListener(t3, n3));
      });
    };
    const K2 = "undefined" != typeof window ? window.memoryStorage : new class {
      constructor() {
        this.storage = {};
      }
      getItem(t3) {
        return this[t3] || null;
      }
      setItem(t3, e4) {
        this.storage[t3] = e4;
      }
      removeItem(t3) {
        delete this.storage[t3];
      }
    }();
    "undefined" != typeof window && (window.memoryStorage = K2);
    const Y2 = (() => {
      if ("undefined" == typeof window)
        return false;
      try {
        window.localStorage.setItem("local_storage_supported", "1");
        const t3 = window.localStorage.getItem("local_storage_supported");
        return window.localStorage.removeItem("local_storage_supported"), "1" === t3;
      } catch (t3) {
        return false;
      }
    })() ? window.localStorage : K2, V2 = (t3, e4 = null) => {
      const r3 = ((t4, e6 = null) => {
        const r4 = Y2.getItem(t4);
        try {
          return JSON.parse(r4) || e6;
        } catch (t5) {
          return r4 || e6;
        }
      })(t3, null);
      return r3 ? new Date().getTime() > r3.expiry ? ($2(t3), e4) : r3.value : e4;
    }, W2 = (t3, e4) => Y2.setItem(t3, "string" == typeof e4 ? e4 : JSON.stringify(e4)), H2 = (t3, e4, r3) => W2(t3, { value: e4, expiry: new Date().getTime() + r3 }), $2 = (t3) => {
      W2(t3, ""), Y2.removeItem(t3);
    };
    async function G2(t3, e4) {
      if (403 === t3.status)
        throw e4.code = null, $2(e4.sessionKey), new Error("[Blocto SDK]: Session expired!");
      return t3.json();
    }
    class Z2 extends C2 {
      constructor({ chainId: t3 = "0x1", rpc: e4, server: r3, appId: n3 }) {
        super(), this.accounts = [], E2(t3, "'chainId' is required"), "number" == typeof t3 ? this.chainId = t3 : t3.includes("0x") ? this.chainId = parseInt(t3, 16) : this.chainId = parseInt(t3, 10), this.networkId = this.chainId, this.chain = I2[this.chainId], this.net = k2[this.chainId], E2(this.chain, `unsupported 'chainId': ${this.chainId}`), this.rpc = e4 || x2[this.chainId] || process.env.RPC || "", E2(this.rpc, "'rpc' is required for Ethereum"), this.server = r3 || R2[this.chainId] || "https://wallet.blocto.app", this.appId = n3 || process.env.APP_ID;
      }
      tryRetrieveSessionFromStorage() {
        const t3 = V2(this.sessionKey, {}), e4 = t3 && t3.code, r3 = t3 && t3.address && t3.address[this.chain];
        this.connected = Boolean(e4 && r3), this.code = e4 || null, this.accounts = r3 ? [r3] : [];
      }
      checkNetworkMatched() {
        const t3 = window.ethereum;
        if (t3 && t3.isBlocto && parseInt(t3.chainId, 16) !== this.chainId)
          throw new Error("Blocto SDK network mismatched");
      }
      async send(t3, e4) {
        switch (true) {
          case e4 instanceof Function:
            return this.sendAsync(t3, e4);
          case ("string" == typeof t3 && Array.isArray(e4)):
            return this.sendAsync({ method: t3, params: e4 });
          default:
            return this.sendAsync(t3);
        }
      }
      async sendAsync(t3, e4) {
        const r3 = new Promise((e6) => {
          if (Array.isArray(t3)) {
            const r4 = t3.filter((t4) => "eth_sendTransaction" === t4.method).map((t4) => t4.params[0]), n3 = Math.floor(1e4 * Math.random()), i3 = { method: "blocto_sendBatchTransaction", params: r4 }, o3 = this.request(i3), s3 = t3.map(({ method: t4, params: e7 }, r5) => "eth_sendTransaction" === t4 ? o3 : this.request({ id: n3 + r5 + 1, jsonrpc: "2.0", method: t4, params: e7 }));
            Promise.allSettled(s3).then((t4) => e6(t4.map((t5, e7) => ({ id: n3 + e7 + 1, jsonrpc: "2.0", result: "fulfilled" === t5.status ? t5.value : void 0, error: "fulfilled" !== t5.status ? t5.reason : void 0 }))));
          } else
            this.request(t3).then(e6);
        });
        if (!e4)
          return r3;
        r3.then((t4) => e4(null, t4)).catch((t4) => e4(t4));
      }
      async request(t3) {
        const e4 = window.ethereum;
        if (e4 && e4.isBlocto)
          return e4.request(t3);
        this.connected || await this.enable();
        try {
          let e6 = null, r3 = null;
          switch (t3.method) {
            case "eth_requestAccounts":
              this.accounts = await this.fetchAccounts();
            case "eth_accounts":
              r3 = this.accounts.length ? this.accounts : await this.fetchAccounts();
              break;
            case "eth_coinbase":
              r3 = this.accounts[0];
              break;
            case "eth_chainId":
              r3 = this.chainId, r3 = `0x${r3.toString(16)}`;
              break;
            case "net_version":
              r3 = this.networkId || this.chainId, r3 = `0x${r3.toString(16)}`;
              break;
            case "eth_signTypedData_v3":
            case "eth_signTypedData":
            case "eth_signTypedData_v4":
            case "personal_sign":
            case "eth_sign":
              r3 = await this.handleSign(t3);
              break;
            case "blocto_sendBatchTransaction":
            case "eth_sendTransaction":
              r3 = await this.handleSendTransaction(t3);
              break;
            case "eth_signTransaction":
            case "eth_sendRawTransaction":
              r3 = null;
              break;
            default:
              e6 = await this.handleReadRequests(t3);
          }
          if (e6 && !e6.result && e6.error) {
            const t4 = e6.error.message ? e6.error.message : "Request failed";
            throw new Error(t4);
          }
          return e6 ? e6.result : r3;
        } catch (t4) {
          throw console.error(t4), t4;
        }
      }
      async enable() {
        const t3 = window.ethereum;
        if (t3 && t3.isBlocto) {
          if (parseInt(t3.chainId, 16) !== this.chainId)
            try {
              await t3.request({ method: "wallet_addEthereumChain", params: [{ chainId: `0x${this.chainId.toString(16)}` }] }), this.accounts = [t3.address];
            } catch (t4) {
              console.error(t4);
            }
          return new Promise((e4, r3) => setTimeout(() => t3.enable().then(e4).catch(r3), 10));
        }
        return this.tryRetrieveSessionFromStorage(), new Promise((t4, e4) => {
          if ("undefined" == typeof window && e4("Currently only supported in browser"), this.connected)
            return t4(this.accounts);
          const r3 = encodeURIComponent(window.location.origin), n3 = q2(`${this.server}/authn?l6n=${r3}&chain=${this.chain}`);
          j2(n3), F2("message", (r4, i3) => {
            const o3 = r4;
            if (o3.origin === this.server) {
              if ("FCL::CHALLENGE::RESPONSE" === o3.data.type) {
                i3(), D2(n3), this.code = o3.data.code, this.connected = true, this.eventListeners.connect.forEach((t5) => t5(this.chainId));
                const e6 = o3.data.address;
                this.accounts = e6 ? [e6[this.chain]] : [], H2(this.sessionKey, { code: this.code, address: e6 }, z2), t4(this.accounts);
              }
              "FCL::CHALLENGE::CANCEL" === o3.data.type && (i3(), D2(n3), e4(new Error("User declined the login request")));
            }
          });
        });
      }
      async fetchAccounts() {
        this.checkNetworkMatched();
        const { accounts: t3 } = await fetch(`${this.server}/api/${this.chain}/accounts?code=${this.code}`).then((t4) => G2(t4, this));
        return this.accounts = t3, t3;
      }
      async handleReadRequests(t3) {
        return this.checkNetworkMatched(), fetch(this.rpc, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ id: 1, jsonrpc: "2.0", ...t3 }) }).then((t4) => t4.json());
      }
      async handleSign({ method: t3, params: e4 }) {
        const r3 = `${this.server}/user-signature/${this.chain}`, n3 = q2(r3);
        j2(n3);
        let i3 = "";
        return Array.isArray(e4) && ("eth_sign" === t3 ? i3 = e4[1].slice(2) : "personal_sign" === t3 ? i3 = e4[0].slice(2) : ["eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4"].includes(t3) && (i3 = e4[1])), F2("message", (e6, o3) => {
          const s3 = e6;
          s3.origin === this.server && "ETH:FRAME:READY" === s3.data.type && (n3.contentWindow && n3.contentWindow.postMessage({ type: "ETH:FRAME:READY:RESPONSE", method: t3, message: i3, chain: this.chain }, r3), o3());
        }), new Promise((t4, e6) => F2("message", (r4, i4) => {
          const o3 = r4;
          o3.origin === this.server && "ETH:FRAME:RESPONSE" === o3.data.type && ("APPROVED" === o3.data.status && (i4(), D2(n3), t4(o3.data.signature)), "DECLINED" === o3.data.status && (i4(), D2(n3), e6(new Error("User declined the signing request"))));
        }));
      }
      async handleSendTransaction(t3) {
        this.checkNetworkMatched();
        const { authorizationId: e4 } = await fetch(`${this.server}/api/${this.chain}/authz?code=${this.code}`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(t3.params) }).then((t4) => G2(t4, this));
        if ("undefined" == typeof window)
          throw new Error("Currently only supported in browser");
        const r3 = q2(`${this.server}/authz/${this.chain}/${e4}`);
        return j2(r3), new Promise((t4, e6) => F2("message", (n3, i3) => {
          const o3 = n3;
          o3.origin === this.server && "ETH:FRAME:RESPONSE" === o3.data.type && ("APPROVED" === o3.data.status && (i3(), D2(r3), t4(o3.data.txHash)), "DECLINED" === o3.data.status && (i3(), D2(r3), e6(new Error("User declined to send the transaction"))));
        }));
      }
    }
    var J2 = [], X2 = [], Q2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, tt = false;
    function et() {
      tt = true;
      for (var t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e4 = 0, r3 = t3.length; e4 < r3; ++e4)
        J2[e4] = t3[e4], X2[t3.charCodeAt(e4)] = e4;
      X2["-".charCodeAt(0)] = 62, X2["_".charCodeAt(0)] = 63;
    }
    function rt(t3, e4, r3) {
      for (var n3, i3, o3 = [], s3 = e4; s3 < r3; s3 += 3)
        n3 = (t3[s3] << 16) + (t3[s3 + 1] << 8) + t3[s3 + 2], o3.push(J2[(i3 = n3) >> 18 & 63] + J2[i3 >> 12 & 63] + J2[i3 >> 6 & 63] + J2[63 & i3]);
      return o3.join("");
    }
    function nt(t3) {
      var e4;
      tt || et();
      for (var r3 = t3.length, n3 = r3 % 3, i3 = "", o3 = [], s3 = 16383, a3 = 0, h3 = r3 - n3; a3 < h3; a3 += s3)
        o3.push(rt(t3, a3, a3 + s3 > h3 ? h3 : a3 + s3));
      return 1 === n3 ? (e4 = t3[r3 - 1], i3 += J2[e4 >> 2], i3 += J2[e4 << 4 & 63], i3 += "==") : 2 === n3 && (e4 = (t3[r3 - 2] << 8) + t3[r3 - 1], i3 += J2[e4 >> 10], i3 += J2[e4 >> 4 & 63], i3 += J2[e4 << 2 & 63], i3 += "="), o3.push(i3), o3.join("");
    }
    function it(t3, e4, r3, n3, i3) {
      var o3, s3, a3 = 8 * i3 - n3 - 1, h3 = (1 << a3) - 1, f3 = h3 >> 1, u3 = -7, c3 = r3 ? i3 - 1 : 0, d3 = r3 ? -1 : 1, l3 = t3[e4 + c3];
      for (c3 += d3, o3 = l3 & (1 << -u3) - 1, l3 >>= -u3, u3 += a3; u3 > 0; o3 = 256 * o3 + t3[e4 + c3], c3 += d3, u3 -= 8)
        ;
      for (s3 = o3 & (1 << -u3) - 1, o3 >>= -u3, u3 += n3; u3 > 0; s3 = 256 * s3 + t3[e4 + c3], c3 += d3, u3 -= 8)
        ;
      if (0 === o3)
        o3 = 1 - f3;
      else {
        if (o3 === h3)
          return s3 ? NaN : 1 / 0 * (l3 ? -1 : 1);
        s3 += Math.pow(2, n3), o3 -= f3;
      }
      return (l3 ? -1 : 1) * s3 * Math.pow(2, o3 - n3);
    }
    function ot(t3, e4, r3, n3, i3, o3) {
      var s3, a3, h3, f3 = 8 * o3 - i3 - 1, u3 = (1 << f3) - 1, c3 = u3 >> 1, d3 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l3 = n3 ? 0 : o3 - 1, p3 = n3 ? 1 : -1, b3 = e4 < 0 || 0 === e4 && 1 / e4 < 0 ? 1 : 0;
      for (e4 = Math.abs(e4), isNaN(e4) || e4 === 1 / 0 ? (a3 = isNaN(e4) ? 1 : 0, s3 = u3) : (s3 = Math.floor(Math.log(e4) / Math.LN2), e4 * (h3 = Math.pow(2, -s3)) < 1 && (s3--, h3 *= 2), (e4 += s3 + c3 >= 1 ? d3 / h3 : d3 * Math.pow(2, 1 - c3)) * h3 >= 2 && (s3++, h3 /= 2), s3 + c3 >= u3 ? (a3 = 0, s3 = u3) : s3 + c3 >= 1 ? (a3 = (e4 * h3 - 1) * Math.pow(2, i3), s3 += c3) : (a3 = e4 * Math.pow(2, c3 - 1) * Math.pow(2, i3), s3 = 0)); i3 >= 8; t3[r3 + l3] = 255 & a3, l3 += p3, a3 /= 256, i3 -= 8)
        ;
      for (s3 = s3 << i3 | a3, f3 += i3; f3 > 0; t3[r3 + l3] = 255 & s3, l3 += p3, s3 /= 256, f3 -= 8)
        ;
      t3[r3 + l3 - p3] |= 128 * b3;
    }
    var st = {}.toString, at = Array.isArray || function(t3) {
      return "[object Array]" == st.call(t3);
    };
    ct.TYPED_ARRAY_SUPPORT = void 0 === t2.TYPED_ARRAY_SUPPORT || t2.TYPED_ARRAY_SUPPORT;
    var ht = ft();
    function ft() {
      return ct.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function ut(t3, e4) {
      if (ft() < e4)
        throw new RangeError("Invalid typed array length");
      return ct.TYPED_ARRAY_SUPPORT ? (t3 = new Uint8Array(e4)).__proto__ = ct.prototype : (null === t3 && (t3 = new ct(e4)), t3.length = e4), t3;
    }
    function ct(t3, e4, r3) {
      if (!(ct.TYPED_ARRAY_SUPPORT || this instanceof ct))
        return new ct(t3, e4, r3);
      if ("number" == typeof t3) {
        if ("string" == typeof e4)
          throw new Error("If encoding is specified then the first argument must be a string");
        return pt2(this, t3);
      }
      return dt(this, t3, e4, r3);
    }
    function dt(t3, e4, r3, n3) {
      if ("number" == typeof e4)
        throw new TypeError('"value" argument must not be a number');
      return "undefined" != typeof ArrayBuffer && e4 instanceof ArrayBuffer ? function(t4, e6, r4, n4) {
        if (e6.byteLength, r4 < 0 || e6.byteLength < r4)
          throw new RangeError("'offset' is out of bounds");
        if (e6.byteLength < r4 + (n4 || 0))
          throw new RangeError("'length' is out of bounds");
        e6 = void 0 === r4 && void 0 === n4 ? new Uint8Array(e6) : void 0 === n4 ? new Uint8Array(e6, r4) : new Uint8Array(e6, r4, n4);
        ct.TYPED_ARRAY_SUPPORT ? (t4 = e6).__proto__ = ct.prototype : t4 = bt(t4, e6);
        return t4;
      }(t3, e4, r3, n3) : "string" == typeof e4 ? function(t4, e6, r4) {
        "string" == typeof r4 && "" !== r4 || (r4 = "utf8");
        if (!ct.isEncoding(r4))
          throw new TypeError('"encoding" must be a valid string encoding');
        var n4 = 0 | gt2(e6, r4), i3 = (t4 = ut(t4, n4)).write(e6, r4);
        i3 !== n4 && (t4 = t4.slice(0, i3));
        return t4;
      }(t3, e4, r3) : function(t4, e6) {
        if (yt(e6)) {
          var r4 = 0 | mt2(e6.length);
          return 0 === (t4 = ut(t4, r4)).length || e6.copy(t4, 0, 0, r4), t4;
        }
        if (e6) {
          if ("undefined" != typeof ArrayBuffer && e6.buffer instanceof ArrayBuffer || "length" in e6)
            return "number" != typeof e6.length || (n4 = e6.length) != n4 ? ut(t4, 0) : bt(t4, e6);
          if ("Buffer" === e6.type && at(e6.data))
            return bt(t4, e6.data);
        }
        var n4;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }(t3, e4);
    }
    function lt(t3) {
      if ("number" != typeof t3)
        throw new TypeError('"size" argument must be a number');
      if (t3 < 0)
        throw new RangeError('"size" argument must not be negative');
    }
    function pt2(t3, e4) {
      if (lt(e4), t3 = ut(t3, e4 < 0 ? 0 : 0 | mt2(e4)), !ct.TYPED_ARRAY_SUPPORT)
        for (var r3 = 0; r3 < e4; ++r3)
          t3[r3] = 0;
      return t3;
    }
    function bt(t3, e4) {
      var r3 = e4.length < 0 ? 0 : 0 | mt2(e4.length);
      t3 = ut(t3, r3);
      for (var n3 = 0; n3 < r3; n3 += 1)
        t3[n3] = 255 & e4[n3];
      return t3;
    }
    function mt2(t3) {
      if (t3 >= ft())
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ft().toString(16) + " bytes");
      return 0 | t3;
    }
    function yt(t3) {
      return !(null == t3 || !t3._isBuffer);
    }
    function gt2(t3, e4) {
      if (yt(t3))
        return t3.length;
      if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t3) || t3 instanceof ArrayBuffer))
        return t3.byteLength;
      "string" != typeof t3 && (t3 = "" + t3);
      var r3 = t3.length;
      if (0 === r3)
        return 0;
      for (var n3 = false; ; )
        switch (e4) {
          case "ascii":
          case "latin1":
          case "binary":
            return r3;
          case "utf8":
          case "utf-8":
          case void 0:
            return Vt(t3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * r3;
          case "hex":
            return r3 >>> 1;
          case "base64":
            return Wt(t3).length;
          default:
            if (n3)
              return Vt(t3).length;
            e4 = ("" + e4).toLowerCase(), n3 = true;
        }
    }
    function vt(t3, e4, r3) {
      var n3 = false;
      if ((void 0 === e4 || e4 < 0) && (e4 = 0), e4 > this.length)
        return "";
      if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0)
        return "";
      if ((r3 >>>= 0) <= (e4 >>>= 0))
        return "";
      for (t3 || (t3 = "utf8"); ; )
        switch (t3) {
          case "hex":
            return Ut(this, e4, r3);
          case "utf8":
          case "utf-8":
            return Tt(this, e4, r3);
          case "ascii":
            return Pt(this, e4, r3);
          case "latin1":
          case "binary":
            return Ot(this, e4, r3);
          case "base64":
            return Rt(this, e4, r3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Lt(this, e4, r3);
          default:
            if (n3)
              throw new TypeError("Unknown encoding: " + t3);
            t3 = (t3 + "").toLowerCase(), n3 = true;
        }
    }
    function wt(t3, e4, r3) {
      var n3 = t3[e4];
      t3[e4] = t3[r3], t3[r3] = n3;
    }
    function Mt(t3, e4, r3, n3, i3) {
      if (0 === t3.length)
        return -1;
      if ("string" == typeof r3 ? (n3 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), r3 = +r3, isNaN(r3) && (r3 = i3 ? 0 : t3.length - 1), r3 < 0 && (r3 = t3.length + r3), r3 >= t3.length) {
        if (i3)
          return -1;
        r3 = t3.length - 1;
      } else if (r3 < 0) {
        if (!i3)
          return -1;
        r3 = 0;
      }
      if ("string" == typeof e4 && (e4 = ct.from(e4, n3)), yt(e4))
        return 0 === e4.length ? -1 : _t(t3, e4, r3, n3, i3);
      if ("number" == typeof e4)
        return e4 &= 255, ct.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i3 ? Uint8Array.prototype.indexOf.call(t3, e4, r3) : Uint8Array.prototype.lastIndexOf.call(t3, e4, r3) : _t(t3, [e4], r3, n3, i3);
      throw new TypeError("val must be string, number or Buffer");
    }
    function _t(t3, e4, r3, n3, i3) {
      var o3, s3 = 1, a3 = t3.length, h3 = e4.length;
      if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
        if (t3.length < 2 || e4.length < 2)
          return -1;
        s3 = 2, a3 /= 2, h3 /= 2, r3 /= 2;
      }
      function f3(t4, e6) {
        return 1 === s3 ? t4[e6] : t4.readUInt16BE(e6 * s3);
      }
      if (i3) {
        var u3 = -1;
        for (o3 = r3; o3 < a3; o3++)
          if (f3(t3, o3) === f3(e4, -1 === u3 ? 0 : o3 - u3)) {
            if (-1 === u3 && (u3 = o3), o3 - u3 + 1 === h3)
              return u3 * s3;
          } else
            -1 !== u3 && (o3 -= o3 - u3), u3 = -1;
      } else
        for (r3 + h3 > a3 && (r3 = a3 - h3), o3 = r3; o3 >= 0; o3--) {
          for (var c3 = true, d3 = 0; d3 < h3; d3++)
            if (f3(t3, o3 + d3) !== f3(e4, d3)) {
              c3 = false;
              break;
            }
          if (c3)
            return o3;
        }
      return -1;
    }
    function At(t3, e4, r3, n3) {
      r3 = Number(r3) || 0;
      var i3 = t3.length - r3;
      n3 ? (n3 = Number(n3)) > i3 && (n3 = i3) : n3 = i3;
      var o3 = e4.length;
      if (o3 % 2 != 0)
        throw new TypeError("Invalid hex string");
      n3 > o3 / 2 && (n3 = o3 / 2);
      for (var s3 = 0; s3 < n3; ++s3) {
        var a3 = parseInt(e4.substr(2 * s3, 2), 16);
        if (isNaN(a3))
          return s3;
        t3[r3 + s3] = a3;
      }
      return s3;
    }
    function St(t3, e4, r3, n3) {
      return Ht(Vt(e4, t3.length - r3), t3, r3, n3);
    }
    function Et(t3, e4, r3, n3) {
      return Ht(function(t4) {
        for (var e6 = [], r4 = 0; r4 < t4.length; ++r4)
          e6.push(255 & t4.charCodeAt(r4));
        return e6;
      }(e4), t3, r3, n3);
    }
    function xt(t3, e4, r3, n3) {
      return Et(t3, e4, r3, n3);
    }
    function It(t3, e4, r3, n3) {
      return Ht(Wt(e4), t3, r3, n3);
    }
    function kt(t3, e4, r3, n3) {
      return Ht(function(t4, e6) {
        for (var r4, n4, i3, o3 = [], s3 = 0; s3 < t4.length && !((e6 -= 2) < 0); ++s3)
          n4 = (r4 = t4.charCodeAt(s3)) >> 8, i3 = r4 % 256, o3.push(i3), o3.push(n4);
        return o3;
      }(e4, t3.length - r3), t3, r3, n3);
    }
    function Rt(t3, e4, r3) {
      return 0 === e4 && r3 === t3.length ? nt(t3) : nt(t3.slice(e4, r3));
    }
    function Tt(t3, e4, r3) {
      r3 = Math.min(t3.length, r3);
      for (var n3 = [], i3 = e4; i3 < r3; ) {
        var o3, s3, a3, h3, f3 = t3[i3], u3 = null, c3 = f3 > 239 ? 4 : f3 > 223 ? 3 : f3 > 191 ? 2 : 1;
        if (i3 + c3 <= r3)
          switch (c3) {
            case 1:
              f3 < 128 && (u3 = f3);
              break;
            case 2:
              128 == (192 & (o3 = t3[i3 + 1])) && (h3 = (31 & f3) << 6 | 63 & o3) > 127 && (u3 = h3);
              break;
            case 3:
              o3 = t3[i3 + 1], s3 = t3[i3 + 2], 128 == (192 & o3) && 128 == (192 & s3) && (h3 = (15 & f3) << 12 | (63 & o3) << 6 | 63 & s3) > 2047 && (h3 < 55296 || h3 > 57343) && (u3 = h3);
              break;
            case 4:
              o3 = t3[i3 + 1], s3 = t3[i3 + 2], a3 = t3[i3 + 3], 128 == (192 & o3) && 128 == (192 & s3) && 128 == (192 & a3) && (h3 = (15 & f3) << 18 | (63 & o3) << 12 | (63 & s3) << 6 | 63 & a3) > 65535 && h3 < 1114112 && (u3 = h3);
          }
        null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3.push(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3.push(u3), i3 += c3;
      }
      return function(t4) {
        var e6 = t4.length;
        if (e6 <= Bt)
          return String.fromCharCode.apply(String, t4);
        var r4 = "", n4 = 0;
        for (; n4 < e6; )
          r4 += String.fromCharCode.apply(String, t4.slice(n4, n4 += Bt));
        return r4;
      }(n3);
    }
    ct.poolSize = 8192, ct._augment = function(t3) {
      return t3.__proto__ = ct.prototype, t3;
    }, ct.from = function(t3, e4, r3) {
      return dt(null, t3, e4, r3);
    }, ct.TYPED_ARRAY_SUPPORT && (ct.prototype.__proto__ = Uint8Array.prototype, ct.__proto__ = Uint8Array), ct.alloc = function(t3, e4, r3) {
      return function(t4, e6, r4, n3) {
        return lt(e6), e6 <= 0 ? ut(t4, e6) : void 0 !== r4 ? "string" == typeof n3 ? ut(t4, e6).fill(r4, n3) : ut(t4, e6).fill(r4) : ut(t4, e6);
      }(null, t3, e4, r3);
    }, ct.allocUnsafe = function(t3) {
      return pt2(null, t3);
    }, ct.allocUnsafeSlow = function(t3) {
      return pt2(null, t3);
    }, ct.isBuffer = $t, ct.compare = function(t3, e4) {
      if (!yt(t3) || !yt(e4))
        throw new TypeError("Arguments must be Buffers");
      if (t3 === e4)
        return 0;
      for (var r3 = t3.length, n3 = e4.length, i3 = 0, o3 = Math.min(r3, n3); i3 < o3; ++i3)
        if (t3[i3] !== e4[i3]) {
          r3 = t3[i3], n3 = e4[i3];
          break;
        }
      return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
    }, ct.isEncoding = function(t3) {
      switch (String(t3).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, ct.concat = function(t3, e4) {
      if (!at(t3))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t3.length)
        return ct.alloc(0);
      var r3;
      if (void 0 === e4)
        for (e4 = 0, r3 = 0; r3 < t3.length; ++r3)
          e4 += t3[r3].length;
      var n3 = ct.allocUnsafe(e4), i3 = 0;
      for (r3 = 0; r3 < t3.length; ++r3) {
        var o3 = t3[r3];
        if (!yt(o3))
          throw new TypeError('"list" argument must be an Array of Buffers');
        o3.copy(n3, i3), i3 += o3.length;
      }
      return n3;
    }, ct.byteLength = gt2, ct.prototype._isBuffer = true, ct.prototype.swap16 = function() {
      var t3 = this.length;
      if (t3 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var e4 = 0; e4 < t3; e4 += 2)
        wt(this, e4, e4 + 1);
      return this;
    }, ct.prototype.swap32 = function() {
      var t3 = this.length;
      if (t3 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var e4 = 0; e4 < t3; e4 += 4)
        wt(this, e4, e4 + 3), wt(this, e4 + 1, e4 + 2);
      return this;
    }, ct.prototype.swap64 = function() {
      var t3 = this.length;
      if (t3 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var e4 = 0; e4 < t3; e4 += 8)
        wt(this, e4, e4 + 7), wt(this, e4 + 1, e4 + 6), wt(this, e4 + 2, e4 + 5), wt(this, e4 + 3, e4 + 4);
      return this;
    }, ct.prototype.toString = function() {
      var t3 = 0 | this.length;
      return 0 === t3 ? "" : 0 === arguments.length ? Tt(this, 0, t3) : vt.apply(this, arguments);
    }, ct.prototype.equals = function(t3) {
      if (!yt(t3))
        throw new TypeError("Argument must be a Buffer");
      return this === t3 || 0 === ct.compare(this, t3);
    }, ct.prototype.inspect = function() {
      var t3 = "";
      return this.length > 0 && (t3 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t3 += " ... ")), "<Buffer " + t3 + ">";
    }, ct.prototype.compare = function(t3, e4, r3, n3, i3) {
      if (!yt(t3))
        throw new TypeError("Argument must be a Buffer");
      if (void 0 === e4 && (e4 = 0), void 0 === r3 && (r3 = t3 ? t3.length : 0), void 0 === n3 && (n3 = 0), void 0 === i3 && (i3 = this.length), e4 < 0 || r3 > t3.length || n3 < 0 || i3 > this.length)
        throw new RangeError("out of range index");
      if (n3 >= i3 && e4 >= r3)
        return 0;
      if (n3 >= i3)
        return -1;
      if (e4 >= r3)
        return 1;
      if (this === t3)
        return 0;
      for (var o3 = (i3 >>>= 0) - (n3 >>>= 0), s3 = (r3 >>>= 0) - (e4 >>>= 0), a3 = Math.min(o3, s3), h3 = this.slice(n3, i3), f3 = t3.slice(e4, r3), u3 = 0; u3 < a3; ++u3)
        if (h3[u3] !== f3[u3]) {
          o3 = h3[u3], s3 = f3[u3];
          break;
        }
      return o3 < s3 ? -1 : s3 < o3 ? 1 : 0;
    }, ct.prototype.includes = function(t3, e4, r3) {
      return -1 !== this.indexOf(t3, e4, r3);
    }, ct.prototype.indexOf = function(t3, e4, r3) {
      return Mt(this, t3, e4, r3, true);
    }, ct.prototype.lastIndexOf = function(t3, e4, r3) {
      return Mt(this, t3, e4, r3, false);
    }, ct.prototype.write = function(t3, e4, r3, n3) {
      if (void 0 === e4)
        n3 = "utf8", r3 = this.length, e4 = 0;
      else if (void 0 === r3 && "string" == typeof e4)
        n3 = e4, r3 = this.length, e4 = 0;
      else {
        if (!isFinite(e4))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        e4 |= 0, isFinite(r3) ? (r3 |= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = r3, r3 = void 0);
      }
      var i3 = this.length - e4;
      if ((void 0 === r3 || r3 > i3) && (r3 = i3), t3.length > 0 && (r3 < 0 || e4 < 0) || e4 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n3 || (n3 = "utf8");
      for (var o3 = false; ; )
        switch (n3) {
          case "hex":
            return At(this, t3, e4, r3);
          case "utf8":
          case "utf-8":
            return St(this, t3, e4, r3);
          case "ascii":
            return Et(this, t3, e4, r3);
          case "latin1":
          case "binary":
            return xt(this, t3, e4, r3);
          case "base64":
            return It(this, t3, e4, r3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return kt(this, t3, e4, r3);
          default:
            if (o3)
              throw new TypeError("Unknown encoding: " + n3);
            n3 = ("" + n3).toLowerCase(), o3 = true;
        }
    }, ct.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    var Bt = 4096;
    function Pt(t3, e4, r3) {
      var n3 = "";
      r3 = Math.min(t3.length, r3);
      for (var i3 = e4; i3 < r3; ++i3)
        n3 += String.fromCharCode(127 & t3[i3]);
      return n3;
    }
    function Ot(t3, e4, r3) {
      var n3 = "";
      r3 = Math.min(t3.length, r3);
      for (var i3 = e4; i3 < r3; ++i3)
        n3 += String.fromCharCode(t3[i3]);
      return n3;
    }
    function Ut(t3, e4, r3) {
      var n3 = t3.length;
      (!e4 || e4 < 0) && (e4 = 0), (!r3 || r3 < 0 || r3 > n3) && (r3 = n3);
      for (var i3 = "", o3 = e4; o3 < r3; ++o3)
        i3 += Yt(t3[o3]);
      return i3;
    }
    function Lt(t3, e4, r3) {
      for (var n3 = t3.slice(e4, r3), i3 = "", o3 = 0; o3 < n3.length; o3 += 2)
        i3 += String.fromCharCode(n3[o3] + 256 * n3[o3 + 1]);
      return i3;
    }
    function Nt(t3, e4, r3) {
      if (t3 % 1 != 0 || t3 < 0)
        throw new RangeError("offset is not uint");
      if (t3 + e4 > r3)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function zt(t3, e4, r3, n3, i3, o3) {
      if (!yt(t3))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e4 > i3 || e4 < o3)
        throw new RangeError('"value" argument is out of bounds');
      if (r3 + n3 > t3.length)
        throw new RangeError("Index out of range");
    }
    function Ct(t3, e4, r3, n3) {
      e4 < 0 && (e4 = 65535 + e4 + 1);
      for (var i3 = 0, o3 = Math.min(t3.length - r3, 2); i3 < o3; ++i3)
        t3[r3 + i3] = (e4 & 255 << 8 * (n3 ? i3 : 1 - i3)) >>> 8 * (n3 ? i3 : 1 - i3);
    }
    function qt(t3, e4, r3, n3) {
      e4 < 0 && (e4 = 4294967295 + e4 + 1);
      for (var i3 = 0, o3 = Math.min(t3.length - r3, 4); i3 < o3; ++i3)
        t3[r3 + i3] = e4 >>> 8 * (n3 ? i3 : 3 - i3) & 255;
    }
    function jt(t3, e4, r3, n3, i3, o3) {
      if (r3 + n3 > t3.length)
        throw new RangeError("Index out of range");
      if (r3 < 0)
        throw new RangeError("Index out of range");
    }
    function Dt(t3, e4, r3, n3, i3) {
      return i3 || jt(t3, 0, r3, 4), ot(t3, e4, r3, n3, 23, 4), r3 + 4;
    }
    function Ft(t3, e4, r3, n3, i3) {
      return i3 || jt(t3, 0, r3, 8), ot(t3, e4, r3, n3, 52, 8), r3 + 8;
    }
    ct.prototype.slice = function(t3, e4) {
      var r3, n3 = this.length;
      if ((t3 = ~~t3) < 0 ? (t3 += n3) < 0 && (t3 = 0) : t3 > n3 && (t3 = n3), (e4 = void 0 === e4 ? n3 : ~~e4) < 0 ? (e4 += n3) < 0 && (e4 = 0) : e4 > n3 && (e4 = n3), e4 < t3 && (e4 = t3), ct.TYPED_ARRAY_SUPPORT)
        (r3 = this.subarray(t3, e4)).__proto__ = ct.prototype;
      else {
        var i3 = e4 - t3;
        r3 = new ct(i3, void 0);
        for (var o3 = 0; o3 < i3; ++o3)
          r3[o3] = this[o3 + t3];
      }
      return r3;
    }, ct.prototype.readUIntLE = function(t3, e4, r3) {
      t3 |= 0, e4 |= 0, r3 || Nt(t3, e4, this.length);
      for (var n3 = this[t3], i3 = 1, o3 = 0; ++o3 < e4 && (i3 *= 256); )
        n3 += this[t3 + o3] * i3;
      return n3;
    }, ct.prototype.readUIntBE = function(t3, e4, r3) {
      t3 |= 0, e4 |= 0, r3 || Nt(t3, e4, this.length);
      for (var n3 = this[t3 + --e4], i3 = 1; e4 > 0 && (i3 *= 256); )
        n3 += this[t3 + --e4] * i3;
      return n3;
    }, ct.prototype.readUInt8 = function(t3, e4) {
      return e4 || Nt(t3, 1, this.length), this[t3];
    }, ct.prototype.readUInt16LE = function(t3, e4) {
      return e4 || Nt(t3, 2, this.length), this[t3] | this[t3 + 1] << 8;
    }, ct.prototype.readUInt16BE = function(t3, e4) {
      return e4 || Nt(t3, 2, this.length), this[t3] << 8 | this[t3 + 1];
    }, ct.prototype.readUInt32LE = function(t3, e4) {
      return e4 || Nt(t3, 4, this.length), (this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16) + 16777216 * this[t3 + 3];
    }, ct.prototype.readUInt32BE = function(t3, e4) {
      return e4 || Nt(t3, 4, this.length), 16777216 * this[t3] + (this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3]);
    }, ct.prototype.readIntLE = function(t3, e4, r3) {
      t3 |= 0, e4 |= 0, r3 || Nt(t3, e4, this.length);
      for (var n3 = this[t3], i3 = 1, o3 = 0; ++o3 < e4 && (i3 *= 256); )
        n3 += this[t3 + o3] * i3;
      return n3 >= (i3 *= 128) && (n3 -= Math.pow(2, 8 * e4)), n3;
    }, ct.prototype.readIntBE = function(t3, e4, r3) {
      t3 |= 0, e4 |= 0, r3 || Nt(t3, e4, this.length);
      for (var n3 = e4, i3 = 1, o3 = this[t3 + --n3]; n3 > 0 && (i3 *= 256); )
        o3 += this[t3 + --n3] * i3;
      return o3 >= (i3 *= 128) && (o3 -= Math.pow(2, 8 * e4)), o3;
    }, ct.prototype.readInt8 = function(t3, e4) {
      return e4 || Nt(t3, 1, this.length), 128 & this[t3] ? -1 * (255 - this[t3] + 1) : this[t3];
    }, ct.prototype.readInt16LE = function(t3, e4) {
      e4 || Nt(t3, 2, this.length);
      var r3 = this[t3] | this[t3 + 1] << 8;
      return 32768 & r3 ? 4294901760 | r3 : r3;
    }, ct.prototype.readInt16BE = function(t3, e4) {
      e4 || Nt(t3, 2, this.length);
      var r3 = this[t3 + 1] | this[t3] << 8;
      return 32768 & r3 ? 4294901760 | r3 : r3;
    }, ct.prototype.readInt32LE = function(t3, e4) {
      return e4 || Nt(t3, 4, this.length), this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16 | this[t3 + 3] << 24;
    }, ct.prototype.readInt32BE = function(t3, e4) {
      return e4 || Nt(t3, 4, this.length), this[t3] << 24 | this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3];
    }, ct.prototype.readFloatLE = function(t3, e4) {
      return e4 || Nt(t3, 4, this.length), it(this, t3, true, 23, 4);
    }, ct.prototype.readFloatBE = function(t3, e4) {
      return e4 || Nt(t3, 4, this.length), it(this, t3, false, 23, 4);
    }, ct.prototype.readDoubleLE = function(t3, e4) {
      return e4 || Nt(t3, 8, this.length), it(this, t3, true, 52, 8);
    }, ct.prototype.readDoubleBE = function(t3, e4) {
      return e4 || Nt(t3, 8, this.length), it(this, t3, false, 52, 8);
    }, ct.prototype.writeUIntLE = function(t3, e4, r3, n3) {
      (t3 = +t3, e4 |= 0, r3 |= 0, n3) || zt(this, t3, e4, r3, Math.pow(2, 8 * r3) - 1, 0);
      var i3 = 1, o3 = 0;
      for (this[e4] = 255 & t3; ++o3 < r3 && (i3 *= 256); )
        this[e4 + o3] = t3 / i3 & 255;
      return e4 + r3;
    }, ct.prototype.writeUIntBE = function(t3, e4, r3, n3) {
      (t3 = +t3, e4 |= 0, r3 |= 0, n3) || zt(this, t3, e4, r3, Math.pow(2, 8 * r3) - 1, 0);
      var i3 = r3 - 1, o3 = 1;
      for (this[e4 + i3] = 255 & t3; --i3 >= 0 && (o3 *= 256); )
        this[e4 + i3] = t3 / o3 & 255;
      return e4 + r3;
    }, ct.prototype.writeUInt8 = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 1, 255, 0), ct.TYPED_ARRAY_SUPPORT || (t3 = Math.floor(t3)), this[e4] = 255 & t3, e4 + 1;
    }, ct.prototype.writeUInt16LE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 2, 65535, 0), ct.TYPED_ARRAY_SUPPORT ? (this[e4] = 255 & t3, this[e4 + 1] = t3 >>> 8) : Ct(this, t3, e4, true), e4 + 2;
    }, ct.prototype.writeUInt16BE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 2, 65535, 0), ct.TYPED_ARRAY_SUPPORT ? (this[e4] = t3 >>> 8, this[e4 + 1] = 255 & t3) : Ct(this, t3, e4, false), e4 + 2;
    }, ct.prototype.writeUInt32LE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 4, 4294967295, 0), ct.TYPED_ARRAY_SUPPORT ? (this[e4 + 3] = t3 >>> 24, this[e4 + 2] = t3 >>> 16, this[e4 + 1] = t3 >>> 8, this[e4] = 255 & t3) : qt(this, t3, e4, true), e4 + 4;
    }, ct.prototype.writeUInt32BE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 4, 4294967295, 0), ct.TYPED_ARRAY_SUPPORT ? (this[e4] = t3 >>> 24, this[e4 + 1] = t3 >>> 16, this[e4 + 2] = t3 >>> 8, this[e4 + 3] = 255 & t3) : qt(this, t3, e4, false), e4 + 4;
    }, ct.prototype.writeIntLE = function(t3, e4, r3, n3) {
      if (t3 = +t3, e4 |= 0, !n3) {
        var i3 = Math.pow(2, 8 * r3 - 1);
        zt(this, t3, e4, r3, i3 - 1, -i3);
      }
      var o3 = 0, s3 = 1, a3 = 0;
      for (this[e4] = 255 & t3; ++o3 < r3 && (s3 *= 256); )
        t3 < 0 && 0 === a3 && 0 !== this[e4 + o3 - 1] && (a3 = 1), this[e4 + o3] = (t3 / s3 >> 0) - a3 & 255;
      return e4 + r3;
    }, ct.prototype.writeIntBE = function(t3, e4, r3, n3) {
      if (t3 = +t3, e4 |= 0, !n3) {
        var i3 = Math.pow(2, 8 * r3 - 1);
        zt(this, t3, e4, r3, i3 - 1, -i3);
      }
      var o3 = r3 - 1, s3 = 1, a3 = 0;
      for (this[e4 + o3] = 255 & t3; --o3 >= 0 && (s3 *= 256); )
        t3 < 0 && 0 === a3 && 0 !== this[e4 + o3 + 1] && (a3 = 1), this[e4 + o3] = (t3 / s3 >> 0) - a3 & 255;
      return e4 + r3;
    }, ct.prototype.writeInt8 = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 1, 127, -128), ct.TYPED_ARRAY_SUPPORT || (t3 = Math.floor(t3)), t3 < 0 && (t3 = 255 + t3 + 1), this[e4] = 255 & t3, e4 + 1;
    }, ct.prototype.writeInt16LE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 2, 32767, -32768), ct.TYPED_ARRAY_SUPPORT ? (this[e4] = 255 & t3, this[e4 + 1] = t3 >>> 8) : Ct(this, t3, e4, true), e4 + 2;
    }, ct.prototype.writeInt16BE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 2, 32767, -32768), ct.TYPED_ARRAY_SUPPORT ? (this[e4] = t3 >>> 8, this[e4 + 1] = 255 & t3) : Ct(this, t3, e4, false), e4 + 2;
    }, ct.prototype.writeInt32LE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 4, 2147483647, -2147483648), ct.TYPED_ARRAY_SUPPORT ? (this[e4] = 255 & t3, this[e4 + 1] = t3 >>> 8, this[e4 + 2] = t3 >>> 16, this[e4 + 3] = t3 >>> 24) : qt(this, t3, e4, true), e4 + 4;
    }, ct.prototype.writeInt32BE = function(t3, e4, r3) {
      return t3 = +t3, e4 |= 0, r3 || zt(this, t3, e4, 4, 2147483647, -2147483648), t3 < 0 && (t3 = 4294967295 + t3 + 1), ct.TYPED_ARRAY_SUPPORT ? (this[e4] = t3 >>> 24, this[e4 + 1] = t3 >>> 16, this[e4 + 2] = t3 >>> 8, this[e4 + 3] = 255 & t3) : qt(this, t3, e4, false), e4 + 4;
    }, ct.prototype.writeFloatLE = function(t3, e4, r3) {
      return Dt(this, t3, e4, true, r3);
    }, ct.prototype.writeFloatBE = function(t3, e4, r3) {
      return Dt(this, t3, e4, false, r3);
    }, ct.prototype.writeDoubleLE = function(t3, e4, r3) {
      return Ft(this, t3, e4, true, r3);
    }, ct.prototype.writeDoubleBE = function(t3, e4, r3) {
      return Ft(this, t3, e4, false, r3);
    }, ct.prototype.copy = function(t3, e4, r3, n3) {
      if (r3 || (r3 = 0), n3 || 0 === n3 || (n3 = this.length), e4 >= t3.length && (e4 = t3.length), e4 || (e4 = 0), n3 > 0 && n3 < r3 && (n3 = r3), n3 === r3)
        return 0;
      if (0 === t3.length || 0 === this.length)
        return 0;
      if (e4 < 0)
        throw new RangeError("targetStart out of bounds");
      if (r3 < 0 || r3 >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (n3 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n3 > this.length && (n3 = this.length), t3.length - e4 < n3 - r3 && (n3 = t3.length - e4 + r3);
      var i3, o3 = n3 - r3;
      if (this === t3 && r3 < e4 && e4 < n3)
        for (i3 = o3 - 1; i3 >= 0; --i3)
          t3[i3 + e4] = this[i3 + r3];
      else if (o3 < 1e3 || !ct.TYPED_ARRAY_SUPPORT)
        for (i3 = 0; i3 < o3; ++i3)
          t3[i3 + e4] = this[i3 + r3];
      else
        Uint8Array.prototype.set.call(t3, this.subarray(r3, r3 + o3), e4);
      return o3;
    }, ct.prototype.fill = function(t3, e4, r3, n3) {
      if ("string" == typeof t3) {
        if ("string" == typeof e4 ? (n3 = e4, e4 = 0, r3 = this.length) : "string" == typeof r3 && (n3 = r3, r3 = this.length), 1 === t3.length) {
          var i3 = t3.charCodeAt(0);
          i3 < 256 && (t3 = i3);
        }
        if (void 0 !== n3 && "string" != typeof n3)
          throw new TypeError("encoding must be a string");
        if ("string" == typeof n3 && !ct.isEncoding(n3))
          throw new TypeError("Unknown encoding: " + n3);
      } else
        "number" == typeof t3 && (t3 &= 255);
      if (e4 < 0 || this.length < e4 || this.length < r3)
        throw new RangeError("Out of range index");
      if (r3 <= e4)
        return this;
      var o3;
      if (e4 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, t3 || (t3 = 0), "number" == typeof t3)
        for (o3 = e4; o3 < r3; ++o3)
          this[o3] = t3;
      else {
        var s3 = yt(t3) ? t3 : Vt(new ct(t3, n3).toString()), a3 = s3.length;
        for (o3 = 0; o3 < r3 - e4; ++o3)
          this[o3 + e4] = s3[o3 % a3];
      }
      return this;
    };
    var Kt = /[^+\/0-9A-Za-z-_]/g;
    function Yt(t3) {
      return t3 < 16 ? "0" + t3.toString(16) : t3.toString(16);
    }
    function Vt(t3, e4) {
      var r3;
      e4 = e4 || 1 / 0;
      for (var n3 = t3.length, i3 = null, o3 = [], s3 = 0; s3 < n3; ++s3) {
        if ((r3 = t3.charCodeAt(s3)) > 55295 && r3 < 57344) {
          if (!i3) {
            if (r3 > 56319) {
              (e4 -= 3) > -1 && o3.push(239, 191, 189);
              continue;
            }
            if (s3 + 1 === n3) {
              (e4 -= 3) > -1 && o3.push(239, 191, 189);
              continue;
            }
            i3 = r3;
            continue;
          }
          if (r3 < 56320) {
            (e4 -= 3) > -1 && o3.push(239, 191, 189), i3 = r3;
            continue;
          }
          r3 = 65536 + (i3 - 55296 << 10 | r3 - 56320);
        } else
          i3 && (e4 -= 3) > -1 && o3.push(239, 191, 189);
        if (i3 = null, r3 < 128) {
          if ((e4 -= 1) < 0)
            break;
          o3.push(r3);
        } else if (r3 < 2048) {
          if ((e4 -= 2) < 0)
            break;
          o3.push(r3 >> 6 | 192, 63 & r3 | 128);
        } else if (r3 < 65536) {
          if ((e4 -= 3) < 0)
            break;
          o3.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
        } else {
          if (!(r3 < 1114112))
            throw new Error("Invalid code point");
          if ((e4 -= 4) < 0)
            break;
          o3.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
        }
      }
      return o3;
    }
    function Wt(t3) {
      return function(t4) {
        var e4, r3, n3, i3, o3, s3;
        tt || et();
        var a3 = t4.length;
        if (a3 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        o3 = "=" === t4[a3 - 2] ? 2 : "=" === t4[a3 - 1] ? 1 : 0, s3 = new Q2(3 * a3 / 4 - o3), n3 = o3 > 0 ? a3 - 4 : a3;
        var h3 = 0;
        for (e4 = 0, r3 = 0; e4 < n3; e4 += 4, r3 += 3)
          i3 = X2[t4.charCodeAt(e4)] << 18 | X2[t4.charCodeAt(e4 + 1)] << 12 | X2[t4.charCodeAt(e4 + 2)] << 6 | X2[t4.charCodeAt(e4 + 3)], s3[h3++] = i3 >> 16 & 255, s3[h3++] = i3 >> 8 & 255, s3[h3++] = 255 & i3;
        return 2 === o3 ? (i3 = X2[t4.charCodeAt(e4)] << 2 | X2[t4.charCodeAt(e4 + 1)] >> 4, s3[h3++] = 255 & i3) : 1 === o3 && (i3 = X2[t4.charCodeAt(e4)] << 10 | X2[t4.charCodeAt(e4 + 1)] << 4 | X2[t4.charCodeAt(e4 + 2)] >> 2, s3[h3++] = i3 >> 8 & 255, s3[h3++] = 255 & i3), s3;
      }(function(t4) {
        if ((t4 = function(t5) {
          return t5.trim ? t5.trim() : t5.replace(/^\s+|\s+$/g, "");
        }(t4).replace(Kt, "")).length < 2)
          return "";
        for (; t4.length % 4 != 0; )
          t4 += "=";
        return t4;
      }(t3));
    }
    function Ht(t3, e4, r3, n3) {
      for (var i3 = 0; i3 < n3 && !(i3 + r3 >= e4.length || i3 >= t3.length); ++i3)
        e4[i3 + r3] = t3[i3];
      return i3;
    }
    function $t(t3) {
      return null != t3 && (!!t3._isBuffer || Gt(t3) || function(t4) {
        return "function" == typeof t4.readFloatLE && "function" == typeof t4.slice && Gt(t4.slice(0, 0));
      }(t3));
    }
    function Gt(t3) {
      return !!t3.constructor && "function" == typeof t3.constructor.isBuffer && t3.constructor.isBuffer(t3);
    }
    var Zt = Object.freeze({ __proto__: null, Buffer: ct, INSPECT_MAX_BYTES: 50, SlowBuffer: function(t3) {
      return +t3 != t3 && (t3 = 0), ct.alloc(+t3);
    }, isBuffer: $t, kMaxLength: ht }), Jt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : {};
    function Xt(t3) {
      return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
    }
    function Qt(t3, e4) {
      return t3(e4 = { exports: {} }, e4.exports), e4.exports;
    }
    function te2(t3) {
      return t3 && t3.default || t3;
    }
    var ee2 = te2(Object.freeze({ __proto__: null, default: {} })), re2 = Qt(function(t3) {
      !function(t4) {
        var e4 = function(t5) {
          var e6, r4 = new Float64Array(16);
          if (t5)
            for (e6 = 0; e6 < t5.length; e6++)
              r4[e6] = t5[e6];
          return r4;
        }, r3 = function() {
          throw new Error("no PRNG");
        }, n3 = new Uint8Array(16), i3 = new Uint8Array(32);
        i3[0] = 9;
        var o3 = e4(), s3 = e4([1]), a3 = e4([56129, 1]), h3 = e4([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), f3 = e4([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), u3 = e4([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), c3 = e4([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), d3 = e4([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function l3(t5, e6, r4, n4) {
          t5[e6] = r4 >> 24 & 255, t5[e6 + 1] = r4 >> 16 & 255, t5[e6 + 2] = r4 >> 8 & 255, t5[e6 + 3] = 255 & r4, t5[e6 + 4] = n4 >> 24 & 255, t5[e6 + 5] = n4 >> 16 & 255, t5[e6 + 6] = n4 >> 8 & 255, t5[e6 + 7] = 255 & n4;
        }
        function p3(t5, e6, r4, n4, i4) {
          var o4, s4 = 0;
          for (o4 = 0; o4 < i4; o4++)
            s4 |= t5[e6 + o4] ^ r4[n4 + o4];
          return (1 & s4 - 1 >>> 8) - 1;
        }
        function b3(t5, e6, r4, n4) {
          return p3(t5, e6, r4, n4, 16);
        }
        function m3(t5, e6, r4, n4) {
          return p3(t5, e6, r4, n4, 32);
        }
        function y3(t5, e6, r4, n4) {
          !function(t6, e7, r5, n5) {
            for (var i4, o4 = 255 & n5[0] | (255 & n5[1]) << 8 | (255 & n5[2]) << 16 | (255 & n5[3]) << 24, s4 = 255 & r5[0] | (255 & r5[1]) << 8 | (255 & r5[2]) << 16 | (255 & r5[3]) << 24, a4 = 255 & r5[4] | (255 & r5[5]) << 8 | (255 & r5[6]) << 16 | (255 & r5[7]) << 24, h4 = 255 & r5[8] | (255 & r5[9]) << 8 | (255 & r5[10]) << 16 | (255 & r5[11]) << 24, f4 = 255 & r5[12] | (255 & r5[13]) << 8 | (255 & r5[14]) << 16 | (255 & r5[15]) << 24, u4 = 255 & n5[4] | (255 & n5[5]) << 8 | (255 & n5[6]) << 16 | (255 & n5[7]) << 24, c4 = 255 & e7[0] | (255 & e7[1]) << 8 | (255 & e7[2]) << 16 | (255 & e7[3]) << 24, d4 = 255 & e7[4] | (255 & e7[5]) << 8 | (255 & e7[6]) << 16 | (255 & e7[7]) << 24, l4 = 255 & e7[8] | (255 & e7[9]) << 8 | (255 & e7[10]) << 16 | (255 & e7[11]) << 24, p4 = 255 & e7[12] | (255 & e7[13]) << 8 | (255 & e7[14]) << 16 | (255 & e7[15]) << 24, b4 = 255 & n5[8] | (255 & n5[9]) << 8 | (255 & n5[10]) << 16 | (255 & n5[11]) << 24, m4 = 255 & r5[16] | (255 & r5[17]) << 8 | (255 & r5[18]) << 16 | (255 & r5[19]) << 24, y4 = 255 & r5[20] | (255 & r5[21]) << 8 | (255 & r5[22]) << 16 | (255 & r5[23]) << 24, g3 = 255 & r5[24] | (255 & r5[25]) << 8 | (255 & r5[26]) << 16 | (255 & r5[27]) << 24, v4 = 255 & r5[28] | (255 & r5[29]) << 8 | (255 & r5[30]) << 16 | (255 & r5[31]) << 24, w4 = 255 & n5[12] | (255 & n5[13]) << 8 | (255 & n5[14]) << 16 | (255 & n5[15]) << 24, M4 = o4, _4 = s4, A4 = a4, S4 = h4, E4 = f4, x4 = u4, I4 = c4, k4 = d4, R4 = l4, T4 = p4, B4 = b4, P4 = m4, O4 = y4, U4 = g3, L4 = v4, N4 = w4, z4 = 0; z4 < 20; z4 += 2)
              M4 ^= (i4 = (O4 ^= (i4 = (R4 ^= (i4 = (E4 ^= (i4 = M4 + O4 | 0) << 7 | i4 >>> 25) + M4 | 0) << 9 | i4 >>> 23) + E4 | 0) << 13 | i4 >>> 19) + R4 | 0) << 18 | i4 >>> 14, x4 ^= (i4 = (_4 ^= (i4 = (U4 ^= (i4 = (T4 ^= (i4 = x4 + _4 | 0) << 7 | i4 >>> 25) + x4 | 0) << 9 | i4 >>> 23) + T4 | 0) << 13 | i4 >>> 19) + U4 | 0) << 18 | i4 >>> 14, B4 ^= (i4 = (I4 ^= (i4 = (A4 ^= (i4 = (L4 ^= (i4 = B4 + I4 | 0) << 7 | i4 >>> 25) + B4 | 0) << 9 | i4 >>> 23) + L4 | 0) << 13 | i4 >>> 19) + A4 | 0) << 18 | i4 >>> 14, N4 ^= (i4 = (P4 ^= (i4 = (k4 ^= (i4 = (S4 ^= (i4 = N4 + P4 | 0) << 7 | i4 >>> 25) + N4 | 0) << 9 | i4 >>> 23) + S4 | 0) << 13 | i4 >>> 19) + k4 | 0) << 18 | i4 >>> 14, M4 ^= (i4 = (S4 ^= (i4 = (A4 ^= (i4 = (_4 ^= (i4 = M4 + S4 | 0) << 7 | i4 >>> 25) + M4 | 0) << 9 | i4 >>> 23) + _4 | 0) << 13 | i4 >>> 19) + A4 | 0) << 18 | i4 >>> 14, x4 ^= (i4 = (E4 ^= (i4 = (k4 ^= (i4 = (I4 ^= (i4 = x4 + E4 | 0) << 7 | i4 >>> 25) + x4 | 0) << 9 | i4 >>> 23) + I4 | 0) << 13 | i4 >>> 19) + k4 | 0) << 18 | i4 >>> 14, B4 ^= (i4 = (T4 ^= (i4 = (R4 ^= (i4 = (P4 ^= (i4 = B4 + T4 | 0) << 7 | i4 >>> 25) + B4 | 0) << 9 | i4 >>> 23) + P4 | 0) << 13 | i4 >>> 19) + R4 | 0) << 18 | i4 >>> 14, N4 ^= (i4 = (L4 ^= (i4 = (U4 ^= (i4 = (O4 ^= (i4 = N4 + L4 | 0) << 7 | i4 >>> 25) + N4 | 0) << 9 | i4 >>> 23) + O4 | 0) << 13 | i4 >>> 19) + U4 | 0) << 18 | i4 >>> 14;
            M4 = M4 + o4 | 0, _4 = _4 + s4 | 0, A4 = A4 + a4 | 0, S4 = S4 + h4 | 0, E4 = E4 + f4 | 0, x4 = x4 + u4 | 0, I4 = I4 + c4 | 0, k4 = k4 + d4 | 0, R4 = R4 + l4 | 0, T4 = T4 + p4 | 0, B4 = B4 + b4 | 0, P4 = P4 + m4 | 0, O4 = O4 + y4 | 0, U4 = U4 + g3 | 0, L4 = L4 + v4 | 0, N4 = N4 + w4 | 0, t6[0] = M4 >>> 0 & 255, t6[1] = M4 >>> 8 & 255, t6[2] = M4 >>> 16 & 255, t6[3] = M4 >>> 24 & 255, t6[4] = _4 >>> 0 & 255, t6[5] = _4 >>> 8 & 255, t6[6] = _4 >>> 16 & 255, t6[7] = _4 >>> 24 & 255, t6[8] = A4 >>> 0 & 255, t6[9] = A4 >>> 8 & 255, t6[10] = A4 >>> 16 & 255, t6[11] = A4 >>> 24 & 255, t6[12] = S4 >>> 0 & 255, t6[13] = S4 >>> 8 & 255, t6[14] = S4 >>> 16 & 255, t6[15] = S4 >>> 24 & 255, t6[16] = E4 >>> 0 & 255, t6[17] = E4 >>> 8 & 255, t6[18] = E4 >>> 16 & 255, t6[19] = E4 >>> 24 & 255, t6[20] = x4 >>> 0 & 255, t6[21] = x4 >>> 8 & 255, t6[22] = x4 >>> 16 & 255, t6[23] = x4 >>> 24 & 255, t6[24] = I4 >>> 0 & 255, t6[25] = I4 >>> 8 & 255, t6[26] = I4 >>> 16 & 255, t6[27] = I4 >>> 24 & 255, t6[28] = k4 >>> 0 & 255, t6[29] = k4 >>> 8 & 255, t6[30] = k4 >>> 16 & 255, t6[31] = k4 >>> 24 & 255, t6[32] = R4 >>> 0 & 255, t6[33] = R4 >>> 8 & 255, t6[34] = R4 >>> 16 & 255, t6[35] = R4 >>> 24 & 255, t6[36] = T4 >>> 0 & 255, t6[37] = T4 >>> 8 & 255, t6[38] = T4 >>> 16 & 255, t6[39] = T4 >>> 24 & 255, t6[40] = B4 >>> 0 & 255, t6[41] = B4 >>> 8 & 255, t6[42] = B4 >>> 16 & 255, t6[43] = B4 >>> 24 & 255, t6[44] = P4 >>> 0 & 255, t6[45] = P4 >>> 8 & 255, t6[46] = P4 >>> 16 & 255, t6[47] = P4 >>> 24 & 255, t6[48] = O4 >>> 0 & 255, t6[49] = O4 >>> 8 & 255, t6[50] = O4 >>> 16 & 255, t6[51] = O4 >>> 24 & 255, t6[52] = U4 >>> 0 & 255, t6[53] = U4 >>> 8 & 255, t6[54] = U4 >>> 16 & 255, t6[55] = U4 >>> 24 & 255, t6[56] = L4 >>> 0 & 255, t6[57] = L4 >>> 8 & 255, t6[58] = L4 >>> 16 & 255, t6[59] = L4 >>> 24 & 255, t6[60] = N4 >>> 0 & 255, t6[61] = N4 >>> 8 & 255, t6[62] = N4 >>> 16 & 255, t6[63] = N4 >>> 24 & 255;
          }(t5, e6, r4, n4);
        }
        function g2(t5, e6, r4, n4) {
          !function(t6, e7, r5, n5) {
            for (var i4, o4 = 255 & n5[0] | (255 & n5[1]) << 8 | (255 & n5[2]) << 16 | (255 & n5[3]) << 24, s4 = 255 & r5[0] | (255 & r5[1]) << 8 | (255 & r5[2]) << 16 | (255 & r5[3]) << 24, a4 = 255 & r5[4] | (255 & r5[5]) << 8 | (255 & r5[6]) << 16 | (255 & r5[7]) << 24, h4 = 255 & r5[8] | (255 & r5[9]) << 8 | (255 & r5[10]) << 16 | (255 & r5[11]) << 24, f4 = 255 & r5[12] | (255 & r5[13]) << 8 | (255 & r5[14]) << 16 | (255 & r5[15]) << 24, u4 = 255 & n5[4] | (255 & n5[5]) << 8 | (255 & n5[6]) << 16 | (255 & n5[7]) << 24, c4 = 255 & e7[0] | (255 & e7[1]) << 8 | (255 & e7[2]) << 16 | (255 & e7[3]) << 24, d4 = 255 & e7[4] | (255 & e7[5]) << 8 | (255 & e7[6]) << 16 | (255 & e7[7]) << 24, l4 = 255 & e7[8] | (255 & e7[9]) << 8 | (255 & e7[10]) << 16 | (255 & e7[11]) << 24, p4 = 255 & e7[12] | (255 & e7[13]) << 8 | (255 & e7[14]) << 16 | (255 & e7[15]) << 24, b4 = 255 & n5[8] | (255 & n5[9]) << 8 | (255 & n5[10]) << 16 | (255 & n5[11]) << 24, m4 = 255 & r5[16] | (255 & r5[17]) << 8 | (255 & r5[18]) << 16 | (255 & r5[19]) << 24, y4 = 255 & r5[20] | (255 & r5[21]) << 8 | (255 & r5[22]) << 16 | (255 & r5[23]) << 24, g3 = 255 & r5[24] | (255 & r5[25]) << 8 | (255 & r5[26]) << 16 | (255 & r5[27]) << 24, v4 = 255 & r5[28] | (255 & r5[29]) << 8 | (255 & r5[30]) << 16 | (255 & r5[31]) << 24, w4 = 255 & n5[12] | (255 & n5[13]) << 8 | (255 & n5[14]) << 16 | (255 & n5[15]) << 24, M4 = 0; M4 < 20; M4 += 2)
              o4 ^= (i4 = (y4 ^= (i4 = (l4 ^= (i4 = (f4 ^= (i4 = o4 + y4 | 0) << 7 | i4 >>> 25) + o4 | 0) << 9 | i4 >>> 23) + f4 | 0) << 13 | i4 >>> 19) + l4 | 0) << 18 | i4 >>> 14, u4 ^= (i4 = (s4 ^= (i4 = (g3 ^= (i4 = (p4 ^= (i4 = u4 + s4 | 0) << 7 | i4 >>> 25) + u4 | 0) << 9 | i4 >>> 23) + p4 | 0) << 13 | i4 >>> 19) + g3 | 0) << 18 | i4 >>> 14, b4 ^= (i4 = (c4 ^= (i4 = (a4 ^= (i4 = (v4 ^= (i4 = b4 + c4 | 0) << 7 | i4 >>> 25) + b4 | 0) << 9 | i4 >>> 23) + v4 | 0) << 13 | i4 >>> 19) + a4 | 0) << 18 | i4 >>> 14, w4 ^= (i4 = (m4 ^= (i4 = (d4 ^= (i4 = (h4 ^= (i4 = w4 + m4 | 0) << 7 | i4 >>> 25) + w4 | 0) << 9 | i4 >>> 23) + h4 | 0) << 13 | i4 >>> 19) + d4 | 0) << 18 | i4 >>> 14, o4 ^= (i4 = (h4 ^= (i4 = (a4 ^= (i4 = (s4 ^= (i4 = o4 + h4 | 0) << 7 | i4 >>> 25) + o4 | 0) << 9 | i4 >>> 23) + s4 | 0) << 13 | i4 >>> 19) + a4 | 0) << 18 | i4 >>> 14, u4 ^= (i4 = (f4 ^= (i4 = (d4 ^= (i4 = (c4 ^= (i4 = u4 + f4 | 0) << 7 | i4 >>> 25) + u4 | 0) << 9 | i4 >>> 23) + c4 | 0) << 13 | i4 >>> 19) + d4 | 0) << 18 | i4 >>> 14, b4 ^= (i4 = (p4 ^= (i4 = (l4 ^= (i4 = (m4 ^= (i4 = b4 + p4 | 0) << 7 | i4 >>> 25) + b4 | 0) << 9 | i4 >>> 23) + m4 | 0) << 13 | i4 >>> 19) + l4 | 0) << 18 | i4 >>> 14, w4 ^= (i4 = (v4 ^= (i4 = (g3 ^= (i4 = (y4 ^= (i4 = w4 + v4 | 0) << 7 | i4 >>> 25) + w4 | 0) << 9 | i4 >>> 23) + y4 | 0) << 13 | i4 >>> 19) + g3 | 0) << 18 | i4 >>> 14;
            t6[0] = o4 >>> 0 & 255, t6[1] = o4 >>> 8 & 255, t6[2] = o4 >>> 16 & 255, t6[3] = o4 >>> 24 & 255, t6[4] = u4 >>> 0 & 255, t6[5] = u4 >>> 8 & 255, t6[6] = u4 >>> 16 & 255, t6[7] = u4 >>> 24 & 255, t6[8] = b4 >>> 0 & 255, t6[9] = b4 >>> 8 & 255, t6[10] = b4 >>> 16 & 255, t6[11] = b4 >>> 24 & 255, t6[12] = w4 >>> 0 & 255, t6[13] = w4 >>> 8 & 255, t6[14] = w4 >>> 16 & 255, t6[15] = w4 >>> 24 & 255, t6[16] = c4 >>> 0 & 255, t6[17] = c4 >>> 8 & 255, t6[18] = c4 >>> 16 & 255, t6[19] = c4 >>> 24 & 255, t6[20] = d4 >>> 0 & 255, t6[21] = d4 >>> 8 & 255, t6[22] = d4 >>> 16 & 255, t6[23] = d4 >>> 24 & 255, t6[24] = l4 >>> 0 & 255, t6[25] = l4 >>> 8 & 255, t6[26] = l4 >>> 16 & 255, t6[27] = l4 >>> 24 & 255, t6[28] = p4 >>> 0 & 255, t6[29] = p4 >>> 8 & 255, t6[30] = p4 >>> 16 & 255, t6[31] = p4 >>> 24 & 255;
          }(t5, e6, r4, n4);
        }
        var v3 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function w3(t5, e6, r4, n4, i4, o4, s4) {
          var a4, h4, f4 = new Uint8Array(16), u4 = new Uint8Array(64);
          for (h4 = 0; h4 < 16; h4++)
            f4[h4] = 0;
          for (h4 = 0; h4 < 8; h4++)
            f4[h4] = o4[h4];
          for (; i4 >= 64; ) {
            for (y3(u4, f4, s4, v3), h4 = 0; h4 < 64; h4++)
              t5[e6 + h4] = r4[n4 + h4] ^ u4[h4];
            for (a4 = 1, h4 = 8; h4 < 16; h4++)
              a4 = a4 + (255 & f4[h4]) | 0, f4[h4] = 255 & a4, a4 >>>= 8;
            i4 -= 64, e6 += 64, n4 += 64;
          }
          if (i4 > 0)
            for (y3(u4, f4, s4, v3), h4 = 0; h4 < i4; h4++)
              t5[e6 + h4] = r4[n4 + h4] ^ u4[h4];
          return 0;
        }
        function M3(t5, e6, r4, n4, i4) {
          var o4, s4, a4 = new Uint8Array(16), h4 = new Uint8Array(64);
          for (s4 = 0; s4 < 16; s4++)
            a4[s4] = 0;
          for (s4 = 0; s4 < 8; s4++)
            a4[s4] = n4[s4];
          for (; r4 >= 64; ) {
            for (y3(h4, a4, i4, v3), s4 = 0; s4 < 64; s4++)
              t5[e6 + s4] = h4[s4];
            for (o4 = 1, s4 = 8; s4 < 16; s4++)
              o4 = o4 + (255 & a4[s4]) | 0, a4[s4] = 255 & o4, o4 >>>= 8;
            r4 -= 64, e6 += 64;
          }
          if (r4 > 0)
            for (y3(h4, a4, i4, v3), s4 = 0; s4 < r4; s4++)
              t5[e6 + s4] = h4[s4];
          return 0;
        }
        function _3(t5, e6, r4, n4, i4) {
          var o4 = new Uint8Array(32);
          g2(o4, n4, i4, v3);
          for (var s4 = new Uint8Array(8), a4 = 0; a4 < 8; a4++)
            s4[a4] = n4[a4 + 16];
          return M3(t5, e6, r4, s4, o4);
        }
        function A3(t5, e6, r4, n4, i4, o4, s4) {
          var a4 = new Uint8Array(32);
          g2(a4, o4, s4, v3);
          for (var h4 = new Uint8Array(8), f4 = 0; f4 < 8; f4++)
            h4[f4] = o4[f4 + 16];
          return w3(t5, e6, r4, n4, i4, h4, a4);
        }
        var S3 = function(t5) {
          var e6, r4, n4, i4, o4, s4, a4, h4;
          this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, e6 = 255 & t5[0] | (255 & t5[1]) << 8, this.r[0] = 8191 & e6, r4 = 255 & t5[2] | (255 & t5[3]) << 8, this.r[1] = 8191 & (e6 >>> 13 | r4 << 3), n4 = 255 & t5[4] | (255 & t5[5]) << 8, this.r[2] = 7939 & (r4 >>> 10 | n4 << 6), i4 = 255 & t5[6] | (255 & t5[7]) << 8, this.r[3] = 8191 & (n4 >>> 7 | i4 << 9), o4 = 255 & t5[8] | (255 & t5[9]) << 8, this.r[4] = 255 & (i4 >>> 4 | o4 << 12), this.r[5] = o4 >>> 1 & 8190, s4 = 255 & t5[10] | (255 & t5[11]) << 8, this.r[6] = 8191 & (o4 >>> 14 | s4 << 2), a4 = 255 & t5[12] | (255 & t5[13]) << 8, this.r[7] = 8065 & (s4 >>> 11 | a4 << 5), h4 = 255 & t5[14] | (255 & t5[15]) << 8, this.r[8] = 8191 & (a4 >>> 8 | h4 << 8), this.r[9] = h4 >>> 5 & 127, this.pad[0] = 255 & t5[16] | (255 & t5[17]) << 8, this.pad[1] = 255 & t5[18] | (255 & t5[19]) << 8, this.pad[2] = 255 & t5[20] | (255 & t5[21]) << 8, this.pad[3] = 255 & t5[22] | (255 & t5[23]) << 8, this.pad[4] = 255 & t5[24] | (255 & t5[25]) << 8, this.pad[5] = 255 & t5[26] | (255 & t5[27]) << 8, this.pad[6] = 255 & t5[28] | (255 & t5[29]) << 8, this.pad[7] = 255 & t5[30] | (255 & t5[31]) << 8;
        };
        function E3(t5, e6, r4, n4, i4, o4) {
          var s4 = new S3(o4);
          return s4.update(r4, n4, i4), s4.finish(t5, e6), 0;
        }
        function x3(t5, e6, r4, n4, i4, o4) {
          var s4 = new Uint8Array(16);
          return E3(s4, 0, r4, n4, i4, o4), b3(t5, e6, s4, 0);
        }
        function I3(t5, e6, r4, n4, i4) {
          var o4;
          if (r4 < 32)
            return -1;
          for (A3(t5, 0, e6, 0, r4, n4, i4), E3(t5, 16, t5, 32, r4 - 32, t5), o4 = 0; o4 < 16; o4++)
            t5[o4] = 0;
          return 0;
        }
        function k3(t5, e6, r4, n4, i4) {
          var o4, s4 = new Uint8Array(32);
          if (r4 < 32)
            return -1;
          if (_3(s4, 0, 32, n4, i4), 0 !== x3(e6, 16, e6, 32, r4 - 32, s4))
            return -1;
          for (A3(t5, 0, e6, 0, r4, n4, i4), o4 = 0; o4 < 32; o4++)
            t5[o4] = 0;
          return 0;
        }
        function R3(t5, e6) {
          var r4;
          for (r4 = 0; r4 < 16; r4++)
            t5[r4] = 0 | e6[r4];
        }
        function T3(t5) {
          var e6, r4, n4 = 1;
          for (e6 = 0; e6 < 16; e6++)
            r4 = t5[e6] + n4 + 65535, n4 = Math.floor(r4 / 65536), t5[e6] = r4 - 65536 * n4;
          t5[0] += n4 - 1 + 37 * (n4 - 1);
        }
        function B3(t5, e6, r4) {
          for (var n4, i4 = ~(r4 - 1), o4 = 0; o4 < 16; o4++)
            n4 = i4 & (t5[o4] ^ e6[o4]), t5[o4] ^= n4, e6[o4] ^= n4;
        }
        function P3(t5, r4) {
          var n4, i4, o4, s4 = e4(), a4 = e4();
          for (n4 = 0; n4 < 16; n4++)
            a4[n4] = r4[n4];
          for (T3(a4), T3(a4), T3(a4), i4 = 0; i4 < 2; i4++) {
            for (s4[0] = a4[0] - 65517, n4 = 1; n4 < 15; n4++)
              s4[n4] = a4[n4] - 65535 - (s4[n4 - 1] >> 16 & 1), s4[n4 - 1] &= 65535;
            s4[15] = a4[15] - 32767 - (s4[14] >> 16 & 1), o4 = s4[15] >> 16 & 1, s4[14] &= 65535, B3(a4, s4, 1 - o4);
          }
          for (n4 = 0; n4 < 16; n4++)
            t5[2 * n4] = 255 & a4[n4], t5[2 * n4 + 1] = a4[n4] >> 8;
        }
        function O3(t5, e6) {
          var r4 = new Uint8Array(32), n4 = new Uint8Array(32);
          return P3(r4, t5), P3(n4, e6), m3(r4, 0, n4, 0);
        }
        function U3(t5) {
          var e6 = new Uint8Array(32);
          return P3(e6, t5), 1 & e6[0];
        }
        function L3(t5, e6) {
          var r4;
          for (r4 = 0; r4 < 16; r4++)
            t5[r4] = e6[2 * r4] + (e6[2 * r4 + 1] << 8);
          t5[15] &= 32767;
        }
        function N3(t5, e6, r4) {
          for (var n4 = 0; n4 < 16; n4++)
            t5[n4] = e6[n4] + r4[n4];
        }
        function z3(t5, e6, r4) {
          for (var n4 = 0; n4 < 16; n4++)
            t5[n4] = e6[n4] - r4[n4];
        }
        function C3(t5, e6, r4) {
          var n4, i4, o4 = 0, s4 = 0, a4 = 0, h4 = 0, f4 = 0, u4 = 0, c4 = 0, d4 = 0, l4 = 0, p4 = 0, b4 = 0, m4 = 0, y4 = 0, g3 = 0, v4 = 0, w4 = 0, M4 = 0, _4 = 0, A4 = 0, S4 = 0, E4 = 0, x4 = 0, I4 = 0, k4 = 0, R4 = 0, T4 = 0, B4 = 0, P4 = 0, O4 = 0, U4 = 0, L4 = 0, N4 = r4[0], z4 = r4[1], C4 = r4[2], q4 = r4[3], j4 = r4[4], D4 = r4[5], F4 = r4[6], K4 = r4[7], Y4 = r4[8], V4 = r4[9], W4 = r4[10], H4 = r4[11], $4 = r4[12], G4 = r4[13], Z4 = r4[14], J4 = r4[15];
          o4 += (n4 = e6[0]) * N4, s4 += n4 * z4, a4 += n4 * C4, h4 += n4 * q4, f4 += n4 * j4, u4 += n4 * D4, c4 += n4 * F4, d4 += n4 * K4, l4 += n4 * Y4, p4 += n4 * V4, b4 += n4 * W4, m4 += n4 * H4, y4 += n4 * $4, g3 += n4 * G4, v4 += n4 * Z4, w4 += n4 * J4, s4 += (n4 = e6[1]) * N4, a4 += n4 * z4, h4 += n4 * C4, f4 += n4 * q4, u4 += n4 * j4, c4 += n4 * D4, d4 += n4 * F4, l4 += n4 * K4, p4 += n4 * Y4, b4 += n4 * V4, m4 += n4 * W4, y4 += n4 * H4, g3 += n4 * $4, v4 += n4 * G4, w4 += n4 * Z4, M4 += n4 * J4, a4 += (n4 = e6[2]) * N4, h4 += n4 * z4, f4 += n4 * C4, u4 += n4 * q4, c4 += n4 * j4, d4 += n4 * D4, l4 += n4 * F4, p4 += n4 * K4, b4 += n4 * Y4, m4 += n4 * V4, y4 += n4 * W4, g3 += n4 * H4, v4 += n4 * $4, w4 += n4 * G4, M4 += n4 * Z4, _4 += n4 * J4, h4 += (n4 = e6[3]) * N4, f4 += n4 * z4, u4 += n4 * C4, c4 += n4 * q4, d4 += n4 * j4, l4 += n4 * D4, p4 += n4 * F4, b4 += n4 * K4, m4 += n4 * Y4, y4 += n4 * V4, g3 += n4 * W4, v4 += n4 * H4, w4 += n4 * $4, M4 += n4 * G4, _4 += n4 * Z4, A4 += n4 * J4, f4 += (n4 = e6[4]) * N4, u4 += n4 * z4, c4 += n4 * C4, d4 += n4 * q4, l4 += n4 * j4, p4 += n4 * D4, b4 += n4 * F4, m4 += n4 * K4, y4 += n4 * Y4, g3 += n4 * V4, v4 += n4 * W4, w4 += n4 * H4, M4 += n4 * $4, _4 += n4 * G4, A4 += n4 * Z4, S4 += n4 * J4, u4 += (n4 = e6[5]) * N4, c4 += n4 * z4, d4 += n4 * C4, l4 += n4 * q4, p4 += n4 * j4, b4 += n4 * D4, m4 += n4 * F4, y4 += n4 * K4, g3 += n4 * Y4, v4 += n4 * V4, w4 += n4 * W4, M4 += n4 * H4, _4 += n4 * $4, A4 += n4 * G4, S4 += n4 * Z4, E4 += n4 * J4, c4 += (n4 = e6[6]) * N4, d4 += n4 * z4, l4 += n4 * C4, p4 += n4 * q4, b4 += n4 * j4, m4 += n4 * D4, y4 += n4 * F4, g3 += n4 * K4, v4 += n4 * Y4, w4 += n4 * V4, M4 += n4 * W4, _4 += n4 * H4, A4 += n4 * $4, S4 += n4 * G4, E4 += n4 * Z4, x4 += n4 * J4, d4 += (n4 = e6[7]) * N4, l4 += n4 * z4, p4 += n4 * C4, b4 += n4 * q4, m4 += n4 * j4, y4 += n4 * D4, g3 += n4 * F4, v4 += n4 * K4, w4 += n4 * Y4, M4 += n4 * V4, _4 += n4 * W4, A4 += n4 * H4, S4 += n4 * $4, E4 += n4 * G4, x4 += n4 * Z4, I4 += n4 * J4, l4 += (n4 = e6[8]) * N4, p4 += n4 * z4, b4 += n4 * C4, m4 += n4 * q4, y4 += n4 * j4, g3 += n4 * D4, v4 += n4 * F4, w4 += n4 * K4, M4 += n4 * Y4, _4 += n4 * V4, A4 += n4 * W4, S4 += n4 * H4, E4 += n4 * $4, x4 += n4 * G4, I4 += n4 * Z4, k4 += n4 * J4, p4 += (n4 = e6[9]) * N4, b4 += n4 * z4, m4 += n4 * C4, y4 += n4 * q4, g3 += n4 * j4, v4 += n4 * D4, w4 += n4 * F4, M4 += n4 * K4, _4 += n4 * Y4, A4 += n4 * V4, S4 += n4 * W4, E4 += n4 * H4, x4 += n4 * $4, I4 += n4 * G4, k4 += n4 * Z4, R4 += n4 * J4, b4 += (n4 = e6[10]) * N4, m4 += n4 * z4, y4 += n4 * C4, g3 += n4 * q4, v4 += n4 * j4, w4 += n4 * D4, M4 += n4 * F4, _4 += n4 * K4, A4 += n4 * Y4, S4 += n4 * V4, E4 += n4 * W4, x4 += n4 * H4, I4 += n4 * $4, k4 += n4 * G4, R4 += n4 * Z4, T4 += n4 * J4, m4 += (n4 = e6[11]) * N4, y4 += n4 * z4, g3 += n4 * C4, v4 += n4 * q4, w4 += n4 * j4, M4 += n4 * D4, _4 += n4 * F4, A4 += n4 * K4, S4 += n4 * Y4, E4 += n4 * V4, x4 += n4 * W4, I4 += n4 * H4, k4 += n4 * $4, R4 += n4 * G4, T4 += n4 * Z4, B4 += n4 * J4, y4 += (n4 = e6[12]) * N4, g3 += n4 * z4, v4 += n4 * C4, w4 += n4 * q4, M4 += n4 * j4, _4 += n4 * D4, A4 += n4 * F4, S4 += n4 * K4, E4 += n4 * Y4, x4 += n4 * V4, I4 += n4 * W4, k4 += n4 * H4, R4 += n4 * $4, T4 += n4 * G4, B4 += n4 * Z4, P4 += n4 * J4, g3 += (n4 = e6[13]) * N4, v4 += n4 * z4, w4 += n4 * C4, M4 += n4 * q4, _4 += n4 * j4, A4 += n4 * D4, S4 += n4 * F4, E4 += n4 * K4, x4 += n4 * Y4, I4 += n4 * V4, k4 += n4 * W4, R4 += n4 * H4, T4 += n4 * $4, B4 += n4 * G4, P4 += n4 * Z4, O4 += n4 * J4, v4 += (n4 = e6[14]) * N4, w4 += n4 * z4, M4 += n4 * C4, _4 += n4 * q4, A4 += n4 * j4, S4 += n4 * D4, E4 += n4 * F4, x4 += n4 * K4, I4 += n4 * Y4, k4 += n4 * V4, R4 += n4 * W4, T4 += n4 * H4, B4 += n4 * $4, P4 += n4 * G4, O4 += n4 * Z4, U4 += n4 * J4, w4 += (n4 = e6[15]) * N4, s4 += 38 * (_4 += n4 * C4), a4 += 38 * (A4 += n4 * q4), h4 += 38 * (S4 += n4 * j4), f4 += 38 * (E4 += n4 * D4), u4 += 38 * (x4 += n4 * F4), c4 += 38 * (I4 += n4 * K4), d4 += 38 * (k4 += n4 * Y4), l4 += 38 * (R4 += n4 * V4), p4 += 38 * (T4 += n4 * W4), b4 += 38 * (B4 += n4 * H4), m4 += 38 * (P4 += n4 * $4), y4 += 38 * (O4 += n4 * G4), g3 += 38 * (U4 += n4 * Z4), v4 += 38 * (L4 += n4 * J4), o4 = (n4 = (o4 += 38 * (M4 += n4 * z4)) + (i4 = 1) + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), s4 = (n4 = s4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), a4 = (n4 = a4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), h4 = (n4 = h4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), f4 = (n4 = f4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), u4 = (n4 = u4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), c4 = (n4 = c4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), d4 = (n4 = d4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), l4 = (n4 = l4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), p4 = (n4 = p4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), b4 = (n4 = b4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), m4 = (n4 = m4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), y4 = (n4 = y4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), g3 = (n4 = g3 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), v4 = (n4 = v4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), w4 = (n4 = w4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), o4 = (n4 = (o4 += i4 - 1 + 37 * (i4 - 1)) + (i4 = 1) + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), s4 = (n4 = s4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), a4 = (n4 = a4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), h4 = (n4 = h4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), f4 = (n4 = f4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), u4 = (n4 = u4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), c4 = (n4 = c4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), d4 = (n4 = d4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), l4 = (n4 = l4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), p4 = (n4 = p4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), b4 = (n4 = b4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), m4 = (n4 = m4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), y4 = (n4 = y4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), g3 = (n4 = g3 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), v4 = (n4 = v4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), w4 = (n4 = w4 + i4 + 65535) - 65536 * (i4 = Math.floor(n4 / 65536)), o4 += i4 - 1 + 37 * (i4 - 1), t5[0] = o4, t5[1] = s4, t5[2] = a4, t5[3] = h4, t5[4] = f4, t5[5] = u4, t5[6] = c4, t5[7] = d4, t5[8] = l4, t5[9] = p4, t5[10] = b4, t5[11] = m4, t5[12] = y4, t5[13] = g3, t5[14] = v4, t5[15] = w4;
        }
        function q3(t5, e6) {
          C3(t5, e6, e6);
        }
        function j3(t5, r4) {
          var n4, i4 = e4();
          for (n4 = 0; n4 < 16; n4++)
            i4[n4] = r4[n4];
          for (n4 = 253; n4 >= 0; n4--)
            q3(i4, i4), 2 !== n4 && 4 !== n4 && C3(i4, i4, r4);
          for (n4 = 0; n4 < 16; n4++)
            t5[n4] = i4[n4];
        }
        function D3(t5, r4) {
          var n4, i4 = e4();
          for (n4 = 0; n4 < 16; n4++)
            i4[n4] = r4[n4];
          for (n4 = 250; n4 >= 0; n4--)
            q3(i4, i4), 1 !== n4 && C3(i4, i4, r4);
          for (n4 = 0; n4 < 16; n4++)
            t5[n4] = i4[n4];
        }
        function F3(t5, r4, n4) {
          var i4, o4, s4 = new Uint8Array(32), h4 = new Float64Array(80), f4 = e4(), u4 = e4(), c4 = e4(), d4 = e4(), l4 = e4(), p4 = e4();
          for (o4 = 0; o4 < 31; o4++)
            s4[o4] = r4[o4];
          for (s4[31] = 127 & r4[31] | 64, s4[0] &= 248, L3(h4, n4), o4 = 0; o4 < 16; o4++)
            u4[o4] = h4[o4], d4[o4] = f4[o4] = c4[o4] = 0;
          for (f4[0] = d4[0] = 1, o4 = 254; o4 >= 0; --o4)
            B3(f4, u4, i4 = s4[o4 >>> 3] >>> (7 & o4) & 1), B3(c4, d4, i4), N3(l4, f4, c4), z3(f4, f4, c4), N3(c4, u4, d4), z3(u4, u4, d4), q3(d4, l4), q3(p4, f4), C3(f4, c4, f4), C3(c4, u4, l4), N3(l4, f4, c4), z3(f4, f4, c4), q3(u4, f4), z3(c4, d4, p4), C3(f4, c4, a3), N3(f4, f4, d4), C3(c4, c4, f4), C3(f4, d4, p4), C3(d4, u4, h4), q3(u4, l4), B3(f4, u4, i4), B3(c4, d4, i4);
          for (o4 = 0; o4 < 16; o4++)
            h4[o4 + 16] = f4[o4], h4[o4 + 32] = c4[o4], h4[o4 + 48] = u4[o4], h4[o4 + 64] = d4[o4];
          var b4 = h4.subarray(32), m4 = h4.subarray(16);
          return j3(b4, b4), C3(m4, m4, b4), P3(t5, m4), 0;
        }
        function K3(t5, e6) {
          return F3(t5, e6, i3);
        }
        function Y3(t5, e6) {
          return r3(e6, 32), K3(t5, e6);
        }
        function V3(t5, e6, r4) {
          var i4 = new Uint8Array(32);
          return F3(i4, r4, e6), g2(t5, n3, i4, v3);
        }
        S3.prototype.blocks = function(t5, e6, r4) {
          for (var n4, i4, o4, s4, a4, h4, f4, u4, c4, d4, l4, p4, b4, m4, y4, g3, v4, w4, M4, _4 = this.fin ? 0 : 2048, A4 = this.h[0], S4 = this.h[1], E4 = this.h[2], x4 = this.h[3], I4 = this.h[4], k4 = this.h[5], R4 = this.h[6], T4 = this.h[7], B4 = this.h[8], P4 = this.h[9], O4 = this.r[0], U4 = this.r[1], L4 = this.r[2], N4 = this.r[3], z4 = this.r[4], C4 = this.r[5], q4 = this.r[6], j4 = this.r[7], D4 = this.r[8], F4 = this.r[9]; r4 >= 16; )
            d4 = c4 = 0, d4 += (A4 += 8191 & (n4 = 255 & t5[e6 + 0] | (255 & t5[e6 + 1]) << 8)) * O4, d4 += (S4 += 8191 & (n4 >>> 13 | (i4 = 255 & t5[e6 + 2] | (255 & t5[e6 + 3]) << 8) << 3)) * (5 * F4), d4 += (E4 += 8191 & (i4 >>> 10 | (o4 = 255 & t5[e6 + 4] | (255 & t5[e6 + 5]) << 8) << 6)) * (5 * D4), d4 += (x4 += 8191 & (o4 >>> 7 | (s4 = 255 & t5[e6 + 6] | (255 & t5[e6 + 7]) << 8) << 9)) * (5 * j4), c4 = (d4 += (I4 += 8191 & (s4 >>> 4 | (a4 = 255 & t5[e6 + 8] | (255 & t5[e6 + 9]) << 8) << 12)) * (5 * q4)) >>> 13, d4 &= 8191, d4 += (k4 += a4 >>> 1 & 8191) * (5 * C4), d4 += (R4 += 8191 & (a4 >>> 14 | (h4 = 255 & t5[e6 + 10] | (255 & t5[e6 + 11]) << 8) << 2)) * (5 * z4), d4 += (T4 += 8191 & (h4 >>> 11 | (f4 = 255 & t5[e6 + 12] | (255 & t5[e6 + 13]) << 8) << 5)) * (5 * N4), d4 += (B4 += 8191 & (f4 >>> 8 | (u4 = 255 & t5[e6 + 14] | (255 & t5[e6 + 15]) << 8) << 8)) * (5 * L4), l4 = c4 += (d4 += (P4 += u4 >>> 5 | _4) * (5 * U4)) >>> 13, l4 += A4 * U4, l4 += S4 * O4, l4 += E4 * (5 * F4), l4 += x4 * (5 * D4), c4 = (l4 += I4 * (5 * j4)) >>> 13, l4 &= 8191, l4 += k4 * (5 * q4), l4 += R4 * (5 * C4), l4 += T4 * (5 * z4), l4 += B4 * (5 * N4), c4 += (l4 += P4 * (5 * L4)) >>> 13, l4 &= 8191, p4 = c4, p4 += A4 * L4, p4 += S4 * U4, p4 += E4 * O4, p4 += x4 * (5 * F4), c4 = (p4 += I4 * (5 * D4)) >>> 13, p4 &= 8191, p4 += k4 * (5 * j4), p4 += R4 * (5 * q4), p4 += T4 * (5 * C4), p4 += B4 * (5 * z4), b4 = c4 += (p4 += P4 * (5 * N4)) >>> 13, b4 += A4 * N4, b4 += S4 * L4, b4 += E4 * U4, b4 += x4 * O4, c4 = (b4 += I4 * (5 * F4)) >>> 13, b4 &= 8191, b4 += k4 * (5 * D4), b4 += R4 * (5 * j4), b4 += T4 * (5 * q4), b4 += B4 * (5 * C4), m4 = c4 += (b4 += P4 * (5 * z4)) >>> 13, m4 += A4 * z4, m4 += S4 * N4, m4 += E4 * L4, m4 += x4 * U4, c4 = (m4 += I4 * O4) >>> 13, m4 &= 8191, m4 += k4 * (5 * F4), m4 += R4 * (5 * D4), m4 += T4 * (5 * j4), m4 += B4 * (5 * q4), y4 = c4 += (m4 += P4 * (5 * C4)) >>> 13, y4 += A4 * C4, y4 += S4 * z4, y4 += E4 * N4, y4 += x4 * L4, c4 = (y4 += I4 * U4) >>> 13, y4 &= 8191, y4 += k4 * O4, y4 += R4 * (5 * F4), y4 += T4 * (5 * D4), y4 += B4 * (5 * j4), g3 = c4 += (y4 += P4 * (5 * q4)) >>> 13, g3 += A4 * q4, g3 += S4 * C4, g3 += E4 * z4, g3 += x4 * N4, c4 = (g3 += I4 * L4) >>> 13, g3 &= 8191, g3 += k4 * U4, g3 += R4 * O4, g3 += T4 * (5 * F4), g3 += B4 * (5 * D4), v4 = c4 += (g3 += P4 * (5 * j4)) >>> 13, v4 += A4 * j4, v4 += S4 * q4, v4 += E4 * C4, v4 += x4 * z4, c4 = (v4 += I4 * N4) >>> 13, v4 &= 8191, v4 += k4 * L4, v4 += R4 * U4, v4 += T4 * O4, v4 += B4 * (5 * F4), w4 = c4 += (v4 += P4 * (5 * D4)) >>> 13, w4 += A4 * D4, w4 += S4 * j4, w4 += E4 * q4, w4 += x4 * C4, c4 = (w4 += I4 * z4) >>> 13, w4 &= 8191, w4 += k4 * N4, w4 += R4 * L4, w4 += T4 * U4, w4 += B4 * O4, M4 = c4 += (w4 += P4 * (5 * F4)) >>> 13, M4 += A4 * F4, M4 += S4 * D4, M4 += E4 * j4, M4 += x4 * q4, c4 = (M4 += I4 * C4) >>> 13, M4 &= 8191, M4 += k4 * z4, M4 += R4 * N4, M4 += T4 * L4, M4 += B4 * U4, A4 = d4 = 8191 & (c4 = (c4 = ((c4 += (M4 += P4 * O4) >>> 13) << 2) + c4 | 0) + (d4 &= 8191) | 0), S4 = l4 += c4 >>>= 13, E4 = p4 &= 8191, x4 = b4 &= 8191, I4 = m4 &= 8191, k4 = y4 &= 8191, R4 = g3 &= 8191, T4 = v4 &= 8191, B4 = w4 &= 8191, P4 = M4 &= 8191, e6 += 16, r4 -= 16;
          this.h[0] = A4, this.h[1] = S4, this.h[2] = E4, this.h[3] = x4, this.h[4] = I4, this.h[5] = k4, this.h[6] = R4, this.h[7] = T4, this.h[8] = B4, this.h[9] = P4;
        }, S3.prototype.finish = function(t5, e6) {
          var r4, n4, i4, o4, s4 = new Uint16Array(10);
          if (this.leftover) {
            for (o4 = this.leftover, this.buffer[o4++] = 1; o4 < 16; o4++)
              this.buffer[o4] = 0;
            this.fin = 1, this.blocks(this.buffer, 0, 16);
          }
          for (r4 = this.h[1] >>> 13, this.h[1] &= 8191, o4 = 2; o4 < 10; o4++)
            this.h[o4] += r4, r4 = this.h[o4] >>> 13, this.h[o4] &= 8191;
          for (this.h[0] += 5 * r4, r4 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += r4, r4 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += r4, s4[0] = this.h[0] + 5, r4 = s4[0] >>> 13, s4[0] &= 8191, o4 = 1; o4 < 10; o4++)
            s4[o4] = this.h[o4] + r4, r4 = s4[o4] >>> 13, s4[o4] &= 8191;
          for (s4[9] -= 8192, n4 = (1 ^ r4) - 1, o4 = 0; o4 < 10; o4++)
            s4[o4] &= n4;
          for (n4 = ~n4, o4 = 0; o4 < 10; o4++)
            this.h[o4] = this.h[o4] & n4 | s4[o4];
          for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), i4 = this.h[0] + this.pad[0], this.h[0] = 65535 & i4, o4 = 1; o4 < 8; o4++)
            i4 = (this.h[o4] + this.pad[o4] | 0) + (i4 >>> 16) | 0, this.h[o4] = 65535 & i4;
          t5[e6 + 0] = this.h[0] >>> 0 & 255, t5[e6 + 1] = this.h[0] >>> 8 & 255, t5[e6 + 2] = this.h[1] >>> 0 & 255, t5[e6 + 3] = this.h[1] >>> 8 & 255, t5[e6 + 4] = this.h[2] >>> 0 & 255, t5[e6 + 5] = this.h[2] >>> 8 & 255, t5[e6 + 6] = this.h[3] >>> 0 & 255, t5[e6 + 7] = this.h[3] >>> 8 & 255, t5[e6 + 8] = this.h[4] >>> 0 & 255, t5[e6 + 9] = this.h[4] >>> 8 & 255, t5[e6 + 10] = this.h[5] >>> 0 & 255, t5[e6 + 11] = this.h[5] >>> 8 & 255, t5[e6 + 12] = this.h[6] >>> 0 & 255, t5[e6 + 13] = this.h[6] >>> 8 & 255, t5[e6 + 14] = this.h[7] >>> 0 & 255, t5[e6 + 15] = this.h[7] >>> 8 & 255;
        }, S3.prototype.update = function(t5, e6, r4) {
          var n4, i4;
          if (this.leftover) {
            for ((i4 = 16 - this.leftover) > r4 && (i4 = r4), n4 = 0; n4 < i4; n4++)
              this.buffer[this.leftover + n4] = t5[e6 + n4];
            if (r4 -= i4, e6 += i4, this.leftover += i4, this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16), this.leftover = 0;
          }
          if (r4 >= 16 && (i4 = r4 - r4 % 16, this.blocks(t5, e6, i4), e6 += i4, r4 -= i4), r4) {
            for (n4 = 0; n4 < r4; n4++)
              this.buffer[this.leftover + n4] = t5[e6 + n4];
            this.leftover += r4;
          }
        };
        var W3 = I3, H3 = k3;
        var $3 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
        function G3(t5, e6, r4, n4) {
          for (var i4, o4, s4, a4, h4, f4, u4, c4, d4, l4, p4, b4, m4, y4, g3, v4, w4, M4, _4, A4, S4, E4, x4, I4, k4, R4, T4 = new Int32Array(16), B4 = new Int32Array(16), P4 = t5[0], O4 = t5[1], U4 = t5[2], L4 = t5[3], N4 = t5[4], z4 = t5[5], C4 = t5[6], q4 = t5[7], j4 = e6[0], D4 = e6[1], F4 = e6[2], K4 = e6[3], Y4 = e6[4], V4 = e6[5], W4 = e6[6], H4 = e6[7], G4 = 0; n4 >= 128; ) {
            for (_4 = 0; _4 < 16; _4++)
              A4 = 8 * _4 + G4, T4[_4] = r4[A4 + 0] << 24 | r4[A4 + 1] << 16 | r4[A4 + 2] << 8 | r4[A4 + 3], B4[_4] = r4[A4 + 4] << 24 | r4[A4 + 5] << 16 | r4[A4 + 6] << 8 | r4[A4 + 7];
            for (_4 = 0; _4 < 80; _4++)
              if (i4 = P4, o4 = O4, s4 = U4, a4 = L4, h4 = N4, f4 = z4, u4 = C4, d4 = j4, l4 = D4, p4 = F4, b4 = K4, m4 = Y4, y4 = V4, g3 = W4, x4 = 65535 & (E4 = H4), I4 = E4 >>> 16, k4 = 65535 & (S4 = q4), R4 = S4 >>> 16, x4 += 65535 & (E4 = (Y4 >>> 14 | N4 << 18) ^ (Y4 >>> 18 | N4 << 14) ^ (N4 >>> 9 | Y4 << 23)), I4 += E4 >>> 16, k4 += 65535 & (S4 = (N4 >>> 14 | Y4 << 18) ^ (N4 >>> 18 | Y4 << 14) ^ (Y4 >>> 9 | N4 << 23)), R4 += S4 >>> 16, x4 += 65535 & (E4 = Y4 & V4 ^ ~Y4 & W4), I4 += E4 >>> 16, k4 += 65535 & (S4 = N4 & z4 ^ ~N4 & C4), R4 += S4 >>> 16, x4 += 65535 & (E4 = $3[2 * _4 + 1]), I4 += E4 >>> 16, k4 += 65535 & (S4 = $3[2 * _4]), R4 += S4 >>> 16, S4 = T4[_4 % 16], I4 += (E4 = B4[_4 % 16]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16, x4 = 65535 & (E4 = M4 = 65535 & x4 | I4 << 16), I4 = E4 >>> 16, k4 = 65535 & (S4 = w4 = 65535 & k4 | (R4 += k4 >>> 16) << 16), R4 = S4 >>> 16, x4 += 65535 & (E4 = (j4 >>> 28 | P4 << 4) ^ (P4 >>> 2 | j4 << 30) ^ (P4 >>> 7 | j4 << 25)), I4 += E4 >>> 16, k4 += 65535 & (S4 = (P4 >>> 28 | j4 << 4) ^ (j4 >>> 2 | P4 << 30) ^ (j4 >>> 7 | P4 << 25)), R4 += S4 >>> 16, I4 += (E4 = j4 & D4 ^ j4 & F4 ^ D4 & F4) >>> 16, k4 += 65535 & (S4 = P4 & O4 ^ P4 & U4 ^ O4 & U4), R4 += S4 >>> 16, c4 = 65535 & (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) | (R4 += k4 >>> 16) << 16, v4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = b4), I4 = E4 >>> 16, k4 = 65535 & (S4 = a4), R4 = S4 >>> 16, I4 += (E4 = M4) >>> 16, k4 += 65535 & (S4 = w4), R4 += S4 >>> 16, O4 = i4, U4 = o4, L4 = s4, N4 = a4 = 65535 & (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) | (R4 += k4 >>> 16) << 16, z4 = h4, C4 = f4, q4 = u4, P4 = c4, D4 = d4, F4 = l4, K4 = p4, Y4 = b4 = 65535 & x4 | I4 << 16, V4 = m4, W4 = y4, H4 = g3, j4 = v4, _4 % 16 == 15)
                for (A4 = 0; A4 < 16; A4++)
                  S4 = T4[A4], x4 = 65535 & (E4 = B4[A4]), I4 = E4 >>> 16, k4 = 65535 & S4, R4 = S4 >>> 16, S4 = T4[(A4 + 9) % 16], x4 += 65535 & (E4 = B4[(A4 + 9) % 16]), I4 += E4 >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, w4 = T4[(A4 + 1) % 16], x4 += 65535 & (E4 = ((M4 = B4[(A4 + 1) % 16]) >>> 1 | w4 << 31) ^ (M4 >>> 8 | w4 << 24) ^ (M4 >>> 7 | w4 << 25)), I4 += E4 >>> 16, k4 += 65535 & (S4 = (w4 >>> 1 | M4 << 31) ^ (w4 >>> 8 | M4 << 24) ^ w4 >>> 7), R4 += S4 >>> 16, w4 = T4[(A4 + 14) % 16], I4 += (E4 = ((M4 = B4[(A4 + 14) % 16]) >>> 19 | w4 << 13) ^ (w4 >>> 29 | M4 << 3) ^ (M4 >>> 6 | w4 << 26)) >>> 16, k4 += 65535 & (S4 = (w4 >>> 19 | M4 << 13) ^ (M4 >>> 29 | w4 << 3) ^ w4 >>> 6), R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, T4[A4] = 65535 & k4 | R4 << 16, B4[A4] = 65535 & x4 | I4 << 16;
            x4 = 65535 & (E4 = j4), I4 = E4 >>> 16, k4 = 65535 & (S4 = P4), R4 = S4 >>> 16, S4 = t5[0], I4 += (E4 = e6[0]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[0] = P4 = 65535 & k4 | R4 << 16, e6[0] = j4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = D4), I4 = E4 >>> 16, k4 = 65535 & (S4 = O4), R4 = S4 >>> 16, S4 = t5[1], I4 += (E4 = e6[1]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[1] = O4 = 65535 & k4 | R4 << 16, e6[1] = D4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = F4), I4 = E4 >>> 16, k4 = 65535 & (S4 = U4), R4 = S4 >>> 16, S4 = t5[2], I4 += (E4 = e6[2]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[2] = U4 = 65535 & k4 | R4 << 16, e6[2] = F4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = K4), I4 = E4 >>> 16, k4 = 65535 & (S4 = L4), R4 = S4 >>> 16, S4 = t5[3], I4 += (E4 = e6[3]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[3] = L4 = 65535 & k4 | R4 << 16, e6[3] = K4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = Y4), I4 = E4 >>> 16, k4 = 65535 & (S4 = N4), R4 = S4 >>> 16, S4 = t5[4], I4 += (E4 = e6[4]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[4] = N4 = 65535 & k4 | R4 << 16, e6[4] = Y4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = V4), I4 = E4 >>> 16, k4 = 65535 & (S4 = z4), R4 = S4 >>> 16, S4 = t5[5], I4 += (E4 = e6[5]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[5] = z4 = 65535 & k4 | R4 << 16, e6[5] = V4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = W4), I4 = E4 >>> 16, k4 = 65535 & (S4 = C4), R4 = S4 >>> 16, S4 = t5[6], I4 += (E4 = e6[6]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[6] = C4 = 65535 & k4 | R4 << 16, e6[6] = W4 = 65535 & x4 | I4 << 16, x4 = 65535 & (E4 = H4), I4 = E4 >>> 16, k4 = 65535 & (S4 = q4), R4 = S4 >>> 16, S4 = t5[7], I4 += (E4 = e6[7]) >>> 16, k4 += 65535 & S4, R4 += S4 >>> 16, R4 += (k4 += (I4 += (x4 += 65535 & E4) >>> 16) >>> 16) >>> 16, t5[7] = q4 = 65535 & k4 | R4 << 16, e6[7] = H4 = 65535 & x4 | I4 << 16, G4 += 128, n4 -= 128;
          }
          return n4;
        }
        function Z3(t5, e6, r4) {
          var n4, i4 = new Int32Array(8), o4 = new Int32Array(8), s4 = new Uint8Array(256), a4 = r4;
          for (i4[0] = 1779033703, i4[1] = 3144134277, i4[2] = 1013904242, i4[3] = 2773480762, i4[4] = 1359893119, i4[5] = 2600822924, i4[6] = 528734635, i4[7] = 1541459225, o4[0] = 4089235720, o4[1] = 2227873595, o4[2] = 4271175723, o4[3] = 1595750129, o4[4] = 2917565137, o4[5] = 725511199, o4[6] = 4215389547, o4[7] = 327033209, G3(i4, o4, e6, r4), r4 %= 128, n4 = 0; n4 < r4; n4++)
            s4[n4] = e6[a4 - r4 + n4];
          for (s4[r4] = 128, s4[(r4 = 256 - 128 * (r4 < 112 ? 1 : 0)) - 9] = 0, l3(s4, r4 - 8, a4 / 536870912 | 0, a4 << 3), G3(i4, o4, s4, r4), n4 = 0; n4 < 8; n4++)
            l3(t5, 8 * n4, i4[n4], o4[n4]);
          return 0;
        }
        function J3(t5, r4) {
          var n4 = e4(), i4 = e4(), o4 = e4(), s4 = e4(), a4 = e4(), h4 = e4(), u4 = e4(), c4 = e4(), d4 = e4();
          z3(n4, t5[1], t5[0]), z3(d4, r4[1], r4[0]), C3(n4, n4, d4), N3(i4, t5[0], t5[1]), N3(d4, r4[0], r4[1]), C3(i4, i4, d4), C3(o4, t5[3], r4[3]), C3(o4, o4, f3), C3(s4, t5[2], r4[2]), N3(s4, s4, s4), z3(a4, i4, n4), z3(h4, s4, o4), N3(u4, s4, o4), N3(c4, i4, n4), C3(t5[0], a4, h4), C3(t5[1], c4, u4), C3(t5[2], u4, h4), C3(t5[3], a4, c4);
        }
        function X3(t5, e6, r4) {
          var n4;
          for (n4 = 0; n4 < 4; n4++)
            B3(t5[n4], e6[n4], r4);
        }
        function Q3(t5, r4) {
          var n4 = e4(), i4 = e4(), o4 = e4();
          j3(o4, r4[2]), C3(n4, r4[0], o4), C3(i4, r4[1], o4), P3(t5, i4), t5[31] ^= U3(n4) << 7;
        }
        function tt2(t5, e6, r4) {
          var n4, i4;
          for (R3(t5[0], o3), R3(t5[1], s3), R3(t5[2], s3), R3(t5[3], o3), i4 = 255; i4 >= 0; --i4)
            X3(t5, e6, n4 = r4[i4 / 8 | 0] >> (7 & i4) & 1), J3(e6, t5), J3(t5, t5), X3(t5, e6, n4);
        }
        function et2(t5, r4) {
          var n4 = [e4(), e4(), e4(), e4()];
          R3(n4[0], u3), R3(n4[1], c3), R3(n4[2], s3), C3(n4[3], u3, c3), tt2(t5, n4, r4);
        }
        function rt2(t5, n4, i4) {
          var o4, s4 = new Uint8Array(64), a4 = [e4(), e4(), e4(), e4()];
          for (i4 || r3(n4, 32), Z3(s4, n4, 32), s4[0] &= 248, s4[31] &= 127, s4[31] |= 64, et2(a4, s4), Q3(t5, a4), o4 = 0; o4 < 32; o4++)
            n4[o4 + 32] = t5[o4];
          return 0;
        }
        var nt2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function it2(t5, e6) {
          var r4, n4, i4, o4;
          for (n4 = 63; n4 >= 32; --n4) {
            for (r4 = 0, i4 = n4 - 32, o4 = n4 - 12; i4 < o4; ++i4)
              e6[i4] += r4 - 16 * e6[n4] * nt2[i4 - (n4 - 32)], r4 = Math.floor((e6[i4] + 128) / 256), e6[i4] -= 256 * r4;
            e6[i4] += r4, e6[n4] = 0;
          }
          for (r4 = 0, i4 = 0; i4 < 32; i4++)
            e6[i4] += r4 - (e6[31] >> 4) * nt2[i4], r4 = e6[i4] >> 8, e6[i4] &= 255;
          for (i4 = 0; i4 < 32; i4++)
            e6[i4] -= r4 * nt2[i4];
          for (n4 = 0; n4 < 32; n4++)
            e6[n4 + 1] += e6[n4] >> 8, t5[n4] = 255 & e6[n4];
        }
        function ot2(t5) {
          var e6, r4 = new Float64Array(64);
          for (e6 = 0; e6 < 64; e6++)
            r4[e6] = t5[e6];
          for (e6 = 0; e6 < 64; e6++)
            t5[e6] = 0;
          it2(t5, r4);
        }
        function st2(t5, r4, n4, i4) {
          var o4, s4, a4 = new Uint8Array(64), h4 = new Uint8Array(64), f4 = new Uint8Array(64), u4 = new Float64Array(64), c4 = [e4(), e4(), e4(), e4()];
          Z3(a4, i4, 32), a4[0] &= 248, a4[31] &= 127, a4[31] |= 64;
          var d4 = n4 + 64;
          for (o4 = 0; o4 < n4; o4++)
            t5[64 + o4] = r4[o4];
          for (o4 = 0; o4 < 32; o4++)
            t5[32 + o4] = a4[32 + o4];
          for (Z3(f4, t5.subarray(32), n4 + 32), ot2(f4), et2(c4, f4), Q3(t5, c4), o4 = 32; o4 < 64; o4++)
            t5[o4] = i4[o4];
          for (Z3(h4, t5, n4 + 64), ot2(h4), o4 = 0; o4 < 64; o4++)
            u4[o4] = 0;
          for (o4 = 0; o4 < 32; o4++)
            u4[o4] = f4[o4];
          for (o4 = 0; o4 < 32; o4++)
            for (s4 = 0; s4 < 32; s4++)
              u4[o4 + s4] += h4[o4] * a4[s4];
          return it2(t5.subarray(32), u4), d4;
        }
        function at2(t5, r4, n4, i4) {
          var a4, f4 = new Uint8Array(32), u4 = new Uint8Array(64), c4 = [e4(), e4(), e4(), e4()], l4 = [e4(), e4(), e4(), e4()];
          if (n4 < 64)
            return -1;
          if (function(t6, r5) {
            var n5 = e4(), i5 = e4(), a5 = e4(), f5 = e4(), u5 = e4(), c5 = e4(), l5 = e4();
            return R3(t6[2], s3), L3(t6[1], r5), q3(a5, t6[1]), C3(f5, a5, h3), z3(a5, a5, t6[2]), N3(f5, t6[2], f5), q3(u5, f5), q3(c5, u5), C3(l5, c5, u5), C3(n5, l5, a5), C3(n5, n5, f5), D3(n5, n5), C3(n5, n5, a5), C3(n5, n5, f5), C3(n5, n5, f5), C3(t6[0], n5, f5), q3(i5, t6[0]), C3(i5, i5, f5), O3(i5, a5) && C3(t6[0], t6[0], d3), q3(i5, t6[0]), C3(i5, i5, f5), O3(i5, a5) ? -1 : (U3(t6[0]) === r5[31] >> 7 && z3(t6[0], o3, t6[0]), C3(t6[3], t6[0], t6[1]), 0);
          }(l4, i4))
            return -1;
          for (a4 = 0; a4 < n4; a4++)
            t5[a4] = r4[a4];
          for (a4 = 0; a4 < 32; a4++)
            t5[a4 + 32] = i4[a4];
          if (Z3(u4, t5, n4), ot2(u4), tt2(c4, l4, u4), et2(l4, r4.subarray(32)), J3(c4, l4), Q3(f4, c4), n4 -= 64, m3(r4, 0, f4, 0)) {
            for (a4 = 0; a4 < n4; a4++)
              t5[a4] = 0;
            return -1;
          }
          for (a4 = 0; a4 < n4; a4++)
            t5[a4] = r4[a4 + 64];
          return n4;
        }
        var ht2 = 16, ft2 = 64, ut2 = 32, ct2 = 64;
        function dt2(t5, e6) {
          if (32 !== t5.length)
            throw new Error("bad key size");
          if (24 !== e6.length)
            throw new Error("bad nonce size");
        }
        function lt2() {
          for (var t5 = 0; t5 < arguments.length; t5++)
            if (!(arguments[t5] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
        }
        function pt3(t5) {
          for (var e6 = 0; e6 < t5.length; e6++)
            t5[e6] = 0;
        }
        t4.lowlevel = { crypto_core_hsalsa20: g2, crypto_stream_xor: A3, crypto_stream: _3, crypto_stream_salsa20_xor: w3, crypto_stream_salsa20: M3, crypto_onetimeauth: E3, crypto_onetimeauth_verify: x3, crypto_verify_16: b3, crypto_verify_32: m3, crypto_secretbox: I3, crypto_secretbox_open: k3, crypto_scalarmult: F3, crypto_scalarmult_base: K3, crypto_box_beforenm: V3, crypto_box_afternm: W3, crypto_box: function(t5, e6, r4, n4, i4, o4) {
          var s4 = new Uint8Array(32);
          return V3(s4, i4, o4), W3(t5, e6, r4, n4, s4);
        }, crypto_box_open: function(t5, e6, r4, n4, i4, o4) {
          var s4 = new Uint8Array(32);
          return V3(s4, i4, o4), H3(t5, e6, r4, n4, s4);
        }, crypto_box_keypair: Y3, crypto_hash: Z3, crypto_sign: st2, crypto_sign_keypair: rt2, crypto_sign_open: at2, crypto_secretbox_KEYBYTES: 32, crypto_secretbox_NONCEBYTES: 24, crypto_secretbox_ZEROBYTES: 32, crypto_secretbox_BOXZEROBYTES: ht2, crypto_scalarmult_BYTES: 32, crypto_scalarmult_SCALARBYTES: 32, crypto_box_PUBLICKEYBYTES: 32, crypto_box_SECRETKEYBYTES: 32, crypto_box_BEFORENMBYTES: 32, crypto_box_NONCEBYTES: 24, crypto_box_ZEROBYTES: 32, crypto_box_BOXZEROBYTES: 16, crypto_sign_BYTES: ft2, crypto_sign_PUBLICKEYBYTES: ut2, crypto_sign_SECRETKEYBYTES: ct2, crypto_sign_SEEDBYTES: 32, crypto_hash_BYTES: 64, gf: e4, D: h3, L: nt2, pack25519: P3, unpack25519: L3, M: C3, A: N3, S: q3, Z: z3, pow2523: D3, add: J3, set25519: R3, modL: it2, scalarmult: tt2, scalarbase: et2 }, t4.randomBytes = function(t5) {
          var e6 = new Uint8Array(t5);
          return r3(e6, t5), e6;
        }, t4.secretbox = function(t5, e6, r4) {
          lt2(t5, e6, r4), dt2(r4, e6);
          for (var n4 = new Uint8Array(32 + t5.length), i4 = new Uint8Array(n4.length), o4 = 0; o4 < t5.length; o4++)
            n4[o4 + 32] = t5[o4];
          return I3(i4, n4, n4.length, e6, r4), i4.subarray(ht2);
        }, t4.secretbox.open = function(t5, e6, r4) {
          lt2(t5, e6, r4), dt2(r4, e6);
          for (var n4 = new Uint8Array(ht2 + t5.length), i4 = new Uint8Array(n4.length), o4 = 0; o4 < t5.length; o4++)
            n4[o4 + ht2] = t5[o4];
          return n4.length < 32 || 0 !== k3(i4, n4, n4.length, e6, r4) ? null : i4.subarray(32);
        }, t4.secretbox.keyLength = 32, t4.secretbox.nonceLength = 24, t4.secretbox.overheadLength = ht2, t4.scalarMult = function(t5, e6) {
          if (lt2(t5, e6), 32 !== t5.length)
            throw new Error("bad n size");
          if (32 !== e6.length)
            throw new Error("bad p size");
          var r4 = new Uint8Array(32);
          return F3(r4, t5, e6), r4;
        }, t4.scalarMult.base = function(t5) {
          if (lt2(t5), 32 !== t5.length)
            throw new Error("bad n size");
          var e6 = new Uint8Array(32);
          return K3(e6, t5), e6;
        }, t4.scalarMult.scalarLength = 32, t4.scalarMult.groupElementLength = 32, t4.box = function(e6, r4, n4, i4) {
          var o4 = t4.box.before(n4, i4);
          return t4.secretbox(e6, r4, o4);
        }, t4.box.before = function(t5, e6) {
          lt2(t5, e6), function(t6, e7) {
            if (32 !== t6.length)
              throw new Error("bad public key size");
            if (32 !== e7.length)
              throw new Error("bad secret key size");
          }(t5, e6);
          var r4 = new Uint8Array(32);
          return V3(r4, t5, e6), r4;
        }, t4.box.after = t4.secretbox, t4.box.open = function(e6, r4, n4, i4) {
          var o4 = t4.box.before(n4, i4);
          return t4.secretbox.open(e6, r4, o4);
        }, t4.box.open.after = t4.secretbox.open, t4.box.keyPair = function() {
          var t5 = new Uint8Array(32), e6 = new Uint8Array(32);
          return Y3(t5, e6), { publicKey: t5, secretKey: e6 };
        }, t4.box.keyPair.fromSecretKey = function(t5) {
          if (lt2(t5), 32 !== t5.length)
            throw new Error("bad secret key size");
          var e6 = new Uint8Array(32);
          return K3(e6, t5), { publicKey: e6, secretKey: new Uint8Array(t5) };
        }, t4.box.publicKeyLength = 32, t4.box.secretKeyLength = 32, t4.box.sharedKeyLength = 32, t4.box.nonceLength = 24, t4.box.overheadLength = t4.secretbox.overheadLength, t4.sign = function(t5, e6) {
          if (lt2(t5, e6), e6.length !== ct2)
            throw new Error("bad secret key size");
          var r4 = new Uint8Array(ft2 + t5.length);
          return st2(r4, t5, t5.length, e6), r4;
        }, t4.sign.open = function(t5, e6) {
          if (lt2(t5, e6), e6.length !== ut2)
            throw new Error("bad public key size");
          var r4 = new Uint8Array(t5.length), n4 = at2(r4, t5, t5.length, e6);
          if (n4 < 0)
            return null;
          for (var i4 = new Uint8Array(n4), o4 = 0; o4 < i4.length; o4++)
            i4[o4] = r4[o4];
          return i4;
        }, t4.sign.detached = function(e6, r4) {
          for (var n4 = t4.sign(e6, r4), i4 = new Uint8Array(ft2), o4 = 0; o4 < i4.length; o4++)
            i4[o4] = n4[o4];
          return i4;
        }, t4.sign.detached.verify = function(t5, e6, r4) {
          if (lt2(t5, e6, r4), e6.length !== ft2)
            throw new Error("bad signature size");
          if (r4.length !== ut2)
            throw new Error("bad public key size");
          var n4, i4 = new Uint8Array(ft2 + t5.length), o4 = new Uint8Array(ft2 + t5.length);
          for (n4 = 0; n4 < ft2; n4++)
            i4[n4] = e6[n4];
          for (n4 = 0; n4 < t5.length; n4++)
            i4[n4 + ft2] = t5[n4];
          return at2(o4, i4, i4.length, r4) >= 0;
        }, t4.sign.keyPair = function() {
          var t5 = new Uint8Array(ut2), e6 = new Uint8Array(ct2);
          return rt2(t5, e6), { publicKey: t5, secretKey: e6 };
        }, t4.sign.keyPair.fromSecretKey = function(t5) {
          if (lt2(t5), t5.length !== ct2)
            throw new Error("bad secret key size");
          for (var e6 = new Uint8Array(ut2), r4 = 0; r4 < e6.length; r4++)
            e6[r4] = t5[32 + r4];
          return { publicKey: e6, secretKey: new Uint8Array(t5) };
        }, t4.sign.keyPair.fromSeed = function(t5) {
          if (lt2(t5), 32 !== t5.length)
            throw new Error("bad seed size");
          for (var e6 = new Uint8Array(ut2), r4 = new Uint8Array(ct2), n4 = 0; n4 < 32; n4++)
            r4[n4] = t5[n4];
          return rt2(e6, r4, true), { publicKey: e6, secretKey: r4 };
        }, t4.sign.publicKeyLength = ut2, t4.sign.secretKeyLength = ct2, t4.sign.seedLength = 32, t4.sign.signatureLength = ft2, t4.hash = function(t5) {
          lt2(t5);
          var e6 = new Uint8Array(64);
          return Z3(e6, t5, t5.length), e6;
        }, t4.hash.hashLength = 64, t4.verify = function(t5, e6) {
          return lt2(t5, e6), 0 !== t5.length && 0 !== e6.length && (t5.length === e6.length && 0 === p3(t5, 0, e6, 0, t5.length));
        }, t4.setPRNG = function(t5) {
          r3 = t5;
        }, function() {
          var e6 = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
          if (e6 && e6.getRandomValues) {
            t4.setPRNG(function(t5, r4) {
              var n4, i4 = new Uint8Array(r4);
              for (n4 = 0; n4 < r4; n4 += 65536)
                e6.getRandomValues(i4.subarray(n4, n4 + Math.min(r4 - n4, 65536)));
              for (n4 = 0; n4 < r4; n4++)
                t5[n4] = i4[n4];
              pt3(i4);
            });
          } else
            (e6 = ee2) && e6.randomBytes && t4.setPRNG(function(t5, r4) {
              var n4, i4 = e6.randomBytes(r4);
              for (n4 = 0; n4 < r4; n4++)
                t5[n4] = i4[n4];
              pt3(i4);
            });
        }();
      }(t3.exports ? t3.exports : self.nacl = self.nacl || {});
    });
    re2.sign;
    var ne2 = Qt(function(t3) {
      !function(t4, e4) {
        function r3(t5, e6) {
          if (!t5)
            throw new Error(e6 || "Assertion failed");
        }
        function n3(t5, e6) {
          t5.super_ = e6;
          var r4 = function() {
          };
          r4.prototype = e6.prototype, t5.prototype = new r4(), t5.prototype.constructor = t5;
        }
        function i3(t5, e6, r4) {
          if (i3.isBN(t5))
            return t5;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t5 && ("le" !== e6 && "be" !== e6 || (r4 = e6, e6 = 10), this._init(t5 || 0, e6 || 10, r4 || "be"));
        }
        var o3;
        "object" == typeof t4 ? t4.exports = i3 : e4.BN = i3, i3.BN = i3, i3.wordSize = 26;
        try {
          o3 = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : ee2.Buffer;
        } catch (t5) {
        }
        function s3(t5, e6) {
          var n4 = t5.charCodeAt(e6);
          return n4 >= 48 && n4 <= 57 ? n4 - 48 : n4 >= 65 && n4 <= 70 ? n4 - 55 : n4 >= 97 && n4 <= 102 ? n4 - 87 : void r3(false, "Invalid character in " + t5);
        }
        function a3(t5, e6, r4) {
          var n4 = s3(t5, r4);
          return r4 - 1 >= e6 && (n4 |= s3(t5, r4 - 1) << 4), n4;
        }
        function h3(t5, e6, n4, i4) {
          for (var o4 = 0, s4 = 0, a4 = Math.min(t5.length, n4), h4 = e6; h4 < a4; h4++) {
            var f4 = t5.charCodeAt(h4) - 48;
            o4 *= i4, s4 = f4 >= 49 ? f4 - 49 + 10 : f4 >= 17 ? f4 - 17 + 10 : f4, r3(f4 >= 0 && s4 < i4, "Invalid character"), o4 += s4;
          }
          return o4;
        }
        function f3(t5, e6) {
          t5.words = e6.words, t5.length = e6.length, t5.negative = e6.negative, t5.red = e6.red;
        }
        if (i3.isBN = function(t5) {
          return t5 instanceof i3 || null !== t5 && "object" == typeof t5 && t5.constructor.wordSize === i3.wordSize && Array.isArray(t5.words);
        }, i3.max = function(t5, e6) {
          return t5.cmp(e6) > 0 ? t5 : e6;
        }, i3.min = function(t5, e6) {
          return t5.cmp(e6) < 0 ? t5 : e6;
        }, i3.prototype._init = function(t5, e6, n4) {
          if ("number" == typeof t5)
            return this._initNumber(t5, e6, n4);
          if ("object" == typeof t5)
            return this._initArray(t5, e6, n4);
          "hex" === e6 && (e6 = 16), r3(e6 === (0 | e6) && e6 >= 2 && e6 <= 36);
          var i4 = 0;
          "-" === (t5 = t5.toString().replace(/\s+/g, ""))[0] && (i4++, this.negative = 1), i4 < t5.length && (16 === e6 ? this._parseHex(t5, i4, n4) : (this._parseBase(t5, e6, i4), "le" === n4 && this._initArray(this.toArray(), e6, n4)));
        }, i3.prototype._initNumber = function(t5, e6, n4) {
          t5 < 0 && (this.negative = 1, t5 = -t5), t5 < 67108864 ? (this.words = [67108863 & t5], this.length = 1) : t5 < 4503599627370496 ? (this.words = [67108863 & t5, t5 / 67108864 & 67108863], this.length = 2) : (r3(t5 < 9007199254740992), this.words = [67108863 & t5, t5 / 67108864 & 67108863, 1], this.length = 3), "le" === n4 && this._initArray(this.toArray(), e6, n4);
        }, i3.prototype._initArray = function(t5, e6, n4) {
          if (r3("number" == typeof t5.length), t5.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(t5.length / 3), this.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++)
            this.words[i4] = 0;
          var o4, s4, a4 = 0;
          if ("be" === n4)
            for (i4 = t5.length - 1, o4 = 0; i4 >= 0; i4 -= 3)
              s4 = t5[i4] | t5[i4 - 1] << 8 | t5[i4 - 2] << 16, this.words[o4] |= s4 << a4 & 67108863, this.words[o4 + 1] = s4 >>> 26 - a4 & 67108863, (a4 += 24) >= 26 && (a4 -= 26, o4++);
          else if ("le" === n4)
            for (i4 = 0, o4 = 0; i4 < t5.length; i4 += 3)
              s4 = t5[i4] | t5[i4 + 1] << 8 | t5[i4 + 2] << 16, this.words[o4] |= s4 << a4 & 67108863, this.words[o4 + 1] = s4 >>> 26 - a4 & 67108863, (a4 += 24) >= 26 && (a4 -= 26, o4++);
          return this._strip();
        }, i3.prototype._parseHex = function(t5, e6, r4) {
          this.length = Math.ceil((t5.length - e6) / 6), this.words = new Array(this.length);
          for (var n4 = 0; n4 < this.length; n4++)
            this.words[n4] = 0;
          var i4, o4 = 0, s4 = 0;
          if ("be" === r4)
            for (n4 = t5.length - 1; n4 >= e6; n4 -= 2)
              i4 = a3(t5, e6, n4) << o4, this.words[s4] |= 67108863 & i4, o4 >= 18 ? (o4 -= 18, s4 += 1, this.words[s4] |= i4 >>> 26) : o4 += 8;
          else
            for (n4 = (t5.length - e6) % 2 == 0 ? e6 + 1 : e6; n4 < t5.length; n4 += 2)
              i4 = a3(t5, e6, n4) << o4, this.words[s4] |= 67108863 & i4, o4 >= 18 ? (o4 -= 18, s4 += 1, this.words[s4] |= i4 >>> 26) : o4 += 8;
          this._strip();
        }, i3.prototype._parseBase = function(t5, e6, r4) {
          this.words = [0], this.length = 1;
          for (var n4 = 0, i4 = 1; i4 <= 67108863; i4 *= e6)
            n4++;
          n4--, i4 = i4 / e6 | 0;
          for (var o4 = t5.length - r4, s4 = o4 % n4, a4 = Math.min(o4, o4 - s4) + r4, f4 = 0, u4 = r4; u4 < a4; u4 += n4)
            f4 = h3(t5, u4, u4 + n4, e6), this.imuln(i4), this.words[0] + f4 < 67108864 ? this.words[0] += f4 : this._iaddn(f4);
          if (0 !== s4) {
            var c4 = 1;
            for (f4 = h3(t5, u4, t5.length, e6), u4 = 0; u4 < s4; u4++)
              c4 *= e6;
            this.imuln(c4), this.words[0] + f4 < 67108864 ? this.words[0] += f4 : this._iaddn(f4);
          }
          this._strip();
        }, i3.prototype.copy = function(t5) {
          t5.words = new Array(this.length);
          for (var e6 = 0; e6 < this.length; e6++)
            t5.words[e6] = this.words[e6];
          t5.length = this.length, t5.negative = this.negative, t5.red = this.red;
        }, i3.prototype._move = function(t5) {
          f3(t5, this);
        }, i3.prototype.clone = function() {
          var t5 = new i3(null);
          return this.copy(t5), t5;
        }, i3.prototype._expand = function(t5) {
          for (; this.length < t5; )
            this.words[this.length++] = 0;
          return this;
        }, i3.prototype._strip = function() {
          for (; this.length > 1 && 0 === this.words[this.length - 1]; )
            this.length--;
          return this._normSign();
        }, i3.prototype._normSign = function() {
          return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
        }, "undefined" != typeof Symbol && "function" == typeof Symbol.for)
          try {
            i3.prototype[Symbol.for("nodejs.util.inspect.custom")] = u3;
          } catch (t5) {
            i3.prototype.inspect = u3;
          }
        else
          i3.prototype.inspect = u3;
        function u3() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var c3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], d3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], l3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        i3.prototype.toString = function(t5, e6) {
          var n4;
          if (e6 = 0 | e6 || 1, 16 === (t5 = t5 || 10) || "hex" === t5) {
            n4 = "";
            for (var i4 = 0, o4 = 0, s4 = 0; s4 < this.length; s4++) {
              var a4 = this.words[s4], h4 = (16777215 & (a4 << i4 | o4)).toString(16);
              n4 = 0 !== (o4 = a4 >>> 24 - i4 & 16777215) || s4 !== this.length - 1 ? c3[6 - h4.length] + h4 + n4 : h4 + n4, (i4 += 2) >= 26 && (i4 -= 26, s4--);
            }
            for (0 !== o4 && (n4 = o4.toString(16) + n4); n4.length % e6 != 0; )
              n4 = "0" + n4;
            return 0 !== this.negative && (n4 = "-" + n4), n4;
          }
          if (t5 === (0 | t5) && t5 >= 2 && t5 <= 36) {
            var f4 = d3[t5], u4 = l3[t5];
            n4 = "";
            var p4 = this.clone();
            for (p4.negative = 0; !p4.isZero(); ) {
              var b4 = p4.modrn(u4).toString(t5);
              n4 = (p4 = p4.idivn(u4)).isZero() ? b4 + n4 : c3[f4 - b4.length] + b4 + n4;
            }
            for (this.isZero() && (n4 = "0" + n4); n4.length % e6 != 0; )
              n4 = "0" + n4;
            return 0 !== this.negative && (n4 = "-" + n4), n4;
          }
          r3(false, "Base should be between 2 and 36");
        }, i3.prototype.toNumber = function() {
          var t5 = this.words[0];
          return 2 === this.length ? t5 += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t5 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r3(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t5 : t5;
        }, i3.prototype.toJSON = function() {
          return this.toString(16, 2);
        }, o3 && (i3.prototype.toBuffer = function(t5, e6) {
          return this.toArrayLike(o3, t5, e6);
        }), i3.prototype.toArray = function(t5, e6) {
          return this.toArrayLike(Array, t5, e6);
        };
        function p3(t5, e6, r4) {
          r4.negative = e6.negative ^ t5.negative;
          var n4 = t5.length + e6.length | 0;
          r4.length = n4, n4 = n4 - 1 | 0;
          var i4 = 0 | t5.words[0], o4 = 0 | e6.words[0], s4 = i4 * o4, a4 = 67108863 & s4, h4 = s4 / 67108864 | 0;
          r4.words[0] = a4;
          for (var f4 = 1; f4 < n4; f4++) {
            for (var u4 = h4 >>> 26, c4 = 67108863 & h4, d4 = Math.min(f4, e6.length - 1), l4 = Math.max(0, f4 - t5.length + 1); l4 <= d4; l4++) {
              var p4 = f4 - l4 | 0;
              u4 += (s4 = (i4 = 0 | t5.words[p4]) * (o4 = 0 | e6.words[l4]) + c4) / 67108864 | 0, c4 = 67108863 & s4;
            }
            r4.words[f4] = 0 | c4, h4 = 0 | u4;
          }
          return 0 !== h4 ? r4.words[f4] = 0 | h4 : r4.length--, r4._strip();
        }
        i3.prototype.toArrayLike = function(t5, e6, n4) {
          this._strip();
          var i4 = this.byteLength(), o4 = n4 || Math.max(1, i4);
          r3(i4 <= o4, "byte array longer than desired length"), r3(o4 > 0, "Requested array length <= 0");
          var s4 = function(t6, e7) {
            return t6.allocUnsafe ? t6.allocUnsafe(e7) : new t6(e7);
          }(t5, o4);
          return this["_toArrayLike" + ("le" === e6 ? "LE" : "BE")](s4, i4), s4;
        }, i3.prototype._toArrayLikeLE = function(t5, e6) {
          for (var r4 = 0, n4 = 0, i4 = 0, o4 = 0; i4 < this.length; i4++) {
            var s4 = this.words[i4] << o4 | n4;
            t5[r4++] = 255 & s4, r4 < t5.length && (t5[r4++] = s4 >> 8 & 255), r4 < t5.length && (t5[r4++] = s4 >> 16 & 255), 6 === o4 ? (r4 < t5.length && (t5[r4++] = s4 >> 24 & 255), n4 = 0, o4 = 0) : (n4 = s4 >>> 24, o4 += 2);
          }
          if (r4 < t5.length)
            for (t5[r4++] = n4; r4 < t5.length; )
              t5[r4++] = 0;
        }, i3.prototype._toArrayLikeBE = function(t5, e6) {
          for (var r4 = t5.length - 1, n4 = 0, i4 = 0, o4 = 0; i4 < this.length; i4++) {
            var s4 = this.words[i4] << o4 | n4;
            t5[r4--] = 255 & s4, r4 >= 0 && (t5[r4--] = s4 >> 8 & 255), r4 >= 0 && (t5[r4--] = s4 >> 16 & 255), 6 === o4 ? (r4 >= 0 && (t5[r4--] = s4 >> 24 & 255), n4 = 0, o4 = 0) : (n4 = s4 >>> 24, o4 += 2);
          }
          if (r4 >= 0)
            for (t5[r4--] = n4; r4 >= 0; )
              t5[r4--] = 0;
        }, Math.clz32 ? i3.prototype._countBits = function(t5) {
          return 32 - Math.clz32(t5);
        } : i3.prototype._countBits = function(t5) {
          var e6 = t5, r4 = 0;
          return e6 >= 4096 && (r4 += 13, e6 >>>= 13), e6 >= 64 && (r4 += 7, e6 >>>= 7), e6 >= 8 && (r4 += 4, e6 >>>= 4), e6 >= 2 && (r4 += 2, e6 >>>= 2), r4 + e6;
        }, i3.prototype._zeroBits = function(t5) {
          if (0 === t5)
            return 26;
          var e6 = t5, r4 = 0;
          return 0 == (8191 & e6) && (r4 += 13, e6 >>>= 13), 0 == (127 & e6) && (r4 += 7, e6 >>>= 7), 0 == (15 & e6) && (r4 += 4, e6 >>>= 4), 0 == (3 & e6) && (r4 += 2, e6 >>>= 2), 0 == (1 & e6) && r4++, r4;
        }, i3.prototype.bitLength = function() {
          var t5 = this.words[this.length - 1], e6 = this._countBits(t5);
          return 26 * (this.length - 1) + e6;
        }, i3.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var t5 = 0, e6 = 0; e6 < this.length; e6++) {
            var r4 = this._zeroBits(this.words[e6]);
            if (t5 += r4, 26 !== r4)
              break;
          }
          return t5;
        }, i3.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, i3.prototype.toTwos = function(t5) {
          return 0 !== this.negative ? this.abs().inotn(t5).iaddn(1) : this.clone();
        }, i3.prototype.fromTwos = function(t5) {
          return this.testn(t5 - 1) ? this.notn(t5).iaddn(1).ineg() : this.clone();
        }, i3.prototype.isNeg = function() {
          return 0 !== this.negative;
        }, i3.prototype.neg = function() {
          return this.clone().ineg();
        }, i3.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, i3.prototype.iuor = function(t5) {
          for (; this.length < t5.length; )
            this.words[this.length++] = 0;
          for (var e6 = 0; e6 < t5.length; e6++)
            this.words[e6] = this.words[e6] | t5.words[e6];
          return this._strip();
        }, i3.prototype.ior = function(t5) {
          return r3(0 == (this.negative | t5.negative)), this.iuor(t5);
        }, i3.prototype.or = function(t5) {
          return this.length > t5.length ? this.clone().ior(t5) : t5.clone().ior(this);
        }, i3.prototype.uor = function(t5) {
          return this.length > t5.length ? this.clone().iuor(t5) : t5.clone().iuor(this);
        }, i3.prototype.iuand = function(t5) {
          var e6;
          e6 = this.length > t5.length ? t5 : this;
          for (var r4 = 0; r4 < e6.length; r4++)
            this.words[r4] = this.words[r4] & t5.words[r4];
          return this.length = e6.length, this._strip();
        }, i3.prototype.iand = function(t5) {
          return r3(0 == (this.negative | t5.negative)), this.iuand(t5);
        }, i3.prototype.and = function(t5) {
          return this.length > t5.length ? this.clone().iand(t5) : t5.clone().iand(this);
        }, i3.prototype.uand = function(t5) {
          return this.length > t5.length ? this.clone().iuand(t5) : t5.clone().iuand(this);
        }, i3.prototype.iuxor = function(t5) {
          var e6, r4;
          this.length > t5.length ? (e6 = this, r4 = t5) : (e6 = t5, r4 = this);
          for (var n4 = 0; n4 < r4.length; n4++)
            this.words[n4] = e6.words[n4] ^ r4.words[n4];
          if (this !== e6)
            for (; n4 < e6.length; n4++)
              this.words[n4] = e6.words[n4];
          return this.length = e6.length, this._strip();
        }, i3.prototype.ixor = function(t5) {
          return r3(0 == (this.negative | t5.negative)), this.iuxor(t5);
        }, i3.prototype.xor = function(t5) {
          return this.length > t5.length ? this.clone().ixor(t5) : t5.clone().ixor(this);
        }, i3.prototype.uxor = function(t5) {
          return this.length > t5.length ? this.clone().iuxor(t5) : t5.clone().iuxor(this);
        }, i3.prototype.inotn = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6 = 0 | Math.ceil(t5 / 26), n4 = t5 % 26;
          this._expand(e6), n4 > 0 && e6--;
          for (var i4 = 0; i4 < e6; i4++)
            this.words[i4] = 67108863 & ~this.words[i4];
          return n4 > 0 && (this.words[i4] = ~this.words[i4] & 67108863 >> 26 - n4), this._strip();
        }, i3.prototype.notn = function(t5) {
          return this.clone().inotn(t5);
        }, i3.prototype.setn = function(t5, e6) {
          r3("number" == typeof t5 && t5 >= 0);
          var n4 = t5 / 26 | 0, i4 = t5 % 26;
          return this._expand(n4 + 1), this.words[n4] = e6 ? this.words[n4] | 1 << i4 : this.words[n4] & ~(1 << i4), this._strip();
        }, i3.prototype.iadd = function(t5) {
          var e6, r4, n4;
          if (0 !== this.negative && 0 === t5.negative)
            return this.negative = 0, e6 = this.isub(t5), this.negative ^= 1, this._normSign();
          if (0 === this.negative && 0 !== t5.negative)
            return t5.negative = 0, e6 = this.isub(t5), t5.negative = 1, e6._normSign();
          this.length > t5.length ? (r4 = this, n4 = t5) : (r4 = t5, n4 = this);
          for (var i4 = 0, o4 = 0; o4 < n4.length; o4++)
            e6 = (0 | r4.words[o4]) + (0 | n4.words[o4]) + i4, this.words[o4] = 67108863 & e6, i4 = e6 >>> 26;
          for (; 0 !== i4 && o4 < r4.length; o4++)
            e6 = (0 | r4.words[o4]) + i4, this.words[o4] = 67108863 & e6, i4 = e6 >>> 26;
          if (this.length = r4.length, 0 !== i4)
            this.words[this.length] = i4, this.length++;
          else if (r4 !== this)
            for (; o4 < r4.length; o4++)
              this.words[o4] = r4.words[o4];
          return this;
        }, i3.prototype.add = function(t5) {
          var e6;
          return 0 !== t5.negative && 0 === this.negative ? (t5.negative = 0, e6 = this.sub(t5), t5.negative ^= 1, e6) : 0 === t5.negative && 0 !== this.negative ? (this.negative = 0, e6 = t5.sub(this), this.negative = 1, e6) : this.length > t5.length ? this.clone().iadd(t5) : t5.clone().iadd(this);
        }, i3.prototype.isub = function(t5) {
          if (0 !== t5.negative) {
            t5.negative = 0;
            var e6 = this.iadd(t5);
            return t5.negative = 1, e6._normSign();
          }
          if (0 !== this.negative)
            return this.negative = 0, this.iadd(t5), this.negative = 1, this._normSign();
          var r4, n4, i4 = this.cmp(t5);
          if (0 === i4)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          i4 > 0 ? (r4 = this, n4 = t5) : (r4 = t5, n4 = this);
          for (var o4 = 0, s4 = 0; s4 < n4.length; s4++)
            o4 = (e6 = (0 | r4.words[s4]) - (0 | n4.words[s4]) + o4) >> 26, this.words[s4] = 67108863 & e6;
          for (; 0 !== o4 && s4 < r4.length; s4++)
            o4 = (e6 = (0 | r4.words[s4]) + o4) >> 26, this.words[s4] = 67108863 & e6;
          if (0 === o4 && s4 < r4.length && r4 !== this)
            for (; s4 < r4.length; s4++)
              this.words[s4] = r4.words[s4];
          return this.length = Math.max(this.length, s4), r4 !== this && (this.negative = 1), this._strip();
        }, i3.prototype.sub = function(t5) {
          return this.clone().isub(t5);
        };
        var b3 = function(t5, e6, r4) {
          var n4, i4, o4, s4 = t5.words, a4 = e6.words, h4 = r4.words, f4 = 0, u4 = 0 | s4[0], c4 = 8191 & u4, d4 = u4 >>> 13, l4 = 0 | s4[1], p4 = 8191 & l4, b4 = l4 >>> 13, m4 = 0 | s4[2], y4 = 8191 & m4, g3 = m4 >>> 13, v4 = 0 | s4[3], w4 = 8191 & v4, M4 = v4 >>> 13, _4 = 0 | s4[4], A4 = 8191 & _4, S4 = _4 >>> 13, E4 = 0 | s4[5], x3 = 8191 & E4, I3 = E4 >>> 13, k3 = 0 | s4[6], R3 = 8191 & k3, T3 = k3 >>> 13, B3 = 0 | s4[7], P3 = 8191 & B3, O3 = B3 >>> 13, U3 = 0 | s4[8], L3 = 8191 & U3, N3 = U3 >>> 13, z3 = 0 | s4[9], C3 = 8191 & z3, q3 = z3 >>> 13, j3 = 0 | a4[0], D3 = 8191 & j3, F3 = j3 >>> 13, K3 = 0 | a4[1], Y3 = 8191 & K3, V3 = K3 >>> 13, W3 = 0 | a4[2], H3 = 8191 & W3, $3 = W3 >>> 13, G3 = 0 | a4[3], Z3 = 8191 & G3, J3 = G3 >>> 13, X3 = 0 | a4[4], Q3 = 8191 & X3, tt2 = X3 >>> 13, et2 = 0 | a4[5], rt2 = 8191 & et2, nt2 = et2 >>> 13, it2 = 0 | a4[6], ot2 = 8191 & it2, st2 = it2 >>> 13, at2 = 0 | a4[7], ht2 = 8191 & at2, ft2 = at2 >>> 13, ut2 = 0 | a4[8], ct2 = 8191 & ut2, dt2 = ut2 >>> 13, lt2 = 0 | a4[9], pt3 = 8191 & lt2, bt2 = lt2 >>> 13;
          r4.negative = t5.negative ^ e6.negative, r4.length = 19;
          var mt3 = (f4 + (n4 = Math.imul(c4, D3)) | 0) + ((8191 & (i4 = (i4 = Math.imul(c4, F3)) + Math.imul(d4, D3) | 0)) << 13) | 0;
          f4 = ((o4 = Math.imul(d4, F3)) + (i4 >>> 13) | 0) + (mt3 >>> 26) | 0, mt3 &= 67108863, n4 = Math.imul(p4, D3), i4 = (i4 = Math.imul(p4, F3)) + Math.imul(b4, D3) | 0, o4 = Math.imul(b4, F3);
          var yt2 = (f4 + (n4 = n4 + Math.imul(c4, Y3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, V3) | 0) + Math.imul(d4, Y3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, V3) | 0) + (i4 >>> 13) | 0) + (yt2 >>> 26) | 0, yt2 &= 67108863, n4 = Math.imul(y4, D3), i4 = (i4 = Math.imul(y4, F3)) + Math.imul(g3, D3) | 0, o4 = Math.imul(g3, F3), n4 = n4 + Math.imul(p4, Y3) | 0, i4 = (i4 = i4 + Math.imul(p4, V3) | 0) + Math.imul(b4, Y3) | 0, o4 = o4 + Math.imul(b4, V3) | 0;
          var gt3 = (f4 + (n4 = n4 + Math.imul(c4, H3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, $3) | 0) + Math.imul(d4, H3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, $3) | 0) + (i4 >>> 13) | 0) + (gt3 >>> 26) | 0, gt3 &= 67108863, n4 = Math.imul(w4, D3), i4 = (i4 = Math.imul(w4, F3)) + Math.imul(M4, D3) | 0, o4 = Math.imul(M4, F3), n4 = n4 + Math.imul(y4, Y3) | 0, i4 = (i4 = i4 + Math.imul(y4, V3) | 0) + Math.imul(g3, Y3) | 0, o4 = o4 + Math.imul(g3, V3) | 0, n4 = n4 + Math.imul(p4, H3) | 0, i4 = (i4 = i4 + Math.imul(p4, $3) | 0) + Math.imul(b4, H3) | 0, o4 = o4 + Math.imul(b4, $3) | 0;
          var vt2 = (f4 + (n4 = n4 + Math.imul(c4, Z3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, J3) | 0) + Math.imul(d4, Z3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, J3) | 0) + (i4 >>> 13) | 0) + (vt2 >>> 26) | 0, vt2 &= 67108863, n4 = Math.imul(A4, D3), i4 = (i4 = Math.imul(A4, F3)) + Math.imul(S4, D3) | 0, o4 = Math.imul(S4, F3), n4 = n4 + Math.imul(w4, Y3) | 0, i4 = (i4 = i4 + Math.imul(w4, V3) | 0) + Math.imul(M4, Y3) | 0, o4 = o4 + Math.imul(M4, V3) | 0, n4 = n4 + Math.imul(y4, H3) | 0, i4 = (i4 = i4 + Math.imul(y4, $3) | 0) + Math.imul(g3, H3) | 0, o4 = o4 + Math.imul(g3, $3) | 0, n4 = n4 + Math.imul(p4, Z3) | 0, i4 = (i4 = i4 + Math.imul(p4, J3) | 0) + Math.imul(b4, Z3) | 0, o4 = o4 + Math.imul(b4, J3) | 0;
          var wt2 = (f4 + (n4 = n4 + Math.imul(c4, Q3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, tt2) | 0) + Math.imul(d4, Q3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, tt2) | 0) + (i4 >>> 13) | 0) + (wt2 >>> 26) | 0, wt2 &= 67108863, n4 = Math.imul(x3, D3), i4 = (i4 = Math.imul(x3, F3)) + Math.imul(I3, D3) | 0, o4 = Math.imul(I3, F3), n4 = n4 + Math.imul(A4, Y3) | 0, i4 = (i4 = i4 + Math.imul(A4, V3) | 0) + Math.imul(S4, Y3) | 0, o4 = o4 + Math.imul(S4, V3) | 0, n4 = n4 + Math.imul(w4, H3) | 0, i4 = (i4 = i4 + Math.imul(w4, $3) | 0) + Math.imul(M4, H3) | 0, o4 = o4 + Math.imul(M4, $3) | 0, n4 = n4 + Math.imul(y4, Z3) | 0, i4 = (i4 = i4 + Math.imul(y4, J3) | 0) + Math.imul(g3, Z3) | 0, o4 = o4 + Math.imul(g3, J3) | 0, n4 = n4 + Math.imul(p4, Q3) | 0, i4 = (i4 = i4 + Math.imul(p4, tt2) | 0) + Math.imul(b4, Q3) | 0, o4 = o4 + Math.imul(b4, tt2) | 0;
          var Mt2 = (f4 + (n4 = n4 + Math.imul(c4, rt2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, nt2) | 0) + Math.imul(d4, rt2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, nt2) | 0) + (i4 >>> 13) | 0) + (Mt2 >>> 26) | 0, Mt2 &= 67108863, n4 = Math.imul(R3, D3), i4 = (i4 = Math.imul(R3, F3)) + Math.imul(T3, D3) | 0, o4 = Math.imul(T3, F3), n4 = n4 + Math.imul(x3, Y3) | 0, i4 = (i4 = i4 + Math.imul(x3, V3) | 0) + Math.imul(I3, Y3) | 0, o4 = o4 + Math.imul(I3, V3) | 0, n4 = n4 + Math.imul(A4, H3) | 0, i4 = (i4 = i4 + Math.imul(A4, $3) | 0) + Math.imul(S4, H3) | 0, o4 = o4 + Math.imul(S4, $3) | 0, n4 = n4 + Math.imul(w4, Z3) | 0, i4 = (i4 = i4 + Math.imul(w4, J3) | 0) + Math.imul(M4, Z3) | 0, o4 = o4 + Math.imul(M4, J3) | 0, n4 = n4 + Math.imul(y4, Q3) | 0, i4 = (i4 = i4 + Math.imul(y4, tt2) | 0) + Math.imul(g3, Q3) | 0, o4 = o4 + Math.imul(g3, tt2) | 0, n4 = n4 + Math.imul(p4, rt2) | 0, i4 = (i4 = i4 + Math.imul(p4, nt2) | 0) + Math.imul(b4, rt2) | 0, o4 = o4 + Math.imul(b4, nt2) | 0;
          var _t2 = (f4 + (n4 = n4 + Math.imul(c4, ot2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, st2) | 0) + Math.imul(d4, ot2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, st2) | 0) + (i4 >>> 13) | 0) + (_t2 >>> 26) | 0, _t2 &= 67108863, n4 = Math.imul(P3, D3), i4 = (i4 = Math.imul(P3, F3)) + Math.imul(O3, D3) | 0, o4 = Math.imul(O3, F3), n4 = n4 + Math.imul(R3, Y3) | 0, i4 = (i4 = i4 + Math.imul(R3, V3) | 0) + Math.imul(T3, Y3) | 0, o4 = o4 + Math.imul(T3, V3) | 0, n4 = n4 + Math.imul(x3, H3) | 0, i4 = (i4 = i4 + Math.imul(x3, $3) | 0) + Math.imul(I3, H3) | 0, o4 = o4 + Math.imul(I3, $3) | 0, n4 = n4 + Math.imul(A4, Z3) | 0, i4 = (i4 = i4 + Math.imul(A4, J3) | 0) + Math.imul(S4, Z3) | 0, o4 = o4 + Math.imul(S4, J3) | 0, n4 = n4 + Math.imul(w4, Q3) | 0, i4 = (i4 = i4 + Math.imul(w4, tt2) | 0) + Math.imul(M4, Q3) | 0, o4 = o4 + Math.imul(M4, tt2) | 0, n4 = n4 + Math.imul(y4, rt2) | 0, i4 = (i4 = i4 + Math.imul(y4, nt2) | 0) + Math.imul(g3, rt2) | 0, o4 = o4 + Math.imul(g3, nt2) | 0, n4 = n4 + Math.imul(p4, ot2) | 0, i4 = (i4 = i4 + Math.imul(p4, st2) | 0) + Math.imul(b4, ot2) | 0, o4 = o4 + Math.imul(b4, st2) | 0;
          var At2 = (f4 + (n4 = n4 + Math.imul(c4, ht2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, ft2) | 0) + Math.imul(d4, ht2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, ft2) | 0) + (i4 >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, n4 = Math.imul(L3, D3), i4 = (i4 = Math.imul(L3, F3)) + Math.imul(N3, D3) | 0, o4 = Math.imul(N3, F3), n4 = n4 + Math.imul(P3, Y3) | 0, i4 = (i4 = i4 + Math.imul(P3, V3) | 0) + Math.imul(O3, Y3) | 0, o4 = o4 + Math.imul(O3, V3) | 0, n4 = n4 + Math.imul(R3, H3) | 0, i4 = (i4 = i4 + Math.imul(R3, $3) | 0) + Math.imul(T3, H3) | 0, o4 = o4 + Math.imul(T3, $3) | 0, n4 = n4 + Math.imul(x3, Z3) | 0, i4 = (i4 = i4 + Math.imul(x3, J3) | 0) + Math.imul(I3, Z3) | 0, o4 = o4 + Math.imul(I3, J3) | 0, n4 = n4 + Math.imul(A4, Q3) | 0, i4 = (i4 = i4 + Math.imul(A4, tt2) | 0) + Math.imul(S4, Q3) | 0, o4 = o4 + Math.imul(S4, tt2) | 0, n4 = n4 + Math.imul(w4, rt2) | 0, i4 = (i4 = i4 + Math.imul(w4, nt2) | 0) + Math.imul(M4, rt2) | 0, o4 = o4 + Math.imul(M4, nt2) | 0, n4 = n4 + Math.imul(y4, ot2) | 0, i4 = (i4 = i4 + Math.imul(y4, st2) | 0) + Math.imul(g3, ot2) | 0, o4 = o4 + Math.imul(g3, st2) | 0, n4 = n4 + Math.imul(p4, ht2) | 0, i4 = (i4 = i4 + Math.imul(p4, ft2) | 0) + Math.imul(b4, ht2) | 0, o4 = o4 + Math.imul(b4, ft2) | 0;
          var St2 = (f4 + (n4 = n4 + Math.imul(c4, ct2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, dt2) | 0) + Math.imul(d4, ct2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, dt2) | 0) + (i4 >>> 13) | 0) + (St2 >>> 26) | 0, St2 &= 67108863, n4 = Math.imul(C3, D3), i4 = (i4 = Math.imul(C3, F3)) + Math.imul(q3, D3) | 0, o4 = Math.imul(q3, F3), n4 = n4 + Math.imul(L3, Y3) | 0, i4 = (i4 = i4 + Math.imul(L3, V3) | 0) + Math.imul(N3, Y3) | 0, o4 = o4 + Math.imul(N3, V3) | 0, n4 = n4 + Math.imul(P3, H3) | 0, i4 = (i4 = i4 + Math.imul(P3, $3) | 0) + Math.imul(O3, H3) | 0, o4 = o4 + Math.imul(O3, $3) | 0, n4 = n4 + Math.imul(R3, Z3) | 0, i4 = (i4 = i4 + Math.imul(R3, J3) | 0) + Math.imul(T3, Z3) | 0, o4 = o4 + Math.imul(T3, J3) | 0, n4 = n4 + Math.imul(x3, Q3) | 0, i4 = (i4 = i4 + Math.imul(x3, tt2) | 0) + Math.imul(I3, Q3) | 0, o4 = o4 + Math.imul(I3, tt2) | 0, n4 = n4 + Math.imul(A4, rt2) | 0, i4 = (i4 = i4 + Math.imul(A4, nt2) | 0) + Math.imul(S4, rt2) | 0, o4 = o4 + Math.imul(S4, nt2) | 0, n4 = n4 + Math.imul(w4, ot2) | 0, i4 = (i4 = i4 + Math.imul(w4, st2) | 0) + Math.imul(M4, ot2) | 0, o4 = o4 + Math.imul(M4, st2) | 0, n4 = n4 + Math.imul(y4, ht2) | 0, i4 = (i4 = i4 + Math.imul(y4, ft2) | 0) + Math.imul(g3, ht2) | 0, o4 = o4 + Math.imul(g3, ft2) | 0, n4 = n4 + Math.imul(p4, ct2) | 0, i4 = (i4 = i4 + Math.imul(p4, dt2) | 0) + Math.imul(b4, ct2) | 0, o4 = o4 + Math.imul(b4, dt2) | 0;
          var Et2 = (f4 + (n4 = n4 + Math.imul(c4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, bt2) | 0) + Math.imul(d4, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, bt2) | 0) + (i4 >>> 13) | 0) + (Et2 >>> 26) | 0, Et2 &= 67108863, n4 = Math.imul(C3, Y3), i4 = (i4 = Math.imul(C3, V3)) + Math.imul(q3, Y3) | 0, o4 = Math.imul(q3, V3), n4 = n4 + Math.imul(L3, H3) | 0, i4 = (i4 = i4 + Math.imul(L3, $3) | 0) + Math.imul(N3, H3) | 0, o4 = o4 + Math.imul(N3, $3) | 0, n4 = n4 + Math.imul(P3, Z3) | 0, i4 = (i4 = i4 + Math.imul(P3, J3) | 0) + Math.imul(O3, Z3) | 0, o4 = o4 + Math.imul(O3, J3) | 0, n4 = n4 + Math.imul(R3, Q3) | 0, i4 = (i4 = i4 + Math.imul(R3, tt2) | 0) + Math.imul(T3, Q3) | 0, o4 = o4 + Math.imul(T3, tt2) | 0, n4 = n4 + Math.imul(x3, rt2) | 0, i4 = (i4 = i4 + Math.imul(x3, nt2) | 0) + Math.imul(I3, rt2) | 0, o4 = o4 + Math.imul(I3, nt2) | 0, n4 = n4 + Math.imul(A4, ot2) | 0, i4 = (i4 = i4 + Math.imul(A4, st2) | 0) + Math.imul(S4, ot2) | 0, o4 = o4 + Math.imul(S4, st2) | 0, n4 = n4 + Math.imul(w4, ht2) | 0, i4 = (i4 = i4 + Math.imul(w4, ft2) | 0) + Math.imul(M4, ht2) | 0, o4 = o4 + Math.imul(M4, ft2) | 0, n4 = n4 + Math.imul(y4, ct2) | 0, i4 = (i4 = i4 + Math.imul(y4, dt2) | 0) + Math.imul(g3, ct2) | 0, o4 = o4 + Math.imul(g3, dt2) | 0;
          var xt2 = (f4 + (n4 = n4 + Math.imul(p4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(p4, bt2) | 0) + Math.imul(b4, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(b4, bt2) | 0) + (i4 >>> 13) | 0) + (xt2 >>> 26) | 0, xt2 &= 67108863, n4 = Math.imul(C3, H3), i4 = (i4 = Math.imul(C3, $3)) + Math.imul(q3, H3) | 0, o4 = Math.imul(q3, $3), n4 = n4 + Math.imul(L3, Z3) | 0, i4 = (i4 = i4 + Math.imul(L3, J3) | 0) + Math.imul(N3, Z3) | 0, o4 = o4 + Math.imul(N3, J3) | 0, n4 = n4 + Math.imul(P3, Q3) | 0, i4 = (i4 = i4 + Math.imul(P3, tt2) | 0) + Math.imul(O3, Q3) | 0, o4 = o4 + Math.imul(O3, tt2) | 0, n4 = n4 + Math.imul(R3, rt2) | 0, i4 = (i4 = i4 + Math.imul(R3, nt2) | 0) + Math.imul(T3, rt2) | 0, o4 = o4 + Math.imul(T3, nt2) | 0, n4 = n4 + Math.imul(x3, ot2) | 0, i4 = (i4 = i4 + Math.imul(x3, st2) | 0) + Math.imul(I3, ot2) | 0, o4 = o4 + Math.imul(I3, st2) | 0, n4 = n4 + Math.imul(A4, ht2) | 0, i4 = (i4 = i4 + Math.imul(A4, ft2) | 0) + Math.imul(S4, ht2) | 0, o4 = o4 + Math.imul(S4, ft2) | 0, n4 = n4 + Math.imul(w4, ct2) | 0, i4 = (i4 = i4 + Math.imul(w4, dt2) | 0) + Math.imul(M4, ct2) | 0, o4 = o4 + Math.imul(M4, dt2) | 0;
          var It2 = (f4 + (n4 = n4 + Math.imul(y4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(y4, bt2) | 0) + Math.imul(g3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(g3, bt2) | 0) + (i4 >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, n4 = Math.imul(C3, Z3), i4 = (i4 = Math.imul(C3, J3)) + Math.imul(q3, Z3) | 0, o4 = Math.imul(q3, J3), n4 = n4 + Math.imul(L3, Q3) | 0, i4 = (i4 = i4 + Math.imul(L3, tt2) | 0) + Math.imul(N3, Q3) | 0, o4 = o4 + Math.imul(N3, tt2) | 0, n4 = n4 + Math.imul(P3, rt2) | 0, i4 = (i4 = i4 + Math.imul(P3, nt2) | 0) + Math.imul(O3, rt2) | 0, o4 = o4 + Math.imul(O3, nt2) | 0, n4 = n4 + Math.imul(R3, ot2) | 0, i4 = (i4 = i4 + Math.imul(R3, st2) | 0) + Math.imul(T3, ot2) | 0, o4 = o4 + Math.imul(T3, st2) | 0, n4 = n4 + Math.imul(x3, ht2) | 0, i4 = (i4 = i4 + Math.imul(x3, ft2) | 0) + Math.imul(I3, ht2) | 0, o4 = o4 + Math.imul(I3, ft2) | 0, n4 = n4 + Math.imul(A4, ct2) | 0, i4 = (i4 = i4 + Math.imul(A4, dt2) | 0) + Math.imul(S4, ct2) | 0, o4 = o4 + Math.imul(S4, dt2) | 0;
          var kt2 = (f4 + (n4 = n4 + Math.imul(w4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(w4, bt2) | 0) + Math.imul(M4, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(M4, bt2) | 0) + (i4 >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, n4 = Math.imul(C3, Q3), i4 = (i4 = Math.imul(C3, tt2)) + Math.imul(q3, Q3) | 0, o4 = Math.imul(q3, tt2), n4 = n4 + Math.imul(L3, rt2) | 0, i4 = (i4 = i4 + Math.imul(L3, nt2) | 0) + Math.imul(N3, rt2) | 0, o4 = o4 + Math.imul(N3, nt2) | 0, n4 = n4 + Math.imul(P3, ot2) | 0, i4 = (i4 = i4 + Math.imul(P3, st2) | 0) + Math.imul(O3, ot2) | 0, o4 = o4 + Math.imul(O3, st2) | 0, n4 = n4 + Math.imul(R3, ht2) | 0, i4 = (i4 = i4 + Math.imul(R3, ft2) | 0) + Math.imul(T3, ht2) | 0, o4 = o4 + Math.imul(T3, ft2) | 0, n4 = n4 + Math.imul(x3, ct2) | 0, i4 = (i4 = i4 + Math.imul(x3, dt2) | 0) + Math.imul(I3, ct2) | 0, o4 = o4 + Math.imul(I3, dt2) | 0;
          var Rt2 = (f4 + (n4 = n4 + Math.imul(A4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(A4, bt2) | 0) + Math.imul(S4, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(S4, bt2) | 0) + (i4 >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, n4 = Math.imul(C3, rt2), i4 = (i4 = Math.imul(C3, nt2)) + Math.imul(q3, rt2) | 0, o4 = Math.imul(q3, nt2), n4 = n4 + Math.imul(L3, ot2) | 0, i4 = (i4 = i4 + Math.imul(L3, st2) | 0) + Math.imul(N3, ot2) | 0, o4 = o4 + Math.imul(N3, st2) | 0, n4 = n4 + Math.imul(P3, ht2) | 0, i4 = (i4 = i4 + Math.imul(P3, ft2) | 0) + Math.imul(O3, ht2) | 0, o4 = o4 + Math.imul(O3, ft2) | 0, n4 = n4 + Math.imul(R3, ct2) | 0, i4 = (i4 = i4 + Math.imul(R3, dt2) | 0) + Math.imul(T3, ct2) | 0, o4 = o4 + Math.imul(T3, dt2) | 0;
          var Tt2 = (f4 + (n4 = n4 + Math.imul(x3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(x3, bt2) | 0) + Math.imul(I3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(I3, bt2) | 0) + (i4 >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, n4 = Math.imul(C3, ot2), i4 = (i4 = Math.imul(C3, st2)) + Math.imul(q3, ot2) | 0, o4 = Math.imul(q3, st2), n4 = n4 + Math.imul(L3, ht2) | 0, i4 = (i4 = i4 + Math.imul(L3, ft2) | 0) + Math.imul(N3, ht2) | 0, o4 = o4 + Math.imul(N3, ft2) | 0, n4 = n4 + Math.imul(P3, ct2) | 0, i4 = (i4 = i4 + Math.imul(P3, dt2) | 0) + Math.imul(O3, ct2) | 0, o4 = o4 + Math.imul(O3, dt2) | 0;
          var Bt2 = (f4 + (n4 = n4 + Math.imul(R3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(R3, bt2) | 0) + Math.imul(T3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(T3, bt2) | 0) + (i4 >>> 13) | 0) + (Bt2 >>> 26) | 0, Bt2 &= 67108863, n4 = Math.imul(C3, ht2), i4 = (i4 = Math.imul(C3, ft2)) + Math.imul(q3, ht2) | 0, o4 = Math.imul(q3, ft2), n4 = n4 + Math.imul(L3, ct2) | 0, i4 = (i4 = i4 + Math.imul(L3, dt2) | 0) + Math.imul(N3, ct2) | 0, o4 = o4 + Math.imul(N3, dt2) | 0;
          var Pt2 = (f4 + (n4 = n4 + Math.imul(P3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(P3, bt2) | 0) + Math.imul(O3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(O3, bt2) | 0) + (i4 >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, n4 = Math.imul(C3, ct2), i4 = (i4 = Math.imul(C3, dt2)) + Math.imul(q3, ct2) | 0, o4 = Math.imul(q3, dt2);
          var Ot2 = (f4 + (n4 = n4 + Math.imul(L3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(L3, bt2) | 0) + Math.imul(N3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(N3, bt2) | 0) + (i4 >>> 13) | 0) + (Ot2 >>> 26) | 0, Ot2 &= 67108863;
          var Ut2 = (f4 + (n4 = Math.imul(C3, pt3)) | 0) + ((8191 & (i4 = (i4 = Math.imul(C3, bt2)) + Math.imul(q3, pt3) | 0)) << 13) | 0;
          return f4 = ((o4 = Math.imul(q3, bt2)) + (i4 >>> 13) | 0) + (Ut2 >>> 26) | 0, Ut2 &= 67108863, h4[0] = mt3, h4[1] = yt2, h4[2] = gt3, h4[3] = vt2, h4[4] = wt2, h4[5] = Mt2, h4[6] = _t2, h4[7] = At2, h4[8] = St2, h4[9] = Et2, h4[10] = xt2, h4[11] = It2, h4[12] = kt2, h4[13] = Rt2, h4[14] = Tt2, h4[15] = Bt2, h4[16] = Pt2, h4[17] = Ot2, h4[18] = Ut2, 0 !== f4 && (h4[19] = f4, r4.length++), r4;
        };
        function m3(t5, e6, r4) {
          r4.negative = e6.negative ^ t5.negative, r4.length = t5.length + e6.length;
          for (var n4 = 0, i4 = 0, o4 = 0; o4 < r4.length - 1; o4++) {
            var s4 = i4;
            i4 = 0;
            for (var a4 = 67108863 & n4, h4 = Math.min(o4, e6.length - 1), f4 = Math.max(0, o4 - t5.length + 1); f4 <= h4; f4++) {
              var u4 = o4 - f4, c4 = (0 | t5.words[u4]) * (0 | e6.words[f4]), d4 = 67108863 & c4;
              a4 = 67108863 & (d4 = d4 + a4 | 0), i4 += (s4 = (s4 = s4 + (c4 / 67108864 | 0) | 0) + (d4 >>> 26) | 0) >>> 26, s4 &= 67108863;
            }
            r4.words[o4] = a4, n4 = s4, s4 = i4;
          }
          return 0 !== n4 ? r4.words[o4] = n4 : r4.length--, r4._strip();
        }
        function y3(t5, e6, r4) {
          return m3(t5, e6, r4);
        }
        Math.imul || (b3 = p3), i3.prototype.mulTo = function(t5, e6) {
          var r4 = this.length + t5.length;
          return 10 === this.length && 10 === t5.length ? b3(this, t5, e6) : r4 < 63 ? p3(this, t5, e6) : r4 < 1024 ? m3(this, t5, e6) : y3(this, t5, e6);
        }, i3.prototype.mul = function(t5) {
          var e6 = new i3(null);
          return e6.words = new Array(this.length + t5.length), this.mulTo(t5, e6);
        }, i3.prototype.mulf = function(t5) {
          var e6 = new i3(null);
          return e6.words = new Array(this.length + t5.length), y3(this, t5, e6);
        }, i3.prototype.imul = function(t5) {
          return this.clone().mulTo(t5, this);
        }, i3.prototype.imuln = function(t5) {
          var e6 = t5 < 0;
          e6 && (t5 = -t5), r3("number" == typeof t5), r3(t5 < 67108864);
          for (var n4 = 0, i4 = 0; i4 < this.length; i4++) {
            var o4 = (0 | this.words[i4]) * t5, s4 = (67108863 & o4) + (67108863 & n4);
            n4 >>= 26, n4 += o4 / 67108864 | 0, n4 += s4 >>> 26, this.words[i4] = 67108863 & s4;
          }
          return 0 !== n4 && (this.words[i4] = n4, this.length++), e6 ? this.ineg() : this;
        }, i3.prototype.muln = function(t5) {
          return this.clone().imuln(t5);
        }, i3.prototype.sqr = function() {
          return this.mul(this);
        }, i3.prototype.isqr = function() {
          return this.imul(this.clone());
        }, i3.prototype.pow = function(t5) {
          var e6 = function(t6) {
            for (var e7 = new Array(t6.bitLength()), r5 = 0; r5 < e7.length; r5++) {
              var n5 = r5 / 26 | 0, i4 = r5 % 26;
              e7[r5] = t6.words[n5] >>> i4 & 1;
            }
            return e7;
          }(t5);
          if (0 === e6.length)
            return new i3(1);
          for (var r4 = this, n4 = 0; n4 < e6.length && 0 === e6[n4]; n4++, r4 = r4.sqr())
            ;
          if (++n4 < e6.length)
            for (var o4 = r4.sqr(); n4 < e6.length; n4++, o4 = o4.sqr())
              0 !== e6[n4] && (r4 = r4.mul(o4));
          return r4;
        }, i3.prototype.iushln = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6, n4 = t5 % 26, i4 = (t5 - n4) / 26, o4 = 67108863 >>> 26 - n4 << 26 - n4;
          if (0 !== n4) {
            var s4 = 0;
            for (e6 = 0; e6 < this.length; e6++) {
              var a4 = this.words[e6] & o4, h4 = (0 | this.words[e6]) - a4 << n4;
              this.words[e6] = h4 | s4, s4 = a4 >>> 26 - n4;
            }
            s4 && (this.words[e6] = s4, this.length++);
          }
          if (0 !== i4) {
            for (e6 = this.length - 1; e6 >= 0; e6--)
              this.words[e6 + i4] = this.words[e6];
            for (e6 = 0; e6 < i4; e6++)
              this.words[e6] = 0;
            this.length += i4;
          }
          return this._strip();
        }, i3.prototype.ishln = function(t5) {
          return r3(0 === this.negative), this.iushln(t5);
        }, i3.prototype.iushrn = function(t5, e6, n4) {
          var i4;
          r3("number" == typeof t5 && t5 >= 0), i4 = e6 ? (e6 - e6 % 26) / 26 : 0;
          var o4 = t5 % 26, s4 = Math.min((t5 - o4) / 26, this.length), a4 = 67108863 ^ 67108863 >>> o4 << o4, h4 = n4;
          if (i4 -= s4, i4 = Math.max(0, i4), h4) {
            for (var f4 = 0; f4 < s4; f4++)
              h4.words[f4] = this.words[f4];
            h4.length = s4;
          }
          if (0 === s4)
            ;
          else if (this.length > s4)
            for (this.length -= s4, f4 = 0; f4 < this.length; f4++)
              this.words[f4] = this.words[f4 + s4];
          else
            this.words[0] = 0, this.length = 1;
          var u4 = 0;
          for (f4 = this.length - 1; f4 >= 0 && (0 !== u4 || f4 >= i4); f4--) {
            var c4 = 0 | this.words[f4];
            this.words[f4] = u4 << 26 - o4 | c4 >>> o4, u4 = c4 & a4;
          }
          return h4 && 0 !== u4 && (h4.words[h4.length++] = u4), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip();
        }, i3.prototype.ishrn = function(t5, e6, n4) {
          return r3(0 === this.negative), this.iushrn(t5, e6, n4);
        }, i3.prototype.shln = function(t5) {
          return this.clone().ishln(t5);
        }, i3.prototype.ushln = function(t5) {
          return this.clone().iushln(t5);
        }, i3.prototype.shrn = function(t5) {
          return this.clone().ishrn(t5);
        }, i3.prototype.ushrn = function(t5) {
          return this.clone().iushrn(t5);
        }, i3.prototype.testn = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6 = t5 % 26, n4 = (t5 - e6) / 26, i4 = 1 << e6;
          return !(this.length <= n4) && !!(this.words[n4] & i4);
        }, i3.prototype.imaskn = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6 = t5 % 26, n4 = (t5 - e6) / 26;
          if (r3(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n4)
            return this;
          if (0 !== e6 && n4++, this.length = Math.min(n4, this.length), 0 !== e6) {
            var i4 = 67108863 ^ 67108863 >>> e6 << e6;
            this.words[this.length - 1] &= i4;
          }
          return this._strip();
        }, i3.prototype.maskn = function(t5) {
          return this.clone().imaskn(t5);
        }, i3.prototype.iaddn = function(t5) {
          return r3("number" == typeof t5), r3(t5 < 67108864), t5 < 0 ? this.isubn(-t5) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= t5 ? (this.words[0] = t5 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t5), this.negative = 1, this) : this._iaddn(t5);
        }, i3.prototype._iaddn = function(t5) {
          this.words[0] += t5;
          for (var e6 = 0; e6 < this.length && this.words[e6] >= 67108864; e6++)
            this.words[e6] -= 67108864, e6 === this.length - 1 ? this.words[e6 + 1] = 1 : this.words[e6 + 1]++;
          return this.length = Math.max(this.length, e6 + 1), this;
        }, i3.prototype.isubn = function(t5) {
          if (r3("number" == typeof t5), r3(t5 < 67108864), t5 < 0)
            return this.iaddn(-t5);
          if (0 !== this.negative)
            return this.negative = 0, this.iaddn(t5), this.negative = 1, this;
          if (this.words[0] -= t5, 1 === this.length && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var e6 = 0; e6 < this.length && this.words[e6] < 0; e6++)
              this.words[e6] += 67108864, this.words[e6 + 1] -= 1;
          return this._strip();
        }, i3.prototype.addn = function(t5) {
          return this.clone().iaddn(t5);
        }, i3.prototype.subn = function(t5) {
          return this.clone().isubn(t5);
        }, i3.prototype.iabs = function() {
          return this.negative = 0, this;
        }, i3.prototype.abs = function() {
          return this.clone().iabs();
        }, i3.prototype._ishlnsubmul = function(t5, e6, n4) {
          var i4, o4, s4 = t5.length + n4;
          this._expand(s4);
          var a4 = 0;
          for (i4 = 0; i4 < t5.length; i4++) {
            o4 = (0 | this.words[i4 + n4]) + a4;
            var h4 = (0 | t5.words[i4]) * e6;
            a4 = ((o4 -= 67108863 & h4) >> 26) - (h4 / 67108864 | 0), this.words[i4 + n4] = 67108863 & o4;
          }
          for (; i4 < this.length - n4; i4++)
            a4 = (o4 = (0 | this.words[i4 + n4]) + a4) >> 26, this.words[i4 + n4] = 67108863 & o4;
          if (0 === a4)
            return this._strip();
          for (r3(-1 === a4), a4 = 0, i4 = 0; i4 < this.length; i4++)
            a4 = (o4 = -(0 | this.words[i4]) + a4) >> 26, this.words[i4] = 67108863 & o4;
          return this.negative = 1, this._strip();
        }, i3.prototype._wordDiv = function(t5, e6) {
          var r4 = (this.length, t5.length), n4 = this.clone(), o4 = t5, s4 = 0 | o4.words[o4.length - 1];
          0 !== (r4 = 26 - this._countBits(s4)) && (o4 = o4.ushln(r4), n4.iushln(r4), s4 = 0 | o4.words[o4.length - 1]);
          var a4, h4 = n4.length - o4.length;
          if ("mod" !== e6) {
            (a4 = new i3(null)).length = h4 + 1, a4.words = new Array(a4.length);
            for (var f4 = 0; f4 < a4.length; f4++)
              a4.words[f4] = 0;
          }
          var u4 = n4.clone()._ishlnsubmul(o4, 1, h4);
          0 === u4.negative && (n4 = u4, a4 && (a4.words[h4] = 1));
          for (var c4 = h4 - 1; c4 >= 0; c4--) {
            var d4 = 67108864 * (0 | n4.words[o4.length + c4]) + (0 | n4.words[o4.length + c4 - 1]);
            for (d4 = Math.min(d4 / s4 | 0, 67108863), n4._ishlnsubmul(o4, d4, c4); 0 !== n4.negative; )
              d4--, n4.negative = 0, n4._ishlnsubmul(o4, 1, c4), n4.isZero() || (n4.negative ^= 1);
            a4 && (a4.words[c4] = d4);
          }
          return a4 && a4._strip(), n4._strip(), "div" !== e6 && 0 !== r4 && n4.iushrn(r4), { div: a4 || null, mod: n4 };
        }, i3.prototype.divmod = function(t5, e6, n4) {
          return r3(!t5.isZero()), this.isZero() ? { div: new i3(0), mod: new i3(0) } : 0 !== this.negative && 0 === t5.negative ? (a4 = this.neg().divmod(t5, e6), "mod" !== e6 && (o4 = a4.div.neg()), "div" !== e6 && (s4 = a4.mod.neg(), n4 && 0 !== s4.negative && s4.iadd(t5)), { div: o4, mod: s4 }) : 0 === this.negative && 0 !== t5.negative ? (a4 = this.divmod(t5.neg(), e6), "mod" !== e6 && (o4 = a4.div.neg()), { div: o4, mod: a4.mod }) : 0 != (this.negative & t5.negative) ? (a4 = this.neg().divmod(t5.neg(), e6), "div" !== e6 && (s4 = a4.mod.neg(), n4 && 0 !== s4.negative && s4.isub(t5)), { div: a4.div, mod: s4 }) : t5.length > this.length || this.cmp(t5) < 0 ? { div: new i3(0), mod: this } : 1 === t5.length ? "div" === e6 ? { div: this.divn(t5.words[0]), mod: null } : "mod" === e6 ? { div: null, mod: new i3(this.modrn(t5.words[0])) } : { div: this.divn(t5.words[0]), mod: new i3(this.modrn(t5.words[0])) } : this._wordDiv(t5, e6);
          var o4, s4, a4;
        }, i3.prototype.div = function(t5) {
          return this.divmod(t5, "div", false).div;
        }, i3.prototype.mod = function(t5) {
          return this.divmod(t5, "mod", false).mod;
        }, i3.prototype.umod = function(t5) {
          return this.divmod(t5, "mod", true).mod;
        }, i3.prototype.divRound = function(t5) {
          var e6 = this.divmod(t5);
          if (e6.mod.isZero())
            return e6.div;
          var r4 = 0 !== e6.div.negative ? e6.mod.isub(t5) : e6.mod, n4 = t5.ushrn(1), i4 = t5.andln(1), o4 = r4.cmp(n4);
          return o4 < 0 || 1 === i4 && 0 === o4 ? e6.div : 0 !== e6.div.negative ? e6.div.isubn(1) : e6.div.iaddn(1);
        }, i3.prototype.modrn = function(t5) {
          var e6 = t5 < 0;
          e6 && (t5 = -t5), r3(t5 <= 67108863);
          for (var n4 = (1 << 26) % t5, i4 = 0, o4 = this.length - 1; o4 >= 0; o4--)
            i4 = (n4 * i4 + (0 | this.words[o4])) % t5;
          return e6 ? -i4 : i4;
        }, i3.prototype.modn = function(t5) {
          return this.modrn(t5);
        }, i3.prototype.idivn = function(t5) {
          var e6 = t5 < 0;
          e6 && (t5 = -t5), r3(t5 <= 67108863);
          for (var n4 = 0, i4 = this.length - 1; i4 >= 0; i4--) {
            var o4 = (0 | this.words[i4]) + 67108864 * n4;
            this.words[i4] = o4 / t5 | 0, n4 = o4 % t5;
          }
          return this._strip(), e6 ? this.ineg() : this;
        }, i3.prototype.divn = function(t5) {
          return this.clone().idivn(t5);
        }, i3.prototype.egcd = function(t5) {
          r3(0 === t5.negative), r3(!t5.isZero());
          var e6 = this, n4 = t5.clone();
          e6 = 0 !== e6.negative ? e6.umod(t5) : e6.clone();
          for (var o4 = new i3(1), s4 = new i3(0), a4 = new i3(0), h4 = new i3(1), f4 = 0; e6.isEven() && n4.isEven(); )
            e6.iushrn(1), n4.iushrn(1), ++f4;
          for (var u4 = n4.clone(), c4 = e6.clone(); !e6.isZero(); ) {
            for (var d4 = 0, l4 = 1; 0 == (e6.words[0] & l4) && d4 < 26; ++d4, l4 <<= 1)
              ;
            if (d4 > 0)
              for (e6.iushrn(d4); d4-- > 0; )
                (o4.isOdd() || s4.isOdd()) && (o4.iadd(u4), s4.isub(c4)), o4.iushrn(1), s4.iushrn(1);
            for (var p4 = 0, b4 = 1; 0 == (n4.words[0] & b4) && p4 < 26; ++p4, b4 <<= 1)
              ;
            if (p4 > 0)
              for (n4.iushrn(p4); p4-- > 0; )
                (a4.isOdd() || h4.isOdd()) && (a4.iadd(u4), h4.isub(c4)), a4.iushrn(1), h4.iushrn(1);
            e6.cmp(n4) >= 0 ? (e6.isub(n4), o4.isub(a4), s4.isub(h4)) : (n4.isub(e6), a4.isub(o4), h4.isub(s4));
          }
          return { a: a4, b: h4, gcd: n4.iushln(f4) };
        }, i3.prototype._invmp = function(t5) {
          r3(0 === t5.negative), r3(!t5.isZero());
          var e6 = this, n4 = t5.clone();
          e6 = 0 !== e6.negative ? e6.umod(t5) : e6.clone();
          for (var o4, s4 = new i3(1), a4 = new i3(0), h4 = n4.clone(); e6.cmpn(1) > 0 && n4.cmpn(1) > 0; ) {
            for (var f4 = 0, u4 = 1; 0 == (e6.words[0] & u4) && f4 < 26; ++f4, u4 <<= 1)
              ;
            if (f4 > 0)
              for (e6.iushrn(f4); f4-- > 0; )
                s4.isOdd() && s4.iadd(h4), s4.iushrn(1);
            for (var c4 = 0, d4 = 1; 0 == (n4.words[0] & d4) && c4 < 26; ++c4, d4 <<= 1)
              ;
            if (c4 > 0)
              for (n4.iushrn(c4); c4-- > 0; )
                a4.isOdd() && a4.iadd(h4), a4.iushrn(1);
            e6.cmp(n4) >= 0 ? (e6.isub(n4), s4.isub(a4)) : (n4.isub(e6), a4.isub(s4));
          }
          return (o4 = 0 === e6.cmpn(1) ? s4 : a4).cmpn(0) < 0 && o4.iadd(t5), o4;
        }, i3.prototype.gcd = function(t5) {
          if (this.isZero())
            return t5.abs();
          if (t5.isZero())
            return this.abs();
          var e6 = this.clone(), r4 = t5.clone();
          e6.negative = 0, r4.negative = 0;
          for (var n4 = 0; e6.isEven() && r4.isEven(); n4++)
            e6.iushrn(1), r4.iushrn(1);
          for (; ; ) {
            for (; e6.isEven(); )
              e6.iushrn(1);
            for (; r4.isEven(); )
              r4.iushrn(1);
            var i4 = e6.cmp(r4);
            if (i4 < 0) {
              var o4 = e6;
              e6 = r4, r4 = o4;
            } else if (0 === i4 || 0 === r4.cmpn(1))
              break;
            e6.isub(r4);
          }
          return r4.iushln(n4);
        }, i3.prototype.invm = function(t5) {
          return this.egcd(t5).a.umod(t5);
        }, i3.prototype.isEven = function() {
          return 0 == (1 & this.words[0]);
        }, i3.prototype.isOdd = function() {
          return 1 == (1 & this.words[0]);
        }, i3.prototype.andln = function(t5) {
          return this.words[0] & t5;
        }, i3.prototype.bincn = function(t5) {
          r3("number" == typeof t5);
          var e6 = t5 % 26, n4 = (t5 - e6) / 26, i4 = 1 << e6;
          if (this.length <= n4)
            return this._expand(n4 + 1), this.words[n4] |= i4, this;
          for (var o4 = i4, s4 = n4; 0 !== o4 && s4 < this.length; s4++) {
            var a4 = 0 | this.words[s4];
            o4 = (a4 += o4) >>> 26, a4 &= 67108863, this.words[s4] = a4;
          }
          return 0 !== o4 && (this.words[s4] = o4, this.length++), this;
        }, i3.prototype.isZero = function() {
          return 1 === this.length && 0 === this.words[0];
        }, i3.prototype.cmpn = function(t5) {
          var e6, n4 = t5 < 0;
          if (0 !== this.negative && !n4)
            return -1;
          if (0 === this.negative && n4)
            return 1;
          if (this._strip(), this.length > 1)
            e6 = 1;
          else {
            n4 && (t5 = -t5), r3(t5 <= 67108863, "Number is too big");
            var i4 = 0 | this.words[0];
            e6 = i4 === t5 ? 0 : i4 < t5 ? -1 : 1;
          }
          return 0 !== this.negative ? 0 | -e6 : e6;
        }, i3.prototype.cmp = function(t5) {
          if (0 !== this.negative && 0 === t5.negative)
            return -1;
          if (0 === this.negative && 0 !== t5.negative)
            return 1;
          var e6 = this.ucmp(t5);
          return 0 !== this.negative ? 0 | -e6 : e6;
        }, i3.prototype.ucmp = function(t5) {
          if (this.length > t5.length)
            return 1;
          if (this.length < t5.length)
            return -1;
          for (var e6 = 0, r4 = this.length - 1; r4 >= 0; r4--) {
            var n4 = 0 | this.words[r4], i4 = 0 | t5.words[r4];
            if (n4 !== i4) {
              n4 < i4 ? e6 = -1 : n4 > i4 && (e6 = 1);
              break;
            }
          }
          return e6;
        }, i3.prototype.gtn = function(t5) {
          return 1 === this.cmpn(t5);
        }, i3.prototype.gt = function(t5) {
          return 1 === this.cmp(t5);
        }, i3.prototype.gten = function(t5) {
          return this.cmpn(t5) >= 0;
        }, i3.prototype.gte = function(t5) {
          return this.cmp(t5) >= 0;
        }, i3.prototype.ltn = function(t5) {
          return -1 === this.cmpn(t5);
        }, i3.prototype.lt = function(t5) {
          return -1 === this.cmp(t5);
        }, i3.prototype.lten = function(t5) {
          return this.cmpn(t5) <= 0;
        }, i3.prototype.lte = function(t5) {
          return this.cmp(t5) <= 0;
        }, i3.prototype.eqn = function(t5) {
          return 0 === this.cmpn(t5);
        }, i3.prototype.eq = function(t5) {
          return 0 === this.cmp(t5);
        }, i3.red = function(t5) {
          return new S3(t5);
        }, i3.prototype.toRed = function(t5) {
          return r3(!this.red, "Already a number in reduction context"), r3(0 === this.negative, "red works only with positives"), t5.convertTo(this)._forceRed(t5);
        }, i3.prototype.fromRed = function() {
          return r3(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, i3.prototype._forceRed = function(t5) {
          return this.red = t5, this;
        }, i3.prototype.forceRed = function(t5) {
          return r3(!this.red, "Already a number in reduction context"), this._forceRed(t5);
        }, i3.prototype.redAdd = function(t5) {
          return r3(this.red, "redAdd works only with red numbers"), this.red.add(this, t5);
        }, i3.prototype.redIAdd = function(t5) {
          return r3(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t5);
        }, i3.prototype.redSub = function(t5) {
          return r3(this.red, "redSub works only with red numbers"), this.red.sub(this, t5);
        }, i3.prototype.redISub = function(t5) {
          return r3(this.red, "redISub works only with red numbers"), this.red.isub(this, t5);
        }, i3.prototype.redShl = function(t5) {
          return r3(this.red, "redShl works only with red numbers"), this.red.shl(this, t5);
        }, i3.prototype.redMul = function(t5) {
          return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, t5), this.red.mul(this, t5);
        }, i3.prototype.redIMul = function(t5) {
          return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, t5), this.red.imul(this, t5);
        }, i3.prototype.redSqr = function() {
          return r3(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, i3.prototype.redISqr = function() {
          return r3(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, i3.prototype.redSqrt = function() {
          return r3(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, i3.prototype.redInvm = function() {
          return r3(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, i3.prototype.redNeg = function() {
          return r3(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, i3.prototype.redPow = function(t5) {
          return r3(this.red && !t5.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t5);
        };
        var g2 = { k256: null, p224: null, p192: null, p25519: null };
        function v3(t5, e6) {
          this.name = t5, this.p = new i3(e6, 16), this.n = this.p.bitLength(), this.k = new i3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        function w3() {
          v3.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function M3() {
          v3.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function _3() {
          v3.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function A3() {
          v3.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function S3(t5) {
          if ("string" == typeof t5) {
            var e6 = i3._prime(t5);
            this.m = e6.p, this.prime = e6;
          } else
            r3(t5.gtn(1), "modulus must be greater than 1"), this.m = t5, this.prime = null;
        }
        function E3(t5) {
          S3.call(this, t5), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new i3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        v3.prototype._tmp = function() {
          var t5 = new i3(null);
          return t5.words = new Array(Math.ceil(this.n / 13)), t5;
        }, v3.prototype.ireduce = function(t5) {
          var e6, r4 = t5;
          do {
            this.split(r4, this.tmp), e6 = (r4 = (r4 = this.imulK(r4)).iadd(this.tmp)).bitLength();
          } while (e6 > this.n);
          var n4 = e6 < this.n ? -1 : r4.ucmp(this.p);
          return 0 === n4 ? (r4.words[0] = 0, r4.length = 1) : n4 > 0 ? r4.isub(this.p) : void 0 !== r4.strip ? r4.strip() : r4._strip(), r4;
        }, v3.prototype.split = function(t5, e6) {
          t5.iushrn(this.n, 0, e6);
        }, v3.prototype.imulK = function(t5) {
          return t5.imul(this.k);
        }, n3(w3, v3), w3.prototype.split = function(t5, e6) {
          for (var r4 = 4194303, n4 = Math.min(t5.length, 9), i4 = 0; i4 < n4; i4++)
            e6.words[i4] = t5.words[i4];
          if (e6.length = n4, t5.length <= 9)
            return t5.words[0] = 0, void (t5.length = 1);
          var o4 = t5.words[9];
          for (e6.words[e6.length++] = o4 & r4, i4 = 10; i4 < t5.length; i4++) {
            var s4 = 0 | t5.words[i4];
            t5.words[i4 - 10] = (s4 & r4) << 4 | o4 >>> 22, o4 = s4;
          }
          o4 >>>= 22, t5.words[i4 - 10] = o4, 0 === o4 && t5.length > 10 ? t5.length -= 10 : t5.length -= 9;
        }, w3.prototype.imulK = function(t5) {
          t5.words[t5.length] = 0, t5.words[t5.length + 1] = 0, t5.length += 2;
          for (var e6 = 0, r4 = 0; r4 < t5.length; r4++) {
            var n4 = 0 | t5.words[r4];
            e6 += 977 * n4, t5.words[r4] = 67108863 & e6, e6 = 64 * n4 + (e6 / 67108864 | 0);
          }
          return 0 === t5.words[t5.length - 1] && (t5.length--, 0 === t5.words[t5.length - 1] && t5.length--), t5;
        }, n3(M3, v3), n3(_3, v3), n3(A3, v3), A3.prototype.imulK = function(t5) {
          for (var e6 = 0, r4 = 0; r4 < t5.length; r4++) {
            var n4 = 19 * (0 | t5.words[r4]) + e6, i4 = 67108863 & n4;
            n4 >>>= 26, t5.words[r4] = i4, e6 = n4;
          }
          return 0 !== e6 && (t5.words[t5.length++] = e6), t5;
        }, i3._prime = function(t5) {
          if (g2[t5])
            return g2[t5];
          var e6;
          if ("k256" === t5)
            e6 = new w3();
          else if ("p224" === t5)
            e6 = new M3();
          else if ("p192" === t5)
            e6 = new _3();
          else {
            if ("p25519" !== t5)
              throw new Error("Unknown prime " + t5);
            e6 = new A3();
          }
          return g2[t5] = e6, e6;
        }, S3.prototype._verify1 = function(t5) {
          r3(0 === t5.negative, "red works only with positives"), r3(t5.red, "red works only with red numbers");
        }, S3.prototype._verify2 = function(t5, e6) {
          r3(0 == (t5.negative | e6.negative), "red works only with positives"), r3(t5.red && t5.red === e6.red, "red works only with red numbers");
        }, S3.prototype.imod = function(t5) {
          return this.prime ? this.prime.ireduce(t5)._forceRed(this) : (f3(t5, t5.umod(this.m)._forceRed(this)), t5);
        }, S3.prototype.neg = function(t5) {
          return t5.isZero() ? t5.clone() : this.m.sub(t5)._forceRed(this);
        }, S3.prototype.add = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.add(e6);
          return r4.cmp(this.m) >= 0 && r4.isub(this.m), r4._forceRed(this);
        }, S3.prototype.iadd = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.iadd(e6);
          return r4.cmp(this.m) >= 0 && r4.isub(this.m), r4;
        }, S3.prototype.sub = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.sub(e6);
          return r4.cmpn(0) < 0 && r4.iadd(this.m), r4._forceRed(this);
        }, S3.prototype.isub = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.isub(e6);
          return r4.cmpn(0) < 0 && r4.iadd(this.m), r4;
        }, S3.prototype.shl = function(t5, e6) {
          return this._verify1(t5), this.imod(t5.ushln(e6));
        }, S3.prototype.imul = function(t5, e6) {
          return this._verify2(t5, e6), this.imod(t5.imul(e6));
        }, S3.prototype.mul = function(t5, e6) {
          return this._verify2(t5, e6), this.imod(t5.mul(e6));
        }, S3.prototype.isqr = function(t5) {
          return this.imul(t5, t5.clone());
        }, S3.prototype.sqr = function(t5) {
          return this.mul(t5, t5);
        }, S3.prototype.sqrt = function(t5) {
          if (t5.isZero())
            return t5.clone();
          var e6 = this.m.andln(3);
          if (r3(e6 % 2 == 1), 3 === e6) {
            var n4 = this.m.add(new i3(1)).iushrn(2);
            return this.pow(t5, n4);
          }
          for (var o4 = this.m.subn(1), s4 = 0; !o4.isZero() && 0 === o4.andln(1); )
            s4++, o4.iushrn(1);
          r3(!o4.isZero());
          var a4 = new i3(1).toRed(this), h4 = a4.redNeg(), f4 = this.m.subn(1).iushrn(1), u4 = this.m.bitLength();
          for (u4 = new i3(2 * u4 * u4).toRed(this); 0 !== this.pow(u4, f4).cmp(h4); )
            u4.redIAdd(h4);
          for (var c4 = this.pow(u4, o4), d4 = this.pow(t5, o4.addn(1).iushrn(1)), l4 = this.pow(t5, o4), p4 = s4; 0 !== l4.cmp(a4); ) {
            for (var b4 = l4, m4 = 0; 0 !== b4.cmp(a4); m4++)
              b4 = b4.redSqr();
            r3(m4 < p4);
            var y4 = this.pow(c4, new i3(1).iushln(p4 - m4 - 1));
            d4 = d4.redMul(y4), c4 = y4.redSqr(), l4 = l4.redMul(c4), p4 = m4;
          }
          return d4;
        }, S3.prototype.invm = function(t5) {
          var e6 = t5._invmp(this.m);
          return 0 !== e6.negative ? (e6.negative = 0, this.imod(e6).redNeg()) : this.imod(e6);
        }, S3.prototype.pow = function(t5, e6) {
          if (e6.isZero())
            return new i3(1).toRed(this);
          if (0 === e6.cmpn(1))
            return t5.clone();
          var r4 = new Array(16);
          r4[0] = new i3(1).toRed(this), r4[1] = t5;
          for (var n4 = 2; n4 < r4.length; n4++)
            r4[n4] = this.mul(r4[n4 - 1], t5);
          var o4 = r4[0], s4 = 0, a4 = 0, h4 = e6.bitLength() % 26;
          for (0 === h4 && (h4 = 26), n4 = e6.length - 1; n4 >= 0; n4--) {
            for (var f4 = e6.words[n4], u4 = h4 - 1; u4 >= 0; u4--) {
              var c4 = f4 >> u4 & 1;
              o4 !== r4[0] && (o4 = this.sqr(o4)), 0 !== c4 || 0 !== s4 ? (s4 <<= 1, s4 |= c4, (4 === ++a4 || 0 === n4 && 0 === u4) && (o4 = this.mul(o4, r4[s4]), a4 = 0, s4 = 0)) : a4 = 0;
            }
            h4 = 26;
          }
          return o4;
        }, S3.prototype.convertTo = function(t5) {
          var e6 = t5.umod(this.m);
          return e6 === t5 ? e6.clone() : e6;
        }, S3.prototype.convertFrom = function(t5) {
          var e6 = t5.clone();
          return e6.red = null, e6;
        }, i3.mont = function(t5) {
          return new E3(t5);
        }, n3(E3, S3), E3.prototype.convertTo = function(t5) {
          return this.imod(t5.ushln(this.shift));
        }, E3.prototype.convertFrom = function(t5) {
          var e6 = this.imod(t5.mul(this.rinv));
          return e6.red = null, e6;
        }, E3.prototype.imul = function(t5, e6) {
          if (t5.isZero() || e6.isZero())
            return t5.words[0] = 0, t5.length = 1, t5;
          var r4 = t5.imul(e6), n4 = r4.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i4 = r4.isub(n4).iushrn(this.shift), o4 = i4;
          return i4.cmp(this.m) >= 0 ? o4 = i4.isub(this.m) : i4.cmpn(0) < 0 && (o4 = i4.iadd(this.m)), o4._forceRed(this);
        }, E3.prototype.mul = function(t5, e6) {
          if (t5.isZero() || e6.isZero())
            return new i3(0)._forceRed(this);
          var r4 = t5.mul(e6), n4 = r4.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), o4 = r4.isub(n4).iushrn(this.shift), s4 = o4;
          return o4.cmp(this.m) >= 0 ? s4 = o4.isub(this.m) : o4.cmpn(0) < 0 && (s4 = o4.iadd(this.m)), s4._forceRed(this);
        }, E3.prototype.invm = function(t5) {
          return this.imod(t5._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(t3, Jt);
    }), ie2 = Qt(function(t3, e4) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var r3 = Zt.Buffer;
      function n3(t4, e6) {
        for (var r4 in t4)
          e6[r4] = t4[r4];
      }
      function i3(t4, e6, n4) {
        return r3(t4, e6, n4);
      }
      r3.from && r3.alloc && r3.allocUnsafe && r3.allocUnsafeSlow ? t3.exports = Zt : (n3(Zt, e4), e4.Buffer = i3), i3.prototype = Object.create(r3.prototype), n3(r3, i3), i3.from = function(t4, e6, n4) {
        if ("number" == typeof t4)
          throw new TypeError("Argument must not be a number");
        return r3(t4, e6, n4);
      }, i3.alloc = function(t4, e6, n4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        var i4 = r3(t4);
        return void 0 !== e6 ? "string" == typeof n4 ? i4.fill(e6, n4) : i4.fill(e6) : i4.fill(0), i4;
      }, i3.allocUnsafe = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return r3(t4);
      }, i3.allocUnsafeSlow = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return Zt.SlowBuffer(t4);
      };
    });
    ie2.Buffer;
    var oe2 = ie2.Buffer;
    var se2 = function(t3) {
      if (t3.length >= 255)
        throw new TypeError("Alphabet too long");
      for (var e4 = new Uint8Array(256), r3 = 0; r3 < e4.length; r3++)
        e4[r3] = 255;
      for (var n3 = 0; n3 < t3.length; n3++) {
        var i3 = t3.charAt(n3), o3 = i3.charCodeAt(0);
        if (255 !== e4[o3])
          throw new TypeError(i3 + " is ambiguous");
        e4[o3] = n3;
      }
      var s3 = t3.length, a3 = t3.charAt(0), h3 = Math.log(s3) / Math.log(256), f3 = Math.log(256) / Math.log(s3);
      function u3(t4) {
        if ("string" != typeof t4)
          throw new TypeError("Expected String");
        if (0 === t4.length)
          return oe2.alloc(0);
        for (var r4 = 0, n4 = 0, i4 = 0; t4[r4] === a3; )
          n4++, r4++;
        for (var o4 = (t4.length - r4) * h3 + 1 >>> 0, f4 = new Uint8Array(o4); t4[r4]; ) {
          var u4 = e4[t4.charCodeAt(r4)];
          if (255 === u4)
            return;
          for (var c3 = 0, d3 = o4 - 1; (0 !== u4 || c3 < i4) && -1 !== d3; d3--, c3++)
            u4 += s3 * f4[d3] >>> 0, f4[d3] = u4 % 256 >>> 0, u4 = u4 / 256 >>> 0;
          if (0 !== u4)
            throw new Error("Non-zero carry");
          i4 = c3, r4++;
        }
        for (var l3 = o4 - i4; l3 !== o4 && 0 === f4[l3]; )
          l3++;
        var p3 = oe2.allocUnsafe(n4 + (o4 - l3));
        p3.fill(0, 0, n4);
        for (var b3 = n4; l3 !== o4; )
          p3[b3++] = f4[l3++];
        return p3;
      }
      return { encode: function(e6) {
        if ((Array.isArray(e6) || e6 instanceof Uint8Array) && (e6 = oe2.from(e6)), !oe2.isBuffer(e6))
          throw new TypeError("Expected Buffer");
        if (0 === e6.length)
          return "";
        for (var r4 = 0, n4 = 0, i4 = 0, o4 = e6.length; i4 !== o4 && 0 === e6[i4]; )
          i4++, r4++;
        for (var h4 = (o4 - i4) * f3 + 1 >>> 0, u4 = new Uint8Array(h4); i4 !== o4; ) {
          for (var c3 = e6[i4], d3 = 0, l3 = h4 - 1; (0 !== c3 || d3 < n4) && -1 !== l3; l3--, d3++)
            c3 += 256 * u4[l3] >>> 0, u4[l3] = c3 % s3 >>> 0, c3 = c3 / s3 >>> 0;
          if (0 !== c3)
            throw new Error("Non-zero carry");
          n4 = d3, i4++;
        }
        for (var p3 = h4 - n4; p3 !== h4 && 0 === u4[p3]; )
          p3++;
        for (var b3 = a3.repeat(r4); p3 < h4; ++p3)
          b3 += t3.charAt(u4[p3]);
        return b3;
      }, decodeUnsafe: u3, decode: function(t4) {
        var e6 = u3(t4);
        if (e6)
          return e6;
        throw new Error("Non-base" + s3 + " character");
      } };
    }, ae2 = se2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    function he2(t3, e4, r3) {
      return e4 <= t3 && t3 <= r3;
    }
    function fe2(t3) {
      if (void 0 === t3)
        return {};
      if (t3 === Object(t3))
        return t3;
      throw TypeError("Could not convert argument to dictionary");
    }
    function ue2(t3) {
      this.tokens = [].slice.call(t3);
    }
    ue2.prototype = { endOfStream: function() {
      return !this.tokens.length;
    }, read: function() {
      return this.tokens.length ? this.tokens.shift() : -1;
    }, prepend: function(t3) {
      if (Array.isArray(t3))
        for (var e4 = t3; e4.length; )
          this.tokens.unshift(e4.pop());
      else
        this.tokens.unshift(t3);
    }, push: function(t3) {
      if (Array.isArray(t3))
        for (var e4 = t3; e4.length; )
          this.tokens.push(e4.shift());
      else
        this.tokens.push(t3);
    } };
    var ce2 = -1;
    function de2(t3, e4) {
      if (t3)
        throw TypeError("Decoder error");
      return e4 || 65533;
    }
    var le2 = "utf-8";
    function pe2(t3, e4) {
      if (!(this instanceof pe2))
        return new pe2(t3, e4);
      if ((t3 = void 0 !== t3 ? String(t3).toLowerCase() : le2) !== le2)
        throw new Error("Encoding not supported. Only utf-8 is supported");
      e4 = fe2(e4), this._streaming = false, this._BOMseen = false, this._decoder = null, this._fatal = Boolean(e4.fatal), this._ignoreBOM = Boolean(e4.ignoreBOM), Object.defineProperty(this, "encoding", { value: "utf-8" }), Object.defineProperty(this, "fatal", { value: this._fatal }), Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
    }
    function be2(t3, e4) {
      if (!(this instanceof be2))
        return new be2(t3, e4);
      if ((t3 = void 0 !== t3 ? String(t3).toLowerCase() : le2) !== le2)
        throw new Error("Encoding not supported. Only utf-8 is supported");
      e4 = fe2(e4), this._streaming = false, this._encoder = null, this._options = { fatal: Boolean(e4.fatal) }, Object.defineProperty(this, "encoding", { value: "utf-8" });
    }
    function me2(t3) {
      var e4 = t3.fatal, r3 = 0, n3 = 0, i3 = 0, o3 = 128, s3 = 191;
      this.handler = function(t4, a3) {
        if (-1 === a3 && 0 !== i3)
          return i3 = 0, de2(e4);
        if (-1 === a3)
          return ce2;
        if (0 === i3) {
          if (he2(a3, 0, 127))
            return a3;
          if (he2(a3, 194, 223))
            i3 = 1, r3 = a3 - 192;
          else if (he2(a3, 224, 239))
            224 === a3 && (o3 = 160), 237 === a3 && (s3 = 159), i3 = 2, r3 = a3 - 224;
          else {
            if (!he2(a3, 240, 244))
              return de2(e4);
            240 === a3 && (o3 = 144), 244 === a3 && (s3 = 143), i3 = 3, r3 = a3 - 240;
          }
          return r3 <<= 6 * i3, null;
        }
        if (!he2(a3, o3, s3))
          return r3 = i3 = n3 = 0, o3 = 128, s3 = 191, t4.prepend(a3), de2(e4);
        if (o3 = 128, s3 = 191, r3 += a3 - 128 << 6 * (i3 - (n3 += 1)), n3 !== i3)
          return null;
        var h3 = r3;
        return r3 = i3 = n3 = 0, h3;
      };
    }
    function ye2(t3) {
      t3.fatal, this.handler = function(t4, e4) {
        if (-1 === e4)
          return ce2;
        if (he2(e4, 0, 127))
          return e4;
        var r3, n3;
        he2(e4, 128, 2047) ? (r3 = 1, n3 = 192) : he2(e4, 2048, 65535) ? (r3 = 2, n3 = 224) : he2(e4, 65536, 1114111) && (r3 = 3, n3 = 240);
        for (var i3 = [(e4 >> 6 * r3) + n3]; r3 > 0; ) {
          var o3 = e4 >> 6 * (r3 - 1);
          i3.push(128 | 63 & o3), r3 -= 1;
        }
        return i3;
      };
    }
    pe2.prototype = { decode: function(t3, e4) {
      var r3;
      r3 = "object" == typeof t3 && t3 instanceof ArrayBuffer ? new Uint8Array(t3) : "object" == typeof t3 && "buffer" in t3 && t3.buffer instanceof ArrayBuffer ? new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength) : new Uint8Array(0), e4 = fe2(e4), this._streaming || (this._decoder = new me2({ fatal: this._fatal }), this._BOMseen = false), this._streaming = Boolean(e4.stream);
      for (var n3, i3 = new ue2(r3), o3 = []; !i3.endOfStream() && (n3 = this._decoder.handler(i3, i3.read())) !== ce2; )
        null !== n3 && (Array.isArray(n3) ? o3.push.apply(o3, n3) : o3.push(n3));
      if (!this._streaming) {
        do {
          if ((n3 = this._decoder.handler(i3, i3.read())) === ce2)
            break;
          null !== n3 && (Array.isArray(n3) ? o3.push.apply(o3, n3) : o3.push(n3));
        } while (!i3.endOfStream());
        this._decoder = null;
      }
      return o3.length && (-1 === ["utf-8"].indexOf(this.encoding) || this._ignoreBOM || this._BOMseen || (65279 === o3[0] ? (this._BOMseen = true, o3.shift()) : this._BOMseen = true)), function(t4) {
        for (var e6 = "", r4 = 0; r4 < t4.length; ++r4) {
          var n4 = t4[r4];
          n4 <= 65535 ? e6 += String.fromCharCode(n4) : (n4 -= 65536, e6 += String.fromCharCode(55296 + (n4 >> 10), 56320 + (1023 & n4)));
        }
        return e6;
      }(o3);
    } }, be2.prototype = { encode: function(t3, e4) {
      t3 = t3 ? String(t3) : "", e4 = fe2(e4), this._streaming || (this._encoder = new ye2(this._options)), this._streaming = Boolean(e4.stream);
      for (var r3, n3 = [], i3 = new ue2(function(t4) {
        for (var e6 = String(t4), r4 = e6.length, n4 = 0, i4 = []; n4 < r4; ) {
          var o3 = e6.charCodeAt(n4);
          if (o3 < 55296 || o3 > 57343)
            i4.push(o3);
          else if (56320 <= o3 && o3 <= 57343)
            i4.push(65533);
          else if (55296 <= o3 && o3 <= 56319)
            if (n4 === r4 - 1)
              i4.push(65533);
            else {
              var s3 = t4.charCodeAt(n4 + 1);
              if (56320 <= s3 && s3 <= 57343) {
                var a3 = 1023 & o3, h3 = 1023 & s3;
                i4.push(65536 + (a3 << 10) + h3), n4 += 1;
              } else
                i4.push(65533);
            }
          n4 += 1;
        }
        return i4;
      }(t3)); !i3.endOfStream() && (r3 = this._encoder.handler(i3, i3.read())) !== ce2; )
        Array.isArray(r3) ? n3.push.apply(n3, r3) : n3.push(r3);
      if (!this._streaming) {
        for (; (r3 = this._encoder.handler(i3, i3.read())) !== ce2; )
          Array.isArray(r3) ? n3.push.apply(n3, r3) : n3.push(r3);
        this._encoder = null;
      }
      return new Uint8Array(n3);
    } };
    var ge2 = te2(Object.freeze({ __proto__: null, TextEncoder: be2, TextDecoder: pe2 })), ve2 = Qt(function(t3, e4) {
      var r3 = Jt && Jt.__createBinding || (Object.create ? function(t4, e6, r4, n4) {
        void 0 === n4 && (n4 = r4), Object.defineProperty(t4, n4, { enumerable: true, get: function() {
          return e6[r4];
        } });
      } : function(t4, e6, r4, n4) {
        void 0 === n4 && (n4 = r4), t4[n4] = e6[r4];
      }), n3 = Jt && Jt.__setModuleDefault || (Object.create ? function(t4, e6) {
        Object.defineProperty(t4, "default", { enumerable: true, value: e6 });
      } : function(t4, e6) {
        t4.default = e6;
      }), i3 = Jt && Jt.__decorate || function(t4, e6, r4, n4) {
        var i4, o4 = arguments.length, s4 = o4 < 3 ? e6 : null === n4 ? n4 = Object.getOwnPropertyDescriptor(e6, r4) : n4;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          s4 = Reflect.decorate(t4, e6, r4, n4);
        else
          for (var a4 = t4.length - 1; a4 >= 0; a4--)
            (i4 = t4[a4]) && (s4 = (o4 < 3 ? i4(s4) : o4 > 3 ? i4(e6, r4, s4) : i4(e6, r4)) || s4);
        return o4 > 3 && s4 && Object.defineProperty(e6, r4, s4), s4;
      }, o3 = Jt && Jt.__importStar || function(t4) {
        if (t4 && t4.__esModule)
          return t4;
        var e6 = {};
        if (null != t4)
          for (var i4 in t4)
            "default" !== i4 && Object.hasOwnProperty.call(t4, i4) && r3(e6, t4, i4);
        return n3(e6, t4), e6;
      }, s3 = Jt && Jt.__importDefault || function(t4) {
        return t4 && t4.__esModule ? t4 : { default: t4 };
      };
      Object.defineProperty(e4, "__esModule", { value: true }), e4.deserializeUnchecked = e4.deserialize = e4.serialize = e4.BinaryReader = e4.BinaryWriter = e4.BorshError = e4.baseDecode = e4.baseEncode = void 0;
      const a3 = s3(ne2), h3 = s3(ae2), f3 = o3(ge2), u3 = new ("function" != typeof TextDecoder ? f3.TextDecoder : TextDecoder)("utf-8", { fatal: true });
      e4.baseEncode = function(t4) {
        return "string" == typeof t4 && (t4 = ct.from(t4, "utf8")), h3.default.encode(ct.from(t4));
      }, e4.baseDecode = function(t4) {
        return ct.from(h3.default.decode(t4));
      };
      const c3 = 1024;
      class d3 extends Error {
        constructor(t4) {
          super(t4), this.fieldPath = [], this.originalMessage = t4;
        }
        addToFieldPath(t4) {
          this.fieldPath.splice(0, 0, t4), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      }
      e4.BorshError = d3;
      class l3 {
        constructor() {
          this.buf = ct.alloc(c3), this.length = 0;
        }
        maybeResize() {
          this.buf.length < 16 + this.length && (this.buf = ct.concat([this.buf, ct.alloc(c3)]));
        }
        writeU8(t4) {
          this.maybeResize(), this.buf.writeUInt8(t4, this.length), this.length += 1;
        }
        writeU16(t4) {
          this.maybeResize(), this.buf.writeUInt16LE(t4, this.length), this.length += 2;
        }
        writeU32(t4) {
          this.maybeResize(), this.buf.writeUInt32LE(t4, this.length), this.length += 4;
        }
        writeU64(t4) {
          this.maybeResize(), this.writeBuffer(ct.from(new a3.default(t4).toArray("le", 8)));
        }
        writeU128(t4) {
          this.maybeResize(), this.writeBuffer(ct.from(new a3.default(t4).toArray("le", 16)));
        }
        writeU256(t4) {
          this.maybeResize(), this.writeBuffer(ct.from(new a3.default(t4).toArray("le", 32)));
        }
        writeU512(t4) {
          this.maybeResize(), this.writeBuffer(ct.from(new a3.default(t4).toArray("le", 64)));
        }
        writeBuffer(t4) {
          this.buf = ct.concat([ct.from(this.buf.subarray(0, this.length)), t4, ct.alloc(c3)]), this.length += t4.length;
        }
        writeString(t4) {
          this.maybeResize();
          const e6 = ct.from(t4, "utf8");
          this.writeU32(e6.length), this.writeBuffer(e6);
        }
        writeFixedArray(t4) {
          this.writeBuffer(ct.from(t4));
        }
        writeArray(t4, e6) {
          this.maybeResize(), this.writeU32(t4.length);
          for (const r4 of t4)
            this.maybeResize(), e6(r4);
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      }
      function p3(t4, e6, r4) {
        const n4 = r4.value;
        r4.value = function(...t5) {
          try {
            return n4.apply(this, t5);
          } catch (t6) {
            if (t6 instanceof RangeError) {
              const e7 = t6.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(e7) >= 0)
                throw new d3("Reached the end of buffer when deserializing");
            }
            throw t6;
          }
        };
      }
      e4.BinaryWriter = l3;
      class b3 {
        constructor(t4) {
          this.buf = t4, this.offset = 0;
        }
        readU8() {
          const t4 = this.buf.readUInt8(this.offset);
          return this.offset += 1, t4;
        }
        readU16() {
          const t4 = this.buf.readUInt16LE(this.offset);
          return this.offset += 2, t4;
        }
        readU32() {
          const t4 = this.buf.readUInt32LE(this.offset);
          return this.offset += 4, t4;
        }
        readU64() {
          const t4 = this.readBuffer(8);
          return new a3.default(t4, "le");
        }
        readU128() {
          const t4 = this.readBuffer(16);
          return new a3.default(t4, "le");
        }
        readU256() {
          const t4 = this.readBuffer(32);
          return new a3.default(t4, "le");
        }
        readU512() {
          const t4 = this.readBuffer(64);
          return new a3.default(t4, "le");
        }
        readBuffer(t4) {
          if (this.offset + t4 > this.buf.length)
            throw new d3(`Expected buffer length ${t4} isn't within bounds`);
          const e6 = this.buf.slice(this.offset, this.offset + t4);
          return this.offset += t4, e6;
        }
        readString() {
          const t4 = this.readU32(), e6 = this.readBuffer(t4);
          try {
            return u3.decode(e6);
          } catch (t5) {
            throw new d3(`Error decoding UTF-8 string: ${t5}`);
          }
        }
        readFixedArray(t4) {
          return new Uint8Array(this.readBuffer(t4));
        }
        readArray(t4) {
          const e6 = this.readU32(), r4 = Array();
          for (let n4 = 0; n4 < e6; ++n4)
            r4.push(t4());
          return r4;
        }
      }
      function m3(t4) {
        return t4.charAt(0).toUpperCase() + t4.slice(1);
      }
      function y3(t4, e6, r4, n4, i4) {
        try {
          if ("string" == typeof n4)
            i4[`write${m3(n4)}`](r4);
          else if (n4 instanceof Array)
            if ("number" == typeof n4[0]) {
              if (r4.length !== n4[0])
                throw new d3(`Expecting byte array of length ${n4[0]}, but got ${r4.length} bytes`);
              i4.writeFixedArray(r4);
            } else if (2 === n4.length && "number" == typeof n4[1]) {
              if (r4.length !== n4[1])
                throw new d3(`Expecting byte array of length ${n4[1]}, but got ${r4.length} bytes`);
              for (let e7 = 0; e7 < n4[1]; e7++)
                y3(t4, null, r4[e7], n4[0], i4);
            } else
              i4.writeArray(r4, (r5) => {
                y3(t4, e6, r5, n4[0], i4);
              });
          else if (void 0 !== n4.kind)
            switch (n4.kind) {
              case "option":
                null == r4 ? i4.writeU8(0) : (i4.writeU8(1), y3(t4, e6, r4, n4.type, i4));
                break;
              case "map":
                i4.writeU32(r4.size), r4.forEach((r5, o4) => {
                  y3(t4, e6, o4, n4.key, i4), y3(t4, e6, r5, n4.value, i4);
                });
                break;
              default:
                throw new d3(`FieldType ${n4} unrecognized`);
            }
          else
            g2(t4, r4, i4);
        } catch (t5) {
          throw t5 instanceof d3 && t5.addToFieldPath(e6), t5;
        }
      }
      function g2(t4, e6, r4) {
        if ("function" == typeof e6.borshSerialize)
          return void e6.borshSerialize(r4);
        const n4 = t4.get(e6.constructor);
        if (!n4)
          throw new d3(`Class ${e6.constructor.name} is missing in schema`);
        if ("struct" === n4.kind)
          n4.fields.map(([n5, i4]) => {
            y3(t4, n5, e6[n5], i4, r4);
          });
        else {
          if ("enum" !== n4.kind)
            throw new d3(`Unexpected schema kind: ${n4.kind} for ${e6.constructor.name}`);
          {
            const i4 = e6[n4.field];
            for (let o4 = 0; o4 < n4.values.length; ++o4) {
              const [s4, a4] = n4.values[o4];
              if (s4 === i4) {
                r4.writeU8(o4), y3(t4, s4, e6[s4], a4, r4);
                break;
              }
            }
          }
        }
      }
      function v3(t4, e6, r4, n4) {
        try {
          if ("string" == typeof r4)
            return n4[`read${m3(r4)}`]();
          if (r4 instanceof Array) {
            if ("number" == typeof r4[0])
              return n4.readFixedArray(r4[0]);
            if ("number" == typeof r4[1]) {
              const e7 = [];
              for (let i4 = 0; i4 < r4[1]; i4++)
                e7.push(v3(t4, null, r4[0], n4));
              return e7;
            }
            return n4.readArray(() => v3(t4, e6, r4[0], n4));
          }
          if ("option" === r4.kind) {
            return n4.readU8() ? v3(t4, e6, r4.type, n4) : void 0;
          }
          if ("map" === r4.kind) {
            let i4 = /* @__PURE__ */ new Map();
            const o4 = n4.readU32();
            for (let s4 = 0; s4 < o4; s4++) {
              const o5 = v3(t4, e6, r4.key, n4), s5 = v3(t4, e6, r4.value, n4);
              i4.set(o5, s5);
            }
            return i4;
          }
          return w3(t4, r4, n4);
        } catch (t5) {
          throw t5 instanceof d3 && t5.addToFieldPath(e6), t5;
        }
      }
      function w3(t4, e6, r4) {
        if ("function" == typeof e6.borshDeserialize)
          return e6.borshDeserialize(r4);
        const n4 = t4.get(e6);
        if (!n4)
          throw new d3(`Class ${e6.name} is missing in schema`);
        if ("struct" === n4.kind) {
          const n5 = {};
          for (const [i4, o4] of t4.get(e6).fields)
            n5[i4] = v3(t4, i4, o4, r4);
          return new e6(n5);
        }
        if ("enum" === n4.kind) {
          const i4 = r4.readU8();
          if (i4 >= n4.values.length)
            throw new d3(`Enum index: ${i4} is out of range`);
          const [o4, s4] = n4.values[i4];
          return new e6({ [o4]: v3(t4, o4, s4, r4) });
        }
        throw new d3(`Unexpected schema kind: ${n4.kind} for ${e6.constructor.name}`);
      }
      i3([p3], b3.prototype, "readU8", null), i3([p3], b3.prototype, "readU16", null), i3([p3], b3.prototype, "readU32", null), i3([p3], b3.prototype, "readU64", null), i3([p3], b3.prototype, "readU128", null), i3([p3], b3.prototype, "readU256", null), i3([p3], b3.prototype, "readU512", null), i3([p3], b3.prototype, "readString", null), i3([p3], b3.prototype, "readFixedArray", null), i3([p3], b3.prototype, "readArray", null), e4.BinaryReader = b3, e4.serialize = function(t4, e6, r4 = l3) {
        const n4 = new r4();
        return g2(t4, e6, n4), n4.toArray();
      }, e4.deserialize = function(t4, e6, r4, n4 = b3) {
        const i4 = new n4(r4), o4 = w3(t4, e6, i4);
        if (i4.offset < r4.length)
          throw new d3(`Unexpected ${r4.length - i4.offset} bytes after deserialized data`);
        return o4;
      }, e4.deserializeUnchecked = function(t4, e6, r4, n4 = b3) {
        return w3(t4, e6, new n4(r4));
      };
    });
    Xt(ve2);
    var we2 = ve2.deserializeUnchecked, Me2 = ve2.deserialize, _e2 = ve2.serialize;
    ve2.BinaryReader, ve2.BinaryWriter, ve2.BorshError, ve2.baseDecode, ve2.baseEncode;
    var Ae2 = Qt(function(t3, e4) {
      function r3(t4) {
        if (!(t4 instanceof Uint8Array))
          throw new TypeError("b must be a Uint8Array");
      }
      function n3(t4) {
        return r3(t4), Zt.Buffer.from(t4.buffer, t4.byteOffset, t4.length);
      }
      Object.defineProperty(e4, "__esModule", { value: true }), e4.s16 = e4.s8 = e4.nu64be = e4.u48be = e4.u40be = e4.u32be = e4.u24be = e4.u16be = e4.nu64 = e4.u48 = e4.u40 = e4.u32 = e4.u24 = e4.u16 = e4.u8 = e4.offset = e4.greedy = e4.Constant = e4.UTF8 = e4.CString = e4.Blob = e4.Boolean = e4.BitField = e4.BitStructure = e4.VariantLayout = e4.Union = e4.UnionLayoutDiscriminator = e4.UnionDiscriminator = e4.Structure = e4.Sequence = e4.DoubleBE = e4.Double = e4.FloatBE = e4.Float = e4.NearInt64BE = e4.NearInt64 = e4.NearUInt64BE = e4.NearUInt64 = e4.IntBE = e4.Int = e4.UIntBE = e4.UInt = e4.OffsetLayout = e4.GreedyCount = e4.ExternalLayout = e4.bindConstructorLayout = e4.nameWithProperty = e4.Layout = e4.uint8ArrayToBuffer = e4.checkUint8Array = void 0, e4.constant = e4.utf8 = e4.cstr = e4.blob = e4.unionLayoutDiscriminator = e4.union = e4.seq = e4.bits = e4.struct = e4.f64be = e4.f64 = e4.f32be = e4.f32 = e4.ns64be = e4.s48be = e4.s40be = e4.s32be = e4.s24be = e4.s16be = e4.ns64 = e4.s48 = e4.s40 = e4.s32 = e4.s24 = void 0, e4.checkUint8Array = r3, e4.uint8ArrayToBuffer = n3;
      class i3 {
        constructor(t4, e6) {
          if (!Number.isInteger(t4))
            throw new TypeError("span must be an integer");
          this.span = t4, this.property = e6;
        }
        makeDestinationObject() {
          return {};
        }
        getSpan(t4, e6) {
          if (0 > this.span)
            throw new RangeError("indeterminate span");
          return this.span;
        }
        replicate(t4) {
          const e6 = Object.create(this.constructor.prototype);
          return Object.assign(e6, this), e6.property = t4, e6;
        }
        fromArray(t4) {
        }
      }
      function o3(t4, e6) {
        return e6.property ? t4 + "[" + e6.property + "]" : t4;
      }
      e4.Layout = i3, e4.nameWithProperty = o3, e4.bindConstructorLayout = function(t4, e6) {
        if ("function" != typeof t4)
          throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(t4, "layout_"))
          throw new Error("Class is already bound to a layout");
        if (!(e6 && e6 instanceof i3))
          throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(e6, "boundConstructor_"))
          throw new Error("layout is already bound to a constructor");
        t4.layout_ = e6, e6.boundConstructor_ = t4, e6.makeDestinationObject = () => new t4(), Object.defineProperty(t4.prototype, "encode", { value(t5, r4) {
          return e6.encode(this, t5, r4);
        }, writable: true }), Object.defineProperty(t4, "decode", { value: (t5, r4) => e6.decode(t5, r4), writable: true });
      };
      class s3 extends i3 {
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      }
      e4.ExternalLayout = s3;
      class a3 extends s3 {
        constructor(t4 = 1, e6) {
          if (!Number.isInteger(t4) || 0 >= t4)
            throw new TypeError("elementSpan must be a (positive) integer");
          super(-1, e6), this.elementSpan = t4;
        }
        isCount() {
          return true;
        }
        decode(t4, e6 = 0) {
          r3(t4);
          const n4 = t4.length - e6;
          return Math.floor(n4 / this.elementSpan);
        }
        encode(t4, e6, r4) {
          return 0;
        }
      }
      e4.GreedyCount = a3;
      class h3 extends s3 {
        constructor(t4, e6 = 0, r4) {
          if (!(t4 instanceof i3))
            throw new TypeError("layout must be a Layout");
          if (!Number.isInteger(e6))
            throw new TypeError("offset must be integer or undefined");
          super(t4.span, r4 || t4.property), this.layout = t4, this.offset = e6;
        }
        isCount() {
          return this.layout instanceof f3 || this.layout instanceof u3;
        }
        decode(t4, e6 = 0) {
          return this.layout.decode(t4, e6 + this.offset);
        }
        encode(t4, e6, r4 = 0) {
          return this.layout.encode(t4, e6, r4 + this.offset);
        }
      }
      e4.OffsetLayout = h3;
      class f3 extends i3 {
        constructor(t4, e6) {
          if (super(t4, e6), 6 < this.span)
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(t4, e6 = 0) {
          return n3(t4).readUIntLE(e6, this.span);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeUIntLE(t4, r4, this.span), this.span;
        }
      }
      e4.UInt = f3;
      class u3 extends i3 {
        constructor(t4, e6) {
          if (super(t4, e6), 6 < this.span)
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(t4, e6 = 0) {
          return n3(t4).readUIntBE(e6, this.span);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeUIntBE(t4, r4, this.span), this.span;
        }
      }
      e4.UIntBE = u3;
      class c3 extends i3 {
        constructor(t4, e6) {
          if (super(t4, e6), 6 < this.span)
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(t4, e6 = 0) {
          return n3(t4).readIntLE(e6, this.span);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeIntLE(t4, r4, this.span), this.span;
        }
      }
      e4.Int = c3;
      class d3 extends i3 {
        constructor(t4, e6) {
          if (super(t4, e6), 6 < this.span)
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(t4, e6 = 0) {
          return n3(t4).readIntBE(e6, this.span);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeIntBE(t4, r4, this.span), this.span;
        }
      }
      e4.IntBE = d3;
      const l3 = Math.pow(2, 32);
      function p3(t4) {
        const e6 = Math.floor(t4 / l3);
        return { hi32: e6, lo32: t4 - e6 * l3 };
      }
      function b3(t4, e6) {
        return t4 * l3 + e6;
      }
      class m3 extends i3 {
        constructor(t4) {
          super(8, t4);
        }
        decode(t4, e6 = 0) {
          const r4 = n3(t4), i4 = r4.readUInt32LE(e6);
          return b3(r4.readUInt32LE(e6 + 4), i4);
        }
        encode(t4, e6, r4 = 0) {
          const i4 = p3(t4), o4 = n3(e6);
          return o4.writeUInt32LE(i4.lo32, r4), o4.writeUInt32LE(i4.hi32, r4 + 4), 8;
        }
      }
      e4.NearUInt64 = m3;
      class y3 extends i3 {
        constructor(t4) {
          super(8, t4);
        }
        decode(t4, e6 = 0) {
          const r4 = n3(t4);
          return b3(r4.readUInt32BE(e6), r4.readUInt32BE(e6 + 4));
        }
        encode(t4, e6, r4 = 0) {
          const i4 = p3(t4), o4 = n3(e6);
          return o4.writeUInt32BE(i4.hi32, r4), o4.writeUInt32BE(i4.lo32, r4 + 4), 8;
        }
      }
      e4.NearUInt64BE = y3;
      class g2 extends i3 {
        constructor(t4) {
          super(8, t4);
        }
        decode(t4, e6 = 0) {
          const r4 = n3(t4), i4 = r4.readUInt32LE(e6);
          return b3(r4.readInt32LE(e6 + 4), i4);
        }
        encode(t4, e6, r4 = 0) {
          const i4 = p3(t4), o4 = n3(e6);
          return o4.writeUInt32LE(i4.lo32, r4), o4.writeInt32LE(i4.hi32, r4 + 4), 8;
        }
      }
      e4.NearInt64 = g2;
      class v3 extends i3 {
        constructor(t4) {
          super(8, t4);
        }
        decode(t4, e6 = 0) {
          const r4 = n3(t4);
          return b3(r4.readInt32BE(e6), r4.readUInt32BE(e6 + 4));
        }
        encode(t4, e6, r4 = 0) {
          const i4 = p3(t4), o4 = n3(e6);
          return o4.writeInt32BE(i4.hi32, r4), o4.writeUInt32BE(i4.lo32, r4 + 4), 8;
        }
      }
      e4.NearInt64BE = v3;
      class w3 extends i3 {
        constructor(t4) {
          super(4, t4);
        }
        decode(t4, e6 = 0) {
          return n3(t4).readFloatLE(e6);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeFloatLE(t4, r4), 4;
        }
      }
      e4.Float = w3;
      class M3 extends i3 {
        constructor(t4) {
          super(4, t4);
        }
        decode(t4, e6 = 0) {
          return n3(t4).readFloatBE(e6);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeFloatBE(t4, r4), 4;
        }
      }
      e4.FloatBE = M3;
      class _3 extends i3 {
        constructor(t4) {
          super(8, t4);
        }
        decode(t4, e6 = 0) {
          return n3(t4).readDoubleLE(e6);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeDoubleLE(t4, r4), 8;
        }
      }
      e4.Double = _3;
      class A3 extends i3 {
        constructor(t4) {
          super(8, t4);
        }
        decode(t4, e6 = 0) {
          return n3(t4).readDoubleBE(e6);
        }
        encode(t4, e6, r4 = 0) {
          return n3(e6).writeDoubleBE(t4, r4), 8;
        }
      }
      e4.DoubleBE = A3;
      class S3 extends i3 {
        constructor(t4, e6, r4) {
          if (!(t4 instanceof i3))
            throw new TypeError("elementLayout must be a Layout");
          if (!(e6 instanceof s3 && e6.isCount() || Number.isInteger(e6) && 0 <= e6))
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          let n4 = -1;
          !(e6 instanceof s3) && 0 < t4.span && (n4 = e6 * t4.span), super(n4, r4), this.elementLayout = t4, this.count = e6;
        }
        getSpan(t4, e6 = 0) {
          if (0 <= this.span)
            return this.span;
          let r4 = 0, n4 = this.count;
          if (n4 instanceof s3 && (n4 = n4.decode(t4, e6)), 0 < this.elementLayout.span)
            r4 = n4 * this.elementLayout.span;
          else {
            let i4 = 0;
            for (; i4 < n4; )
              r4 += this.elementLayout.getSpan(t4, e6 + r4), ++i4;
          }
          return r4;
        }
        decode(t4, e6 = 0) {
          const r4 = [];
          let n4 = 0, i4 = this.count;
          for (i4 instanceof s3 && (i4 = i4.decode(t4, e6)); n4 < i4; )
            r4.push(this.elementLayout.decode(t4, e6)), e6 += this.elementLayout.getSpan(t4, e6), n4 += 1;
          return r4;
        }
        encode(t4, e6, r4 = 0) {
          const n4 = this.elementLayout, i4 = t4.reduce((t5, i5) => t5 + n4.encode(i5, e6, r4 + t5), 0);
          return this.count instanceof s3 && this.count.encode(t4.length, e6, r4), i4;
        }
      }
      e4.Sequence = S3;
      class E3 extends i3 {
        constructor(t4, e6, r4) {
          if (!Array.isArray(t4) || !t4.reduce((t5, e7) => t5 && e7 instanceof i3, true))
            throw new TypeError("fields must be array of Layout instances");
          "boolean" == typeof e6 && void 0 === r4 && (r4 = e6, e6 = void 0);
          for (const e7 of t4)
            if (0 > e7.span && void 0 === e7.property)
              throw new Error("fields cannot contain unnamed variable-length layout");
          let n4 = -1;
          try {
            n4 = t4.reduce((t5, e7) => t5 + e7.getSpan(), 0);
          } catch (t5) {
          }
          super(n4, e6), this.fields = t4, this.decodePrefixes = !!r4;
        }
        getSpan(t4, e6 = 0) {
          if (0 <= this.span)
            return this.span;
          let r4 = 0;
          try {
            r4 = this.fields.reduce((r5, n4) => {
              const i4 = n4.getSpan(t4, e6);
              return e6 += i4, r5 + i4;
            }, 0);
          } catch (t5) {
            throw new RangeError("indeterminate span");
          }
          return r4;
        }
        decode(t4, e6 = 0) {
          r3(t4);
          const n4 = this.makeDestinationObject();
          for (const r4 of this.fields)
            if (void 0 !== r4.property && (n4[r4.property] = r4.decode(t4, e6)), e6 += r4.getSpan(t4, e6), this.decodePrefixes && t4.length === e6)
              break;
          return n4;
        }
        encode(t4, e6, r4 = 0) {
          const n4 = r4;
          let i4 = 0, o4 = 0;
          for (const n5 of this.fields) {
            let s4 = n5.span;
            if (o4 = 0 < s4 ? s4 : 0, void 0 !== n5.property) {
              const i5 = t4[n5.property];
              void 0 !== i5 && (o4 = n5.encode(i5, e6, r4), 0 > s4 && (s4 = n5.getSpan(e6, r4)));
            }
            i4 = r4, r4 += s4;
          }
          return i4 + o4 - n4;
        }
        fromArray(t4) {
          const e6 = this.makeDestinationObject();
          for (const r4 of this.fields)
            void 0 !== r4.property && 0 < t4.length && (e6[r4.property] = t4.shift());
          return e6;
        }
        layoutFor(t4) {
          if ("string" != typeof t4)
            throw new TypeError("property must be string");
          for (const e6 of this.fields)
            if (e6.property === t4)
              return e6;
        }
        offsetOf(t4) {
          if ("string" != typeof t4)
            throw new TypeError("property must be string");
          let e6 = 0;
          for (const r4 of this.fields) {
            if (r4.property === t4)
              return e6;
            0 > r4.span ? e6 = -1 : 0 <= e6 && (e6 += r4.span);
          }
        }
      }
      e4.Structure = E3;
      class x3 {
        constructor(t4) {
          this.property = t4;
        }
        decode(t4, e6) {
          throw new Error("UnionDiscriminator is abstract");
        }
        encode(t4, e6, r4) {
          throw new Error("UnionDiscriminator is abstract");
        }
      }
      e4.UnionDiscriminator = x3;
      class I3 extends x3 {
        constructor(t4, e6) {
          if (!(t4 instanceof s3 && t4.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          super(e6 || t4.property || "variant"), this.layout = t4;
        }
        decode(t4, e6) {
          return this.layout.decode(t4, e6);
        }
        encode(t4, e6, r4) {
          return this.layout.encode(t4, e6, r4);
        }
      }
      e4.UnionLayoutDiscriminator = I3;
      class k3 extends i3 {
        constructor(t4, e6, r4) {
          let n4;
          if (t4 instanceof f3 || t4 instanceof u3)
            n4 = new I3(new h3(t4));
          else if (t4 instanceof s3 && t4.isCount())
            n4 = new I3(t4);
          else {
            if (!(t4 instanceof x3))
              throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
            n4 = t4;
          }
          if (void 0 === e6 && (e6 = null), !(null === e6 || e6 instanceof i3))
            throw new TypeError("defaultLayout must be null or a Layout");
          if (null !== e6) {
            if (0 > e6.span)
              throw new Error("defaultLayout must have constant span");
            void 0 === e6.property && (e6 = e6.replicate("content"));
          }
          let o4 = -1;
          e6 && (o4 = e6.span, 0 <= o4 && (t4 instanceof f3 || t4 instanceof u3) && (o4 += n4.layout.span)), super(o4, r4), this.discriminator = n4, this.usesPrefixDiscriminator = t4 instanceof f3 || t4 instanceof u3, this.defaultLayout = e6, this.registry = {};
          let a4 = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(t5) {
            return a4(t5);
          }, this.configGetSourceVariant = function(t5) {
            a4 = t5.bind(this);
          };
        }
        getSpan(t4, e6 = 0) {
          if (0 <= this.span)
            return this.span;
          const r4 = this.getVariant(t4, e6);
          if (!r4)
            throw new Error("unable to determine span for unrecognized variant");
          return r4.getSpan(t4, e6);
        }
        defaultGetSourceVariant(t4) {
          if (Object.prototype.hasOwnProperty.call(t4, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(t4, this.defaultLayout.property))
              return;
            const e6 = this.registry[t4[this.discriminator.property]];
            if (e6 && (!e6.layout || e6.property && Object.prototype.hasOwnProperty.call(t4, e6.property)))
              return e6;
          } else
            for (const e6 in this.registry) {
              const r4 = this.registry[e6];
              if (r4.property && Object.prototype.hasOwnProperty.call(t4, r4.property))
                return r4;
            }
          throw new Error("unable to infer src variant");
        }
        decode(t4, e6 = 0) {
          let r4;
          const n4 = this.discriminator, i4 = n4.decode(t4, e6), o4 = this.registry[i4];
          if (void 0 === o4) {
            const o5 = this.defaultLayout;
            let s4 = 0;
            this.usesPrefixDiscriminator && (s4 = n4.layout.span), r4 = this.makeDestinationObject(), r4[n4.property] = i4, r4[o5.property] = o5.decode(t4, e6 + s4);
          } else
            r4 = o4.decode(t4, e6);
          return r4;
        }
        encode(t4, e6, r4 = 0) {
          const n4 = this.getSourceVariant(t4);
          if (void 0 === n4) {
            const n5 = this.discriminator, i4 = this.defaultLayout;
            let o4 = 0;
            return this.usesPrefixDiscriminator && (o4 = n5.layout.span), n5.encode(t4[n5.property], e6, r4), o4 + i4.encode(t4[i4.property], e6, r4 + o4);
          }
          return n4.encode(t4, e6, r4);
        }
        addVariant(t4, e6, r4) {
          const n4 = new R3(this, t4, e6, r4);
          return this.registry[t4] = n4, n4;
        }
        getVariant(t4, e6 = 0) {
          let r4;
          return r4 = t4 instanceof Uint8Array ? this.discriminator.decode(t4, e6) : t4, this.registry[r4];
        }
      }
      e4.Union = k3;
      class R3 extends i3 {
        constructor(t4, e6, r4, n4) {
          if (!(t4 instanceof k3))
            throw new TypeError("union must be a Union");
          if (!Number.isInteger(e6) || 0 > e6)
            throw new TypeError("variant must be a (non-negative) integer");
          if ("string" == typeof r4 && void 0 === n4 && (n4 = r4, r4 = null), r4) {
            if (!(r4 instanceof i3))
              throw new TypeError("layout must be a Layout");
            if (null !== t4.defaultLayout && 0 <= r4.span && r4.span > t4.defaultLayout.span)
              throw new Error("variant span exceeds span of containing union");
            if ("string" != typeof n4)
              throw new TypeError("variant must have a String property");
          }
          let o4 = t4.span;
          0 > t4.span && (o4 = r4 ? r4.span : 0, 0 <= o4 && t4.usesPrefixDiscriminator && (o4 += t4.discriminator.layout.span)), super(o4, n4), this.union = t4, this.variant = e6, this.layout = r4 || null;
        }
        getSpan(t4, e6 = 0) {
          if (0 <= this.span)
            return this.span;
          let r4 = 0;
          this.union.usesPrefixDiscriminator && (r4 = this.union.discriminator.layout.span);
          let n4 = 0;
          return this.layout && (n4 = this.layout.getSpan(t4, e6 + r4)), r4 + n4;
        }
        decode(t4, e6 = 0) {
          const r4 = this.makeDestinationObject();
          if (this !== this.union.getVariant(t4, e6))
            throw new Error("variant mismatch");
          let n4 = 0;
          return this.union.usesPrefixDiscriminator && (n4 = this.union.discriminator.layout.span), this.layout ? r4[this.property] = this.layout.decode(t4, e6 + n4) : this.property ? r4[this.property] = true : this.union.usesPrefixDiscriminator && (r4[this.union.discriminator.property] = this.variant), r4;
        }
        encode(t4, e6, r4 = 0) {
          let n4 = 0;
          if (this.union.usesPrefixDiscriminator && (n4 = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(t4, this.property))
            throw new TypeError("variant lacks property " + this.property);
          this.union.discriminator.encode(this.variant, e6, r4);
          let i4 = n4;
          if (this.layout && (this.layout.encode(t4[this.property], e6, r4 + n4), i4 += this.layout.getSpan(e6, r4 + n4), 0 <= this.union.span && i4 > this.union.span))
            throw new Error("encoded variant overruns containing union");
          return i4;
        }
        fromArray(t4) {
          if (this.layout)
            return this.layout.fromArray(t4);
        }
      }
      function T3(t4) {
        return 0 > t4 && (t4 += 4294967296), t4;
      }
      e4.VariantLayout = R3;
      class B3 extends i3 {
        constructor(t4, e6, r4) {
          if (!(t4 instanceof f3 || t4 instanceof u3))
            throw new TypeError("word must be a UInt or UIntBE layout");
          if ("string" == typeof e6 && void 0 === r4 && (r4 = e6, e6 = false), 4 < t4.span)
            throw new RangeError("word cannot exceed 32 bits");
          super(t4.span, r4), this.word = t4, this.msb = !!e6, this.fields = [];
          let n4 = 0;
          this._packedSetValue = function(t5) {
            return n4 = T3(t5), this;
          }, this._packedGetValue = function() {
            return n4;
          };
        }
        decode(t4, e6 = 0) {
          const r4 = this.makeDestinationObject(), n4 = this.word.decode(t4, e6);
          this._packedSetValue(n4);
          for (const e7 of this.fields)
            void 0 !== e7.property && (r4[e7.property] = e7.decode(t4));
          return r4;
        }
        encode(t4, e6, r4 = 0) {
          const n4 = this.word.decode(e6, r4);
          this._packedSetValue(n4);
          for (const e7 of this.fields)
            if (void 0 !== e7.property) {
              const r5 = t4[e7.property];
              void 0 !== r5 && e7.encode(r5);
            }
          return this.word.encode(this._packedGetValue(), e6, r4);
        }
        addField(t4, e6) {
          const r4 = new P3(this, t4, e6);
          return this.fields.push(r4), r4;
        }
        addBoolean(t4) {
          const e6 = new O3(this, t4);
          return this.fields.push(e6), e6;
        }
        fieldFor(t4) {
          if ("string" != typeof t4)
            throw new TypeError("property must be string");
          for (const e6 of this.fields)
            if (e6.property === t4)
              return e6;
        }
      }
      e4.BitStructure = B3;
      class P3 {
        constructor(t4, e6, r4) {
          if (!(t4 instanceof B3))
            throw new TypeError("container must be a BitStructure");
          if (!Number.isInteger(e6) || 0 >= e6)
            throw new TypeError("bits must be positive integer");
          const n4 = 8 * t4.span, i4 = t4.fields.reduce((t5, e7) => t5 + e7.bits, 0);
          if (e6 + i4 > n4)
            throw new Error("bits too long for span remainder (" + (n4 - i4) + " of " + n4 + " remain)");
          this.container = t4, this.bits = e6, this.valueMask = (1 << e6) - 1, 32 === e6 && (this.valueMask = 4294967295), this.start = i4, this.container.msb && (this.start = n4 - i4 - e6), this.wordMask = T3(this.valueMask << this.start), this.property = r4;
        }
        decode(t4, e6) {
          return T3(this.container._packedGetValue() & this.wordMask) >>> this.start;
        }
        encode(t4) {
          if ("number" != typeof t4 || !Number.isInteger(t4) || t4 !== T3(t4 & this.valueMask))
            throw new TypeError(o3("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          const e6 = this.container._packedGetValue(), r4 = T3(t4 << this.start);
          this.container._packedSetValue(T3(e6 & ~this.wordMask) | r4);
        }
      }
      e4.BitField = P3;
      class O3 extends P3 {
        constructor(t4, e6) {
          super(t4, 1, e6);
        }
        decode(t4, e6) {
          return !!super.decode(t4, e6);
        }
        encode(t4) {
          "boolean" == typeof t4 && (t4 = +t4), super.encode(t4);
        }
      }
      e4.Boolean = O3;
      class U3 extends i3 {
        constructor(t4, e6) {
          if (!(t4 instanceof s3 && t4.isCount() || Number.isInteger(t4) && 0 <= t4))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          let r4 = -1;
          t4 instanceof s3 || (r4 = t4), super(r4, e6), this.length = t4;
        }
        getSpan(t4, e6) {
          let r4 = this.span;
          return 0 > r4 && (r4 = this.length.decode(t4, e6)), r4;
        }
        decode(t4, e6 = 0) {
          let r4 = this.span;
          return 0 > r4 && (r4 = this.length.decode(t4, e6)), n3(t4).slice(e6, e6 + r4);
        }
        encode(t4, e6, r4) {
          let i4 = this.length;
          if (this.length instanceof s3 && (i4 = t4.length), !(t4 instanceof Uint8Array && i4 === t4.length))
            throw new TypeError(o3("Blob.encode", this) + " requires (length " + i4 + ") Uint8Array as src");
          if (r4 + i4 > e6.length)
            throw new RangeError("encoding overruns Uint8Array");
          const a4 = n3(t4);
          return n3(e6).write(a4.toString("hex"), r4, i4, "hex"), this.length instanceof s3 && this.length.encode(i4, e6, r4), i4;
        }
      }
      e4.Blob = U3;
      class L3 extends i3 {
        constructor(t4) {
          super(-1, t4);
        }
        getSpan(t4, e6 = 0) {
          r3(t4);
          let n4 = e6;
          for (; n4 < t4.length && 0 !== t4[n4]; )
            n4 += 1;
          return 1 + n4 - e6;
        }
        decode(t4, e6 = 0) {
          const r4 = this.getSpan(t4, e6);
          return n3(t4).slice(e6, e6 + r4 - 1).toString("utf-8");
        }
        encode(t4, e6, r4 = 0) {
          "string" != typeof t4 && (t4 = String(t4));
          const i4 = Zt.Buffer.from(t4, "utf8"), o4 = i4.length;
          if (r4 + o4 > e6.length)
            throw new RangeError("encoding overruns Buffer");
          const s4 = n3(e6);
          return i4.copy(s4, r4), s4[r4 + o4] = 0, o4 + 1;
        }
      }
      e4.CString = L3;
      class N3 extends i3 {
        constructor(t4, e6) {
          if ("string" == typeof t4 && void 0 === e6 && (e6 = t4, t4 = void 0), void 0 === t4)
            t4 = -1;
          else if (!Number.isInteger(t4))
            throw new TypeError("maxSpan must be an integer");
          super(-1, e6), this.maxSpan = t4;
        }
        getSpan(t4, e6 = 0) {
          return r3(t4), t4.length - e6;
        }
        decode(t4, e6 = 0) {
          const r4 = this.getSpan(t4, e6);
          if (0 <= this.maxSpan && this.maxSpan < r4)
            throw new RangeError("text length exceeds maxSpan");
          return n3(t4).slice(e6, e6 + r4).toString("utf-8");
        }
        encode(t4, e6, r4 = 0) {
          "string" != typeof t4 && (t4 = String(t4));
          const i4 = Zt.Buffer.from(t4, "utf8"), o4 = i4.length;
          if (0 <= this.maxSpan && this.maxSpan < o4)
            throw new RangeError("text length exceeds maxSpan");
          if (r4 + o4 > e6.length)
            throw new RangeError("encoding overruns Buffer");
          return i4.copy(n3(e6), r4), o4;
        }
      }
      e4.UTF8 = N3;
      class z3 extends i3 {
        constructor(t4, e6) {
          super(0, e6), this.value = t4;
        }
        decode(t4, e6) {
          return this.value;
        }
        encode(t4, e6, r4) {
          return 0;
        }
      }
      e4.Constant = z3, e4.greedy = (t4, e6) => new a3(t4, e6), e4.offset = (t4, e6, r4) => new h3(t4, e6, r4), e4.u8 = (t4) => new f3(1, t4), e4.u16 = (t4) => new f3(2, t4), e4.u24 = (t4) => new f3(3, t4), e4.u32 = (t4) => new f3(4, t4), e4.u40 = (t4) => new f3(5, t4), e4.u48 = (t4) => new f3(6, t4), e4.nu64 = (t4) => new m3(t4), e4.u16be = (t4) => new u3(2, t4), e4.u24be = (t4) => new u3(3, t4), e4.u32be = (t4) => new u3(4, t4), e4.u40be = (t4) => new u3(5, t4), e4.u48be = (t4) => new u3(6, t4), e4.nu64be = (t4) => new y3(t4), e4.s8 = (t4) => new c3(1, t4), e4.s16 = (t4) => new c3(2, t4), e4.s24 = (t4) => new c3(3, t4), e4.s32 = (t4) => new c3(4, t4), e4.s40 = (t4) => new c3(5, t4), e4.s48 = (t4) => new c3(6, t4), e4.ns64 = (t4) => new g2(t4), e4.s16be = (t4) => new d3(2, t4), e4.s24be = (t4) => new d3(3, t4), e4.s32be = (t4) => new d3(4, t4), e4.s40be = (t4) => new d3(5, t4), e4.s48be = (t4) => new d3(6, t4), e4.ns64be = (t4) => new v3(t4), e4.f32 = (t4) => new w3(t4), e4.f32be = (t4) => new M3(t4), e4.f64 = (t4) => new _3(t4), e4.f64be = (t4) => new A3(t4), e4.struct = (t4, e6, r4) => new E3(t4, e6, r4), e4.bits = (t4, e6, r4) => new B3(t4, e6, r4), e4.seq = (t4, e6, r4) => new S3(t4, e6, r4), e4.union = (t4, e6, r4) => new k3(t4, e6, r4), e4.unionLayoutDiscriminator = (t4, e6) => new I3(t4, e6), e4.blob = (t4, e6) => new U3(t4, e6), e4.cstr = (t4) => new L3(t4), e4.utf8 = (t4, e6) => new N3(t4, e6), e4.constant = (t4, e6) => new z3(t4, e6);
    });
    Xt(Ae2), Ae2.s16, Ae2.s8, Ae2.nu64be, Ae2.u48be, Ae2.u40be, Ae2.u32be, Ae2.u24be, Ae2.u16be;
    var Se2 = Ae2.nu64;
    Ae2.u48, Ae2.u40;
    var Ee2 = Ae2.u32;
    Ae2.u24;
    var xe2 = Ae2.u16, Ie2 = Ae2.u8, ke2 = Ae2.offset;
    Ae2.greedy, Ae2.Constant, Ae2.UTF8, Ae2.CString, Ae2.Blob, Ae2.Boolean, Ae2.BitField, Ae2.BitStructure, Ae2.VariantLayout, Ae2.Union, Ae2.UnionLayoutDiscriminator, Ae2.UnionDiscriminator, Ae2.Structure, Ae2.Sequence, Ae2.DoubleBE, Ae2.Double, Ae2.FloatBE, Ae2.Float, Ae2.NearInt64BE, Ae2.NearInt64, Ae2.NearUInt64BE, Ae2.NearUInt64, Ae2.IntBE, Ae2.Int, Ae2.UIntBE, Ae2.UInt, Ae2.OffsetLayout, Ae2.GreedyCount, Ae2.ExternalLayout, Ae2.bindConstructorLayout, Ae2.nameWithProperty, Ae2.Layout, Ae2.uint8ArrayToBuffer, Ae2.checkUint8Array, Ae2.constant, Ae2.utf8, Ae2.cstr;
    var Re2 = Ae2.blob;
    Ae2.unionLayoutDiscriminator, Ae2.union;
    var Te2 = Ae2.seq;
    Ae2.bits;
    var Be2 = Ae2.struct;
    Ae2.f64be, Ae2.f64, Ae2.f32be, Ae2.f32, Ae2.ns64be, Ae2.s48be, Ae2.s40be, Ae2.s32be, Ae2.s24be, Ae2.s16be;
    var Pe2 = Ae2.ns64;
    Ae2.s48, Ae2.s40, Ae2.s32, Ae2.s24;
    class Oe2 extends TypeError {
      constructor(t3, e4) {
        let r3;
        const { message: n3, ...i3 } = t3, { path: o3 } = t3;
        super(0 === o3.length ? n3 : "At path: " + o3.join(".") + " -- " + n3), Object.assign(this, i3), this.name = this.constructor.name, this.failures = () => {
          var n4;
          return null != (n4 = r3) ? n4 : r3 = [t3, ...e4()];
        };
      }
    }
    function Ue2(t3) {
      return "object" == typeof t3 && null != t3;
    }
    function Le2(t3) {
      return "string" == typeof t3 ? JSON.stringify(t3) : "" + t3;
    }
    function Ne2(t3, e4, r3, n3) {
      if (true === t3)
        return;
      false === t3 ? t3 = {} : "string" == typeof t3 && (t3 = { message: t3 });
      const { path: i3, branch: o3 } = e4, { type: s3 } = r3, { refinement: a3, message: h3 = "Expected a value of type `" + s3 + "`" + (a3 ? " with refinement `" + a3 + "`" : "") + ", but received: `" + Le2(n3) + "`" } = t3;
      return { value: n3, type: s3, refinement: a3, key: i3[i3.length - 1], path: i3, branch: o3, ...t3, message: h3 };
    }
    function* ze(t3, e4, r3, n3) {
      var i3;
      Ue2(i3 = t3) && "function" == typeof i3[Symbol.iterator] || (t3 = [t3]);
      for (const i4 of t3) {
        const t4 = Ne2(i4, e4, r3, n3);
        t4 && (yield t4);
      }
    }
    function* Ce2(t3, e4, r3 = {}) {
      const { path: n3 = [], branch: i3 = [t3], coerce: o3 = false, mask: s3 = false } = r3, a3 = { path: n3, branch: i3 };
      if (o3 && (t3 = e4.coercer(t3, a3), s3 && "type" !== e4.type && Ue2(e4.schema) && Ue2(t3) && !Array.isArray(t3)))
        for (const r4 in t3)
          void 0 === e4.schema[r4] && delete t3[r4];
      let h3 = true;
      for (const r4 of e4.validator(t3, a3))
        h3 = false, yield [r4, void 0];
      for (let [r4, f3, u3] of e4.entries(t3, a3)) {
        const e6 = Ce2(f3, u3, { path: void 0 === r4 ? n3 : [...n3, r4], branch: void 0 === r4 ? i3 : [...i3, f3], coerce: o3, mask: s3 });
        for (const n4 of e6)
          n4[0] ? (h3 = false, yield [n4[0], void 0]) : o3 && (f3 = n4[1], void 0 === r4 ? t3 = f3 : t3 instanceof Map ? t3.set(r4, f3) : t3 instanceof Set ? t3.add(f3) : Ue2(t3) && (t3[r4] = f3));
      }
      if (h3)
        for (const r4 of e4.refiner(t3, a3))
          h3 = false, yield [r4, void 0];
      h3 && (yield [void 0, t3]);
    }
    class qe2 {
      constructor(t3) {
        const { type: e4, schema: r3, validator: n3, refiner: i3, coercer: o3 = (t4) => t4, entries: s3 = function* () {
        } } = t3;
        this.type = e4, this.schema = r3, this.entries = s3, this.coercer = o3, this.validator = n3 ? (t4, e6) => ze(n3(t4, e6), e6, this, t4) : () => [], this.refiner = i3 ? (t4, e6) => ze(i3(t4, e6), e6, this, t4) : () => [];
      }
      assert(t3) {
        return function(t4, e4) {
          const r3 = Fe2(t4, e4);
          if (r3[0])
            throw r3[0];
        }(t3, this);
      }
      create(t3) {
        return je2(t3, this);
      }
      is(t3) {
        return De2(t3, this);
      }
      mask(t3) {
        return function(t4, e4) {
          const r3 = Fe2(t4, e4, { coerce: true, mask: true });
          if (r3[0])
            throw r3[0];
          return r3[1];
        }(t3, this);
      }
      validate(t3, e4 = {}) {
        return Fe2(t3, this, e4);
      }
    }
    function je2(t3, e4) {
      const r3 = Fe2(t3, e4, { coerce: true });
      if (r3[0])
        throw r3[0];
      return r3[1];
    }
    function De2(t3, e4) {
      return !Fe2(t3, e4)[0];
    }
    function Fe2(t3, e4, r3 = {}) {
      const n3 = Ce2(t3, e4, r3), i3 = function(t4) {
        const { done: e6, value: r4 } = t4.next();
        return e6 ? void 0 : r4;
      }(n3);
      if (i3[0]) {
        return [new Oe2(i3[0], function* () {
          for (const t4 of n3)
            t4[0] && (yield t4[0]);
        }), void 0];
      }
      return [void 0, i3[1]];
    }
    function Ke2(t3, e4) {
      return new qe2({ type: t3, schema: null, validator: e4 });
    }
    function Ye2(t3) {
      return new qe2({ type: "array", schema: t3, *entries(e4) {
        if (t3 && Array.isArray(e4))
          for (const [r3, n3] of e4.entries())
            yield [r3, n3, t3];
      }, coercer: (t4) => Array.isArray(t4) ? t4.slice() : t4, validator: (t4) => Array.isArray(t4) || "Expected an array value, but received: " + Le2(t4) });
    }
    function Ve2() {
      return Ke2("boolean", (t3) => "boolean" == typeof t3);
    }
    function We2(t3) {
      return Ke2("instance", (e4) => e4 instanceof t3 || "Expected a `" + t3.name + "` instance, but received: " + Le2(e4));
    }
    function He2(t3) {
      const e4 = Le2(t3), r3 = typeof t3;
      return new qe2({ type: "literal", schema: "string" === r3 || "number" === r3 || "boolean" === r3 ? t3 : null, validator: (r4) => r4 === t3 || "Expected the literal `" + e4 + "`, but received: " + Le2(r4) });
    }
    function $e2(t3) {
      return new qe2({ ...t3, validator: (e4, r3) => null === e4 || t3.validator(e4, r3), refiner: (e4, r3) => null === e4 || t3.refiner(e4, r3) });
    }
    function Ge2() {
      return Ke2("number", (t3) => "number" == typeof t3 && !isNaN(t3) || "Expected a number, but received: " + Le2(t3));
    }
    function Ze2(t3) {
      return new qe2({ ...t3, validator: (e4, r3) => void 0 === e4 || t3.validator(e4, r3), refiner: (e4, r3) => void 0 === e4 || t3.refiner(e4, r3) });
    }
    function Je2(t3, e4) {
      return new qe2({ type: "record", schema: null, *entries(r3) {
        if (Ue2(r3))
          for (const n3 in r3) {
            const i3 = r3[n3];
            yield [n3, n3, t3], yield [n3, i3, e4];
          }
      }, validator: (t4) => Ue2(t4) || "Expected an object, but received: " + Le2(t4) });
    }
    function Xe2() {
      return Ke2("string", (t3) => "string" == typeof t3 || "Expected a string, but received: " + Le2(t3));
    }
    function Qe2(t3) {
      const e4 = Ke2("never", () => false);
      return new qe2({ type: "tuple", schema: null, *entries(r3) {
        if (Array.isArray(r3)) {
          const n3 = Math.max(t3.length, r3.length);
          for (let i3 = 0; i3 < n3; i3++)
            yield [i3, r3[i3], t3[i3] || e4];
        }
      }, validator: (t4) => Array.isArray(t4) || "Expected an array, but received: " + Le2(t4) });
    }
    function tr(t3) {
      const e4 = Object.keys(t3);
      return new qe2({ type: "type", schema: t3, *entries(r3) {
        if (Ue2(r3))
          for (const n3 of e4)
            yield [n3, r3[n3], t3[n3]];
      }, validator: (t4) => Ue2(t4) || "Expected an object, but received: " + Le2(t4) });
    }
    function er(t3) {
      const e4 = t3.map((t4) => t4.type).join(" | ");
      return new qe2({ type: "union", schema: null, validator(r3, n3) {
        const i3 = [];
        for (const e6 of t3) {
          const [...t4] = Ce2(r3, e6, n3), [o3] = t4;
          if (!o3[0])
            return [];
          for (const [e7] of t4)
            e7 && i3.push(e7);
        }
        return ["Expected the value to satisfy a union of `" + e4 + "`, but received: " + Le2(r3), ...i3];
      } });
    }
    function rr() {
      return Ke2("unknown", () => true);
    }
    function nr(t3, e4, r3) {
      return new qe2({ ...t3, coercer: (n3, i3) => De2(n3, e4) ? t3.coercer(r3(n3, i3), i3) : t3.coercer(n3, i3) });
    }
    var ir = Qt(function(t3) {
      t3.exports = function(t4) {
        return t4 && t4.__esModule ? t4 : { default: t4 };
      }, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(ir);
    var or = Qt(function(t3) {
      t3.exports = function(t4, e4) {
        if (!(t4 instanceof e4))
          throw new TypeError("Cannot call a class as a function");
      }, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(or);
    var sr = Qt(function(t3) {
      function e4(r3, n3) {
        return t3.exports = e4 = Object.setPrototypeOf || function(t4, e6) {
          return t4.__proto__ = e6, t4;
        }, t3.exports.__esModule = true, t3.exports.default = t3.exports, e4(r3, n3);
      }
      t3.exports = e4, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(sr);
    var ar = Qt(function(t3) {
      t3.exports = function(t4, e4) {
        if ("function" != typeof e4 && null !== e4)
          throw new TypeError("Super expression must either be null or a function");
        t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && sr(t4, e4);
      }, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(ar);
    var hr = Qt(function(t3) {
      function e4(r3) {
        return t3.exports = e4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, t3.exports.__esModule = true, t3.exports.default = t3.exports, e4(r3);
      }
      t3.exports = e4, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(hr);
    var fr = Qt(function(t3) {
      t3.exports = function(t4) {
        if (void 0 === t4)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(fr);
    var ur = Qt(function(t3) {
      var e4 = hr.default;
      t3.exports = function(t4, r3) {
        if (r3 && ("object" === e4(r3) || "function" == typeof r3))
          return r3;
        if (void 0 !== r3)
          throw new TypeError("Derived constructors may only return object or undefined");
        return fr(t4);
      }, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(ur);
    var cr = Qt(function(t3) {
      function e4(r3) {
        return t3.exports = e4 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t4) {
          return t4.__proto__ || Object.getPrototypeOf(t4);
        }, t3.exports.__esModule = true, t3.exports.default = t3.exports, e4(r3);
      }
      t3.exports = e4, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(cr);
    var dr = Qt(function(t3) {
      function e4(t4, e6) {
        for (var r3 = 0; r3 < e6.length; r3++) {
          var n3 = e6[r3];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(t4, n3.key, n3);
        }
      }
      t3.exports = function(t4, r3, n3) {
        return r3 && e4(t4.prototype, r3), n3 && e4(t4, n3), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(dr);
    var lr = Qt(function(t3) {
      var e4 = Object.prototype.hasOwnProperty, r3 = "~";
      function n3() {
      }
      function i3(t4, e6, r4) {
        this.fn = t4, this.context = e6, this.once = r4 || false;
      }
      function o3(t4, e6, n4, o4, s4) {
        if ("function" != typeof n4)
          throw new TypeError("The listener must be a function");
        var a4 = new i3(n4, o4 || t4, s4), h3 = r3 ? r3 + e6 : e6;
        return t4._events[h3] ? t4._events[h3].fn ? t4._events[h3] = [t4._events[h3], a4] : t4._events[h3].push(a4) : (t4._events[h3] = a4, t4._eventsCount++), t4;
      }
      function s3(t4, e6) {
        0 == --t4._eventsCount ? t4._events = new n3() : delete t4._events[e6];
      }
      function a3() {
        this._events = new n3(), this._eventsCount = 0;
      }
      Object.create && (n3.prototype = /* @__PURE__ */ Object.create(null), new n3().__proto__ || (r3 = false)), a3.prototype.eventNames = function() {
        var t4, n4, i4 = [];
        if (0 === this._eventsCount)
          return i4;
        for (n4 in t4 = this._events)
          e4.call(t4, n4) && i4.push(r3 ? n4.slice(1) : n4);
        return Object.getOwnPropertySymbols ? i4.concat(Object.getOwnPropertySymbols(t4)) : i4;
      }, a3.prototype.listeners = function(t4) {
        var e6 = r3 ? r3 + t4 : t4, n4 = this._events[e6];
        if (!n4)
          return [];
        if (n4.fn)
          return [n4.fn];
        for (var i4 = 0, o4 = n4.length, s4 = new Array(o4); i4 < o4; i4++)
          s4[i4] = n4[i4].fn;
        return s4;
      }, a3.prototype.listenerCount = function(t4) {
        var e6 = r3 ? r3 + t4 : t4, n4 = this._events[e6];
        return n4 ? n4.fn ? 1 : n4.length : 0;
      }, a3.prototype.emit = function(t4, e6, n4, i4, o4, s4) {
        var a4 = r3 ? r3 + t4 : t4;
        if (!this._events[a4])
          return false;
        var h3, f3, u3 = this._events[a4], c3 = arguments.length;
        if (u3.fn) {
          switch (u3.once && this.removeListener(t4, u3.fn, void 0, true), c3) {
            case 1:
              return u3.fn.call(u3.context), true;
            case 2:
              return u3.fn.call(u3.context, e6), true;
            case 3:
              return u3.fn.call(u3.context, e6, n4), true;
            case 4:
              return u3.fn.call(u3.context, e6, n4, i4), true;
            case 5:
              return u3.fn.call(u3.context, e6, n4, i4, o4), true;
            case 6:
              return u3.fn.call(u3.context, e6, n4, i4, o4, s4), true;
          }
          for (f3 = 1, h3 = new Array(c3 - 1); f3 < c3; f3++)
            h3[f3 - 1] = arguments[f3];
          u3.fn.apply(u3.context, h3);
        } else {
          var d3, l3 = u3.length;
          for (f3 = 0; f3 < l3; f3++)
            switch (u3[f3].once && this.removeListener(t4, u3[f3].fn, void 0, true), c3) {
              case 1:
                u3[f3].fn.call(u3[f3].context);
                break;
              case 2:
                u3[f3].fn.call(u3[f3].context, e6);
                break;
              case 3:
                u3[f3].fn.call(u3[f3].context, e6, n4);
                break;
              case 4:
                u3[f3].fn.call(u3[f3].context, e6, n4, i4);
                break;
              default:
                if (!h3)
                  for (d3 = 1, h3 = new Array(c3 - 1); d3 < c3; d3++)
                    h3[d3 - 1] = arguments[d3];
                u3[f3].fn.apply(u3[f3].context, h3);
            }
        }
        return true;
      }, a3.prototype.on = function(t4, e6, r4) {
        return o3(this, t4, e6, r4, false);
      }, a3.prototype.once = function(t4, e6, r4) {
        return o3(this, t4, e6, r4, true);
      }, a3.prototype.removeListener = function(t4, e6, n4, i4) {
        var o4 = r3 ? r3 + t4 : t4;
        if (!this._events[o4])
          return this;
        if (!e6)
          return s3(this, o4), this;
        var a4 = this._events[o4];
        if (a4.fn)
          a4.fn !== e6 || i4 && !a4.once || n4 && a4.context !== n4 || s3(this, o4);
        else {
          for (var h3 = 0, f3 = [], u3 = a4.length; h3 < u3; h3++)
            (a4[h3].fn !== e6 || i4 && !a4[h3].once || n4 && a4[h3].context !== n4) && f3.push(a4[h3]);
          f3.length ? this._events[o4] = 1 === f3.length ? f3[0] : f3 : s3(this, o4);
        }
        return this;
      }, a3.prototype.removeAllListeners = function(t4) {
        var e6;
        return t4 ? (e6 = r3 ? r3 + t4 : t4, this._events[e6] && s3(this, e6)) : (this._events = new n3(), this._eventsCount = 0), this;
      }, a3.prototype.off = a3.prototype.removeListener, a3.prototype.addListener = a3.prototype.on, a3.prefixed = r3, a3.EventEmitter = a3, t3.exports = a3;
    }), pr = Qt(function(t3, e4) {
      Object.defineProperty(e4, "__esModule", { value: true }), e4.default = function(t4, e6) {
        return new h3(t4, e6);
      };
      var r3 = ir(or), n3 = ir(dr), i3 = ir(ar), o3 = ir(ur), s3 = ir(cr);
      function a3(t4) {
        var e6 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t5) {
            return false;
          }
        }();
        return function() {
          var r4, n4 = (0, s3.default)(t4);
          if (e6) {
            var i4 = (0, s3.default)(this).constructor;
            r4 = Reflect.construct(n4, arguments, i4);
          } else
            r4 = n4.apply(this, arguments);
          return (0, o3.default)(this, r4);
        };
      }
      var h3 = function(t4) {
        (0, i3.default)(o4, t4);
        var e6 = a3(o4);
        function o4(t5, n4, i4) {
          var s4;
          return (0, r3.default)(this, o4), (s4 = e6.call(this)).socket = new window.WebSocket(t5, i4), s4.socket.onopen = function() {
            return s4.emit("open");
          }, s4.socket.onmessage = function(t6) {
            return s4.emit("message", t6.data);
          }, s4.socket.onerror = function(t6) {
            return s4.emit("error", t6);
          }, s4.socket.onclose = function(t6) {
            s4.emit("close", t6.code, t6.reason);
          }, s4;
        }
        return (0, n3.default)(o4, [{ key: "send", value: function(t5, e7, r4) {
          var n4 = r4 || e7;
          try {
            this.socket.send(t5), n4();
          } catch (t6) {
            n4(t6);
          }
        } }, { key: "close", value: function(t5, e7) {
          this.socket.close(t5, e7);
        } }, { key: "addEventListener", value: function(t5, e7, r4) {
          this.socket.addEventListener(t5, e7, r4);
        } }]), o4;
      }(lr.EventEmitter);
    });
    Xt(pr);
    var br = Qt(function(t3) {
      var e4 = function(t4) {
        var e6, r3 = Object.prototype, n3 = r3.hasOwnProperty, i3 = "function" == typeof Symbol ? Symbol : {}, o3 = i3.iterator || "@@iterator", s3 = i3.asyncIterator || "@@asyncIterator", a3 = i3.toStringTag || "@@toStringTag";
        function h3(t5, e7, r4) {
          return Object.defineProperty(t5, e7, { value: r4, enumerable: true, configurable: true, writable: true }), t5[e7];
        }
        try {
          h3({}, "");
        } catch (t5) {
          h3 = function(t6, e7, r4) {
            return t6[e7] = r4;
          };
        }
        function f3(t5, e7, r4, n4) {
          var i4 = e7 && e7.prototype instanceof m3 ? e7 : m3, o4 = Object.create(i4.prototype), s4 = new k3(n4 || []);
          return o4._invoke = function(t6, e8, r5) {
            var n5 = c3;
            return function(i5, o5) {
              if (n5 === l3)
                throw new Error("Generator is already running");
              if (n5 === p3) {
                if ("throw" === i5)
                  throw o5;
                return T3();
              }
              for (r5.method = i5, r5.arg = o5; ; ) {
                var s5 = r5.delegate;
                if (s5) {
                  var a4 = E3(s5, r5);
                  if (a4) {
                    if (a4 === b3)
                      continue;
                    return a4;
                  }
                }
                if ("next" === r5.method)
                  r5.sent = r5._sent = r5.arg;
                else if ("throw" === r5.method) {
                  if (n5 === c3)
                    throw n5 = p3, r5.arg;
                  r5.dispatchException(r5.arg);
                } else
                  "return" === r5.method && r5.abrupt("return", r5.arg);
                n5 = l3;
                var h4 = u3(t6, e8, r5);
                if ("normal" === h4.type) {
                  if (n5 = r5.done ? p3 : d3, h4.arg === b3)
                    continue;
                  return { value: h4.arg, done: r5.done };
                }
                "throw" === h4.type && (n5 = p3, r5.method = "throw", r5.arg = h4.arg);
              }
            };
          }(t5, r4, s4), o4;
        }
        function u3(t5, e7, r4) {
          try {
            return { type: "normal", arg: t5.call(e7, r4) };
          } catch (t6) {
            return { type: "throw", arg: t6 };
          }
        }
        t4.wrap = f3;
        var c3 = "suspendedStart", d3 = "suspendedYield", l3 = "executing", p3 = "completed", b3 = {};
        function m3() {
        }
        function y3() {
        }
        function g2() {
        }
        var v3 = {};
        v3[o3] = function() {
          return this;
        };
        var w3 = Object.getPrototypeOf, M3 = w3 && w3(w3(R3([])));
        M3 && M3 !== r3 && n3.call(M3, o3) && (v3 = M3);
        var _3 = g2.prototype = m3.prototype = Object.create(v3);
        function A3(t5) {
          ["next", "throw", "return"].forEach(function(e7) {
            h3(t5, e7, function(t6) {
              return this._invoke(e7, t6);
            });
          });
        }
        function S3(t5, e7) {
          function r4(i5, o4, s4, a4) {
            var h4 = u3(t5[i5], t5, o4);
            if ("throw" !== h4.type) {
              var f4 = h4.arg, c4 = f4.value;
              return c4 && "object" == typeof c4 && n3.call(c4, "__await") ? e7.resolve(c4.__await).then(function(t6) {
                r4("next", t6, s4, a4);
              }, function(t6) {
                r4("throw", t6, s4, a4);
              }) : e7.resolve(c4).then(function(t6) {
                f4.value = t6, s4(f4);
              }, function(t6) {
                return r4("throw", t6, s4, a4);
              });
            }
            a4(h4.arg);
          }
          var i4;
          this._invoke = function(t6, n4) {
            function o4() {
              return new e7(function(e8, i5) {
                r4(t6, n4, e8, i5);
              });
            }
            return i4 = i4 ? i4.then(o4, o4) : o4();
          };
        }
        function E3(t5, r4) {
          var n4 = t5.iterator[r4.method];
          if (n4 === e6) {
            if (r4.delegate = null, "throw" === r4.method) {
              if (t5.iterator.return && (r4.method = "return", r4.arg = e6, E3(t5, r4), "throw" === r4.method))
                return b3;
              r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return b3;
          }
          var i4 = u3(n4, t5.iterator, r4.arg);
          if ("throw" === i4.type)
            return r4.method = "throw", r4.arg = i4.arg, r4.delegate = null, b3;
          var o4 = i4.arg;
          return o4 ? o4.done ? (r4[t5.resultName] = o4.value, r4.next = t5.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e6), r4.delegate = null, b3) : o4 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, b3);
        }
        function x3(t5) {
          var e7 = { tryLoc: t5[0] };
          1 in t5 && (e7.catchLoc = t5[1]), 2 in t5 && (e7.finallyLoc = t5[2], e7.afterLoc = t5[3]), this.tryEntries.push(e7);
        }
        function I3(t5) {
          var e7 = t5.completion || {};
          e7.type = "normal", delete e7.arg, t5.completion = e7;
        }
        function k3(t5) {
          this.tryEntries = [{ tryLoc: "root" }], t5.forEach(x3, this), this.reset(true);
        }
        function R3(t5) {
          if (t5) {
            var r4 = t5[o3];
            if (r4)
              return r4.call(t5);
            if ("function" == typeof t5.next)
              return t5;
            if (!isNaN(t5.length)) {
              var i4 = -1, s4 = function r5() {
                for (; ++i4 < t5.length; )
                  if (n3.call(t5, i4))
                    return r5.value = t5[i4], r5.done = false, r5;
                return r5.value = e6, r5.done = true, r5;
              };
              return s4.next = s4;
            }
          }
          return { next: T3 };
        }
        function T3() {
          return { value: e6, done: true };
        }
        return y3.prototype = _3.constructor = g2, g2.constructor = y3, y3.displayName = h3(g2, a3, "GeneratorFunction"), t4.isGeneratorFunction = function(t5) {
          var e7 = "function" == typeof t5 && t5.constructor;
          return !!e7 && (e7 === y3 || "GeneratorFunction" === (e7.displayName || e7.name));
        }, t4.mark = function(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, g2) : (t5.__proto__ = g2, h3(t5, a3, "GeneratorFunction")), t5.prototype = Object.create(_3), t5;
        }, t4.awrap = function(t5) {
          return { __await: t5 };
        }, A3(S3.prototype), S3.prototype[s3] = function() {
          return this;
        }, t4.AsyncIterator = S3, t4.async = function(e7, r4, n4, i4, o4) {
          void 0 === o4 && (o4 = Promise);
          var s4 = new S3(f3(e7, r4, n4, i4), o4);
          return t4.isGeneratorFunction(r4) ? s4 : s4.next().then(function(t5) {
            return t5.done ? t5.value : s4.next();
          });
        }, A3(_3), h3(_3, a3, "Generator"), _3[o3] = function() {
          return this;
        }, _3.toString = function() {
          return "[object Generator]";
        }, t4.keys = function(t5) {
          var e7 = [];
          for (var r4 in t5)
            e7.push(r4);
          return e7.reverse(), function r5() {
            for (; e7.length; ) {
              var n4 = e7.pop();
              if (n4 in t5)
                return r5.value = n4, r5.done = false, r5;
            }
            return r5.done = true, r5;
          };
        }, t4.values = R3, k3.prototype = { constructor: k3, reset: function(t5) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = e6, this.done = false, this.delegate = null, this.method = "next", this.arg = e6, this.tryEntries.forEach(I3), !t5)
            for (var r4 in this)
              "t" === r4.charAt(0) && n3.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e6);
        }, stop: function() {
          this.done = true;
          var t5 = this.tryEntries[0].completion;
          if ("throw" === t5.type)
            throw t5.arg;
          return this.rval;
        }, dispatchException: function(t5) {
          if (this.done)
            throw t5;
          var r4 = this;
          function i4(n4, i5) {
            return a4.type = "throw", a4.arg = t5, r4.next = n4, i5 && (r4.method = "next", r4.arg = e6), !!i5;
          }
          for (var o4 = this.tryEntries.length - 1; o4 >= 0; --o4) {
            var s4 = this.tryEntries[o4], a4 = s4.completion;
            if ("root" === s4.tryLoc)
              return i4("end");
            if (s4.tryLoc <= this.prev) {
              var h4 = n3.call(s4, "catchLoc"), f4 = n3.call(s4, "finallyLoc");
              if (h4 && f4) {
                if (this.prev < s4.catchLoc)
                  return i4(s4.catchLoc, true);
                if (this.prev < s4.finallyLoc)
                  return i4(s4.finallyLoc);
              } else if (h4) {
                if (this.prev < s4.catchLoc)
                  return i4(s4.catchLoc, true);
              } else {
                if (!f4)
                  throw new Error("try statement without catch or finally");
                if (this.prev < s4.finallyLoc)
                  return i4(s4.finallyLoc);
              }
            }
          }
        }, abrupt: function(t5, e7) {
          for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
            var i4 = this.tryEntries[r4];
            if (i4.tryLoc <= this.prev && n3.call(i4, "finallyLoc") && this.prev < i4.finallyLoc) {
              var o4 = i4;
              break;
            }
          }
          o4 && ("break" === t5 || "continue" === t5) && o4.tryLoc <= e7 && e7 <= o4.finallyLoc && (o4 = null);
          var s4 = o4 ? o4.completion : {};
          return s4.type = t5, s4.arg = e7, o4 ? (this.method = "next", this.next = o4.finallyLoc, b3) : this.complete(s4);
        }, complete: function(t5, e7) {
          if ("throw" === t5.type)
            throw t5.arg;
          return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && e7 && (this.next = e7), b3;
        }, finish: function(t5) {
          for (var e7 = this.tryEntries.length - 1; e7 >= 0; --e7) {
            var r4 = this.tryEntries[e7];
            if (r4.finallyLoc === t5)
              return this.complete(r4.completion, r4.afterLoc), I3(r4), b3;
          }
        }, catch: function(t5) {
          for (var e7 = this.tryEntries.length - 1; e7 >= 0; --e7) {
            var r4 = this.tryEntries[e7];
            if (r4.tryLoc === t5) {
              var n4 = r4.completion;
              if ("throw" === n4.type) {
                var i4 = n4.arg;
                I3(r4);
              }
              return i4;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function(t5, r4, n4) {
          return this.delegate = { iterator: R3(t5), resultName: r4, nextLoc: n4 }, "next" === this.method && (this.arg = e6), b3;
        } }, t4;
      }(t3.exports);
      try {
        regeneratorRuntime = e4;
      } catch (t4) {
        Function("r", "regeneratorRuntime = r")(e4);
      }
    }), mr = Qt(function(t3) {
      function e4(t4, e6, r3, n3, i3, o3, s3) {
        try {
          var a3 = t4[o3](s3), h3 = a3.value;
        } catch (t5) {
          return void r3(t5);
        }
        a3.done ? e6(h3) : Promise.resolve(h3).then(n3, i3);
      }
      t3.exports = function(t4) {
        return function() {
          var r3 = this, n3 = arguments;
          return new Promise(function(i3, o3) {
            var s3 = t4.apply(r3, n3);
            function a3(t5) {
              e4(s3, i3, o3, a3, h3, "next", t5);
            }
            function h3(t5) {
              e4(s3, i3, o3, a3, h3, "throw", t5);
            }
            a3(void 0);
          });
        };
      }, t3.exports.__esModule = true, t3.exports.default = t3.exports;
    });
    Xt(mr);
    /*!
    	  Copyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection
    
    	  Permission is hereby granted, free of charge, to any person obtaining a copy
    	  of this software and associated documentation files (the "Software"), to deal
    	  in the Software without restriction, including without limitation the rights
    	  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    	  copies of the Software, and to permit persons to whom the Software is
    	  furnished to do so, subject to the following conditions:
    
    	  The above copyright notice and this permission notice shall be included in
    	  all copies or substantial portions of the Software.
    
    	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    	  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    	  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    	  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    	  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    	  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    	  THE SOFTWARE.
    
    	  */
    var yr = "~", gr = "\\x" + ("0" + yr.charCodeAt(0).toString(16)).slice(-2), vr = "\\" + gr, wr = new RegExp(gr, "g"), Mr = new RegExp(vr, "g"), _r = new RegExp("(?:^|([^\\\\]))" + vr), Ar = [].indexOf || function(t3) {
      for (var e4 = this.length; e4-- && this[e4] !== t3; )
        ;
      return e4;
    }, Sr = String;
    function Er(t3, e4, r3) {
      return e4 instanceof Array ? function(t4, e6, r4) {
        for (var n3 = 0, i3 = e6.length; n3 < i3; n3++)
          e6[n3] = Er(t4, e6[n3], r4);
        return e6;
      }(t3, e4, r3) : e4 instanceof Sr ? e4.length ? r3.hasOwnProperty(e4) ? r3[e4] : r3[e4] = function(t4, e6) {
        for (var r4 = 0, n3 = e6.length; r4 < n3; t4 = t4[e6[r4++].replace(Mr, yr)])
          ;
        return t4;
      }(t3, e4.split(yr)) : t3 : e4 instanceof Object ? function(t4, e6, r4) {
        for (var n3 in e6)
          e6.hasOwnProperty(n3) && (e6[n3] = Er(t4, e6[n3], r4));
        return e6;
      }(t3, e4, r3) : e4;
    }
    var xr = { stringify: function(t3, e4, r3, n3) {
      return xr.parser.stringify(t3, function(t4, e6, r4) {
        var n4, i3, o3 = false, s3 = !!e6, a3 = [], h3 = [t4], f3 = [t4], u3 = [r4 ? yr : "[Circular]"], c3 = t4, d3 = 1;
        return s3 && (i3 = "object" == typeof e6 ? function(t5, r5) {
          return "" !== t5 && e6.indexOf(t5) < 0 ? void 0 : r5;
        } : e6), function(t5, e7) {
          return s3 && (e7 = i3.call(this, t5, e7)), o3 ? (c3 !== this && (n4 = d3 - Ar.call(h3, this) - 1, d3 -= n4, h3.splice(d3, h3.length), a3.splice(d3 - 1, a3.length), c3 = this), "object" == typeof e7 && e7 ? (Ar.call(h3, e7) < 0 && h3.push(c3 = e7), d3 = h3.length, (n4 = Ar.call(f3, e7)) < 0 ? (n4 = f3.push(e7) - 1, r4 ? (a3.push(("" + t5).replace(wr, gr)), u3[n4] = yr + a3.join(yr)) : u3[n4] = u3[0]) : e7 = u3[n4]) : "string" == typeof e7 && r4 && (e7 = e7.replace(gr, vr).replace(yr, gr))) : o3 = true, e7;
        };
      }(t3, e4, !n3), r3);
    }, parse: function(t3, e4) {
      return xr.parser.parse(t3, function(t4) {
        return function(e6, r3) {
          var n3 = "string" == typeof r3;
          return n3 && r3.charAt(0) === yr ? new Sr(r3.slice(1)) : ("" === e6 && (r3 = Er(r3, r3, {})), n3 && (r3 = r3.replace(_r, "$1~").replace(vr, gr)), t4 ? t4.call(this, e6, r3) : r3);
        };
      }(e4));
    }, parser: JSON }, Ir = xr, kr = Qt(function(t3, e4) {
      Object.defineProperty(e4, "__esModule", { value: true }), e4.default = void 0;
      var r3 = ir(br), n3 = ir(mr), i3 = ir(hr), o3 = ir(or), s3 = ir(dr), a3 = ir(ar), h3 = ir(ur), f3 = ir(cr), u3 = ir(Ir);
      function c3(t4) {
        var e6 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t5) {
            return false;
          }
        }();
        return function() {
          var r4, n4 = (0, f3.default)(t4);
          if (e6) {
            var i4 = (0, f3.default)(this).constructor;
            r4 = Reflect.construct(n4, arguments, i4);
          } else
            r4 = n4.apply(this, arguments);
          return (0, h3.default)(this, r4);
        };
      }
      var d3 = function(t4, e6) {
        var r4 = {};
        for (var n4 in t4)
          Object.prototype.hasOwnProperty.call(t4, n4) && e6.indexOf(n4) < 0 && (r4[n4] = t4[n4]);
        if (null != t4 && "function" == typeof Object.getOwnPropertySymbols) {
          var i4 = 0;
          for (n4 = Object.getOwnPropertySymbols(t4); i4 < n4.length; i4++)
            e6.indexOf(n4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(t4, n4[i4]) && (r4[n4[i4]] = t4[n4[i4]]);
        }
        return r4;
      }, l3 = function(t4) {
        (0, a3.default)(b3, t4);
        var e6, h4, f4, l4, p3 = c3(b3);
        function b3(t5) {
          var e7, r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "ws://localhost:8080", n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i4 = arguments.length > 3 ? arguments[3] : void 0;
          (0, o3.default)(this, b3);
          var s4 = n4.autoconnect, a4 = void 0 === s4 || s4, h5 = n4.reconnect, f5 = void 0 === h5 || h5, u4 = n4.reconnect_interval, c4 = void 0 === u4 ? 1e3 : u4, l5 = n4.max_reconnects, m3 = void 0 === l5 ? 5 : l5, y3 = d3(n4, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
          return (e7 = p3.call(this)).webSocketFactory = t5, e7.queue = {}, e7.rpc_id = 0, e7.address = r4, e7.autoconnect = a4, e7.ready = false, e7.reconnect = f5, e7.reconnect_interval = c4, e7.max_reconnects = m3, e7.rest_options = y3, e7.current_reconnects = 0, e7.generate_request_id = i4 || function() {
            return ++e7.rpc_id;
          }, e7.autoconnect && e7._connect(e7.address, Object.assign({ autoconnect: e7.autoconnect, reconnect: e7.reconnect, reconnect_interval: e7.reconnect_interval, max_reconnects: e7.max_reconnects }, e7.rest_options)), e7;
        }
        return (0, s3.default)(b3, [{ key: "connect", value: function() {
          this.socket || this._connect(this.address, Object.assign({ autoconnect: this.autoconnect, reconnect: this.reconnect, reconnect_interval: this.reconnect_interval, max_reconnects: this.max_reconnects }, this.rest_options));
        } }, { key: "call", value: function(t5, e7, r4, n4) {
          var o4 = this;
          return n4 || "object" !== (0, i3.default)(r4) || (n4 = r4, r4 = null), new Promise(function(i4, s4) {
            if (!o4.ready)
              return s4(new Error("socket not ready"));
            var a4 = o4.generate_request_id(t5, e7), h5 = { jsonrpc: "2.0", method: t5, params: e7 || null, id: a4 };
            o4.socket.send(JSON.stringify(h5), n4, function(t6) {
              if (t6)
                return s4(t6);
              o4.queue[a4] = { promise: [i4, s4] }, r4 && (o4.queue[a4].timeout = setTimeout(function() {
                delete o4.queue[a4], s4(new Error("reply timeout"));
              }, r4));
            });
          });
        } }, { key: "login", value: (l4 = (0, n3.default)(r3.default.mark(function t5(e7) {
          var n4;
          return r3.default.wrap(function(t6) {
            for (; ; )
              switch (t6.prev = t6.next) {
                case 0:
                  return t6.next = 2, this.call("rpc.login", e7);
                case 2:
                  if (n4 = t6.sent) {
                    t6.next = 5;
                    break;
                  }
                  throw new Error("authentication failed");
                case 5:
                  return t6.abrupt("return", n4);
                case 6:
                case "end":
                  return t6.stop();
              }
          }, t5, this);
        })), function(t5) {
          return l4.apply(this, arguments);
        }) }, { key: "listMethods", value: (f4 = (0, n3.default)(r3.default.mark(function t5() {
          return r3.default.wrap(function(t6) {
            for (; ; )
              switch (t6.prev = t6.next) {
                case 0:
                  return t6.next = 2, this.call("__listMethods");
                case 2:
                  return t6.abrupt("return", t6.sent);
                case 3:
                case "end":
                  return t6.stop();
              }
          }, t5, this);
        })), function() {
          return f4.apply(this, arguments);
        }) }, { key: "notify", value: function(t5, e7) {
          var r4 = this;
          return new Promise(function(n4, i4) {
            if (!r4.ready)
              return i4(new Error("socket not ready"));
            var o4 = { jsonrpc: "2.0", method: t5, params: e7 || null };
            r4.socket.send(JSON.stringify(o4), function(t6) {
              if (t6)
                return i4(t6);
              n4();
            });
          });
        } }, { key: "subscribe", value: (h4 = (0, n3.default)(r3.default.mark(function t5(e7) {
          var n4;
          return r3.default.wrap(function(t6) {
            for (; ; )
              switch (t6.prev = t6.next) {
                case 0:
                  return "string" == typeof e7 && (e7 = [e7]), t6.next = 3, this.call("rpc.on", e7);
                case 3:
                  if (n4 = t6.sent, "string" != typeof e7 || "ok" === n4[e7]) {
                    t6.next = 6;
                    break;
                  }
                  throw new Error("Failed subscribing to an event '" + e7 + "' with: " + n4[e7]);
                case 6:
                  return t6.abrupt("return", n4);
                case 7:
                case "end":
                  return t6.stop();
              }
          }, t5, this);
        })), function(t5) {
          return h4.apply(this, arguments);
        }) }, { key: "unsubscribe", value: (e6 = (0, n3.default)(r3.default.mark(function t5(e7) {
          var n4;
          return r3.default.wrap(function(t6) {
            for (; ; )
              switch (t6.prev = t6.next) {
                case 0:
                  return "string" == typeof e7 && (e7 = [e7]), t6.next = 3, this.call("rpc.off", e7);
                case 3:
                  if (n4 = t6.sent, "string" != typeof e7 || "ok" === n4[e7]) {
                    t6.next = 6;
                    break;
                  }
                  throw new Error("Failed unsubscribing from an event with: " + n4);
                case 6:
                  return t6.abrupt("return", n4);
                case 7:
                case "end":
                  return t6.stop();
              }
          }, t5, this);
        })), function(t5) {
          return e6.apply(this, arguments);
        }) }, { key: "close", value: function(t5, e7) {
          this.socket.close(t5 || 1e3, e7);
        } }, { key: "_connect", value: function(t5, e7) {
          var r4 = this;
          this.socket = this.webSocketFactory(t5, e7), this.socket.addEventListener("open", function() {
            r4.ready = true, r4.emit("open"), r4.current_reconnects = 0;
          }), this.socket.addEventListener("message", function(t6) {
            var e8 = t6.data;
            e8 instanceof ArrayBuffer && (e8 = ct.from(e8).toString());
            try {
              e8 = u3.default.parse(e8);
            } catch (t7) {
              return;
            }
            if (e8.notification && r4.listeners(e8.notification).length) {
              if (!Object.keys(e8.params).length)
                return r4.emit(e8.notification);
              var n4 = [e8.notification];
              if (e8.params.constructor === Object)
                n4.push(e8.params);
              else
                for (var i4 = 0; i4 < e8.params.length; i4++)
                  n4.push(e8.params[i4]);
              return Promise.resolve().then(function() {
                r4.emit.apply(r4, n4);
              });
            }
            if (!r4.queue[e8.id])
              return e8.method && e8.params ? Promise.resolve().then(function() {
                r4.emit(e8.method, e8.params);
              }) : void 0;
            "error" in e8 == "result" in e8 && r4.queue[e8.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), r4.queue[e8.id].timeout && clearTimeout(r4.queue[e8.id].timeout), e8.error ? r4.queue[e8.id].promise[1](e8.error) : r4.queue[e8.id].promise[0](e8.result), delete r4.queue[e8.id];
          }), this.socket.addEventListener("error", function(t6) {
            return r4.emit("error", t6);
          }), this.socket.addEventListener("close", function(n4) {
            var i4 = n4.code, o4 = n4.reason;
            r4.ready && setTimeout(function() {
              return r4.emit("close", i4, o4);
            }, 0), r4.ready = false, r4.socket = void 0, 1e3 !== i4 && (r4.current_reconnects++, r4.reconnect && (r4.max_reconnects > r4.current_reconnects || 0 === r4.max_reconnects) && setTimeout(function() {
              return r4._connect(t5, e7);
            }, r4.reconnect_interval));
          });
        } }]), b3;
      }(lr.EventEmitter);
      e4.default = l3;
    });
    Xt(kr);
    var Rr, Tr = Qt(function(t3, e4) {
      Object.defineProperty(e4, "__esModule", { value: true }), e4.Client = void 0;
      var r3 = ir(or), n3 = ir(ar), i3 = ir(ur), o3 = ir(cr), s3 = ir(pr);
      function a3(t4) {
        var e6 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t5) {
            return false;
          }
        }();
        return function() {
          var r4, n4 = (0, o3.default)(t4);
          if (e6) {
            var s4 = (0, o3.default)(this).constructor;
            r4 = Reflect.construct(n4, arguments, s4);
          } else
            r4 = n4.apply(this, arguments);
          return (0, i3.default)(this, r4);
        };
      }
      var h3 = function(t4) {
        (0, n3.default)(i4, t4);
        var e6 = a3(i4);
        function i4() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "ws://localhost:8080", n4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o4 = n4.autoconnect, a4 = void 0 === o4 || o4, h4 = n4.reconnect, f3 = void 0 === h4 || h4, u3 = n4.reconnect_interval, c3 = void 0 === u3 ? 1e3 : u3, d3 = n4.max_reconnects, l3 = void 0 === d3 ? 5 : d3, p3 = arguments.length > 2 ? arguments[2] : void 0;
          return (0, r3.default)(this, i4), e6.call(this, s3.default, t5, { autoconnect: a4, reconnect: f3, reconnect_interval: c3, max_reconnects: l3 }, p3);
        }
        return i4;
      }(ir(kr).default);
      e4.Client = h3;
    });
    Xt(Tr), Tr.Client;
    var Br = new Uint8Array(16);
    function Pr() {
      if (!Rr && !(Rr = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto)))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return Rr(Br);
    }
    var Or = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    function Ur(t3) {
      return "string" == typeof t3 && Or.test(t3);
    }
    for (var Lr, Nr, zr = [], Cr = 0; Cr < 256; ++Cr)
      zr.push((Cr + 256).toString(16).substr(1));
    function qr(t3) {
      var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r3 = (zr[t3[e4 + 0]] + zr[t3[e4 + 1]] + zr[t3[e4 + 2]] + zr[t3[e4 + 3]] + "-" + zr[t3[e4 + 4]] + zr[t3[e4 + 5]] + "-" + zr[t3[e4 + 6]] + zr[t3[e4 + 7]] + "-" + zr[t3[e4 + 8]] + zr[t3[e4 + 9]] + "-" + zr[t3[e4 + 10]] + zr[t3[e4 + 11]] + zr[t3[e4 + 12]] + zr[t3[e4 + 13]] + zr[t3[e4 + 14]] + zr[t3[e4 + 15]]).toLowerCase();
      if (!Ur(r3))
        throw TypeError("Stringified UUID is invalid");
      return r3;
    }
    var jr = 0, Dr = 0;
    function Fr(t3) {
      if (!Ur(t3))
        throw TypeError("Invalid UUID");
      var e4, r3 = new Uint8Array(16);
      return r3[0] = (e4 = parseInt(t3.slice(0, 8), 16)) >>> 24, r3[1] = e4 >>> 16 & 255, r3[2] = e4 >>> 8 & 255, r3[3] = 255 & e4, r3[4] = (e4 = parseInt(t3.slice(9, 13), 16)) >>> 8, r3[5] = 255 & e4, r3[6] = (e4 = parseInt(t3.slice(14, 18), 16)) >>> 8, r3[7] = 255 & e4, r3[8] = (e4 = parseInt(t3.slice(19, 23), 16)) >>> 8, r3[9] = 255 & e4, r3[10] = (e4 = parseInt(t3.slice(24, 36), 16)) / 1099511627776 & 255, r3[11] = e4 / 4294967296 & 255, r3[12] = e4 >>> 24 & 255, r3[13] = e4 >>> 16 & 255, r3[14] = e4 >>> 8 & 255, r3[15] = 255 & e4, r3;
    }
    function Kr(t3, e4, r3) {
      function n3(t4, n4, i3, o3) {
        if ("string" == typeof t4 && (t4 = function(t5) {
          t5 = unescape(encodeURIComponent(t5));
          for (var e6 = [], r4 = 0; r4 < t5.length; ++r4)
            e6.push(t5.charCodeAt(r4));
          return e6;
        }(t4)), "string" == typeof n4 && (n4 = Fr(n4)), 16 !== n4.length)
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var s3 = new Uint8Array(16 + t4.length);
        if (s3.set(n4), s3.set(t4, n4.length), (s3 = r3(s3))[6] = 15 & s3[6] | e4, s3[8] = 63 & s3[8] | 128, i3) {
          o3 = o3 || 0;
          for (var a3 = 0; a3 < 16; ++a3)
            i3[o3 + a3] = s3[a3];
          return i3;
        }
        return qr(s3);
      }
      try {
        n3.name = t3;
      } catch (t4) {
      }
      return n3.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", n3.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8", n3;
    }
    function Yr(t3) {
      return 14 + (t3 + 64 >>> 9 << 4) + 1;
    }
    function Vr(t3, e4) {
      var r3 = (65535 & t3) + (65535 & e4);
      return (t3 >> 16) + (e4 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
    }
    function Wr(t3, e4, r3, n3, i3, o3) {
      return Vr((s3 = Vr(Vr(e4, t3), Vr(n3, o3))) << (a3 = i3) | s3 >>> 32 - a3, r3);
      var s3, a3;
    }
    function Hr(t3, e4, r3, n3, i3, o3, s3) {
      return Wr(e4 & r3 | ~e4 & n3, t3, e4, i3, o3, s3);
    }
    function $r(t3, e4, r3, n3, i3, o3, s3) {
      return Wr(e4 & n3 | r3 & ~n3, t3, e4, i3, o3, s3);
    }
    function Gr(t3, e4, r3, n3, i3, o3, s3) {
      return Wr(e4 ^ r3 ^ n3, t3, e4, i3, o3, s3);
    }
    function Zr(t3, e4, r3, n3, i3, o3, s3) {
      return Wr(r3 ^ (e4 | ~n3), t3, e4, i3, o3, s3);
    }
    var Jr = Kr("v3", 48, function(t3) {
      if ("string" == typeof t3) {
        var e4 = unescape(encodeURIComponent(t3));
        t3 = new Uint8Array(e4.length);
        for (var r3 = 0; r3 < e4.length; ++r3)
          t3[r3] = e4.charCodeAt(r3);
      }
      return function(t4) {
        for (var e6 = [], r4 = 32 * t4.length, n3 = "0123456789abcdef", i3 = 0; i3 < r4; i3 += 8) {
          var o3 = t4[i3 >> 5] >>> i3 % 32 & 255, s3 = parseInt(n3.charAt(o3 >>> 4 & 15) + n3.charAt(15 & o3), 16);
          e6.push(s3);
        }
        return e6;
      }(function(t4, e6) {
        t4[e6 >> 5] |= 128 << e6 % 32, t4[Yr(e6) - 1] = e6;
        for (var r4 = 1732584193, n3 = -271733879, i3 = -1732584194, o3 = 271733878, s3 = 0; s3 < t4.length; s3 += 16) {
          var a3 = r4, h3 = n3, f3 = i3, u3 = o3;
          r4 = Hr(r4, n3, i3, o3, t4[s3], 7, -680876936), o3 = Hr(o3, r4, n3, i3, t4[s3 + 1], 12, -389564586), i3 = Hr(i3, o3, r4, n3, t4[s3 + 2], 17, 606105819), n3 = Hr(n3, i3, o3, r4, t4[s3 + 3], 22, -1044525330), r4 = Hr(r4, n3, i3, o3, t4[s3 + 4], 7, -176418897), o3 = Hr(o3, r4, n3, i3, t4[s3 + 5], 12, 1200080426), i3 = Hr(i3, o3, r4, n3, t4[s3 + 6], 17, -1473231341), n3 = Hr(n3, i3, o3, r4, t4[s3 + 7], 22, -45705983), r4 = Hr(r4, n3, i3, o3, t4[s3 + 8], 7, 1770035416), o3 = Hr(o3, r4, n3, i3, t4[s3 + 9], 12, -1958414417), i3 = Hr(i3, o3, r4, n3, t4[s3 + 10], 17, -42063), n3 = Hr(n3, i3, o3, r4, t4[s3 + 11], 22, -1990404162), r4 = Hr(r4, n3, i3, o3, t4[s3 + 12], 7, 1804603682), o3 = Hr(o3, r4, n3, i3, t4[s3 + 13], 12, -40341101), i3 = Hr(i3, o3, r4, n3, t4[s3 + 14], 17, -1502002290), r4 = $r(r4, n3 = Hr(n3, i3, o3, r4, t4[s3 + 15], 22, 1236535329), i3, o3, t4[s3 + 1], 5, -165796510), o3 = $r(o3, r4, n3, i3, t4[s3 + 6], 9, -1069501632), i3 = $r(i3, o3, r4, n3, t4[s3 + 11], 14, 643717713), n3 = $r(n3, i3, o3, r4, t4[s3], 20, -373897302), r4 = $r(r4, n3, i3, o3, t4[s3 + 5], 5, -701558691), o3 = $r(o3, r4, n3, i3, t4[s3 + 10], 9, 38016083), i3 = $r(i3, o3, r4, n3, t4[s3 + 15], 14, -660478335), n3 = $r(n3, i3, o3, r4, t4[s3 + 4], 20, -405537848), r4 = $r(r4, n3, i3, o3, t4[s3 + 9], 5, 568446438), o3 = $r(o3, r4, n3, i3, t4[s3 + 14], 9, -1019803690), i3 = $r(i3, o3, r4, n3, t4[s3 + 3], 14, -187363961), n3 = $r(n3, i3, o3, r4, t4[s3 + 8], 20, 1163531501), r4 = $r(r4, n3, i3, o3, t4[s3 + 13], 5, -1444681467), o3 = $r(o3, r4, n3, i3, t4[s3 + 2], 9, -51403784), i3 = $r(i3, o3, r4, n3, t4[s3 + 7], 14, 1735328473), r4 = Gr(r4, n3 = $r(n3, i3, o3, r4, t4[s3 + 12], 20, -1926607734), i3, o3, t4[s3 + 5], 4, -378558), o3 = Gr(o3, r4, n3, i3, t4[s3 + 8], 11, -2022574463), i3 = Gr(i3, o3, r4, n3, t4[s3 + 11], 16, 1839030562), n3 = Gr(n3, i3, o3, r4, t4[s3 + 14], 23, -35309556), r4 = Gr(r4, n3, i3, o3, t4[s3 + 1], 4, -1530992060), o3 = Gr(o3, r4, n3, i3, t4[s3 + 4], 11, 1272893353), i3 = Gr(i3, o3, r4, n3, t4[s3 + 7], 16, -155497632), n3 = Gr(n3, i3, o3, r4, t4[s3 + 10], 23, -1094730640), r4 = Gr(r4, n3, i3, o3, t4[s3 + 13], 4, 681279174), o3 = Gr(o3, r4, n3, i3, t4[s3], 11, -358537222), i3 = Gr(i3, o3, r4, n3, t4[s3 + 3], 16, -722521979), n3 = Gr(n3, i3, o3, r4, t4[s3 + 6], 23, 76029189), r4 = Gr(r4, n3, i3, o3, t4[s3 + 9], 4, -640364487), o3 = Gr(o3, r4, n3, i3, t4[s3 + 12], 11, -421815835), i3 = Gr(i3, o3, r4, n3, t4[s3 + 15], 16, 530742520), r4 = Zr(r4, n3 = Gr(n3, i3, o3, r4, t4[s3 + 2], 23, -995338651), i3, o3, t4[s3], 6, -198630844), o3 = Zr(o3, r4, n3, i3, t4[s3 + 7], 10, 1126891415), i3 = Zr(i3, o3, r4, n3, t4[s3 + 14], 15, -1416354905), n3 = Zr(n3, i3, o3, r4, t4[s3 + 5], 21, -57434055), r4 = Zr(r4, n3, i3, o3, t4[s3 + 12], 6, 1700485571), o3 = Zr(o3, r4, n3, i3, t4[s3 + 3], 10, -1894986606), i3 = Zr(i3, o3, r4, n3, t4[s3 + 10], 15, -1051523), n3 = Zr(n3, i3, o3, r4, t4[s3 + 1], 21, -2054922799), r4 = Zr(r4, n3, i3, o3, t4[s3 + 8], 6, 1873313359), o3 = Zr(o3, r4, n3, i3, t4[s3 + 15], 10, -30611744), i3 = Zr(i3, o3, r4, n3, t4[s3 + 6], 15, -1560198380), n3 = Zr(n3, i3, o3, r4, t4[s3 + 13], 21, 1309151649), r4 = Zr(r4, n3, i3, o3, t4[s3 + 4], 6, -145523070), o3 = Zr(o3, r4, n3, i3, t4[s3 + 11], 10, -1120210379), i3 = Zr(i3, o3, r4, n3, t4[s3 + 2], 15, 718787259), n3 = Zr(n3, i3, o3, r4, t4[s3 + 9], 21, -343485551), r4 = Vr(r4, a3), n3 = Vr(n3, h3), i3 = Vr(i3, f3), o3 = Vr(o3, u3);
        }
        return [r4, n3, i3, o3];
      }(function(t4) {
        if (0 === t4.length)
          return [];
        for (var e6 = 8 * t4.length, r4 = new Uint32Array(Yr(e6)), n3 = 0; n3 < e6; n3 += 8)
          r4[n3 >> 5] |= (255 & t4[n3 / 8]) << n3 % 32;
        return r4;
      }(t3), 8 * t3.length));
    });
    function Xr(t3, e4, r3, n3) {
      switch (t3) {
        case 0:
          return e4 & r3 ^ ~e4 & n3;
        case 1:
          return e4 ^ r3 ^ n3;
        case 2:
          return e4 & r3 ^ e4 & n3 ^ r3 & n3;
        case 3:
          return e4 ^ r3 ^ n3;
      }
    }
    function Qr(t3, e4) {
      return t3 << e4 | t3 >>> 32 - e4;
    }
    var tn = Kr("v5", 80, function(t3) {
      var e4 = [1518500249, 1859775393, 2400959708, 3395469782], r3 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if ("string" == typeof t3) {
        var n3 = unescape(encodeURIComponent(t3));
        t3 = [];
        for (var i3 = 0; i3 < n3.length; ++i3)
          t3.push(n3.charCodeAt(i3));
      } else
        Array.isArray(t3) || (t3 = Array.prototype.slice.call(t3));
      t3.push(128);
      for (var o3 = t3.length / 4 + 2, s3 = Math.ceil(o3 / 16), a3 = new Array(s3), h3 = 0; h3 < s3; ++h3) {
        for (var f3 = new Uint32Array(16), u3 = 0; u3 < 16; ++u3)
          f3[u3] = t3[64 * h3 + 4 * u3] << 24 | t3[64 * h3 + 4 * u3 + 1] << 16 | t3[64 * h3 + 4 * u3 + 2] << 8 | t3[64 * h3 + 4 * u3 + 3];
        a3[h3] = f3;
      }
      a3[s3 - 1][14] = 8 * (t3.length - 1) / Math.pow(2, 32), a3[s3 - 1][14] = Math.floor(a3[s3 - 1][14]), a3[s3 - 1][15] = 8 * (t3.length - 1) & 4294967295;
      for (var c3 = 0; c3 < s3; ++c3) {
        for (var d3 = new Uint32Array(80), l3 = 0; l3 < 16; ++l3)
          d3[l3] = a3[c3][l3];
        for (var p3 = 16; p3 < 80; ++p3)
          d3[p3] = Qr(d3[p3 - 3] ^ d3[p3 - 8] ^ d3[p3 - 14] ^ d3[p3 - 16], 1);
        for (var b3 = r3[0], m3 = r3[1], y3 = r3[2], g2 = r3[3], v3 = r3[4], w3 = 0; w3 < 80; ++w3) {
          var M3 = Math.floor(w3 / 20), _3 = Qr(b3, 5) + Xr(M3, m3, y3, g2) + v3 + e4[M3] + d3[w3] >>> 0;
          v3 = g2, g2 = y3, y3 = Qr(m3, 30) >>> 0, m3 = b3, b3 = _3;
        }
        r3[0] = r3[0] + b3 >>> 0, r3[1] = r3[1] + m3 >>> 0, r3[2] = r3[2] + y3 >>> 0, r3[3] = r3[3] + g2 >>> 0, r3[4] = r3[4] + v3 >>> 0;
      }
      return [r3[0] >> 24 & 255, r3[0] >> 16 & 255, r3[0] >> 8 & 255, 255 & r3[0], r3[1] >> 24 & 255, r3[1] >> 16 & 255, r3[1] >> 8 & 255, 255 & r3[1], r3[2] >> 24 & 255, r3[2] >> 16 & 255, r3[2] >> 8 & 255, 255 & r3[2], r3[3] >> 24 & 255, r3[3] >> 16 & 255, r3[3] >> 8 & 255, 255 & r3[3], r3[4] >> 24 & 255, r3[4] >> 16 & 255, r3[4] >> 8 & 255, 255 & r3[4]];
    });
    var en = Object.freeze({ __proto__: null, v1: function(t3, e4, r3) {
      var n3 = e4 && r3 || 0, i3 = e4 || new Array(16), o3 = (t3 = t3 || {}).node || Lr, s3 = void 0 !== t3.clockseq ? t3.clockseq : Nr;
      if (null == o3 || null == s3) {
        var a3 = t3.random || (t3.rng || Pr)();
        null == o3 && (o3 = Lr = [1 | a3[0], a3[1], a3[2], a3[3], a3[4], a3[5]]), null == s3 && (s3 = Nr = 16383 & (a3[6] << 8 | a3[7]));
      }
      var h3 = void 0 !== t3.msecs ? t3.msecs : Date.now(), f3 = void 0 !== t3.nsecs ? t3.nsecs : Dr + 1, u3 = h3 - jr + (f3 - Dr) / 1e4;
      if (u3 < 0 && void 0 === t3.clockseq && (s3 = s3 + 1 & 16383), (u3 < 0 || h3 > jr) && void 0 === t3.nsecs && (f3 = 0), f3 >= 1e4)
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      jr = h3, Dr = f3, Nr = s3;
      var c3 = (1e4 * (268435455 & (h3 += 122192928e5)) + f3) % 4294967296;
      i3[n3++] = c3 >>> 24 & 255, i3[n3++] = c3 >>> 16 & 255, i3[n3++] = c3 >>> 8 & 255, i3[n3++] = 255 & c3;
      var d3 = h3 / 4294967296 * 1e4 & 268435455;
      i3[n3++] = d3 >>> 8 & 255, i3[n3++] = 255 & d3, i3[n3++] = d3 >>> 24 & 15 | 16, i3[n3++] = d3 >>> 16 & 255, i3[n3++] = s3 >>> 8 | 128, i3[n3++] = 255 & s3;
      for (var l3 = 0; l3 < 6; ++l3)
        i3[n3 + l3] = o3[l3];
      return e4 || qr(i3);
    }, v3: Jr, v4: function(t3, e4, r3) {
      var n3 = (t3 = t3 || {}).random || (t3.rng || Pr)();
      if (n3[6] = 15 & n3[6] | 64, n3[8] = 63 & n3[8] | 128, e4) {
        r3 = r3 || 0;
        for (var i3 = 0; i3 < 16; ++i3)
          e4[r3 + i3] = n3[i3];
        return e4;
      }
      return qr(n3);
    }, v5: tn, NIL: "00000000-0000-0000-0000-000000000000", version: function(t3) {
      if (!Ur(t3))
        throw TypeError("Invalid UUID");
      return parseInt(t3.substr(14, 1), 16);
    }, validate: Ur, stringify: qr, parse: Fr });
    en.v4, en.v4;
    var rn = "elliptic", nn = "6.5.4", on = "EC cryptography", sn = "lib/elliptic.js", an = ["lib"], hn = { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, fn = { type: "git", url: "git@github.com:indutny/elliptic" }, un = ["EC", "Elliptic", "curve", "Cryptography"], cn = "Fedor Indutny <fedor@indutny.com>", dn = { url: "https://github.com/indutny/elliptic/issues" }, ln = "https://github.com/indutny/elliptic", pn = { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, bn = { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" }, mn = { name: rn, version: nn, description: on, main: sn, files: an, scripts: hn, repository: fn, keywords: un, author: cn, license: "MIT", bugs: dn, homepage: ln, devDependencies: pn, dependencies: bn }, yn = Object.freeze({ __proto__: null, name: rn, version: nn, description: on, main: sn, files: an, scripts: hn, repository: fn, keywords: un, author: cn, license: "MIT", bugs: dn, homepage: ln, devDependencies: pn, dependencies: bn, default: mn }), gn = Qt(function(t3) {
      !function(t4, e4) {
        function r3(t5, e6) {
          if (!t5)
            throw new Error(e6 || "Assertion failed");
        }
        function n3(t5, e6) {
          t5.super_ = e6;
          var r4 = function() {
          };
          r4.prototype = e6.prototype, t5.prototype = new r4(), t5.prototype.constructor = t5;
        }
        function i3(t5, e6, r4) {
          if (i3.isBN(t5))
            return t5;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t5 && ("le" !== e6 && "be" !== e6 || (r4 = e6, e6 = 10), this._init(t5 || 0, e6 || 10, r4 || "be"));
        }
        var o3;
        "object" == typeof t4 ? t4.exports = i3 : e4.BN = i3, i3.BN = i3, i3.wordSize = 26;
        try {
          o3 = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : ee2.Buffer;
        } catch (t5) {
        }
        function s3(t5, e6) {
          var r4 = t5.charCodeAt(e6);
          return r4 >= 65 && r4 <= 70 ? r4 - 55 : r4 >= 97 && r4 <= 102 ? r4 - 87 : r4 - 48 & 15;
        }
        function a3(t5, e6, r4) {
          var n4 = s3(t5, r4);
          return r4 - 1 >= e6 && (n4 |= s3(t5, r4 - 1) << 4), n4;
        }
        function h3(t5, e6, r4, n4) {
          for (var i4 = 0, o4 = Math.min(t5.length, r4), s4 = e6; s4 < o4; s4++) {
            var a4 = t5.charCodeAt(s4) - 48;
            i4 *= n4, i4 += a4 >= 49 ? a4 - 49 + 10 : a4 >= 17 ? a4 - 17 + 10 : a4;
          }
          return i4;
        }
        i3.isBN = function(t5) {
          return t5 instanceof i3 || null !== t5 && "object" == typeof t5 && t5.constructor.wordSize === i3.wordSize && Array.isArray(t5.words);
        }, i3.max = function(t5, e6) {
          return t5.cmp(e6) > 0 ? t5 : e6;
        }, i3.min = function(t5, e6) {
          return t5.cmp(e6) < 0 ? t5 : e6;
        }, i3.prototype._init = function(t5, e6, n4) {
          if ("number" == typeof t5)
            return this._initNumber(t5, e6, n4);
          if ("object" == typeof t5)
            return this._initArray(t5, e6, n4);
          "hex" === e6 && (e6 = 16), r3(e6 === (0 | e6) && e6 >= 2 && e6 <= 36);
          var i4 = 0;
          "-" === (t5 = t5.toString().replace(/\s+/g, ""))[0] && (i4++, this.negative = 1), i4 < t5.length && (16 === e6 ? this._parseHex(t5, i4, n4) : (this._parseBase(t5, e6, i4), "le" === n4 && this._initArray(this.toArray(), e6, n4)));
        }, i3.prototype._initNumber = function(t5, e6, n4) {
          t5 < 0 && (this.negative = 1, t5 = -t5), t5 < 67108864 ? (this.words = [67108863 & t5], this.length = 1) : t5 < 4503599627370496 ? (this.words = [67108863 & t5, t5 / 67108864 & 67108863], this.length = 2) : (r3(t5 < 9007199254740992), this.words = [67108863 & t5, t5 / 67108864 & 67108863, 1], this.length = 3), "le" === n4 && this._initArray(this.toArray(), e6, n4);
        }, i3.prototype._initArray = function(t5, e6, n4) {
          if (r3("number" == typeof t5.length), t5.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(t5.length / 3), this.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++)
            this.words[i4] = 0;
          var o4, s4, a4 = 0;
          if ("be" === n4)
            for (i4 = t5.length - 1, o4 = 0; i4 >= 0; i4 -= 3)
              s4 = t5[i4] | t5[i4 - 1] << 8 | t5[i4 - 2] << 16, this.words[o4] |= s4 << a4 & 67108863, this.words[o4 + 1] = s4 >>> 26 - a4 & 67108863, (a4 += 24) >= 26 && (a4 -= 26, o4++);
          else if ("le" === n4)
            for (i4 = 0, o4 = 0; i4 < t5.length; i4 += 3)
              s4 = t5[i4] | t5[i4 + 1] << 8 | t5[i4 + 2] << 16, this.words[o4] |= s4 << a4 & 67108863, this.words[o4 + 1] = s4 >>> 26 - a4 & 67108863, (a4 += 24) >= 26 && (a4 -= 26, o4++);
          return this.strip();
        }, i3.prototype._parseHex = function(t5, e6, r4) {
          this.length = Math.ceil((t5.length - e6) / 6), this.words = new Array(this.length);
          for (var n4 = 0; n4 < this.length; n4++)
            this.words[n4] = 0;
          var i4, o4 = 0, s4 = 0;
          if ("be" === r4)
            for (n4 = t5.length - 1; n4 >= e6; n4 -= 2)
              i4 = a3(t5, e6, n4) << o4, this.words[s4] |= 67108863 & i4, o4 >= 18 ? (o4 -= 18, s4 += 1, this.words[s4] |= i4 >>> 26) : o4 += 8;
          else
            for (n4 = (t5.length - e6) % 2 == 0 ? e6 + 1 : e6; n4 < t5.length; n4 += 2)
              i4 = a3(t5, e6, n4) << o4, this.words[s4] |= 67108863 & i4, o4 >= 18 ? (o4 -= 18, s4 += 1, this.words[s4] |= i4 >>> 26) : o4 += 8;
          this.strip();
        }, i3.prototype._parseBase = function(t5, e6, r4) {
          this.words = [0], this.length = 1;
          for (var n4 = 0, i4 = 1; i4 <= 67108863; i4 *= e6)
            n4++;
          n4--, i4 = i4 / e6 | 0;
          for (var o4 = t5.length - r4, s4 = o4 % n4, a4 = Math.min(o4, o4 - s4) + r4, f4 = 0, u4 = r4; u4 < a4; u4 += n4)
            f4 = h3(t5, u4, u4 + n4, e6), this.imuln(i4), this.words[0] + f4 < 67108864 ? this.words[0] += f4 : this._iaddn(f4);
          if (0 !== s4) {
            var c4 = 1;
            for (f4 = h3(t5, u4, t5.length, e6), u4 = 0; u4 < s4; u4++)
              c4 *= e6;
            this.imuln(c4), this.words[0] + f4 < 67108864 ? this.words[0] += f4 : this._iaddn(f4);
          }
          this.strip();
        }, i3.prototype.copy = function(t5) {
          t5.words = new Array(this.length);
          for (var e6 = 0; e6 < this.length; e6++)
            t5.words[e6] = this.words[e6];
          t5.length = this.length, t5.negative = this.negative, t5.red = this.red;
        }, i3.prototype.clone = function() {
          var t5 = new i3(null);
          return this.copy(t5), t5;
        }, i3.prototype._expand = function(t5) {
          for (; this.length < t5; )
            this.words[this.length++] = 0;
          return this;
        }, i3.prototype.strip = function() {
          for (; this.length > 1 && 0 === this.words[this.length - 1]; )
            this.length--;
          return this._normSign();
        }, i3.prototype._normSign = function() {
          return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
        }, i3.prototype.inspect = function() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var f3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], u3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], c3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        function d3(t5, e6, r4) {
          r4.negative = e6.negative ^ t5.negative;
          var n4 = t5.length + e6.length | 0;
          r4.length = n4, n4 = n4 - 1 | 0;
          var i4 = 0 | t5.words[0], o4 = 0 | e6.words[0], s4 = i4 * o4, a4 = 67108863 & s4, h4 = s4 / 67108864 | 0;
          r4.words[0] = a4;
          for (var f4 = 1; f4 < n4; f4++) {
            for (var u4 = h4 >>> 26, c4 = 67108863 & h4, d4 = Math.min(f4, e6.length - 1), l4 = Math.max(0, f4 - t5.length + 1); l4 <= d4; l4++) {
              var p4 = f4 - l4 | 0;
              u4 += (s4 = (i4 = 0 | t5.words[p4]) * (o4 = 0 | e6.words[l4]) + c4) / 67108864 | 0, c4 = 67108863 & s4;
            }
            r4.words[f4] = 0 | c4, h4 = 0 | u4;
          }
          return 0 !== h4 ? r4.words[f4] = 0 | h4 : r4.length--, r4.strip();
        }
        i3.prototype.toString = function(t5, e6) {
          var n4;
          if (e6 = 0 | e6 || 1, 16 === (t5 = t5 || 10) || "hex" === t5) {
            n4 = "";
            for (var i4 = 0, o4 = 0, s4 = 0; s4 < this.length; s4++) {
              var a4 = this.words[s4], h4 = (16777215 & (a4 << i4 | o4)).toString(16);
              n4 = 0 !== (o4 = a4 >>> 24 - i4 & 16777215) || s4 !== this.length - 1 ? f3[6 - h4.length] + h4 + n4 : h4 + n4, (i4 += 2) >= 26 && (i4 -= 26, s4--);
            }
            for (0 !== o4 && (n4 = o4.toString(16) + n4); n4.length % e6 != 0; )
              n4 = "0" + n4;
            return 0 !== this.negative && (n4 = "-" + n4), n4;
          }
          if (t5 === (0 | t5) && t5 >= 2 && t5 <= 36) {
            var d4 = u3[t5], l4 = c3[t5];
            n4 = "";
            var p4 = this.clone();
            for (p4.negative = 0; !p4.isZero(); ) {
              var b4 = p4.modn(l4).toString(t5);
              n4 = (p4 = p4.idivn(l4)).isZero() ? b4 + n4 : f3[d4 - b4.length] + b4 + n4;
            }
            for (this.isZero() && (n4 = "0" + n4); n4.length % e6 != 0; )
              n4 = "0" + n4;
            return 0 !== this.negative && (n4 = "-" + n4), n4;
          }
          r3(false, "Base should be between 2 and 36");
        }, i3.prototype.toNumber = function() {
          var t5 = this.words[0];
          return 2 === this.length ? t5 += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t5 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r3(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t5 : t5;
        }, i3.prototype.toJSON = function() {
          return this.toString(16);
        }, i3.prototype.toBuffer = function(t5, e6) {
          return r3(void 0 !== o3), this.toArrayLike(o3, t5, e6);
        }, i3.prototype.toArray = function(t5, e6) {
          return this.toArrayLike(Array, t5, e6);
        }, i3.prototype.toArrayLike = function(t5, e6, n4) {
          var i4 = this.byteLength(), o4 = n4 || Math.max(1, i4);
          r3(i4 <= o4, "byte array longer than desired length"), r3(o4 > 0, "Requested array length <= 0"), this.strip();
          var s4, a4, h4 = "le" === e6, f4 = new t5(o4), u4 = this.clone();
          if (h4) {
            for (a4 = 0; !u4.isZero(); a4++)
              s4 = u4.andln(255), u4.iushrn(8), f4[a4] = s4;
            for (; a4 < o4; a4++)
              f4[a4] = 0;
          } else {
            for (a4 = 0; a4 < o4 - i4; a4++)
              f4[a4] = 0;
            for (a4 = 0; !u4.isZero(); a4++)
              s4 = u4.andln(255), u4.iushrn(8), f4[o4 - a4 - 1] = s4;
          }
          return f4;
        }, Math.clz32 ? i3.prototype._countBits = function(t5) {
          return 32 - Math.clz32(t5);
        } : i3.prototype._countBits = function(t5) {
          var e6 = t5, r4 = 0;
          return e6 >= 4096 && (r4 += 13, e6 >>>= 13), e6 >= 64 && (r4 += 7, e6 >>>= 7), e6 >= 8 && (r4 += 4, e6 >>>= 4), e6 >= 2 && (r4 += 2, e6 >>>= 2), r4 + e6;
        }, i3.prototype._zeroBits = function(t5) {
          if (0 === t5)
            return 26;
          var e6 = t5, r4 = 0;
          return 0 == (8191 & e6) && (r4 += 13, e6 >>>= 13), 0 == (127 & e6) && (r4 += 7, e6 >>>= 7), 0 == (15 & e6) && (r4 += 4, e6 >>>= 4), 0 == (3 & e6) && (r4 += 2, e6 >>>= 2), 0 == (1 & e6) && r4++, r4;
        }, i3.prototype.bitLength = function() {
          var t5 = this.words[this.length - 1], e6 = this._countBits(t5);
          return 26 * (this.length - 1) + e6;
        }, i3.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var t5 = 0, e6 = 0; e6 < this.length; e6++) {
            var r4 = this._zeroBits(this.words[e6]);
            if (t5 += r4, 26 !== r4)
              break;
          }
          return t5;
        }, i3.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, i3.prototype.toTwos = function(t5) {
          return 0 !== this.negative ? this.abs().inotn(t5).iaddn(1) : this.clone();
        }, i3.prototype.fromTwos = function(t5) {
          return this.testn(t5 - 1) ? this.notn(t5).iaddn(1).ineg() : this.clone();
        }, i3.prototype.isNeg = function() {
          return 0 !== this.negative;
        }, i3.prototype.neg = function() {
          return this.clone().ineg();
        }, i3.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, i3.prototype.iuor = function(t5) {
          for (; this.length < t5.length; )
            this.words[this.length++] = 0;
          for (var e6 = 0; e6 < t5.length; e6++)
            this.words[e6] = this.words[e6] | t5.words[e6];
          return this.strip();
        }, i3.prototype.ior = function(t5) {
          return r3(0 == (this.negative | t5.negative)), this.iuor(t5);
        }, i3.prototype.or = function(t5) {
          return this.length > t5.length ? this.clone().ior(t5) : t5.clone().ior(this);
        }, i3.prototype.uor = function(t5) {
          return this.length > t5.length ? this.clone().iuor(t5) : t5.clone().iuor(this);
        }, i3.prototype.iuand = function(t5) {
          var e6;
          e6 = this.length > t5.length ? t5 : this;
          for (var r4 = 0; r4 < e6.length; r4++)
            this.words[r4] = this.words[r4] & t5.words[r4];
          return this.length = e6.length, this.strip();
        }, i3.prototype.iand = function(t5) {
          return r3(0 == (this.negative | t5.negative)), this.iuand(t5);
        }, i3.prototype.and = function(t5) {
          return this.length > t5.length ? this.clone().iand(t5) : t5.clone().iand(this);
        }, i3.prototype.uand = function(t5) {
          return this.length > t5.length ? this.clone().iuand(t5) : t5.clone().iuand(this);
        }, i3.prototype.iuxor = function(t5) {
          var e6, r4;
          this.length > t5.length ? (e6 = this, r4 = t5) : (e6 = t5, r4 = this);
          for (var n4 = 0; n4 < r4.length; n4++)
            this.words[n4] = e6.words[n4] ^ r4.words[n4];
          if (this !== e6)
            for (; n4 < e6.length; n4++)
              this.words[n4] = e6.words[n4];
          return this.length = e6.length, this.strip();
        }, i3.prototype.ixor = function(t5) {
          return r3(0 == (this.negative | t5.negative)), this.iuxor(t5);
        }, i3.prototype.xor = function(t5) {
          return this.length > t5.length ? this.clone().ixor(t5) : t5.clone().ixor(this);
        }, i3.prototype.uxor = function(t5) {
          return this.length > t5.length ? this.clone().iuxor(t5) : t5.clone().iuxor(this);
        }, i3.prototype.inotn = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6 = 0 | Math.ceil(t5 / 26), n4 = t5 % 26;
          this._expand(e6), n4 > 0 && e6--;
          for (var i4 = 0; i4 < e6; i4++)
            this.words[i4] = 67108863 & ~this.words[i4];
          return n4 > 0 && (this.words[i4] = ~this.words[i4] & 67108863 >> 26 - n4), this.strip();
        }, i3.prototype.notn = function(t5) {
          return this.clone().inotn(t5);
        }, i3.prototype.setn = function(t5, e6) {
          r3("number" == typeof t5 && t5 >= 0);
          var n4 = t5 / 26 | 0, i4 = t5 % 26;
          return this._expand(n4 + 1), this.words[n4] = e6 ? this.words[n4] | 1 << i4 : this.words[n4] & ~(1 << i4), this.strip();
        }, i3.prototype.iadd = function(t5) {
          var e6, r4, n4;
          if (0 !== this.negative && 0 === t5.negative)
            return this.negative = 0, e6 = this.isub(t5), this.negative ^= 1, this._normSign();
          if (0 === this.negative && 0 !== t5.negative)
            return t5.negative = 0, e6 = this.isub(t5), t5.negative = 1, e6._normSign();
          this.length > t5.length ? (r4 = this, n4 = t5) : (r4 = t5, n4 = this);
          for (var i4 = 0, o4 = 0; o4 < n4.length; o4++)
            e6 = (0 | r4.words[o4]) + (0 | n4.words[o4]) + i4, this.words[o4] = 67108863 & e6, i4 = e6 >>> 26;
          for (; 0 !== i4 && o4 < r4.length; o4++)
            e6 = (0 | r4.words[o4]) + i4, this.words[o4] = 67108863 & e6, i4 = e6 >>> 26;
          if (this.length = r4.length, 0 !== i4)
            this.words[this.length] = i4, this.length++;
          else if (r4 !== this)
            for (; o4 < r4.length; o4++)
              this.words[o4] = r4.words[o4];
          return this;
        }, i3.prototype.add = function(t5) {
          var e6;
          return 0 !== t5.negative && 0 === this.negative ? (t5.negative = 0, e6 = this.sub(t5), t5.negative ^= 1, e6) : 0 === t5.negative && 0 !== this.negative ? (this.negative = 0, e6 = t5.sub(this), this.negative = 1, e6) : this.length > t5.length ? this.clone().iadd(t5) : t5.clone().iadd(this);
        }, i3.prototype.isub = function(t5) {
          if (0 !== t5.negative) {
            t5.negative = 0;
            var e6 = this.iadd(t5);
            return t5.negative = 1, e6._normSign();
          }
          if (0 !== this.negative)
            return this.negative = 0, this.iadd(t5), this.negative = 1, this._normSign();
          var r4, n4, i4 = this.cmp(t5);
          if (0 === i4)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          i4 > 0 ? (r4 = this, n4 = t5) : (r4 = t5, n4 = this);
          for (var o4 = 0, s4 = 0; s4 < n4.length; s4++)
            o4 = (e6 = (0 | r4.words[s4]) - (0 | n4.words[s4]) + o4) >> 26, this.words[s4] = 67108863 & e6;
          for (; 0 !== o4 && s4 < r4.length; s4++)
            o4 = (e6 = (0 | r4.words[s4]) + o4) >> 26, this.words[s4] = 67108863 & e6;
          if (0 === o4 && s4 < r4.length && r4 !== this)
            for (; s4 < r4.length; s4++)
              this.words[s4] = r4.words[s4];
          return this.length = Math.max(this.length, s4), r4 !== this && (this.negative = 1), this.strip();
        }, i3.prototype.sub = function(t5) {
          return this.clone().isub(t5);
        };
        var l3 = function(t5, e6, r4) {
          var n4, i4, o4, s4 = t5.words, a4 = e6.words, h4 = r4.words, f4 = 0, u4 = 0 | s4[0], c4 = 8191 & u4, d4 = u4 >>> 13, l4 = 0 | s4[1], p4 = 8191 & l4, b4 = l4 >>> 13, m4 = 0 | s4[2], y4 = 8191 & m4, g3 = m4 >>> 13, v4 = 0 | s4[3], w4 = 8191 & v4, M4 = v4 >>> 13, _4 = 0 | s4[4], A4 = 8191 & _4, S3 = _4 >>> 13, E3 = 0 | s4[5], x3 = 8191 & E3, I3 = E3 >>> 13, k3 = 0 | s4[6], R3 = 8191 & k3, T3 = k3 >>> 13, B3 = 0 | s4[7], P3 = 8191 & B3, O3 = B3 >>> 13, U3 = 0 | s4[8], L3 = 8191 & U3, N3 = U3 >>> 13, z3 = 0 | s4[9], C3 = 8191 & z3, q3 = z3 >>> 13, j3 = 0 | a4[0], D3 = 8191 & j3, F3 = j3 >>> 13, K3 = 0 | a4[1], Y3 = 8191 & K3, V3 = K3 >>> 13, W3 = 0 | a4[2], H3 = 8191 & W3, $3 = W3 >>> 13, G3 = 0 | a4[3], Z3 = 8191 & G3, J3 = G3 >>> 13, X3 = 0 | a4[4], Q3 = 8191 & X3, tt2 = X3 >>> 13, et2 = 0 | a4[5], rt2 = 8191 & et2, nt2 = et2 >>> 13, it2 = 0 | a4[6], ot2 = 8191 & it2, st2 = it2 >>> 13, at2 = 0 | a4[7], ht2 = 8191 & at2, ft2 = at2 >>> 13, ut2 = 0 | a4[8], ct2 = 8191 & ut2, dt2 = ut2 >>> 13, lt2 = 0 | a4[9], pt3 = 8191 & lt2, bt2 = lt2 >>> 13;
          r4.negative = t5.negative ^ e6.negative, r4.length = 19;
          var mt3 = (f4 + (n4 = Math.imul(c4, D3)) | 0) + ((8191 & (i4 = (i4 = Math.imul(c4, F3)) + Math.imul(d4, D3) | 0)) << 13) | 0;
          f4 = ((o4 = Math.imul(d4, F3)) + (i4 >>> 13) | 0) + (mt3 >>> 26) | 0, mt3 &= 67108863, n4 = Math.imul(p4, D3), i4 = (i4 = Math.imul(p4, F3)) + Math.imul(b4, D3) | 0, o4 = Math.imul(b4, F3);
          var yt2 = (f4 + (n4 = n4 + Math.imul(c4, Y3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, V3) | 0) + Math.imul(d4, Y3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, V3) | 0) + (i4 >>> 13) | 0) + (yt2 >>> 26) | 0, yt2 &= 67108863, n4 = Math.imul(y4, D3), i4 = (i4 = Math.imul(y4, F3)) + Math.imul(g3, D3) | 0, o4 = Math.imul(g3, F3), n4 = n4 + Math.imul(p4, Y3) | 0, i4 = (i4 = i4 + Math.imul(p4, V3) | 0) + Math.imul(b4, Y3) | 0, o4 = o4 + Math.imul(b4, V3) | 0;
          var gt3 = (f4 + (n4 = n4 + Math.imul(c4, H3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, $3) | 0) + Math.imul(d4, H3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, $3) | 0) + (i4 >>> 13) | 0) + (gt3 >>> 26) | 0, gt3 &= 67108863, n4 = Math.imul(w4, D3), i4 = (i4 = Math.imul(w4, F3)) + Math.imul(M4, D3) | 0, o4 = Math.imul(M4, F3), n4 = n4 + Math.imul(y4, Y3) | 0, i4 = (i4 = i4 + Math.imul(y4, V3) | 0) + Math.imul(g3, Y3) | 0, o4 = o4 + Math.imul(g3, V3) | 0, n4 = n4 + Math.imul(p4, H3) | 0, i4 = (i4 = i4 + Math.imul(p4, $3) | 0) + Math.imul(b4, H3) | 0, o4 = o4 + Math.imul(b4, $3) | 0;
          var vt2 = (f4 + (n4 = n4 + Math.imul(c4, Z3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, J3) | 0) + Math.imul(d4, Z3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, J3) | 0) + (i4 >>> 13) | 0) + (vt2 >>> 26) | 0, vt2 &= 67108863, n4 = Math.imul(A4, D3), i4 = (i4 = Math.imul(A4, F3)) + Math.imul(S3, D3) | 0, o4 = Math.imul(S3, F3), n4 = n4 + Math.imul(w4, Y3) | 0, i4 = (i4 = i4 + Math.imul(w4, V3) | 0) + Math.imul(M4, Y3) | 0, o4 = o4 + Math.imul(M4, V3) | 0, n4 = n4 + Math.imul(y4, H3) | 0, i4 = (i4 = i4 + Math.imul(y4, $3) | 0) + Math.imul(g3, H3) | 0, o4 = o4 + Math.imul(g3, $3) | 0, n4 = n4 + Math.imul(p4, Z3) | 0, i4 = (i4 = i4 + Math.imul(p4, J3) | 0) + Math.imul(b4, Z3) | 0, o4 = o4 + Math.imul(b4, J3) | 0;
          var wt2 = (f4 + (n4 = n4 + Math.imul(c4, Q3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, tt2) | 0) + Math.imul(d4, Q3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, tt2) | 0) + (i4 >>> 13) | 0) + (wt2 >>> 26) | 0, wt2 &= 67108863, n4 = Math.imul(x3, D3), i4 = (i4 = Math.imul(x3, F3)) + Math.imul(I3, D3) | 0, o4 = Math.imul(I3, F3), n4 = n4 + Math.imul(A4, Y3) | 0, i4 = (i4 = i4 + Math.imul(A4, V3) | 0) + Math.imul(S3, Y3) | 0, o4 = o4 + Math.imul(S3, V3) | 0, n4 = n4 + Math.imul(w4, H3) | 0, i4 = (i4 = i4 + Math.imul(w4, $3) | 0) + Math.imul(M4, H3) | 0, o4 = o4 + Math.imul(M4, $3) | 0, n4 = n4 + Math.imul(y4, Z3) | 0, i4 = (i4 = i4 + Math.imul(y4, J3) | 0) + Math.imul(g3, Z3) | 0, o4 = o4 + Math.imul(g3, J3) | 0, n4 = n4 + Math.imul(p4, Q3) | 0, i4 = (i4 = i4 + Math.imul(p4, tt2) | 0) + Math.imul(b4, Q3) | 0, o4 = o4 + Math.imul(b4, tt2) | 0;
          var Mt2 = (f4 + (n4 = n4 + Math.imul(c4, rt2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, nt2) | 0) + Math.imul(d4, rt2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, nt2) | 0) + (i4 >>> 13) | 0) + (Mt2 >>> 26) | 0, Mt2 &= 67108863, n4 = Math.imul(R3, D3), i4 = (i4 = Math.imul(R3, F3)) + Math.imul(T3, D3) | 0, o4 = Math.imul(T3, F3), n4 = n4 + Math.imul(x3, Y3) | 0, i4 = (i4 = i4 + Math.imul(x3, V3) | 0) + Math.imul(I3, Y3) | 0, o4 = o4 + Math.imul(I3, V3) | 0, n4 = n4 + Math.imul(A4, H3) | 0, i4 = (i4 = i4 + Math.imul(A4, $3) | 0) + Math.imul(S3, H3) | 0, o4 = o4 + Math.imul(S3, $3) | 0, n4 = n4 + Math.imul(w4, Z3) | 0, i4 = (i4 = i4 + Math.imul(w4, J3) | 0) + Math.imul(M4, Z3) | 0, o4 = o4 + Math.imul(M4, J3) | 0, n4 = n4 + Math.imul(y4, Q3) | 0, i4 = (i4 = i4 + Math.imul(y4, tt2) | 0) + Math.imul(g3, Q3) | 0, o4 = o4 + Math.imul(g3, tt2) | 0, n4 = n4 + Math.imul(p4, rt2) | 0, i4 = (i4 = i4 + Math.imul(p4, nt2) | 0) + Math.imul(b4, rt2) | 0, o4 = o4 + Math.imul(b4, nt2) | 0;
          var _t2 = (f4 + (n4 = n4 + Math.imul(c4, ot2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, st2) | 0) + Math.imul(d4, ot2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, st2) | 0) + (i4 >>> 13) | 0) + (_t2 >>> 26) | 0, _t2 &= 67108863, n4 = Math.imul(P3, D3), i4 = (i4 = Math.imul(P3, F3)) + Math.imul(O3, D3) | 0, o4 = Math.imul(O3, F3), n4 = n4 + Math.imul(R3, Y3) | 0, i4 = (i4 = i4 + Math.imul(R3, V3) | 0) + Math.imul(T3, Y3) | 0, o4 = o4 + Math.imul(T3, V3) | 0, n4 = n4 + Math.imul(x3, H3) | 0, i4 = (i4 = i4 + Math.imul(x3, $3) | 0) + Math.imul(I3, H3) | 0, o4 = o4 + Math.imul(I3, $3) | 0, n4 = n4 + Math.imul(A4, Z3) | 0, i4 = (i4 = i4 + Math.imul(A4, J3) | 0) + Math.imul(S3, Z3) | 0, o4 = o4 + Math.imul(S3, J3) | 0, n4 = n4 + Math.imul(w4, Q3) | 0, i4 = (i4 = i4 + Math.imul(w4, tt2) | 0) + Math.imul(M4, Q3) | 0, o4 = o4 + Math.imul(M4, tt2) | 0, n4 = n4 + Math.imul(y4, rt2) | 0, i4 = (i4 = i4 + Math.imul(y4, nt2) | 0) + Math.imul(g3, rt2) | 0, o4 = o4 + Math.imul(g3, nt2) | 0, n4 = n4 + Math.imul(p4, ot2) | 0, i4 = (i4 = i4 + Math.imul(p4, st2) | 0) + Math.imul(b4, ot2) | 0, o4 = o4 + Math.imul(b4, st2) | 0;
          var At2 = (f4 + (n4 = n4 + Math.imul(c4, ht2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, ft2) | 0) + Math.imul(d4, ht2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, ft2) | 0) + (i4 >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, n4 = Math.imul(L3, D3), i4 = (i4 = Math.imul(L3, F3)) + Math.imul(N3, D3) | 0, o4 = Math.imul(N3, F3), n4 = n4 + Math.imul(P3, Y3) | 0, i4 = (i4 = i4 + Math.imul(P3, V3) | 0) + Math.imul(O3, Y3) | 0, o4 = o4 + Math.imul(O3, V3) | 0, n4 = n4 + Math.imul(R3, H3) | 0, i4 = (i4 = i4 + Math.imul(R3, $3) | 0) + Math.imul(T3, H3) | 0, o4 = o4 + Math.imul(T3, $3) | 0, n4 = n4 + Math.imul(x3, Z3) | 0, i4 = (i4 = i4 + Math.imul(x3, J3) | 0) + Math.imul(I3, Z3) | 0, o4 = o4 + Math.imul(I3, J3) | 0, n4 = n4 + Math.imul(A4, Q3) | 0, i4 = (i4 = i4 + Math.imul(A4, tt2) | 0) + Math.imul(S3, Q3) | 0, o4 = o4 + Math.imul(S3, tt2) | 0, n4 = n4 + Math.imul(w4, rt2) | 0, i4 = (i4 = i4 + Math.imul(w4, nt2) | 0) + Math.imul(M4, rt2) | 0, o4 = o4 + Math.imul(M4, nt2) | 0, n4 = n4 + Math.imul(y4, ot2) | 0, i4 = (i4 = i4 + Math.imul(y4, st2) | 0) + Math.imul(g3, ot2) | 0, o4 = o4 + Math.imul(g3, st2) | 0, n4 = n4 + Math.imul(p4, ht2) | 0, i4 = (i4 = i4 + Math.imul(p4, ft2) | 0) + Math.imul(b4, ht2) | 0, o4 = o4 + Math.imul(b4, ft2) | 0;
          var St2 = (f4 + (n4 = n4 + Math.imul(c4, ct2) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, dt2) | 0) + Math.imul(d4, ct2) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, dt2) | 0) + (i4 >>> 13) | 0) + (St2 >>> 26) | 0, St2 &= 67108863, n4 = Math.imul(C3, D3), i4 = (i4 = Math.imul(C3, F3)) + Math.imul(q3, D3) | 0, o4 = Math.imul(q3, F3), n4 = n4 + Math.imul(L3, Y3) | 0, i4 = (i4 = i4 + Math.imul(L3, V3) | 0) + Math.imul(N3, Y3) | 0, o4 = o4 + Math.imul(N3, V3) | 0, n4 = n4 + Math.imul(P3, H3) | 0, i4 = (i4 = i4 + Math.imul(P3, $3) | 0) + Math.imul(O3, H3) | 0, o4 = o4 + Math.imul(O3, $3) | 0, n4 = n4 + Math.imul(R3, Z3) | 0, i4 = (i4 = i4 + Math.imul(R3, J3) | 0) + Math.imul(T3, Z3) | 0, o4 = o4 + Math.imul(T3, J3) | 0, n4 = n4 + Math.imul(x3, Q3) | 0, i4 = (i4 = i4 + Math.imul(x3, tt2) | 0) + Math.imul(I3, Q3) | 0, o4 = o4 + Math.imul(I3, tt2) | 0, n4 = n4 + Math.imul(A4, rt2) | 0, i4 = (i4 = i4 + Math.imul(A4, nt2) | 0) + Math.imul(S3, rt2) | 0, o4 = o4 + Math.imul(S3, nt2) | 0, n4 = n4 + Math.imul(w4, ot2) | 0, i4 = (i4 = i4 + Math.imul(w4, st2) | 0) + Math.imul(M4, ot2) | 0, o4 = o4 + Math.imul(M4, st2) | 0, n4 = n4 + Math.imul(y4, ht2) | 0, i4 = (i4 = i4 + Math.imul(y4, ft2) | 0) + Math.imul(g3, ht2) | 0, o4 = o4 + Math.imul(g3, ft2) | 0, n4 = n4 + Math.imul(p4, ct2) | 0, i4 = (i4 = i4 + Math.imul(p4, dt2) | 0) + Math.imul(b4, ct2) | 0, o4 = o4 + Math.imul(b4, dt2) | 0;
          var Et2 = (f4 + (n4 = n4 + Math.imul(c4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(c4, bt2) | 0) + Math.imul(d4, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(d4, bt2) | 0) + (i4 >>> 13) | 0) + (Et2 >>> 26) | 0, Et2 &= 67108863, n4 = Math.imul(C3, Y3), i4 = (i4 = Math.imul(C3, V3)) + Math.imul(q3, Y3) | 0, o4 = Math.imul(q3, V3), n4 = n4 + Math.imul(L3, H3) | 0, i4 = (i4 = i4 + Math.imul(L3, $3) | 0) + Math.imul(N3, H3) | 0, o4 = o4 + Math.imul(N3, $3) | 0, n4 = n4 + Math.imul(P3, Z3) | 0, i4 = (i4 = i4 + Math.imul(P3, J3) | 0) + Math.imul(O3, Z3) | 0, o4 = o4 + Math.imul(O3, J3) | 0, n4 = n4 + Math.imul(R3, Q3) | 0, i4 = (i4 = i4 + Math.imul(R3, tt2) | 0) + Math.imul(T3, Q3) | 0, o4 = o4 + Math.imul(T3, tt2) | 0, n4 = n4 + Math.imul(x3, rt2) | 0, i4 = (i4 = i4 + Math.imul(x3, nt2) | 0) + Math.imul(I3, rt2) | 0, o4 = o4 + Math.imul(I3, nt2) | 0, n4 = n4 + Math.imul(A4, ot2) | 0, i4 = (i4 = i4 + Math.imul(A4, st2) | 0) + Math.imul(S3, ot2) | 0, o4 = o4 + Math.imul(S3, st2) | 0, n4 = n4 + Math.imul(w4, ht2) | 0, i4 = (i4 = i4 + Math.imul(w4, ft2) | 0) + Math.imul(M4, ht2) | 0, o4 = o4 + Math.imul(M4, ft2) | 0, n4 = n4 + Math.imul(y4, ct2) | 0, i4 = (i4 = i4 + Math.imul(y4, dt2) | 0) + Math.imul(g3, ct2) | 0, o4 = o4 + Math.imul(g3, dt2) | 0;
          var xt2 = (f4 + (n4 = n4 + Math.imul(p4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(p4, bt2) | 0) + Math.imul(b4, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(b4, bt2) | 0) + (i4 >>> 13) | 0) + (xt2 >>> 26) | 0, xt2 &= 67108863, n4 = Math.imul(C3, H3), i4 = (i4 = Math.imul(C3, $3)) + Math.imul(q3, H3) | 0, o4 = Math.imul(q3, $3), n4 = n4 + Math.imul(L3, Z3) | 0, i4 = (i4 = i4 + Math.imul(L3, J3) | 0) + Math.imul(N3, Z3) | 0, o4 = o4 + Math.imul(N3, J3) | 0, n4 = n4 + Math.imul(P3, Q3) | 0, i4 = (i4 = i4 + Math.imul(P3, tt2) | 0) + Math.imul(O3, Q3) | 0, o4 = o4 + Math.imul(O3, tt2) | 0, n4 = n4 + Math.imul(R3, rt2) | 0, i4 = (i4 = i4 + Math.imul(R3, nt2) | 0) + Math.imul(T3, rt2) | 0, o4 = o4 + Math.imul(T3, nt2) | 0, n4 = n4 + Math.imul(x3, ot2) | 0, i4 = (i4 = i4 + Math.imul(x3, st2) | 0) + Math.imul(I3, ot2) | 0, o4 = o4 + Math.imul(I3, st2) | 0, n4 = n4 + Math.imul(A4, ht2) | 0, i4 = (i4 = i4 + Math.imul(A4, ft2) | 0) + Math.imul(S3, ht2) | 0, o4 = o4 + Math.imul(S3, ft2) | 0, n4 = n4 + Math.imul(w4, ct2) | 0, i4 = (i4 = i4 + Math.imul(w4, dt2) | 0) + Math.imul(M4, ct2) | 0, o4 = o4 + Math.imul(M4, dt2) | 0;
          var It2 = (f4 + (n4 = n4 + Math.imul(y4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(y4, bt2) | 0) + Math.imul(g3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(g3, bt2) | 0) + (i4 >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, n4 = Math.imul(C3, Z3), i4 = (i4 = Math.imul(C3, J3)) + Math.imul(q3, Z3) | 0, o4 = Math.imul(q3, J3), n4 = n4 + Math.imul(L3, Q3) | 0, i4 = (i4 = i4 + Math.imul(L3, tt2) | 0) + Math.imul(N3, Q3) | 0, o4 = o4 + Math.imul(N3, tt2) | 0, n4 = n4 + Math.imul(P3, rt2) | 0, i4 = (i4 = i4 + Math.imul(P3, nt2) | 0) + Math.imul(O3, rt2) | 0, o4 = o4 + Math.imul(O3, nt2) | 0, n4 = n4 + Math.imul(R3, ot2) | 0, i4 = (i4 = i4 + Math.imul(R3, st2) | 0) + Math.imul(T3, ot2) | 0, o4 = o4 + Math.imul(T3, st2) | 0, n4 = n4 + Math.imul(x3, ht2) | 0, i4 = (i4 = i4 + Math.imul(x3, ft2) | 0) + Math.imul(I3, ht2) | 0, o4 = o4 + Math.imul(I3, ft2) | 0, n4 = n4 + Math.imul(A4, ct2) | 0, i4 = (i4 = i4 + Math.imul(A4, dt2) | 0) + Math.imul(S3, ct2) | 0, o4 = o4 + Math.imul(S3, dt2) | 0;
          var kt2 = (f4 + (n4 = n4 + Math.imul(w4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(w4, bt2) | 0) + Math.imul(M4, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(M4, bt2) | 0) + (i4 >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, n4 = Math.imul(C3, Q3), i4 = (i4 = Math.imul(C3, tt2)) + Math.imul(q3, Q3) | 0, o4 = Math.imul(q3, tt2), n4 = n4 + Math.imul(L3, rt2) | 0, i4 = (i4 = i4 + Math.imul(L3, nt2) | 0) + Math.imul(N3, rt2) | 0, o4 = o4 + Math.imul(N3, nt2) | 0, n4 = n4 + Math.imul(P3, ot2) | 0, i4 = (i4 = i4 + Math.imul(P3, st2) | 0) + Math.imul(O3, ot2) | 0, o4 = o4 + Math.imul(O3, st2) | 0, n4 = n4 + Math.imul(R3, ht2) | 0, i4 = (i4 = i4 + Math.imul(R3, ft2) | 0) + Math.imul(T3, ht2) | 0, o4 = o4 + Math.imul(T3, ft2) | 0, n4 = n4 + Math.imul(x3, ct2) | 0, i4 = (i4 = i4 + Math.imul(x3, dt2) | 0) + Math.imul(I3, ct2) | 0, o4 = o4 + Math.imul(I3, dt2) | 0;
          var Rt2 = (f4 + (n4 = n4 + Math.imul(A4, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(A4, bt2) | 0) + Math.imul(S3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(S3, bt2) | 0) + (i4 >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, n4 = Math.imul(C3, rt2), i4 = (i4 = Math.imul(C3, nt2)) + Math.imul(q3, rt2) | 0, o4 = Math.imul(q3, nt2), n4 = n4 + Math.imul(L3, ot2) | 0, i4 = (i4 = i4 + Math.imul(L3, st2) | 0) + Math.imul(N3, ot2) | 0, o4 = o4 + Math.imul(N3, st2) | 0, n4 = n4 + Math.imul(P3, ht2) | 0, i4 = (i4 = i4 + Math.imul(P3, ft2) | 0) + Math.imul(O3, ht2) | 0, o4 = o4 + Math.imul(O3, ft2) | 0, n4 = n4 + Math.imul(R3, ct2) | 0, i4 = (i4 = i4 + Math.imul(R3, dt2) | 0) + Math.imul(T3, ct2) | 0, o4 = o4 + Math.imul(T3, dt2) | 0;
          var Tt2 = (f4 + (n4 = n4 + Math.imul(x3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(x3, bt2) | 0) + Math.imul(I3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(I3, bt2) | 0) + (i4 >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, n4 = Math.imul(C3, ot2), i4 = (i4 = Math.imul(C3, st2)) + Math.imul(q3, ot2) | 0, o4 = Math.imul(q3, st2), n4 = n4 + Math.imul(L3, ht2) | 0, i4 = (i4 = i4 + Math.imul(L3, ft2) | 0) + Math.imul(N3, ht2) | 0, o4 = o4 + Math.imul(N3, ft2) | 0, n4 = n4 + Math.imul(P3, ct2) | 0, i4 = (i4 = i4 + Math.imul(P3, dt2) | 0) + Math.imul(O3, ct2) | 0, o4 = o4 + Math.imul(O3, dt2) | 0;
          var Bt2 = (f4 + (n4 = n4 + Math.imul(R3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(R3, bt2) | 0) + Math.imul(T3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(T3, bt2) | 0) + (i4 >>> 13) | 0) + (Bt2 >>> 26) | 0, Bt2 &= 67108863, n4 = Math.imul(C3, ht2), i4 = (i4 = Math.imul(C3, ft2)) + Math.imul(q3, ht2) | 0, o4 = Math.imul(q3, ft2), n4 = n4 + Math.imul(L3, ct2) | 0, i4 = (i4 = i4 + Math.imul(L3, dt2) | 0) + Math.imul(N3, ct2) | 0, o4 = o4 + Math.imul(N3, dt2) | 0;
          var Pt2 = (f4 + (n4 = n4 + Math.imul(P3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(P3, bt2) | 0) + Math.imul(O3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(O3, bt2) | 0) + (i4 >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, n4 = Math.imul(C3, ct2), i4 = (i4 = Math.imul(C3, dt2)) + Math.imul(q3, ct2) | 0, o4 = Math.imul(q3, dt2);
          var Ot2 = (f4 + (n4 = n4 + Math.imul(L3, pt3) | 0) | 0) + ((8191 & (i4 = (i4 = i4 + Math.imul(L3, bt2) | 0) + Math.imul(N3, pt3) | 0)) << 13) | 0;
          f4 = ((o4 = o4 + Math.imul(N3, bt2) | 0) + (i4 >>> 13) | 0) + (Ot2 >>> 26) | 0, Ot2 &= 67108863;
          var Ut2 = (f4 + (n4 = Math.imul(C3, pt3)) | 0) + ((8191 & (i4 = (i4 = Math.imul(C3, bt2)) + Math.imul(q3, pt3) | 0)) << 13) | 0;
          return f4 = ((o4 = Math.imul(q3, bt2)) + (i4 >>> 13) | 0) + (Ut2 >>> 26) | 0, Ut2 &= 67108863, h4[0] = mt3, h4[1] = yt2, h4[2] = gt3, h4[3] = vt2, h4[4] = wt2, h4[5] = Mt2, h4[6] = _t2, h4[7] = At2, h4[8] = St2, h4[9] = Et2, h4[10] = xt2, h4[11] = It2, h4[12] = kt2, h4[13] = Rt2, h4[14] = Tt2, h4[15] = Bt2, h4[16] = Pt2, h4[17] = Ot2, h4[18] = Ut2, 0 !== f4 && (h4[19] = f4, r4.length++), r4;
        };
        function p3(t5, e6, r4) {
          return new b3().mulp(t5, e6, r4);
        }
        function b3(t5, e6) {
          this.x = t5, this.y = e6;
        }
        Math.imul || (l3 = d3), i3.prototype.mulTo = function(t5, e6) {
          var r4 = this.length + t5.length;
          return 10 === this.length && 10 === t5.length ? l3(this, t5, e6) : r4 < 63 ? d3(this, t5, e6) : r4 < 1024 ? function(t6, e7, r5) {
            r5.negative = e7.negative ^ t6.negative, r5.length = t6.length + e7.length;
            for (var n4 = 0, i4 = 0, o4 = 0; o4 < r5.length - 1; o4++) {
              var s4 = i4;
              i4 = 0;
              for (var a4 = 67108863 & n4, h4 = Math.min(o4, e7.length - 1), f4 = Math.max(0, o4 - t6.length + 1); f4 <= h4; f4++) {
                var u4 = o4 - f4, c4 = (0 | t6.words[u4]) * (0 | e7.words[f4]), d4 = 67108863 & c4;
                a4 = 67108863 & (d4 = d4 + a4 | 0), i4 += (s4 = (s4 = s4 + (c4 / 67108864 | 0) | 0) + (d4 >>> 26) | 0) >>> 26, s4 &= 67108863;
              }
              r5.words[o4] = a4, n4 = s4, s4 = i4;
            }
            return 0 !== n4 ? r5.words[o4] = n4 : r5.length--, r5.strip();
          }(this, t5, e6) : p3(this, t5, e6);
        }, b3.prototype.makeRBT = function(t5) {
          for (var e6 = new Array(t5), r4 = i3.prototype._countBits(t5) - 1, n4 = 0; n4 < t5; n4++)
            e6[n4] = this.revBin(n4, r4, t5);
          return e6;
        }, b3.prototype.revBin = function(t5, e6, r4) {
          if (0 === t5 || t5 === r4 - 1)
            return t5;
          for (var n4 = 0, i4 = 0; i4 < e6; i4++)
            n4 |= (1 & t5) << e6 - i4 - 1, t5 >>= 1;
          return n4;
        }, b3.prototype.permute = function(t5, e6, r4, n4, i4, o4) {
          for (var s4 = 0; s4 < o4; s4++)
            n4[s4] = e6[t5[s4]], i4[s4] = r4[t5[s4]];
        }, b3.prototype.transform = function(t5, e6, r4, n4, i4, o4) {
          this.permute(o4, t5, e6, r4, n4, i4);
          for (var s4 = 1; s4 < i4; s4 <<= 1)
            for (var a4 = s4 << 1, h4 = Math.cos(2 * Math.PI / a4), f4 = Math.sin(2 * Math.PI / a4), u4 = 0; u4 < i4; u4 += a4)
              for (var c4 = h4, d4 = f4, l4 = 0; l4 < s4; l4++) {
                var p4 = r4[u4 + l4], b4 = n4[u4 + l4], m4 = r4[u4 + l4 + s4], y4 = n4[u4 + l4 + s4], g3 = c4 * m4 - d4 * y4;
                y4 = c4 * y4 + d4 * m4, m4 = g3, r4[u4 + l4] = p4 + m4, n4[u4 + l4] = b4 + y4, r4[u4 + l4 + s4] = p4 - m4, n4[u4 + l4 + s4] = b4 - y4, l4 !== a4 && (g3 = h4 * c4 - f4 * d4, d4 = h4 * d4 + f4 * c4, c4 = g3);
              }
        }, b3.prototype.guessLen13b = function(t5, e6) {
          var r4 = 1 | Math.max(e6, t5), n4 = 1 & r4, i4 = 0;
          for (r4 = r4 / 2 | 0; r4; r4 >>>= 1)
            i4++;
          return 1 << i4 + 1 + n4;
        }, b3.prototype.conjugate = function(t5, e6, r4) {
          if (!(r4 <= 1))
            for (var n4 = 0; n4 < r4 / 2; n4++) {
              var i4 = t5[n4];
              t5[n4] = t5[r4 - n4 - 1], t5[r4 - n4 - 1] = i4, i4 = e6[n4], e6[n4] = -e6[r4 - n4 - 1], e6[r4 - n4 - 1] = -i4;
            }
        }, b3.prototype.normalize13b = function(t5, e6) {
          for (var r4 = 0, n4 = 0; n4 < e6 / 2; n4++) {
            var i4 = 8192 * Math.round(t5[2 * n4 + 1] / e6) + Math.round(t5[2 * n4] / e6) + r4;
            t5[n4] = 67108863 & i4, r4 = i4 < 67108864 ? 0 : i4 / 67108864 | 0;
          }
          return t5;
        }, b3.prototype.convert13b = function(t5, e6, n4, i4) {
          for (var o4 = 0, s4 = 0; s4 < e6; s4++)
            o4 += 0 | t5[s4], n4[2 * s4] = 8191 & o4, o4 >>>= 13, n4[2 * s4 + 1] = 8191 & o4, o4 >>>= 13;
          for (s4 = 2 * e6; s4 < i4; ++s4)
            n4[s4] = 0;
          r3(0 === o4), r3(0 == (-8192 & o4));
        }, b3.prototype.stub = function(t5) {
          for (var e6 = new Array(t5), r4 = 0; r4 < t5; r4++)
            e6[r4] = 0;
          return e6;
        }, b3.prototype.mulp = function(t5, e6, r4) {
          var n4 = 2 * this.guessLen13b(t5.length, e6.length), i4 = this.makeRBT(n4), o4 = this.stub(n4), s4 = new Array(n4), a4 = new Array(n4), h4 = new Array(n4), f4 = new Array(n4), u4 = new Array(n4), c4 = new Array(n4), d4 = r4.words;
          d4.length = n4, this.convert13b(t5.words, t5.length, s4, n4), this.convert13b(e6.words, e6.length, f4, n4), this.transform(s4, o4, a4, h4, n4, i4), this.transform(f4, o4, u4, c4, n4, i4);
          for (var l4 = 0; l4 < n4; l4++) {
            var p4 = a4[l4] * u4[l4] - h4[l4] * c4[l4];
            h4[l4] = a4[l4] * c4[l4] + h4[l4] * u4[l4], a4[l4] = p4;
          }
          return this.conjugate(a4, h4, n4), this.transform(a4, h4, d4, o4, n4, i4), this.conjugate(d4, o4, n4), this.normalize13b(d4, n4), r4.negative = t5.negative ^ e6.negative, r4.length = t5.length + e6.length, r4.strip();
        }, i3.prototype.mul = function(t5) {
          var e6 = new i3(null);
          return e6.words = new Array(this.length + t5.length), this.mulTo(t5, e6);
        }, i3.prototype.mulf = function(t5) {
          var e6 = new i3(null);
          return e6.words = new Array(this.length + t5.length), p3(this, t5, e6);
        }, i3.prototype.imul = function(t5) {
          return this.clone().mulTo(t5, this);
        }, i3.prototype.imuln = function(t5) {
          r3("number" == typeof t5), r3(t5 < 67108864);
          for (var e6 = 0, n4 = 0; n4 < this.length; n4++) {
            var i4 = (0 | this.words[n4]) * t5, o4 = (67108863 & i4) + (67108863 & e6);
            e6 >>= 26, e6 += i4 / 67108864 | 0, e6 += o4 >>> 26, this.words[n4] = 67108863 & o4;
          }
          return 0 !== e6 && (this.words[n4] = e6, this.length++), this;
        }, i3.prototype.muln = function(t5) {
          return this.clone().imuln(t5);
        }, i3.prototype.sqr = function() {
          return this.mul(this);
        }, i3.prototype.isqr = function() {
          return this.imul(this.clone());
        }, i3.prototype.pow = function(t5) {
          var e6 = function(t6) {
            for (var e7 = new Array(t6.bitLength()), r5 = 0; r5 < e7.length; r5++) {
              var n5 = r5 / 26 | 0, i4 = r5 % 26;
              e7[r5] = (t6.words[n5] & 1 << i4) >>> i4;
            }
            return e7;
          }(t5);
          if (0 === e6.length)
            return new i3(1);
          for (var r4 = this, n4 = 0; n4 < e6.length && 0 === e6[n4]; n4++, r4 = r4.sqr())
            ;
          if (++n4 < e6.length)
            for (var o4 = r4.sqr(); n4 < e6.length; n4++, o4 = o4.sqr())
              0 !== e6[n4] && (r4 = r4.mul(o4));
          return r4;
        }, i3.prototype.iushln = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6, n4 = t5 % 26, i4 = (t5 - n4) / 26, o4 = 67108863 >>> 26 - n4 << 26 - n4;
          if (0 !== n4) {
            var s4 = 0;
            for (e6 = 0; e6 < this.length; e6++) {
              var a4 = this.words[e6] & o4, h4 = (0 | this.words[e6]) - a4 << n4;
              this.words[e6] = h4 | s4, s4 = a4 >>> 26 - n4;
            }
            s4 && (this.words[e6] = s4, this.length++);
          }
          if (0 !== i4) {
            for (e6 = this.length - 1; e6 >= 0; e6--)
              this.words[e6 + i4] = this.words[e6];
            for (e6 = 0; e6 < i4; e6++)
              this.words[e6] = 0;
            this.length += i4;
          }
          return this.strip();
        }, i3.prototype.ishln = function(t5) {
          return r3(0 === this.negative), this.iushln(t5);
        }, i3.prototype.iushrn = function(t5, e6, n4) {
          var i4;
          r3("number" == typeof t5 && t5 >= 0), i4 = e6 ? (e6 - e6 % 26) / 26 : 0;
          var o4 = t5 % 26, s4 = Math.min((t5 - o4) / 26, this.length), a4 = 67108863 ^ 67108863 >>> o4 << o4, h4 = n4;
          if (i4 -= s4, i4 = Math.max(0, i4), h4) {
            for (var f4 = 0; f4 < s4; f4++)
              h4.words[f4] = this.words[f4];
            h4.length = s4;
          }
          if (0 === s4)
            ;
          else if (this.length > s4)
            for (this.length -= s4, f4 = 0; f4 < this.length; f4++)
              this.words[f4] = this.words[f4 + s4];
          else
            this.words[0] = 0, this.length = 1;
          var u4 = 0;
          for (f4 = this.length - 1; f4 >= 0 && (0 !== u4 || f4 >= i4); f4--) {
            var c4 = 0 | this.words[f4];
            this.words[f4] = u4 << 26 - o4 | c4 >>> o4, u4 = c4 & a4;
          }
          return h4 && 0 !== u4 && (h4.words[h4.length++] = u4), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
        }, i3.prototype.ishrn = function(t5, e6, n4) {
          return r3(0 === this.negative), this.iushrn(t5, e6, n4);
        }, i3.prototype.shln = function(t5) {
          return this.clone().ishln(t5);
        }, i3.prototype.ushln = function(t5) {
          return this.clone().iushln(t5);
        }, i3.prototype.shrn = function(t5) {
          return this.clone().ishrn(t5);
        }, i3.prototype.ushrn = function(t5) {
          return this.clone().iushrn(t5);
        }, i3.prototype.testn = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6 = t5 % 26, n4 = (t5 - e6) / 26, i4 = 1 << e6;
          return !(this.length <= n4) && !!(this.words[n4] & i4);
        }, i3.prototype.imaskn = function(t5) {
          r3("number" == typeof t5 && t5 >= 0);
          var e6 = t5 % 26, n4 = (t5 - e6) / 26;
          if (r3(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n4)
            return this;
          if (0 !== e6 && n4++, this.length = Math.min(n4, this.length), 0 !== e6) {
            var i4 = 67108863 ^ 67108863 >>> e6 << e6;
            this.words[this.length - 1] &= i4;
          }
          return this.strip();
        }, i3.prototype.maskn = function(t5) {
          return this.clone().imaskn(t5);
        }, i3.prototype.iaddn = function(t5) {
          return r3("number" == typeof t5), r3(t5 < 67108864), t5 < 0 ? this.isubn(-t5) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t5 ? (this.words[0] = t5 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t5), this.negative = 1, this) : this._iaddn(t5);
        }, i3.prototype._iaddn = function(t5) {
          this.words[0] += t5;
          for (var e6 = 0; e6 < this.length && this.words[e6] >= 67108864; e6++)
            this.words[e6] -= 67108864, e6 === this.length - 1 ? this.words[e6 + 1] = 1 : this.words[e6 + 1]++;
          return this.length = Math.max(this.length, e6 + 1), this;
        }, i3.prototype.isubn = function(t5) {
          if (r3("number" == typeof t5), r3(t5 < 67108864), t5 < 0)
            return this.iaddn(-t5);
          if (0 !== this.negative)
            return this.negative = 0, this.iaddn(t5), this.negative = 1, this;
          if (this.words[0] -= t5, 1 === this.length && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var e6 = 0; e6 < this.length && this.words[e6] < 0; e6++)
              this.words[e6] += 67108864, this.words[e6 + 1] -= 1;
          return this.strip();
        }, i3.prototype.addn = function(t5) {
          return this.clone().iaddn(t5);
        }, i3.prototype.subn = function(t5) {
          return this.clone().isubn(t5);
        }, i3.prototype.iabs = function() {
          return this.negative = 0, this;
        }, i3.prototype.abs = function() {
          return this.clone().iabs();
        }, i3.prototype._ishlnsubmul = function(t5, e6, n4) {
          var i4, o4, s4 = t5.length + n4;
          this._expand(s4);
          var a4 = 0;
          for (i4 = 0; i4 < t5.length; i4++) {
            o4 = (0 | this.words[i4 + n4]) + a4;
            var h4 = (0 | t5.words[i4]) * e6;
            a4 = ((o4 -= 67108863 & h4) >> 26) - (h4 / 67108864 | 0), this.words[i4 + n4] = 67108863 & o4;
          }
          for (; i4 < this.length - n4; i4++)
            a4 = (o4 = (0 | this.words[i4 + n4]) + a4) >> 26, this.words[i4 + n4] = 67108863 & o4;
          if (0 === a4)
            return this.strip();
          for (r3(-1 === a4), a4 = 0, i4 = 0; i4 < this.length; i4++)
            a4 = (o4 = -(0 | this.words[i4]) + a4) >> 26, this.words[i4] = 67108863 & o4;
          return this.negative = 1, this.strip();
        }, i3.prototype._wordDiv = function(t5, e6) {
          var r4 = (this.length, t5.length), n4 = this.clone(), o4 = t5, s4 = 0 | o4.words[o4.length - 1];
          0 !== (r4 = 26 - this._countBits(s4)) && (o4 = o4.ushln(r4), n4.iushln(r4), s4 = 0 | o4.words[o4.length - 1]);
          var a4, h4 = n4.length - o4.length;
          if ("mod" !== e6) {
            (a4 = new i3(null)).length = h4 + 1, a4.words = new Array(a4.length);
            for (var f4 = 0; f4 < a4.length; f4++)
              a4.words[f4] = 0;
          }
          var u4 = n4.clone()._ishlnsubmul(o4, 1, h4);
          0 === u4.negative && (n4 = u4, a4 && (a4.words[h4] = 1));
          for (var c4 = h4 - 1; c4 >= 0; c4--) {
            var d4 = 67108864 * (0 | n4.words[o4.length + c4]) + (0 | n4.words[o4.length + c4 - 1]);
            for (d4 = Math.min(d4 / s4 | 0, 67108863), n4._ishlnsubmul(o4, d4, c4); 0 !== n4.negative; )
              d4--, n4.negative = 0, n4._ishlnsubmul(o4, 1, c4), n4.isZero() || (n4.negative ^= 1);
            a4 && (a4.words[c4] = d4);
          }
          return a4 && a4.strip(), n4.strip(), "div" !== e6 && 0 !== r4 && n4.iushrn(r4), { div: a4 || null, mod: n4 };
        }, i3.prototype.divmod = function(t5, e6, n4) {
          return r3(!t5.isZero()), this.isZero() ? { div: new i3(0), mod: new i3(0) } : 0 !== this.negative && 0 === t5.negative ? (a4 = this.neg().divmod(t5, e6), "mod" !== e6 && (o4 = a4.div.neg()), "div" !== e6 && (s4 = a4.mod.neg(), n4 && 0 !== s4.negative && s4.iadd(t5)), { div: o4, mod: s4 }) : 0 === this.negative && 0 !== t5.negative ? (a4 = this.divmod(t5.neg(), e6), "mod" !== e6 && (o4 = a4.div.neg()), { div: o4, mod: a4.mod }) : 0 != (this.negative & t5.negative) ? (a4 = this.neg().divmod(t5.neg(), e6), "div" !== e6 && (s4 = a4.mod.neg(), n4 && 0 !== s4.negative && s4.isub(t5)), { div: a4.div, mod: s4 }) : t5.length > this.length || this.cmp(t5) < 0 ? { div: new i3(0), mod: this } : 1 === t5.length ? "div" === e6 ? { div: this.divn(t5.words[0]), mod: null } : "mod" === e6 ? { div: null, mod: new i3(this.modn(t5.words[0])) } : { div: this.divn(t5.words[0]), mod: new i3(this.modn(t5.words[0])) } : this._wordDiv(t5, e6);
          var o4, s4, a4;
        }, i3.prototype.div = function(t5) {
          return this.divmod(t5, "div", false).div;
        }, i3.prototype.mod = function(t5) {
          return this.divmod(t5, "mod", false).mod;
        }, i3.prototype.umod = function(t5) {
          return this.divmod(t5, "mod", true).mod;
        }, i3.prototype.divRound = function(t5) {
          var e6 = this.divmod(t5);
          if (e6.mod.isZero())
            return e6.div;
          var r4 = 0 !== e6.div.negative ? e6.mod.isub(t5) : e6.mod, n4 = t5.ushrn(1), i4 = t5.andln(1), o4 = r4.cmp(n4);
          return o4 < 0 || 1 === i4 && 0 === o4 ? e6.div : 0 !== e6.div.negative ? e6.div.isubn(1) : e6.div.iaddn(1);
        }, i3.prototype.modn = function(t5) {
          r3(t5 <= 67108863);
          for (var e6 = (1 << 26) % t5, n4 = 0, i4 = this.length - 1; i4 >= 0; i4--)
            n4 = (e6 * n4 + (0 | this.words[i4])) % t5;
          return n4;
        }, i3.prototype.idivn = function(t5) {
          r3(t5 <= 67108863);
          for (var e6 = 0, n4 = this.length - 1; n4 >= 0; n4--) {
            var i4 = (0 | this.words[n4]) + 67108864 * e6;
            this.words[n4] = i4 / t5 | 0, e6 = i4 % t5;
          }
          return this.strip();
        }, i3.prototype.divn = function(t5) {
          return this.clone().idivn(t5);
        }, i3.prototype.egcd = function(t5) {
          r3(0 === t5.negative), r3(!t5.isZero());
          var e6 = this, n4 = t5.clone();
          e6 = 0 !== e6.negative ? e6.umod(t5) : e6.clone();
          for (var o4 = new i3(1), s4 = new i3(0), a4 = new i3(0), h4 = new i3(1), f4 = 0; e6.isEven() && n4.isEven(); )
            e6.iushrn(1), n4.iushrn(1), ++f4;
          for (var u4 = n4.clone(), c4 = e6.clone(); !e6.isZero(); ) {
            for (var d4 = 0, l4 = 1; 0 == (e6.words[0] & l4) && d4 < 26; ++d4, l4 <<= 1)
              ;
            if (d4 > 0)
              for (e6.iushrn(d4); d4-- > 0; )
                (o4.isOdd() || s4.isOdd()) && (o4.iadd(u4), s4.isub(c4)), o4.iushrn(1), s4.iushrn(1);
            for (var p4 = 0, b4 = 1; 0 == (n4.words[0] & b4) && p4 < 26; ++p4, b4 <<= 1)
              ;
            if (p4 > 0)
              for (n4.iushrn(p4); p4-- > 0; )
                (a4.isOdd() || h4.isOdd()) && (a4.iadd(u4), h4.isub(c4)), a4.iushrn(1), h4.iushrn(1);
            e6.cmp(n4) >= 0 ? (e6.isub(n4), o4.isub(a4), s4.isub(h4)) : (n4.isub(e6), a4.isub(o4), h4.isub(s4));
          }
          return { a: a4, b: h4, gcd: n4.iushln(f4) };
        }, i3.prototype._invmp = function(t5) {
          r3(0 === t5.negative), r3(!t5.isZero());
          var e6 = this, n4 = t5.clone();
          e6 = 0 !== e6.negative ? e6.umod(t5) : e6.clone();
          for (var o4, s4 = new i3(1), a4 = new i3(0), h4 = n4.clone(); e6.cmpn(1) > 0 && n4.cmpn(1) > 0; ) {
            for (var f4 = 0, u4 = 1; 0 == (e6.words[0] & u4) && f4 < 26; ++f4, u4 <<= 1)
              ;
            if (f4 > 0)
              for (e6.iushrn(f4); f4-- > 0; )
                s4.isOdd() && s4.iadd(h4), s4.iushrn(1);
            for (var c4 = 0, d4 = 1; 0 == (n4.words[0] & d4) && c4 < 26; ++c4, d4 <<= 1)
              ;
            if (c4 > 0)
              for (n4.iushrn(c4); c4-- > 0; )
                a4.isOdd() && a4.iadd(h4), a4.iushrn(1);
            e6.cmp(n4) >= 0 ? (e6.isub(n4), s4.isub(a4)) : (n4.isub(e6), a4.isub(s4));
          }
          return (o4 = 0 === e6.cmpn(1) ? s4 : a4).cmpn(0) < 0 && o4.iadd(t5), o4;
        }, i3.prototype.gcd = function(t5) {
          if (this.isZero())
            return t5.abs();
          if (t5.isZero())
            return this.abs();
          var e6 = this.clone(), r4 = t5.clone();
          e6.negative = 0, r4.negative = 0;
          for (var n4 = 0; e6.isEven() && r4.isEven(); n4++)
            e6.iushrn(1), r4.iushrn(1);
          for (; ; ) {
            for (; e6.isEven(); )
              e6.iushrn(1);
            for (; r4.isEven(); )
              r4.iushrn(1);
            var i4 = e6.cmp(r4);
            if (i4 < 0) {
              var o4 = e6;
              e6 = r4, r4 = o4;
            } else if (0 === i4 || 0 === r4.cmpn(1))
              break;
            e6.isub(r4);
          }
          return r4.iushln(n4);
        }, i3.prototype.invm = function(t5) {
          return this.egcd(t5).a.umod(t5);
        }, i3.prototype.isEven = function() {
          return 0 == (1 & this.words[0]);
        }, i3.prototype.isOdd = function() {
          return 1 == (1 & this.words[0]);
        }, i3.prototype.andln = function(t5) {
          return this.words[0] & t5;
        }, i3.prototype.bincn = function(t5) {
          r3("number" == typeof t5);
          var e6 = t5 % 26, n4 = (t5 - e6) / 26, i4 = 1 << e6;
          if (this.length <= n4)
            return this._expand(n4 + 1), this.words[n4] |= i4, this;
          for (var o4 = i4, s4 = n4; 0 !== o4 && s4 < this.length; s4++) {
            var a4 = 0 | this.words[s4];
            o4 = (a4 += o4) >>> 26, a4 &= 67108863, this.words[s4] = a4;
          }
          return 0 !== o4 && (this.words[s4] = o4, this.length++), this;
        }, i3.prototype.isZero = function() {
          return 1 === this.length && 0 === this.words[0];
        }, i3.prototype.cmpn = function(t5) {
          var e6, n4 = t5 < 0;
          if (0 !== this.negative && !n4)
            return -1;
          if (0 === this.negative && n4)
            return 1;
          if (this.strip(), this.length > 1)
            e6 = 1;
          else {
            n4 && (t5 = -t5), r3(t5 <= 67108863, "Number is too big");
            var i4 = 0 | this.words[0];
            e6 = i4 === t5 ? 0 : i4 < t5 ? -1 : 1;
          }
          return 0 !== this.negative ? 0 | -e6 : e6;
        }, i3.prototype.cmp = function(t5) {
          if (0 !== this.negative && 0 === t5.negative)
            return -1;
          if (0 === this.negative && 0 !== t5.negative)
            return 1;
          var e6 = this.ucmp(t5);
          return 0 !== this.negative ? 0 | -e6 : e6;
        }, i3.prototype.ucmp = function(t5) {
          if (this.length > t5.length)
            return 1;
          if (this.length < t5.length)
            return -1;
          for (var e6 = 0, r4 = this.length - 1; r4 >= 0; r4--) {
            var n4 = 0 | this.words[r4], i4 = 0 | t5.words[r4];
            if (n4 !== i4) {
              n4 < i4 ? e6 = -1 : n4 > i4 && (e6 = 1);
              break;
            }
          }
          return e6;
        }, i3.prototype.gtn = function(t5) {
          return 1 === this.cmpn(t5);
        }, i3.prototype.gt = function(t5) {
          return 1 === this.cmp(t5);
        }, i3.prototype.gten = function(t5) {
          return this.cmpn(t5) >= 0;
        }, i3.prototype.gte = function(t5) {
          return this.cmp(t5) >= 0;
        }, i3.prototype.ltn = function(t5) {
          return -1 === this.cmpn(t5);
        }, i3.prototype.lt = function(t5) {
          return -1 === this.cmp(t5);
        }, i3.prototype.lten = function(t5) {
          return this.cmpn(t5) <= 0;
        }, i3.prototype.lte = function(t5) {
          return this.cmp(t5) <= 0;
        }, i3.prototype.eqn = function(t5) {
          return 0 === this.cmpn(t5);
        }, i3.prototype.eq = function(t5) {
          return 0 === this.cmp(t5);
        }, i3.red = function(t5) {
          return new _3(t5);
        }, i3.prototype.toRed = function(t5) {
          return r3(!this.red, "Already a number in reduction context"), r3(0 === this.negative, "red works only with positives"), t5.convertTo(this)._forceRed(t5);
        }, i3.prototype.fromRed = function() {
          return r3(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, i3.prototype._forceRed = function(t5) {
          return this.red = t5, this;
        }, i3.prototype.forceRed = function(t5) {
          return r3(!this.red, "Already a number in reduction context"), this._forceRed(t5);
        }, i3.prototype.redAdd = function(t5) {
          return r3(this.red, "redAdd works only with red numbers"), this.red.add(this, t5);
        }, i3.prototype.redIAdd = function(t5) {
          return r3(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t5);
        }, i3.prototype.redSub = function(t5) {
          return r3(this.red, "redSub works only with red numbers"), this.red.sub(this, t5);
        }, i3.prototype.redISub = function(t5) {
          return r3(this.red, "redISub works only with red numbers"), this.red.isub(this, t5);
        }, i3.prototype.redShl = function(t5) {
          return r3(this.red, "redShl works only with red numbers"), this.red.shl(this, t5);
        }, i3.prototype.redMul = function(t5) {
          return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, t5), this.red.mul(this, t5);
        }, i3.prototype.redIMul = function(t5) {
          return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, t5), this.red.imul(this, t5);
        }, i3.prototype.redSqr = function() {
          return r3(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, i3.prototype.redISqr = function() {
          return r3(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, i3.prototype.redSqrt = function() {
          return r3(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, i3.prototype.redInvm = function() {
          return r3(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, i3.prototype.redNeg = function() {
          return r3(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, i3.prototype.redPow = function(t5) {
          return r3(this.red && !t5.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t5);
        };
        var m3 = { k256: null, p224: null, p192: null, p25519: null };
        function y3(t5, e6) {
          this.name = t5, this.p = new i3(e6, 16), this.n = this.p.bitLength(), this.k = new i3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        function g2() {
          y3.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function v3() {
          y3.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function w3() {
          y3.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function M3() {
          y3.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function _3(t5) {
          if ("string" == typeof t5) {
            var e6 = i3._prime(t5);
            this.m = e6.p, this.prime = e6;
          } else
            r3(t5.gtn(1), "modulus must be greater than 1"), this.m = t5, this.prime = null;
        }
        function A3(t5) {
          _3.call(this, t5), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new i3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        y3.prototype._tmp = function() {
          var t5 = new i3(null);
          return t5.words = new Array(Math.ceil(this.n / 13)), t5;
        }, y3.prototype.ireduce = function(t5) {
          var e6, r4 = t5;
          do {
            this.split(r4, this.tmp), e6 = (r4 = (r4 = this.imulK(r4)).iadd(this.tmp)).bitLength();
          } while (e6 > this.n);
          var n4 = e6 < this.n ? -1 : r4.ucmp(this.p);
          return 0 === n4 ? (r4.words[0] = 0, r4.length = 1) : n4 > 0 ? r4.isub(this.p) : void 0 !== r4.strip ? r4.strip() : r4._strip(), r4;
        }, y3.prototype.split = function(t5, e6) {
          t5.iushrn(this.n, 0, e6);
        }, y3.prototype.imulK = function(t5) {
          return t5.imul(this.k);
        }, n3(g2, y3), g2.prototype.split = function(t5, e6) {
          for (var r4 = 4194303, n4 = Math.min(t5.length, 9), i4 = 0; i4 < n4; i4++)
            e6.words[i4] = t5.words[i4];
          if (e6.length = n4, t5.length <= 9)
            return t5.words[0] = 0, void (t5.length = 1);
          var o4 = t5.words[9];
          for (e6.words[e6.length++] = o4 & r4, i4 = 10; i4 < t5.length; i4++) {
            var s4 = 0 | t5.words[i4];
            t5.words[i4 - 10] = (s4 & r4) << 4 | o4 >>> 22, o4 = s4;
          }
          o4 >>>= 22, t5.words[i4 - 10] = o4, 0 === o4 && t5.length > 10 ? t5.length -= 10 : t5.length -= 9;
        }, g2.prototype.imulK = function(t5) {
          t5.words[t5.length] = 0, t5.words[t5.length + 1] = 0, t5.length += 2;
          for (var e6 = 0, r4 = 0; r4 < t5.length; r4++) {
            var n4 = 0 | t5.words[r4];
            e6 += 977 * n4, t5.words[r4] = 67108863 & e6, e6 = 64 * n4 + (e6 / 67108864 | 0);
          }
          return 0 === t5.words[t5.length - 1] && (t5.length--, 0 === t5.words[t5.length - 1] && t5.length--), t5;
        }, n3(v3, y3), n3(w3, y3), n3(M3, y3), M3.prototype.imulK = function(t5) {
          for (var e6 = 0, r4 = 0; r4 < t5.length; r4++) {
            var n4 = 19 * (0 | t5.words[r4]) + e6, i4 = 67108863 & n4;
            n4 >>>= 26, t5.words[r4] = i4, e6 = n4;
          }
          return 0 !== e6 && (t5.words[t5.length++] = e6), t5;
        }, i3._prime = function(t5) {
          if (m3[t5])
            return m3[t5];
          var e6;
          if ("k256" === t5)
            e6 = new g2();
          else if ("p224" === t5)
            e6 = new v3();
          else if ("p192" === t5)
            e6 = new w3();
          else {
            if ("p25519" !== t5)
              throw new Error("Unknown prime " + t5);
            e6 = new M3();
          }
          return m3[t5] = e6, e6;
        }, _3.prototype._verify1 = function(t5) {
          r3(0 === t5.negative, "red works only with positives"), r3(t5.red, "red works only with red numbers");
        }, _3.prototype._verify2 = function(t5, e6) {
          r3(0 == (t5.negative | e6.negative), "red works only with positives"), r3(t5.red && t5.red === e6.red, "red works only with red numbers");
        }, _3.prototype.imod = function(t5) {
          return this.prime ? this.prime.ireduce(t5)._forceRed(this) : t5.umod(this.m)._forceRed(this);
        }, _3.prototype.neg = function(t5) {
          return t5.isZero() ? t5.clone() : this.m.sub(t5)._forceRed(this);
        }, _3.prototype.add = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.add(e6);
          return r4.cmp(this.m) >= 0 && r4.isub(this.m), r4._forceRed(this);
        }, _3.prototype.iadd = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.iadd(e6);
          return r4.cmp(this.m) >= 0 && r4.isub(this.m), r4;
        }, _3.prototype.sub = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.sub(e6);
          return r4.cmpn(0) < 0 && r4.iadd(this.m), r4._forceRed(this);
        }, _3.prototype.isub = function(t5, e6) {
          this._verify2(t5, e6);
          var r4 = t5.isub(e6);
          return r4.cmpn(0) < 0 && r4.iadd(this.m), r4;
        }, _3.prototype.shl = function(t5, e6) {
          return this._verify1(t5), this.imod(t5.ushln(e6));
        }, _3.prototype.imul = function(t5, e6) {
          return this._verify2(t5, e6), this.imod(t5.imul(e6));
        }, _3.prototype.mul = function(t5, e6) {
          return this._verify2(t5, e6), this.imod(t5.mul(e6));
        }, _3.prototype.isqr = function(t5) {
          return this.imul(t5, t5.clone());
        }, _3.prototype.sqr = function(t5) {
          return this.mul(t5, t5);
        }, _3.prototype.sqrt = function(t5) {
          if (t5.isZero())
            return t5.clone();
          var e6 = this.m.andln(3);
          if (r3(e6 % 2 == 1), 3 === e6) {
            var n4 = this.m.add(new i3(1)).iushrn(2);
            return this.pow(t5, n4);
          }
          for (var o4 = this.m.subn(1), s4 = 0; !o4.isZero() && 0 === o4.andln(1); )
            s4++, o4.iushrn(1);
          r3(!o4.isZero());
          var a4 = new i3(1).toRed(this), h4 = a4.redNeg(), f4 = this.m.subn(1).iushrn(1), u4 = this.m.bitLength();
          for (u4 = new i3(2 * u4 * u4).toRed(this); 0 !== this.pow(u4, f4).cmp(h4); )
            u4.redIAdd(h4);
          for (var c4 = this.pow(u4, o4), d4 = this.pow(t5, o4.addn(1).iushrn(1)), l4 = this.pow(t5, o4), p4 = s4; 0 !== l4.cmp(a4); ) {
            for (var b4 = l4, m4 = 0; 0 !== b4.cmp(a4); m4++)
              b4 = b4.redSqr();
            r3(m4 < p4);
            var y4 = this.pow(c4, new i3(1).iushln(p4 - m4 - 1));
            d4 = d4.redMul(y4), c4 = y4.redSqr(), l4 = l4.redMul(c4), p4 = m4;
          }
          return d4;
        }, _3.prototype.invm = function(t5) {
          var e6 = t5._invmp(this.m);
          return 0 !== e6.negative ? (e6.negative = 0, this.imod(e6).redNeg()) : this.imod(e6);
        }, _3.prototype.pow = function(t5, e6) {
          if (e6.isZero())
            return new i3(1).toRed(this);
          if (0 === e6.cmpn(1))
            return t5.clone();
          var r4 = new Array(16);
          r4[0] = new i3(1).toRed(this), r4[1] = t5;
          for (var n4 = 2; n4 < r4.length; n4++)
            r4[n4] = this.mul(r4[n4 - 1], t5);
          var o4 = r4[0], s4 = 0, a4 = 0, h4 = e6.bitLength() % 26;
          for (0 === h4 && (h4 = 26), n4 = e6.length - 1; n4 >= 0; n4--) {
            for (var f4 = e6.words[n4], u4 = h4 - 1; u4 >= 0; u4--) {
              var c4 = f4 >> u4 & 1;
              o4 !== r4[0] && (o4 = this.sqr(o4)), 0 !== c4 || 0 !== s4 ? (s4 <<= 1, s4 |= c4, (4 === ++a4 || 0 === n4 && 0 === u4) && (o4 = this.mul(o4, r4[s4]), a4 = 0, s4 = 0)) : a4 = 0;
            }
            h4 = 26;
          }
          return o4;
        }, _3.prototype.convertTo = function(t5) {
          var e6 = t5.umod(this.m);
          return e6 === t5 ? e6.clone() : e6;
        }, _3.prototype.convertFrom = function(t5) {
          var e6 = t5.clone();
          return e6.red = null, e6;
        }, i3.mont = function(t5) {
          return new A3(t5);
        }, n3(A3, _3), A3.prototype.convertTo = function(t5) {
          return this.imod(t5.ushln(this.shift));
        }, A3.prototype.convertFrom = function(t5) {
          var e6 = this.imod(t5.mul(this.rinv));
          return e6.red = null, e6;
        }, A3.prototype.imul = function(t5, e6) {
          if (t5.isZero() || e6.isZero())
            return t5.words[0] = 0, t5.length = 1, t5;
          var r4 = t5.imul(e6), n4 = r4.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i4 = r4.isub(n4).iushrn(this.shift), o4 = i4;
          return i4.cmp(this.m) >= 0 ? o4 = i4.isub(this.m) : i4.cmpn(0) < 0 && (o4 = i4.iadd(this.m)), o4._forceRed(this);
        }, A3.prototype.mul = function(t5, e6) {
          if (t5.isZero() || e6.isZero())
            return new i3(0)._forceRed(this);
          var r4 = t5.mul(e6), n4 = r4.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), o4 = r4.isub(n4).iushrn(this.shift), s4 = o4;
          return o4.cmp(this.m) >= 0 ? s4 = o4.isub(this.m) : o4.cmpn(0) < 0 && (s4 = o4.iadd(this.m)), s4._forceRed(this);
        }, A3.prototype.invm = function(t5) {
          return this.imod(t5._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(t3, Jt);
    }), vn = wn;
    function wn(t3, e4) {
      if (!t3)
        throw new Error(e4 || "Assertion failed");
    }
    wn.equal = function(t3, e4, r3) {
      if (t3 != e4)
        throw new Error(r3 || "Assertion failed: " + t3 + " != " + e4);
    };
    var Mn, _n = Qt(function(t3, e4) {
      var r3 = e4;
      function n3(t4) {
        return 1 === t4.length ? "0" + t4 : t4;
      }
      function i3(t4) {
        for (var e6 = "", r4 = 0; r4 < t4.length; r4++)
          e6 += n3(t4[r4].toString(16));
        return e6;
      }
      r3.toArray = function(t4, e6) {
        if (Array.isArray(t4))
          return t4.slice();
        if (!t4)
          return [];
        var r4 = [];
        if ("string" != typeof t4) {
          for (var n4 = 0; n4 < t4.length; n4++)
            r4[n4] = 0 | t4[n4];
          return r4;
        }
        if ("hex" === e6) {
          (t4 = t4.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t4 = "0" + t4);
          for (n4 = 0; n4 < t4.length; n4 += 2)
            r4.push(parseInt(t4[n4] + t4[n4 + 1], 16));
        } else
          for (n4 = 0; n4 < t4.length; n4++) {
            var i4 = t4.charCodeAt(n4), o3 = i4 >> 8, s3 = 255 & i4;
            o3 ? r4.push(o3, s3) : r4.push(s3);
          }
        return r4;
      }, r3.zero2 = n3, r3.toHex = i3, r3.encode = function(t4, e6) {
        return "hex" === e6 ? i3(t4) : t4;
      };
    }), An = Qt(function(t3, e4) {
      var r3 = e4;
      r3.assert = vn, r3.toArray = _n.toArray, r3.zero2 = _n.zero2, r3.toHex = _n.toHex, r3.encode = _n.encode, r3.getNAF = function(t4, e6, r4) {
        var n3 = new Array(Math.max(t4.bitLength(), r4) + 1);
        n3.fill(0);
        for (var i3 = 1 << e6 + 1, o3 = t4.clone(), s3 = 0; s3 < n3.length; s3++) {
          var a3, h3 = o3.andln(i3 - 1);
          o3.isOdd() ? (a3 = h3 > (i3 >> 1) - 1 ? (i3 >> 1) - h3 : h3, o3.isubn(a3)) : a3 = 0, n3[s3] = a3, o3.iushrn(1);
        }
        return n3;
      }, r3.getJSF = function(t4, e6) {
        var r4 = [[], []];
        t4 = t4.clone(), e6 = e6.clone();
        for (var n3, i3 = 0, o3 = 0; t4.cmpn(-i3) > 0 || e6.cmpn(-o3) > 0; ) {
          var s3, a3, h3 = t4.andln(3) + i3 & 3, f3 = e6.andln(3) + o3 & 3;
          3 === h3 && (h3 = -1), 3 === f3 && (f3 = -1), s3 = 0 == (1 & h3) ? 0 : 3 !== (n3 = t4.andln(7) + i3 & 7) && 5 !== n3 || 2 !== f3 ? h3 : -h3, r4[0].push(s3), a3 = 0 == (1 & f3) ? 0 : 3 !== (n3 = e6.andln(7) + o3 & 7) && 5 !== n3 || 2 !== h3 ? f3 : -f3, r4[1].push(a3), 2 * i3 === s3 + 1 && (i3 = 1 - i3), 2 * o3 === a3 + 1 && (o3 = 1 - o3), t4.iushrn(1), e6.iushrn(1);
        }
        return r4;
      }, r3.cachedProperty = function(t4, e6, r4) {
        var n3 = "_" + e6;
        t4.prototype[e6] = function() {
          return void 0 !== this[n3] ? this[n3] : this[n3] = r4.call(this);
        };
      }, r3.parseBytes = function(t4) {
        return "string" == typeof t4 ? r3.toArray(t4, "hex") : t4;
      }, r3.intFromLE = function(t4) {
        return new gn(t4, "hex", "le");
      };
    }), Sn = function(t3) {
      return Mn || (Mn = new En(null)), Mn.generate(t3);
    };
    function En(t3) {
      this.rand = t3;
    }
    var xn = En;
    if (En.prototype.generate = function(t3) {
      return this._rand(t3);
    }, En.prototype._rand = function(t3) {
      if (this.rand.getBytes)
        return this.rand.getBytes(t3);
      for (var e4 = new Uint8Array(t3), r3 = 0; r3 < e4.length; r3++)
        e4[r3] = this.rand.getByte();
      return e4;
    }, "object" == typeof self)
      self.crypto && self.crypto.getRandomValues ? En.prototype._rand = function(t3) {
        var e4 = new Uint8Array(t3);
        return self.crypto.getRandomValues(e4), e4;
      } : self.msCrypto && self.msCrypto.getRandomValues ? En.prototype._rand = function(t3) {
        var e4 = new Uint8Array(t3);
        return self.msCrypto.getRandomValues(e4), e4;
      } : "object" == typeof window && (En.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        var In = ee2;
        if ("function" != typeof In.randomBytes)
          throw new Error("Not supported");
        En.prototype._rand = function(t3) {
          return In.randomBytes(t3);
        };
      } catch (t3) {
      }
    Sn.Rand = xn;
    var kn = An.getNAF, Rn = An.getJSF, Tn = An.assert;
    function Bn(t3, e4) {
      this.type = t3, this.p = new gn(e4.p, 16), this.red = e4.prime ? gn.red(e4.prime) : gn.mont(this.p), this.zero = new gn(0).toRed(this.red), this.one = new gn(1).toRed(this.red), this.two = new gn(2).toRed(this.red), this.n = e4.n && new gn(e4.n, 16), this.g = e4.g && this.pointFromJSON(e4.g, e4.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r3 = this.n && this.p.div(this.n);
      !r3 || r3.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    var Pn = Bn;
    function On(t3, e4) {
      this.curve = t3, this.type = e4, this.precomputed = null;
    }
    Bn.prototype.point = function() {
      throw new Error("Not implemented");
    }, Bn.prototype.validate = function() {
      throw new Error("Not implemented");
    }, Bn.prototype._fixedNafMul = function(t3, e4) {
      Tn(t3.precomputed);
      var r3 = t3._getDoubles(), n3 = kn(e4, 1, this._bitLength), i3 = (1 << r3.step + 1) - (r3.step % 2 == 0 ? 2 : 1);
      i3 /= 3;
      var o3, s3, a3 = [];
      for (o3 = 0; o3 < n3.length; o3 += r3.step) {
        s3 = 0;
        for (var h3 = o3 + r3.step - 1; h3 >= o3; h3--)
          s3 = (s3 << 1) + n3[h3];
        a3.push(s3);
      }
      for (var f3 = this.jpoint(null, null, null), u3 = this.jpoint(null, null, null), c3 = i3; c3 > 0; c3--) {
        for (o3 = 0; o3 < a3.length; o3++)
          (s3 = a3[o3]) === c3 ? u3 = u3.mixedAdd(r3.points[o3]) : s3 === -c3 && (u3 = u3.mixedAdd(r3.points[o3].neg()));
        f3 = f3.add(u3);
      }
      return f3.toP();
    }, Bn.prototype._wnafMul = function(t3, e4) {
      var r3 = 4, n3 = t3._getNAFPoints(r3);
      r3 = n3.wnd;
      for (var i3 = n3.points, o3 = kn(e4, r3, this._bitLength), s3 = this.jpoint(null, null, null), a3 = o3.length - 1; a3 >= 0; a3--) {
        for (var h3 = 0; a3 >= 0 && 0 === o3[a3]; a3--)
          h3++;
        if (a3 >= 0 && h3++, s3 = s3.dblp(h3), a3 < 0)
          break;
        var f3 = o3[a3];
        Tn(0 !== f3), s3 = "affine" === t3.type ? f3 > 0 ? s3.mixedAdd(i3[f3 - 1 >> 1]) : s3.mixedAdd(i3[-f3 - 1 >> 1].neg()) : f3 > 0 ? s3.add(i3[f3 - 1 >> 1]) : s3.add(i3[-f3 - 1 >> 1].neg());
      }
      return "affine" === t3.type ? s3.toP() : s3;
    }, Bn.prototype._wnafMulAdd = function(t3, e4, r3, n3, i3) {
      var o3, s3, a3, h3 = this._wnafT1, f3 = this._wnafT2, u3 = this._wnafT3, c3 = 0;
      for (o3 = 0; o3 < n3; o3++) {
        var d3 = (a3 = e4[o3])._getNAFPoints(t3);
        h3[o3] = d3.wnd, f3[o3] = d3.points;
      }
      for (o3 = n3 - 1; o3 >= 1; o3 -= 2) {
        var l3 = o3 - 1, p3 = o3;
        if (1 === h3[l3] && 1 === h3[p3]) {
          var b3 = [e4[l3], null, null, e4[p3]];
          0 === e4[l3].y.cmp(e4[p3].y) ? (b3[1] = e4[l3].add(e4[p3]), b3[2] = e4[l3].toJ().mixedAdd(e4[p3].neg())) : 0 === e4[l3].y.cmp(e4[p3].y.redNeg()) ? (b3[1] = e4[l3].toJ().mixedAdd(e4[p3]), b3[2] = e4[l3].add(e4[p3].neg())) : (b3[1] = e4[l3].toJ().mixedAdd(e4[p3]), b3[2] = e4[l3].toJ().mixedAdd(e4[p3].neg()));
          var m3 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], y3 = Rn(r3[l3], r3[p3]);
          for (c3 = Math.max(y3[0].length, c3), u3[l3] = new Array(c3), u3[p3] = new Array(c3), s3 = 0; s3 < c3; s3++) {
            var g2 = 0 | y3[0][s3], v3 = 0 | y3[1][s3];
            u3[l3][s3] = m3[3 * (g2 + 1) + (v3 + 1)], u3[p3][s3] = 0, f3[l3] = b3;
          }
        } else
          u3[l3] = kn(r3[l3], h3[l3], this._bitLength), u3[p3] = kn(r3[p3], h3[p3], this._bitLength), c3 = Math.max(u3[l3].length, c3), c3 = Math.max(u3[p3].length, c3);
      }
      var w3 = this.jpoint(null, null, null), M3 = this._wnafT4;
      for (o3 = c3; o3 >= 0; o3--) {
        for (var _3 = 0; o3 >= 0; ) {
          var A3 = true;
          for (s3 = 0; s3 < n3; s3++)
            M3[s3] = 0 | u3[s3][o3], 0 !== M3[s3] && (A3 = false);
          if (!A3)
            break;
          _3++, o3--;
        }
        if (o3 >= 0 && _3++, w3 = w3.dblp(_3), o3 < 0)
          break;
        for (s3 = 0; s3 < n3; s3++) {
          var S3 = M3[s3];
          0 !== S3 && (S3 > 0 ? a3 = f3[s3][S3 - 1 >> 1] : S3 < 0 && (a3 = f3[s3][-S3 - 1 >> 1].neg()), w3 = "affine" === a3.type ? w3.mixedAdd(a3) : w3.add(a3));
        }
      }
      for (o3 = 0; o3 < n3; o3++)
        f3[o3] = null;
      return i3 ? w3 : w3.toP();
    }, Bn.BasePoint = On, On.prototype.eq = function() {
      throw new Error("Not implemented");
    }, On.prototype.validate = function() {
      return this.curve.validate(this);
    }, Bn.prototype.decodePoint = function(t3, e4) {
      t3 = An.toArray(t3, e4);
      var r3 = this.p.byteLength();
      if ((4 === t3[0] || 6 === t3[0] || 7 === t3[0]) && t3.length - 1 == 2 * r3)
        return 6 === t3[0] ? Tn(t3[t3.length - 1] % 2 == 0) : 7 === t3[0] && Tn(t3[t3.length - 1] % 2 == 1), this.point(t3.slice(1, 1 + r3), t3.slice(1 + r3, 1 + 2 * r3));
      if ((2 === t3[0] || 3 === t3[0]) && t3.length - 1 === r3)
        return this.pointFromX(t3.slice(1, 1 + r3), 3 === t3[0]);
      throw new Error("Unknown point format");
    }, On.prototype.encodeCompressed = function(t3) {
      return this.encode(t3, true);
    }, On.prototype._encode = function(t3) {
      var e4 = this.curve.p.byteLength(), r3 = this.getX().toArray("be", e4);
      return t3 ? [this.getY().isEven() ? 2 : 3].concat(r3) : [4].concat(r3, this.getY().toArray("be", e4));
    }, On.prototype.encode = function(t3, e4) {
      return An.encode(this._encode(e4), t3);
    }, On.prototype.precompute = function(t3) {
      if (this.precomputed)
        return this;
      var e4 = { doubles: null, naf: null, beta: null };
      return e4.naf = this._getNAFPoints(8), e4.doubles = this._getDoubles(4, t3), e4.beta = this._getBeta(), this.precomputed = e4, this;
    }, On.prototype._hasDoubles = function(t3) {
      if (!this.precomputed)
        return false;
      var e4 = this.precomputed.doubles;
      return !!e4 && e4.points.length >= Math.ceil((t3.bitLength() + 1) / e4.step);
    }, On.prototype._getDoubles = function(t3, e4) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var r3 = [this], n3 = this, i3 = 0; i3 < e4; i3 += t3) {
        for (var o3 = 0; o3 < t3; o3++)
          n3 = n3.dbl();
        r3.push(n3);
      }
      return { step: t3, points: r3 };
    }, On.prototype._getNAFPoints = function(t3) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var e4 = [this], r3 = (1 << t3) - 1, n3 = 1 === r3 ? null : this.dbl(), i3 = 1; i3 < r3; i3++)
        e4[i3] = e4[i3 - 1].add(n3);
      return { wnd: t3, points: e4 };
    }, On.prototype._getBeta = function() {
      return null;
    }, On.prototype.dblp = function(t3) {
      for (var e4 = this, r3 = 0; r3 < t3; r3++)
        e4 = e4.dbl();
      return e4;
    };
    var Un = Qt(function(t3) {
      "function" == typeof Object.create ? t3.exports = function(t4, e4) {
        e4 && (t4.super_ = e4, t4.prototype = Object.create(e4.prototype, { constructor: { value: t4, enumerable: false, writable: true, configurable: true } }));
      } : t3.exports = function(t4, e4) {
        if (e4) {
          t4.super_ = e4;
          var r3 = function() {
          };
          r3.prototype = e4.prototype, t4.prototype = new r3(), t4.prototype.constructor = t4;
        }
      };
    }), Ln = An.assert;
    function Nn(t3) {
      Pn.call(this, "short", t3), this.a = new gn(t3.a, 16).toRed(this.red), this.b = new gn(t3.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(t3), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Un(Nn, Pn);
    var zn = Nn;
    function Cn(t3, e4, r3, n3) {
      Pn.BasePoint.call(this, t3, "affine"), null === e4 && null === r3 ? (this.x = null, this.y = null, this.inf = true) : (this.x = new gn(e4, 16), this.y = new gn(r3, 16), n3 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    function qn(t3, e4, r3, n3) {
      Pn.BasePoint.call(this, t3, "jacobian"), null === e4 && null === r3 && null === n3 ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new gn(0)) : (this.x = new gn(e4, 16), this.y = new gn(r3, 16), this.z = new gn(n3, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    function jn(t3) {
      Pn.call(this, "mont", t3), this.a = new gn(t3.a, 16).toRed(this.red), this.b = new gn(t3.b, 16).toRed(this.red), this.i4 = new gn(4).toRed(this.red).redInvm(), this.two = new gn(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    Nn.prototype._getEndomorphism = function(t3) {
      if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
        var e4, r3;
        if (t3.beta)
          e4 = new gn(t3.beta, 16).toRed(this.red);
        else {
          var n3 = this._getEndoRoots(this.p);
          e4 = (e4 = n3[0].cmp(n3[1]) < 0 ? n3[0] : n3[1]).toRed(this.red);
        }
        if (t3.lambda)
          r3 = new gn(t3.lambda, 16);
        else {
          var i3 = this._getEndoRoots(this.n);
          0 === this.g.mul(i3[0]).x.cmp(this.g.x.redMul(e4)) ? r3 = i3[0] : (r3 = i3[1], Ln(0 === this.g.mul(r3).x.cmp(this.g.x.redMul(e4))));
        }
        return { beta: e4, lambda: r3, basis: t3.basis ? t3.basis.map(function(t4) {
          return { a: new gn(t4.a, 16), b: new gn(t4.b, 16) };
        }) : this._getEndoBasis(r3) };
      }
    }, Nn.prototype._getEndoRoots = function(t3) {
      var e4 = t3 === this.p ? this.red : gn.mont(t3), r3 = new gn(2).toRed(e4).redInvm(), n3 = r3.redNeg(), i3 = new gn(3).toRed(e4).redNeg().redSqrt().redMul(r3);
      return [n3.redAdd(i3).fromRed(), n3.redSub(i3).fromRed()];
    }, Nn.prototype._getEndoBasis = function(t3) {
      for (var e4, r3, n3, i3, o3, s3, a3, h3, f3, u3 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), c3 = t3, d3 = this.n.clone(), l3 = new gn(1), p3 = new gn(0), b3 = new gn(0), m3 = new gn(1), y3 = 0; 0 !== c3.cmpn(0); ) {
        var g2 = d3.div(c3);
        h3 = d3.sub(g2.mul(c3)), f3 = b3.sub(g2.mul(l3));
        var v3 = m3.sub(g2.mul(p3));
        if (!n3 && h3.cmp(u3) < 0)
          e4 = a3.neg(), r3 = l3, n3 = h3.neg(), i3 = f3;
        else if (n3 && 2 == ++y3)
          break;
        a3 = h3, d3 = c3, c3 = h3, b3 = l3, l3 = f3, m3 = p3, p3 = v3;
      }
      o3 = h3.neg(), s3 = f3;
      var w3 = n3.sqr().add(i3.sqr());
      return o3.sqr().add(s3.sqr()).cmp(w3) >= 0 && (o3 = e4, s3 = r3), n3.negative && (n3 = n3.neg(), i3 = i3.neg()), o3.negative && (o3 = o3.neg(), s3 = s3.neg()), [{ a: n3, b: i3 }, { a: o3, b: s3 }];
    }, Nn.prototype._endoSplit = function(t3) {
      var e4 = this.endo.basis, r3 = e4[0], n3 = e4[1], i3 = n3.b.mul(t3).divRound(this.n), o3 = r3.b.neg().mul(t3).divRound(this.n), s3 = i3.mul(r3.a), a3 = o3.mul(n3.a), h3 = i3.mul(r3.b), f3 = o3.mul(n3.b);
      return { k1: t3.sub(s3).sub(a3), k2: h3.add(f3).neg() };
    }, Nn.prototype.pointFromX = function(t3, e4) {
      (t3 = new gn(t3, 16)).red || (t3 = t3.toRed(this.red));
      var r3 = t3.redSqr().redMul(t3).redIAdd(t3.redMul(this.a)).redIAdd(this.b), n3 = r3.redSqrt();
      if (0 !== n3.redSqr().redSub(r3).cmp(this.zero))
        throw new Error("invalid point");
      var i3 = n3.fromRed().isOdd();
      return (e4 && !i3 || !e4 && i3) && (n3 = n3.redNeg()), this.point(t3, n3);
    }, Nn.prototype.validate = function(t3) {
      if (t3.inf)
        return true;
      var e4 = t3.x, r3 = t3.y, n3 = this.a.redMul(e4), i3 = e4.redSqr().redMul(e4).redIAdd(n3).redIAdd(this.b);
      return 0 === r3.redSqr().redISub(i3).cmpn(0);
    }, Nn.prototype._endoWnafMulAdd = function(t3, e4, r3) {
      for (var n3 = this._endoWnafT1, i3 = this._endoWnafT2, o3 = 0; o3 < t3.length; o3++) {
        var s3 = this._endoSplit(e4[o3]), a3 = t3[o3], h3 = a3._getBeta();
        s3.k1.negative && (s3.k1.ineg(), a3 = a3.neg(true)), s3.k2.negative && (s3.k2.ineg(), h3 = h3.neg(true)), n3[2 * o3] = a3, n3[2 * o3 + 1] = h3, i3[2 * o3] = s3.k1, i3[2 * o3 + 1] = s3.k2;
      }
      for (var f3 = this._wnafMulAdd(1, n3, i3, 2 * o3, r3), u3 = 0; u3 < 2 * o3; u3++)
        n3[u3] = null, i3[u3] = null;
      return f3;
    }, Un(Cn, Pn.BasePoint), Nn.prototype.point = function(t3, e4, r3) {
      return new Cn(this, t3, e4, r3);
    }, Nn.prototype.pointFromJSON = function(t3, e4) {
      return Cn.fromJSON(this, t3, e4);
    }, Cn.prototype._getBeta = function() {
      if (this.curve.endo) {
        var t3 = this.precomputed;
        if (t3 && t3.beta)
          return t3.beta;
        var e4 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (t3) {
          var r3 = this.curve, n3 = function(t4) {
            return r3.point(t4.x.redMul(r3.endo.beta), t4.y);
          };
          t3.beta = e4, e4.precomputed = { beta: null, naf: t3.naf && { wnd: t3.naf.wnd, points: t3.naf.points.map(n3) }, doubles: t3.doubles && { step: t3.doubles.step, points: t3.doubles.points.map(n3) } };
        }
        return e4;
      }
    }, Cn.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    }, Cn.fromJSON = function(t3, e4, r3) {
      "string" == typeof e4 && (e4 = JSON.parse(e4));
      var n3 = t3.point(e4[0], e4[1], r3);
      if (!e4[2])
        return n3;
      function i3(e6) {
        return t3.point(e6[0], e6[1], r3);
      }
      var o3 = e4[2];
      return n3.precomputed = { beta: null, doubles: o3.doubles && { step: o3.doubles.step, points: [n3].concat(o3.doubles.points.map(i3)) }, naf: o3.naf && { wnd: o3.naf.wnd, points: [n3].concat(o3.naf.points.map(i3)) } }, n3;
    }, Cn.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, Cn.prototype.isInfinity = function() {
      return this.inf;
    }, Cn.prototype.add = function(t3) {
      if (this.inf)
        return t3;
      if (t3.inf)
        return this;
      if (this.eq(t3))
        return this.dbl();
      if (this.neg().eq(t3))
        return this.curve.point(null, null);
      if (0 === this.x.cmp(t3.x))
        return this.curve.point(null, null);
      var e4 = this.y.redSub(t3.y);
      0 !== e4.cmpn(0) && (e4 = e4.redMul(this.x.redSub(t3.x).redInvm()));
      var r3 = e4.redSqr().redISub(this.x).redISub(t3.x), n3 = e4.redMul(this.x.redSub(r3)).redISub(this.y);
      return this.curve.point(r3, n3);
    }, Cn.prototype.dbl = function() {
      if (this.inf)
        return this;
      var t3 = this.y.redAdd(this.y);
      if (0 === t3.cmpn(0))
        return this.curve.point(null, null);
      var e4 = this.curve.a, r3 = this.x.redSqr(), n3 = t3.redInvm(), i3 = r3.redAdd(r3).redIAdd(r3).redIAdd(e4).redMul(n3), o3 = i3.redSqr().redISub(this.x.redAdd(this.x)), s3 = i3.redMul(this.x.redSub(o3)).redISub(this.y);
      return this.curve.point(o3, s3);
    }, Cn.prototype.getX = function() {
      return this.x.fromRed();
    }, Cn.prototype.getY = function() {
      return this.y.fromRed();
    }, Cn.prototype.mul = function(t3) {
      return t3 = new gn(t3, 16), this.isInfinity() ? this : this._hasDoubles(t3) ? this.curve._fixedNafMul(this, t3) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t3]) : this.curve._wnafMul(this, t3);
    }, Cn.prototype.mulAdd = function(t3, e4, r3) {
      var n3 = [this, e4], i3 = [t3, r3];
      return this.curve.endo ? this.curve._endoWnafMulAdd(n3, i3) : this.curve._wnafMulAdd(1, n3, i3, 2);
    }, Cn.prototype.jmulAdd = function(t3, e4, r3) {
      var n3 = [this, e4], i3 = [t3, r3];
      return this.curve.endo ? this.curve._endoWnafMulAdd(n3, i3, true) : this.curve._wnafMulAdd(1, n3, i3, 2, true);
    }, Cn.prototype.eq = function(t3) {
      return this === t3 || this.inf === t3.inf && (this.inf || 0 === this.x.cmp(t3.x) && 0 === this.y.cmp(t3.y));
    }, Cn.prototype.neg = function(t3) {
      if (this.inf)
        return this;
      var e4 = this.curve.point(this.x, this.y.redNeg());
      if (t3 && this.precomputed) {
        var r3 = this.precomputed, n3 = function(t4) {
          return t4.neg();
        };
        e4.precomputed = { naf: r3.naf && { wnd: r3.naf.wnd, points: r3.naf.points.map(n3) }, doubles: r3.doubles && { step: r3.doubles.step, points: r3.doubles.points.map(n3) } };
      }
      return e4;
    }, Cn.prototype.toJ = function() {
      return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
    }, Un(qn, Pn.BasePoint), Nn.prototype.jpoint = function(t3, e4, r3) {
      return new qn(this, t3, e4, r3);
    }, qn.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var t3 = this.z.redInvm(), e4 = t3.redSqr(), r3 = this.x.redMul(e4), n3 = this.y.redMul(e4).redMul(t3);
      return this.curve.point(r3, n3);
    }, qn.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, qn.prototype.add = function(t3) {
      if (this.isInfinity())
        return t3;
      if (t3.isInfinity())
        return this;
      var e4 = t3.z.redSqr(), r3 = this.z.redSqr(), n3 = this.x.redMul(e4), i3 = t3.x.redMul(r3), o3 = this.y.redMul(e4.redMul(t3.z)), s3 = t3.y.redMul(r3.redMul(this.z)), a3 = n3.redSub(i3), h3 = o3.redSub(s3);
      if (0 === a3.cmpn(0))
        return 0 !== h3.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var f3 = a3.redSqr(), u3 = f3.redMul(a3), c3 = n3.redMul(f3), d3 = h3.redSqr().redIAdd(u3).redISub(c3).redISub(c3), l3 = h3.redMul(c3.redISub(d3)).redISub(o3.redMul(u3)), p3 = this.z.redMul(t3.z).redMul(a3);
      return this.curve.jpoint(d3, l3, p3);
    }, qn.prototype.mixedAdd = function(t3) {
      if (this.isInfinity())
        return t3.toJ();
      if (t3.isInfinity())
        return this;
      var e4 = this.z.redSqr(), r3 = this.x, n3 = t3.x.redMul(e4), i3 = this.y, o3 = t3.y.redMul(e4).redMul(this.z), s3 = r3.redSub(n3), a3 = i3.redSub(o3);
      if (0 === s3.cmpn(0))
        return 0 !== a3.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var h3 = s3.redSqr(), f3 = h3.redMul(s3), u3 = r3.redMul(h3), c3 = a3.redSqr().redIAdd(f3).redISub(u3).redISub(u3), d3 = a3.redMul(u3.redISub(c3)).redISub(i3.redMul(f3)), l3 = this.z.redMul(s3);
      return this.curve.jpoint(c3, d3, l3);
    }, qn.prototype.dblp = function(t3) {
      if (0 === t3)
        return this;
      if (this.isInfinity())
        return this;
      if (!t3)
        return this.dbl();
      var e4;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (e4 = 0; e4 < t3; e4++)
          r3 = r3.dbl();
        return r3;
      }
      var n3 = this.curve.a, i3 = this.curve.tinv, o3 = this.x, s3 = this.y, a3 = this.z, h3 = a3.redSqr().redSqr(), f3 = s3.redAdd(s3);
      for (e4 = 0; e4 < t3; e4++) {
        var u3 = o3.redSqr(), c3 = f3.redSqr(), d3 = c3.redSqr(), l3 = u3.redAdd(u3).redIAdd(u3).redIAdd(n3.redMul(h3)), p3 = o3.redMul(c3), b3 = l3.redSqr().redISub(p3.redAdd(p3)), m3 = p3.redISub(b3), y3 = l3.redMul(m3);
        y3 = y3.redIAdd(y3).redISub(d3);
        var g2 = f3.redMul(a3);
        e4 + 1 < t3 && (h3 = h3.redMul(d3)), o3 = b3, a3 = g2, f3 = y3;
      }
      return this.curve.jpoint(o3, f3.redMul(i3), a3);
    }, qn.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    }, qn.prototype._zeroDbl = function() {
      var t3, e4, r3;
      if (this.zOne) {
        var n3 = this.x.redSqr(), i3 = this.y.redSqr(), o3 = i3.redSqr(), s3 = this.x.redAdd(i3).redSqr().redISub(n3).redISub(o3);
        s3 = s3.redIAdd(s3);
        var a3 = n3.redAdd(n3).redIAdd(n3), h3 = a3.redSqr().redISub(s3).redISub(s3), f3 = o3.redIAdd(o3);
        f3 = (f3 = f3.redIAdd(f3)).redIAdd(f3), t3 = h3, e4 = a3.redMul(s3.redISub(h3)).redISub(f3), r3 = this.y.redAdd(this.y);
      } else {
        var u3 = this.x.redSqr(), c3 = this.y.redSqr(), d3 = c3.redSqr(), l3 = this.x.redAdd(c3).redSqr().redISub(u3).redISub(d3);
        l3 = l3.redIAdd(l3);
        var p3 = u3.redAdd(u3).redIAdd(u3), b3 = p3.redSqr(), m3 = d3.redIAdd(d3);
        m3 = (m3 = m3.redIAdd(m3)).redIAdd(m3), t3 = b3.redISub(l3).redISub(l3), e4 = p3.redMul(l3.redISub(t3)).redISub(m3), r3 = (r3 = this.y.redMul(this.z)).redIAdd(r3);
      }
      return this.curve.jpoint(t3, e4, r3);
    }, qn.prototype._threeDbl = function() {
      var t3, e4, r3;
      if (this.zOne) {
        var n3 = this.x.redSqr(), i3 = this.y.redSqr(), o3 = i3.redSqr(), s3 = this.x.redAdd(i3).redSqr().redISub(n3).redISub(o3);
        s3 = s3.redIAdd(s3);
        var a3 = n3.redAdd(n3).redIAdd(n3).redIAdd(this.curve.a), h3 = a3.redSqr().redISub(s3).redISub(s3);
        t3 = h3;
        var f3 = o3.redIAdd(o3);
        f3 = (f3 = f3.redIAdd(f3)).redIAdd(f3), e4 = a3.redMul(s3.redISub(h3)).redISub(f3), r3 = this.y.redAdd(this.y);
      } else {
        var u3 = this.z.redSqr(), c3 = this.y.redSqr(), d3 = this.x.redMul(c3), l3 = this.x.redSub(u3).redMul(this.x.redAdd(u3));
        l3 = l3.redAdd(l3).redIAdd(l3);
        var p3 = d3.redIAdd(d3), b3 = (p3 = p3.redIAdd(p3)).redAdd(p3);
        t3 = l3.redSqr().redISub(b3), r3 = this.y.redAdd(this.z).redSqr().redISub(c3).redISub(u3);
        var m3 = c3.redSqr();
        m3 = (m3 = (m3 = m3.redIAdd(m3)).redIAdd(m3)).redIAdd(m3), e4 = l3.redMul(p3.redISub(t3)).redISub(m3);
      }
      return this.curve.jpoint(t3, e4, r3);
    }, qn.prototype._dbl = function() {
      var t3 = this.curve.a, e4 = this.x, r3 = this.y, n3 = this.z, i3 = n3.redSqr().redSqr(), o3 = e4.redSqr(), s3 = r3.redSqr(), a3 = o3.redAdd(o3).redIAdd(o3).redIAdd(t3.redMul(i3)), h3 = e4.redAdd(e4), f3 = (h3 = h3.redIAdd(h3)).redMul(s3), u3 = a3.redSqr().redISub(f3.redAdd(f3)), c3 = f3.redISub(u3), d3 = s3.redSqr();
      d3 = (d3 = (d3 = d3.redIAdd(d3)).redIAdd(d3)).redIAdd(d3);
      var l3 = a3.redMul(c3).redISub(d3), p3 = r3.redAdd(r3).redMul(n3);
      return this.curve.jpoint(u3, l3, p3);
    }, qn.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var t3 = this.x.redSqr(), e4 = this.y.redSqr(), r3 = this.z.redSqr(), n3 = e4.redSqr(), i3 = t3.redAdd(t3).redIAdd(t3), o3 = i3.redSqr(), s3 = this.x.redAdd(e4).redSqr().redISub(t3).redISub(n3), a3 = (s3 = (s3 = (s3 = s3.redIAdd(s3)).redAdd(s3).redIAdd(s3)).redISub(o3)).redSqr(), h3 = n3.redIAdd(n3);
      h3 = (h3 = (h3 = h3.redIAdd(h3)).redIAdd(h3)).redIAdd(h3);
      var f3 = i3.redIAdd(s3).redSqr().redISub(o3).redISub(a3).redISub(h3), u3 = e4.redMul(f3);
      u3 = (u3 = u3.redIAdd(u3)).redIAdd(u3);
      var c3 = this.x.redMul(a3).redISub(u3);
      c3 = (c3 = c3.redIAdd(c3)).redIAdd(c3);
      var d3 = this.y.redMul(f3.redMul(h3.redISub(f3)).redISub(s3.redMul(a3)));
      d3 = (d3 = (d3 = d3.redIAdd(d3)).redIAdd(d3)).redIAdd(d3);
      var l3 = this.z.redAdd(s3).redSqr().redISub(r3).redISub(a3);
      return this.curve.jpoint(c3, d3, l3);
    }, qn.prototype.mul = function(t3, e4) {
      return t3 = new gn(t3, e4), this.curve._wnafMul(this, t3);
    }, qn.prototype.eq = function(t3) {
      if ("affine" === t3.type)
        return this.eq(t3.toJ());
      if (this === t3)
        return true;
      var e4 = this.z.redSqr(), r3 = t3.z.redSqr();
      if (0 !== this.x.redMul(r3).redISub(t3.x.redMul(e4)).cmpn(0))
        return false;
      var n3 = e4.redMul(this.z), i3 = r3.redMul(t3.z);
      return 0 === this.y.redMul(i3).redISub(t3.y.redMul(n3)).cmpn(0);
    }, qn.prototype.eqXToP = function(t3) {
      var e4 = this.z.redSqr(), r3 = t3.toRed(this.curve.red).redMul(e4);
      if (0 === this.x.cmp(r3))
        return true;
      for (var n3 = t3.clone(), i3 = this.curve.redN.redMul(e4); ; ) {
        if (n3.iadd(this.curve.n), n3.cmp(this.curve.p) >= 0)
          return false;
        if (r3.redIAdd(i3), 0 === this.x.cmp(r3))
          return true;
      }
    }, qn.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, qn.prototype.isInfinity = function() {
      return 0 === this.z.cmpn(0);
    }, Un(jn, Pn);
    var Dn = jn;
    function Fn(t3, e4, r3) {
      Pn.BasePoint.call(this, t3, "projective"), null === e4 && null === r3 ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new gn(e4, 16), this.z = new gn(r3, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    jn.prototype.validate = function(t3) {
      var e4 = t3.normalize().x, r3 = e4.redSqr(), n3 = r3.redMul(e4).redAdd(r3.redMul(this.a)).redAdd(e4);
      return 0 === n3.redSqrt().redSqr().cmp(n3);
    }, Un(Fn, Pn.BasePoint), jn.prototype.decodePoint = function(t3, e4) {
      return this.point(An.toArray(t3, e4), 1);
    }, jn.prototype.point = function(t3, e4) {
      return new Fn(this, t3, e4);
    }, jn.prototype.pointFromJSON = function(t3) {
      return Fn.fromJSON(this, t3);
    }, Fn.prototype.precompute = function() {
    }, Fn.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    }, Fn.fromJSON = function(t3, e4) {
      return new Fn(t3, e4[0], e4[1] || t3.one);
    }, Fn.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, Fn.prototype.isInfinity = function() {
      return 0 === this.z.cmpn(0);
    }, Fn.prototype.dbl = function() {
      var t3 = this.x.redAdd(this.z).redSqr(), e4 = this.x.redSub(this.z).redSqr(), r3 = t3.redSub(e4), n3 = t3.redMul(e4), i3 = r3.redMul(e4.redAdd(this.curve.a24.redMul(r3)));
      return this.curve.point(n3, i3);
    }, Fn.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    }, Fn.prototype.diffAdd = function(t3, e4) {
      var r3 = this.x.redAdd(this.z), n3 = this.x.redSub(this.z), i3 = t3.x.redAdd(t3.z), o3 = t3.x.redSub(t3.z).redMul(r3), s3 = i3.redMul(n3), a3 = e4.z.redMul(o3.redAdd(s3).redSqr()), h3 = e4.x.redMul(o3.redISub(s3).redSqr());
      return this.curve.point(a3, h3);
    }, Fn.prototype.mul = function(t3) {
      for (var e4 = t3.clone(), r3 = this, n3 = this.curve.point(null, null), i3 = []; 0 !== e4.cmpn(0); e4.iushrn(1))
        i3.push(e4.andln(1));
      for (var o3 = i3.length - 1; o3 >= 0; o3--)
        0 === i3[o3] ? (r3 = r3.diffAdd(n3, this), n3 = n3.dbl()) : (n3 = r3.diffAdd(n3, this), r3 = r3.dbl());
      return n3;
    }, Fn.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    }, Fn.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    }, Fn.prototype.eq = function(t3) {
      return 0 === this.getX().cmp(t3.getX());
    }, Fn.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, Fn.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    var Kn = An.assert;
    function Yn(t3) {
      this.twisted = 1 != (0 | t3.a), this.mOneA = this.twisted && -1 == (0 | t3.a), this.extended = this.mOneA, Pn.call(this, "edwards", t3), this.a = new gn(t3.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new gn(t3.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new gn(t3.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Kn(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 == (0 | t3.c);
    }
    Un(Yn, Pn);
    var Vn = Yn;
    function Wn(t3, e4, r3, n3, i3) {
      Pn.BasePoint.call(this, t3, "projective"), null === e4 && null === r3 && null === n3 ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new gn(e4, 16), this.y = new gn(r3, 16), this.z = n3 ? new gn(n3, 16) : this.curve.one, this.t = i3 && new gn(i3, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    Yn.prototype._mulA = function(t3) {
      return this.mOneA ? t3.redNeg() : this.a.redMul(t3);
    }, Yn.prototype._mulC = function(t3) {
      return this.oneC ? t3 : this.c.redMul(t3);
    }, Yn.prototype.jpoint = function(t3, e4, r3, n3) {
      return this.point(t3, e4, r3, n3);
    }, Yn.prototype.pointFromX = function(t3, e4) {
      (t3 = new gn(t3, 16)).red || (t3 = t3.toRed(this.red));
      var r3 = t3.redSqr(), n3 = this.c2.redSub(this.a.redMul(r3)), i3 = this.one.redSub(this.c2.redMul(this.d).redMul(r3)), o3 = n3.redMul(i3.redInvm()), s3 = o3.redSqrt();
      if (0 !== s3.redSqr().redSub(o3).cmp(this.zero))
        throw new Error("invalid point");
      var a3 = s3.fromRed().isOdd();
      return (e4 && !a3 || !e4 && a3) && (s3 = s3.redNeg()), this.point(t3, s3);
    }, Yn.prototype.pointFromY = function(t3, e4) {
      (t3 = new gn(t3, 16)).red || (t3 = t3.toRed(this.red));
      var r3 = t3.redSqr(), n3 = r3.redSub(this.c2), i3 = r3.redMul(this.d).redMul(this.c2).redSub(this.a), o3 = n3.redMul(i3.redInvm());
      if (0 === o3.cmp(this.zero)) {
        if (e4)
          throw new Error("invalid point");
        return this.point(this.zero, t3);
      }
      var s3 = o3.redSqrt();
      if (0 !== s3.redSqr().redSub(o3).cmp(this.zero))
        throw new Error("invalid point");
      return s3.fromRed().isOdd() !== e4 && (s3 = s3.redNeg()), this.point(s3, t3);
    }, Yn.prototype.validate = function(t3) {
      if (t3.isInfinity())
        return true;
      t3.normalize();
      var e4 = t3.x.redSqr(), r3 = t3.y.redSqr(), n3 = e4.redMul(this.a).redAdd(r3), i3 = this.c2.redMul(this.one.redAdd(this.d.redMul(e4).redMul(r3)));
      return 0 === n3.cmp(i3);
    }, Un(Wn, Pn.BasePoint), Yn.prototype.pointFromJSON = function(t3) {
      return Wn.fromJSON(this, t3);
    }, Yn.prototype.point = function(t3, e4, r3, n3) {
      return new Wn(this, t3, e4, r3, n3);
    }, Wn.fromJSON = function(t3, e4) {
      return new Wn(t3, e4[0], e4[1], e4[2]);
    }, Wn.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, Wn.prototype.isInfinity = function() {
      return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
    }, Wn.prototype._extDbl = function() {
      var t3 = this.x.redSqr(), e4 = this.y.redSqr(), r3 = this.z.redSqr();
      r3 = r3.redIAdd(r3);
      var n3 = this.curve._mulA(t3), i3 = this.x.redAdd(this.y).redSqr().redISub(t3).redISub(e4), o3 = n3.redAdd(e4), s3 = o3.redSub(r3), a3 = n3.redSub(e4), h3 = i3.redMul(s3), f3 = o3.redMul(a3), u3 = i3.redMul(a3), c3 = s3.redMul(o3);
      return this.curve.point(h3, f3, c3, u3);
    }, Wn.prototype._projDbl = function() {
      var t3, e4, r3, n3, i3, o3, s3 = this.x.redAdd(this.y).redSqr(), a3 = this.x.redSqr(), h3 = this.y.redSqr();
      if (this.curve.twisted) {
        var f3 = (n3 = this.curve._mulA(a3)).redAdd(h3);
        this.zOne ? (t3 = s3.redSub(a3).redSub(h3).redMul(f3.redSub(this.curve.two)), e4 = f3.redMul(n3.redSub(h3)), r3 = f3.redSqr().redSub(f3).redSub(f3)) : (i3 = this.z.redSqr(), o3 = f3.redSub(i3).redISub(i3), t3 = s3.redSub(a3).redISub(h3).redMul(o3), e4 = f3.redMul(n3.redSub(h3)), r3 = f3.redMul(o3));
      } else
        n3 = a3.redAdd(h3), i3 = this.curve._mulC(this.z).redSqr(), o3 = n3.redSub(i3).redSub(i3), t3 = this.curve._mulC(s3.redISub(n3)).redMul(o3), e4 = this.curve._mulC(n3).redMul(a3.redISub(h3)), r3 = n3.redMul(o3);
      return this.curve.point(t3, e4, r3);
    }, Wn.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    }, Wn.prototype._extAdd = function(t3) {
      var e4 = this.y.redSub(this.x).redMul(t3.y.redSub(t3.x)), r3 = this.y.redAdd(this.x).redMul(t3.y.redAdd(t3.x)), n3 = this.t.redMul(this.curve.dd).redMul(t3.t), i3 = this.z.redMul(t3.z.redAdd(t3.z)), o3 = r3.redSub(e4), s3 = i3.redSub(n3), a3 = i3.redAdd(n3), h3 = r3.redAdd(e4), f3 = o3.redMul(s3), u3 = a3.redMul(h3), c3 = o3.redMul(h3), d3 = s3.redMul(a3);
      return this.curve.point(f3, u3, d3, c3);
    }, Wn.prototype._projAdd = function(t3) {
      var e4, r3, n3 = this.z.redMul(t3.z), i3 = n3.redSqr(), o3 = this.x.redMul(t3.x), s3 = this.y.redMul(t3.y), a3 = this.curve.d.redMul(o3).redMul(s3), h3 = i3.redSub(a3), f3 = i3.redAdd(a3), u3 = this.x.redAdd(this.y).redMul(t3.x.redAdd(t3.y)).redISub(o3).redISub(s3), c3 = n3.redMul(h3).redMul(u3);
      return this.curve.twisted ? (e4 = n3.redMul(f3).redMul(s3.redSub(this.curve._mulA(o3))), r3 = h3.redMul(f3)) : (e4 = n3.redMul(f3).redMul(s3.redSub(o3)), r3 = this.curve._mulC(h3).redMul(f3)), this.curve.point(c3, e4, r3);
    }, Wn.prototype.add = function(t3) {
      return this.isInfinity() ? t3 : t3.isInfinity() ? this : this.curve.extended ? this._extAdd(t3) : this._projAdd(t3);
    }, Wn.prototype.mul = function(t3) {
      return this._hasDoubles(t3) ? this.curve._fixedNafMul(this, t3) : this.curve._wnafMul(this, t3);
    }, Wn.prototype.mulAdd = function(t3, e4, r3) {
      return this.curve._wnafMulAdd(1, [this, e4], [t3, r3], 2, false);
    }, Wn.prototype.jmulAdd = function(t3, e4, r3) {
      return this.curve._wnafMulAdd(1, [this, e4], [t3, r3], 2, true);
    }, Wn.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var t3 = this.z.redInvm();
      return this.x = this.x.redMul(t3), this.y = this.y.redMul(t3), this.t && (this.t = this.t.redMul(t3)), this.z = this.curve.one, this.zOne = true, this;
    }, Wn.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, Wn.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    }, Wn.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    }, Wn.prototype.eq = function(t3) {
      return this === t3 || 0 === this.getX().cmp(t3.getX()) && 0 === this.getY().cmp(t3.getY());
    }, Wn.prototype.eqXToP = function(t3) {
      var e4 = t3.toRed(this.curve.red).redMul(this.z);
      if (0 === this.x.cmp(e4))
        return true;
      for (var r3 = t3.clone(), n3 = this.curve.redN.redMul(this.z); ; ) {
        if (r3.iadd(this.curve.n), r3.cmp(this.curve.p) >= 0)
          return false;
        if (e4.redIAdd(n3), 0 === this.x.cmp(e4))
          return true;
      }
    }, Wn.prototype.toP = Wn.prototype.normalize, Wn.prototype.mixedAdd = Wn.prototype.add;
    var Hn = Qt(function(t3, e4) {
      var r3 = e4;
      r3.base = Pn, r3.short = zn, r3.mont = Dn, r3.edwards = Vn;
    });
    function $n(t3, e4) {
      return 55296 == (64512 & t3.charCodeAt(e4)) && (!(e4 < 0 || e4 + 1 >= t3.length) && 56320 == (64512 & t3.charCodeAt(e4 + 1)));
    }
    function Gn(t3) {
      return (t3 >>> 24 | t3 >>> 8 & 65280 | t3 << 8 & 16711680 | (255 & t3) << 24) >>> 0;
    }
    function Zn(t3) {
      return 1 === t3.length ? "0" + t3 : t3;
    }
    function Jn(t3) {
      return 7 === t3.length ? "0" + t3 : 6 === t3.length ? "00" + t3 : 5 === t3.length ? "000" + t3 : 4 === t3.length ? "0000" + t3 : 3 === t3.length ? "00000" + t3 : 2 === t3.length ? "000000" + t3 : 1 === t3.length ? "0000000" + t3 : t3;
    }
    var Xn = { inherits: Un, toArray: function(t3, e4) {
      if (Array.isArray(t3))
        return t3.slice();
      if (!t3)
        return [];
      var r3 = [];
      if ("string" == typeof t3)
        if (e4) {
          if ("hex" === e4)
            for ((t3 = t3.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t3 = "0" + t3), i3 = 0; i3 < t3.length; i3 += 2)
              r3.push(parseInt(t3[i3] + t3[i3 + 1], 16));
        } else
          for (var n3 = 0, i3 = 0; i3 < t3.length; i3++) {
            var o3 = t3.charCodeAt(i3);
            o3 < 128 ? r3[n3++] = o3 : o3 < 2048 ? (r3[n3++] = o3 >> 6 | 192, r3[n3++] = 63 & o3 | 128) : $n(t3, i3) ? (o3 = 65536 + ((1023 & o3) << 10) + (1023 & t3.charCodeAt(++i3)), r3[n3++] = o3 >> 18 | 240, r3[n3++] = o3 >> 12 & 63 | 128, r3[n3++] = o3 >> 6 & 63 | 128, r3[n3++] = 63 & o3 | 128) : (r3[n3++] = o3 >> 12 | 224, r3[n3++] = o3 >> 6 & 63 | 128, r3[n3++] = 63 & o3 | 128);
          }
      else
        for (i3 = 0; i3 < t3.length; i3++)
          r3[i3] = 0 | t3[i3];
      return r3;
    }, toHex: function(t3) {
      for (var e4 = "", r3 = 0; r3 < t3.length; r3++)
        e4 += Zn(t3[r3].toString(16));
      return e4;
    }, htonl: Gn, toHex32: function(t3, e4) {
      for (var r3 = "", n3 = 0; n3 < t3.length; n3++) {
        var i3 = t3[n3];
        "little" === e4 && (i3 = Gn(i3)), r3 += Jn(i3.toString(16));
      }
      return r3;
    }, zero2: Zn, zero8: Jn, join32: function(t3, e4, r3, n3) {
      var i3 = r3 - e4;
      vn(i3 % 4 == 0);
      for (var o3 = new Array(i3 / 4), s3 = 0, a3 = e4; s3 < o3.length; s3++, a3 += 4) {
        var h3;
        h3 = "big" === n3 ? t3[a3] << 24 | t3[a3 + 1] << 16 | t3[a3 + 2] << 8 | t3[a3 + 3] : t3[a3 + 3] << 24 | t3[a3 + 2] << 16 | t3[a3 + 1] << 8 | t3[a3], o3[s3] = h3 >>> 0;
      }
      return o3;
    }, split32: function(t3, e4) {
      for (var r3 = new Array(4 * t3.length), n3 = 0, i3 = 0; n3 < t3.length; n3++, i3 += 4) {
        var o3 = t3[n3];
        "big" === e4 ? (r3[i3] = o3 >>> 24, r3[i3 + 1] = o3 >>> 16 & 255, r3[i3 + 2] = o3 >>> 8 & 255, r3[i3 + 3] = 255 & o3) : (r3[i3 + 3] = o3 >>> 24, r3[i3 + 2] = o3 >>> 16 & 255, r3[i3 + 1] = o3 >>> 8 & 255, r3[i3] = 255 & o3);
      }
      return r3;
    }, rotr32: function(t3, e4) {
      return t3 >>> e4 | t3 << 32 - e4;
    }, rotl32: function(t3, e4) {
      return t3 << e4 | t3 >>> 32 - e4;
    }, sum32: function(t3, e4) {
      return t3 + e4 >>> 0;
    }, sum32_3: function(t3, e4, r3) {
      return t3 + e4 + r3 >>> 0;
    }, sum32_4: function(t3, e4, r3, n3) {
      return t3 + e4 + r3 + n3 >>> 0;
    }, sum32_5: function(t3, e4, r3, n3, i3) {
      return t3 + e4 + r3 + n3 + i3 >>> 0;
    }, sum64: function(t3, e4, r3, n3) {
      var i3 = t3[e4], o3 = n3 + t3[e4 + 1] >>> 0, s3 = (o3 < n3 ? 1 : 0) + r3 + i3;
      t3[e4] = s3 >>> 0, t3[e4 + 1] = o3;
    }, sum64_hi: function(t3, e4, r3, n3) {
      return (e4 + n3 >>> 0 < e4 ? 1 : 0) + t3 + r3 >>> 0;
    }, sum64_lo: function(t3, e4, r3, n3) {
      return e4 + n3 >>> 0;
    }, sum64_4_hi: function(t3, e4, r3, n3, i3, o3, s3, a3) {
      var h3 = 0, f3 = e4;
      return h3 += (f3 = f3 + n3 >>> 0) < e4 ? 1 : 0, h3 += (f3 = f3 + o3 >>> 0) < o3 ? 1 : 0, t3 + r3 + i3 + s3 + (h3 += (f3 = f3 + a3 >>> 0) < a3 ? 1 : 0) >>> 0;
    }, sum64_4_lo: function(t3, e4, r3, n3, i3, o3, s3, a3) {
      return e4 + n3 + o3 + a3 >>> 0;
    }, sum64_5_hi: function(t3, e4, r3, n3, i3, o3, s3, a3, h3, f3) {
      var u3 = 0, c3 = e4;
      return u3 += (c3 = c3 + n3 >>> 0) < e4 ? 1 : 0, u3 += (c3 = c3 + o3 >>> 0) < o3 ? 1 : 0, u3 += (c3 = c3 + a3 >>> 0) < a3 ? 1 : 0, t3 + r3 + i3 + s3 + h3 + (u3 += (c3 = c3 + f3 >>> 0) < f3 ? 1 : 0) >>> 0;
    }, sum64_5_lo: function(t3, e4, r3, n3, i3, o3, s3, a3, h3, f3) {
      return e4 + n3 + o3 + a3 + f3 >>> 0;
    }, rotr64_hi: function(t3, e4, r3) {
      return (e4 << 32 - r3 | t3 >>> r3) >>> 0;
    }, rotr64_lo: function(t3, e4, r3) {
      return (t3 << 32 - r3 | e4 >>> r3) >>> 0;
    }, shr64_hi: function(t3, e4, r3) {
      return t3 >>> r3;
    }, shr64_lo: function(t3, e4, r3) {
      return (t3 << 32 - r3 | e4 >>> r3) >>> 0;
    } };
    function Qn() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    var ti2 = Qn;
    Qn.prototype.update = function(t3, e4) {
      if (t3 = Xn.toArray(t3, e4), this.pending ? this.pending = this.pending.concat(t3) : this.pending = t3, this.pendingTotal += t3.length, this.pending.length >= this._delta8) {
        var r3 = (t3 = this.pending).length % this._delta8;
        this.pending = t3.slice(t3.length - r3, t3.length), 0 === this.pending.length && (this.pending = null), t3 = Xn.join32(t3, 0, t3.length - r3, this.endian);
        for (var n3 = 0; n3 < t3.length; n3 += this._delta32)
          this._update(t3, n3, n3 + this._delta32);
      }
      return this;
    }, Qn.prototype.digest = function(t3) {
      return this.update(this._pad()), vn(null === this.pending), this._digest(t3);
    }, Qn.prototype._pad = function() {
      var t3 = this.pendingTotal, e4 = this._delta8, r3 = e4 - (t3 + this.padLength) % e4, n3 = new Array(r3 + this.padLength);
      n3[0] = 128;
      for (var i3 = 1; i3 < r3; i3++)
        n3[i3] = 0;
      if (t3 <<= 3, "big" === this.endian) {
        for (var o3 = 8; o3 < this.padLength; o3++)
          n3[i3++] = 0;
        n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = t3 >>> 24 & 255, n3[i3++] = t3 >>> 16 & 255, n3[i3++] = t3 >>> 8 & 255, n3[i3++] = 255 & t3;
      } else
        for (n3[i3++] = 255 & t3, n3[i3++] = t3 >>> 8 & 255, n3[i3++] = t3 >>> 16 & 255, n3[i3++] = t3 >>> 24 & 255, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, o3 = 8; o3 < this.padLength; o3++)
          n3[i3++] = 0;
      return n3;
    };
    var ei2 = { BlockHash: ti2 }, ri2 = Xn.rotr32;
    function ni2(t3, e4, r3) {
      return t3 & e4 ^ ~t3 & r3;
    }
    function ii2(t3, e4, r3) {
      return t3 & e4 ^ t3 & r3 ^ e4 & r3;
    }
    function oi2(t3, e4, r3) {
      return t3 ^ e4 ^ r3;
    }
    var si2 = { ft_1: function(t3, e4, r3, n3) {
      return 0 === t3 ? ni2(e4, r3, n3) : 1 === t3 || 3 === t3 ? oi2(e4, r3, n3) : 2 === t3 ? ii2(e4, r3, n3) : void 0;
    }, ch32: ni2, maj32: ii2, p32: oi2, s0_256: function(t3) {
      return ri2(t3, 2) ^ ri2(t3, 13) ^ ri2(t3, 22);
    }, s1_256: function(t3) {
      return ri2(t3, 6) ^ ri2(t3, 11) ^ ri2(t3, 25);
    }, g0_256: function(t3) {
      return ri2(t3, 7) ^ ri2(t3, 18) ^ t3 >>> 3;
    }, g1_256: function(t3) {
      return ri2(t3, 17) ^ ri2(t3, 19) ^ t3 >>> 10;
    } }, ai2 = Xn.rotl32, hi2 = Xn.sum32, fi2 = Xn.sum32_5, ui2 = si2.ft_1, ci2 = ei2.BlockHash, di2 = [1518500249, 1859775393, 2400959708, 3395469782];
    function li2() {
      if (!(this instanceof li2))
        return new li2();
      ci2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    Xn.inherits(li2, ci2);
    var pi2 = li2;
    li2.blockSize = 512, li2.outSize = 160, li2.hmacStrength = 80, li2.padLength = 64, li2.prototype._update = function(t3, e4) {
      for (var r3 = this.W, n3 = 0; n3 < 16; n3++)
        r3[n3] = t3[e4 + n3];
      for (; n3 < r3.length; n3++)
        r3[n3] = ai2(r3[n3 - 3] ^ r3[n3 - 8] ^ r3[n3 - 14] ^ r3[n3 - 16], 1);
      var i3 = this.h[0], o3 = this.h[1], s3 = this.h[2], a3 = this.h[3], h3 = this.h[4];
      for (n3 = 0; n3 < r3.length; n3++) {
        var f3 = ~~(n3 / 20), u3 = fi2(ai2(i3, 5), ui2(f3, o3, s3, a3), h3, r3[n3], di2[f3]);
        h3 = a3, a3 = s3, s3 = ai2(o3, 30), o3 = i3, i3 = u3;
      }
      this.h[0] = hi2(this.h[0], i3), this.h[1] = hi2(this.h[1], o3), this.h[2] = hi2(this.h[2], s3), this.h[3] = hi2(this.h[3], a3), this.h[4] = hi2(this.h[4], h3);
    }, li2.prototype._digest = function(t3) {
      return "hex" === t3 ? Xn.toHex32(this.h, "big") : Xn.split32(this.h, "big");
    };
    var bi2 = Xn.sum32, mi2 = Xn.sum32_4, yi2 = Xn.sum32_5, gi2 = si2.ch32, vi2 = si2.maj32, wi2 = si2.s0_256, Mi2 = si2.s1_256, _i = si2.g0_256, Ai2 = si2.g1_256, Si2 = ei2.BlockHash, Ei2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function xi2() {
      if (!(this instanceof xi2))
        return new xi2();
      Si2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = Ei2, this.W = new Array(64);
    }
    Xn.inherits(xi2, Si2);
    var Ii2 = xi2;
    function ki2() {
      if (!(this instanceof ki2))
        return new ki2();
      Ii2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    xi2.blockSize = 512, xi2.outSize = 256, xi2.hmacStrength = 192, xi2.padLength = 64, xi2.prototype._update = function(t3, e4) {
      for (var r3 = this.W, n3 = 0; n3 < 16; n3++)
        r3[n3] = t3[e4 + n3];
      for (; n3 < r3.length; n3++)
        r3[n3] = mi2(Ai2(r3[n3 - 2]), r3[n3 - 7], _i(r3[n3 - 15]), r3[n3 - 16]);
      var i3 = this.h[0], o3 = this.h[1], s3 = this.h[2], a3 = this.h[3], h3 = this.h[4], f3 = this.h[5], u3 = this.h[6], c3 = this.h[7];
      for (vn(this.k.length === r3.length), n3 = 0; n3 < r3.length; n3++) {
        var d3 = yi2(c3, Mi2(h3), gi2(h3, f3, u3), this.k[n3], r3[n3]), l3 = bi2(wi2(i3), vi2(i3, o3, s3));
        c3 = u3, u3 = f3, f3 = h3, h3 = bi2(a3, d3), a3 = s3, s3 = o3, o3 = i3, i3 = bi2(d3, l3);
      }
      this.h[0] = bi2(this.h[0], i3), this.h[1] = bi2(this.h[1], o3), this.h[2] = bi2(this.h[2], s3), this.h[3] = bi2(this.h[3], a3), this.h[4] = bi2(this.h[4], h3), this.h[5] = bi2(this.h[5], f3), this.h[6] = bi2(this.h[6], u3), this.h[7] = bi2(this.h[7], c3);
    }, xi2.prototype._digest = function(t3) {
      return "hex" === t3 ? Xn.toHex32(this.h, "big") : Xn.split32(this.h, "big");
    }, Xn.inherits(ki2, Ii2);
    var Ri2 = ki2;
    ki2.blockSize = 512, ki2.outSize = 224, ki2.hmacStrength = 192, ki2.padLength = 64, ki2.prototype._digest = function(t3) {
      return "hex" === t3 ? Xn.toHex32(this.h.slice(0, 7), "big") : Xn.split32(this.h.slice(0, 7), "big");
    };
    var Ti2 = Xn.rotr64_hi, Bi2 = Xn.rotr64_lo, Pi2 = Xn.shr64_hi, Oi2 = Xn.shr64_lo, Ui2 = Xn.sum64, Li2 = Xn.sum64_hi, Ni2 = Xn.sum64_lo, zi2 = Xn.sum64_4_hi, Ci2 = Xn.sum64_4_lo, qi2 = Xn.sum64_5_hi, ji2 = Xn.sum64_5_lo, Di2 = ei2.BlockHash, Fi2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Ki2() {
      if (!(this instanceof Ki2))
        return new Ki2();
      Di2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = Fi2, this.W = new Array(160);
    }
    Xn.inherits(Ki2, Di2);
    var Yi2 = Ki2;
    function Vi2(t3, e4, r3, n3, i3) {
      var o3 = t3 & r3 ^ ~t3 & i3;
      return o3 < 0 && (o3 += 4294967296), o3;
    }
    function Wi2(t3, e4, r3, n3, i3, o3) {
      var s3 = e4 & n3 ^ ~e4 & o3;
      return s3 < 0 && (s3 += 4294967296), s3;
    }
    function Hi2(t3, e4, r3, n3, i3) {
      var o3 = t3 & r3 ^ t3 & i3 ^ r3 & i3;
      return o3 < 0 && (o3 += 4294967296), o3;
    }
    function $i2(t3, e4, r3, n3, i3, o3) {
      var s3 = e4 & n3 ^ e4 & o3 ^ n3 & o3;
      return s3 < 0 && (s3 += 4294967296), s3;
    }
    function Gi2(t3, e4) {
      var r3 = Ti2(t3, e4, 28) ^ Ti2(e4, t3, 2) ^ Ti2(e4, t3, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Zi2(t3, e4) {
      var r3 = Bi2(t3, e4, 28) ^ Bi2(e4, t3, 2) ^ Bi2(e4, t3, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Ji2(t3, e4) {
      var r3 = Ti2(t3, e4, 14) ^ Ti2(t3, e4, 18) ^ Ti2(e4, t3, 9);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Xi2(t3, e4) {
      var r3 = Bi2(t3, e4, 14) ^ Bi2(t3, e4, 18) ^ Bi2(e4, t3, 9);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Qi2(t3, e4) {
      var r3 = Ti2(t3, e4, 1) ^ Ti2(t3, e4, 8) ^ Pi2(t3, e4, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function to(t3, e4) {
      var r3 = Bi2(t3, e4, 1) ^ Bi2(t3, e4, 8) ^ Oi2(t3, e4, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function eo(t3, e4) {
      var r3 = Ti2(t3, e4, 19) ^ Ti2(e4, t3, 29) ^ Pi2(t3, e4, 6);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function ro(t3, e4) {
      var r3 = Bi2(t3, e4, 19) ^ Bi2(e4, t3, 29) ^ Oi2(t3, e4, 6);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function no() {
      if (!(this instanceof no))
        return new no();
      Yi2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Ki2.blockSize = 1024, Ki2.outSize = 512, Ki2.hmacStrength = 192, Ki2.padLength = 128, Ki2.prototype._prepareBlock = function(t3, e4) {
      for (var r3 = this.W, n3 = 0; n3 < 32; n3++)
        r3[n3] = t3[e4 + n3];
      for (; n3 < r3.length; n3 += 2) {
        var i3 = eo(r3[n3 - 4], r3[n3 - 3]), o3 = ro(r3[n3 - 4], r3[n3 - 3]), s3 = r3[n3 - 14], a3 = r3[n3 - 13], h3 = Qi2(r3[n3 - 30], r3[n3 - 29]), f3 = to(r3[n3 - 30], r3[n3 - 29]), u3 = r3[n3 - 32], c3 = r3[n3 - 31];
        r3[n3] = zi2(i3, o3, s3, a3, h3, f3, u3, c3), r3[n3 + 1] = Ci2(i3, o3, s3, a3, h3, f3, u3, c3);
      }
    }, Ki2.prototype._update = function(t3, e4) {
      this._prepareBlock(t3, e4);
      var r3 = this.W, n3 = this.h[0], i3 = this.h[1], o3 = this.h[2], s3 = this.h[3], a3 = this.h[4], h3 = this.h[5], f3 = this.h[6], u3 = this.h[7], c3 = this.h[8], d3 = this.h[9], l3 = this.h[10], p3 = this.h[11], b3 = this.h[12], m3 = this.h[13], y3 = this.h[14], g2 = this.h[15];
      vn(this.k.length === r3.length);
      for (var v3 = 0; v3 < r3.length; v3 += 2) {
        var w3 = y3, M3 = g2, _3 = Ji2(c3, d3), A3 = Xi2(c3, d3), S3 = Vi2(c3, d3, l3, p3, b3), E3 = Wi2(c3, d3, l3, p3, b3, m3), x3 = this.k[v3], I3 = this.k[v3 + 1], k3 = r3[v3], R3 = r3[v3 + 1], T3 = qi2(w3, M3, _3, A3, S3, E3, x3, I3, k3, R3), B3 = ji2(w3, M3, _3, A3, S3, E3, x3, I3, k3, R3);
        w3 = Gi2(n3, i3), M3 = Zi2(n3, i3), _3 = Hi2(n3, i3, o3, s3, a3), A3 = $i2(n3, i3, o3, s3, a3, h3);
        var P3 = Li2(w3, M3, _3, A3), O3 = Ni2(w3, M3, _3, A3);
        y3 = b3, g2 = m3, b3 = l3, m3 = p3, l3 = c3, p3 = d3, c3 = Li2(f3, u3, T3, B3), d3 = Ni2(u3, u3, T3, B3), f3 = a3, u3 = h3, a3 = o3, h3 = s3, o3 = n3, s3 = i3, n3 = Li2(T3, B3, P3, O3), i3 = Ni2(T3, B3, P3, O3);
      }
      Ui2(this.h, 0, n3, i3), Ui2(this.h, 2, o3, s3), Ui2(this.h, 4, a3, h3), Ui2(this.h, 6, f3, u3), Ui2(this.h, 8, c3, d3), Ui2(this.h, 10, l3, p3), Ui2(this.h, 12, b3, m3), Ui2(this.h, 14, y3, g2);
    }, Ki2.prototype._digest = function(t3) {
      return "hex" === t3 ? Xn.toHex32(this.h, "big") : Xn.split32(this.h, "big");
    }, Xn.inherits(no, Yi2);
    var io = no;
    no.blockSize = 1024, no.outSize = 384, no.hmacStrength = 192, no.padLength = 128, no.prototype._digest = function(t3) {
      return "hex" === t3 ? Xn.toHex32(this.h.slice(0, 12), "big") : Xn.split32(this.h.slice(0, 12), "big");
    };
    var oo = { sha1: pi2, sha224: Ri2, sha256: Ii2, sha384: io, sha512: Yi2 }, so = Xn.rotl32, ao = Xn.sum32, ho = Xn.sum32_3, fo = Xn.sum32_4, uo = ei2.BlockHash;
    function co() {
      if (!(this instanceof co))
        return new co();
      uo.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    Xn.inherits(co, uo);
    var lo = co;
    function po(t3, e4, r3, n3) {
      return t3 <= 15 ? e4 ^ r3 ^ n3 : t3 <= 31 ? e4 & r3 | ~e4 & n3 : t3 <= 47 ? (e4 | ~r3) ^ n3 : t3 <= 63 ? e4 & n3 | r3 & ~n3 : e4 ^ (r3 | ~n3);
    }
    function bo(t3) {
      return t3 <= 15 ? 0 : t3 <= 31 ? 1518500249 : t3 <= 47 ? 1859775393 : t3 <= 63 ? 2400959708 : 2840853838;
    }
    function mo(t3) {
      return t3 <= 15 ? 1352829926 : t3 <= 31 ? 1548603684 : t3 <= 47 ? 1836072691 : t3 <= 63 ? 2053994217 : 0;
    }
    co.blockSize = 512, co.outSize = 160, co.hmacStrength = 192, co.padLength = 64, co.prototype._update = function(t3, e4) {
      for (var r3 = this.h[0], n3 = this.h[1], i3 = this.h[2], o3 = this.h[3], s3 = this.h[4], a3 = r3, h3 = n3, f3 = i3, u3 = o3, c3 = s3, d3 = 0; d3 < 80; d3++) {
        var l3 = ao(so(fo(r3, po(d3, n3, i3, o3), t3[yo[d3] + e4], bo(d3)), vo[d3]), s3);
        r3 = s3, s3 = o3, o3 = so(i3, 10), i3 = n3, n3 = l3, l3 = ao(so(fo(a3, po(79 - d3, h3, f3, u3), t3[go[d3] + e4], mo(d3)), wo[d3]), c3), a3 = c3, c3 = u3, u3 = so(f3, 10), f3 = h3, h3 = l3;
      }
      l3 = ho(this.h[1], i3, u3), this.h[1] = ho(this.h[2], o3, c3), this.h[2] = ho(this.h[3], s3, a3), this.h[3] = ho(this.h[4], r3, h3), this.h[4] = ho(this.h[0], n3, f3), this.h[0] = l3;
    }, co.prototype._digest = function(t3) {
      return "hex" === t3 ? Xn.toHex32(this.h, "little") : Xn.split32(this.h, "little");
    };
    var yo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], go = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], vo = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], wo = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], Mo = { ripemd160: lo };
    function _o(t3, e4, r3) {
      if (!(this instanceof _o))
        return new _o(t3, e4, r3);
      this.Hash = t3, this.blockSize = t3.blockSize / 8, this.outSize = t3.outSize / 8, this.inner = null, this.outer = null, this._init(Xn.toArray(e4, r3));
    }
    var Ao = _o;
    _o.prototype._init = function(t3) {
      t3.length > this.blockSize && (t3 = new this.Hash().update(t3).digest()), vn(t3.length <= this.blockSize);
      for (var e4 = t3.length; e4 < this.blockSize; e4++)
        t3.push(0);
      for (e4 = 0; e4 < t3.length; e4++)
        t3[e4] ^= 54;
      for (this.inner = new this.Hash().update(t3), e4 = 0; e4 < t3.length; e4++)
        t3[e4] ^= 106;
      this.outer = new this.Hash().update(t3);
    }, _o.prototype.update = function(t3, e4) {
      return this.inner.update(t3, e4), this;
    }, _o.prototype.digest = function(t3) {
      return this.outer.update(this.inner.digest()), this.outer.digest(t3);
    };
    var So = Qt(function(t3, e4) {
      var r3 = e4;
      r3.utils = Xn, r3.common = ei2, r3.sha = oo, r3.ripemd = Mo, r3.hmac = Ao, r3.sha1 = r3.sha.sha1, r3.sha256 = r3.sha.sha256, r3.sha224 = r3.sha.sha224, r3.sha384 = r3.sha.sha384, r3.sha512 = r3.sha.sha512, r3.ripemd160 = r3.ripemd.ripemd160;
    }), Eo = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } }, xo = Qt(function(t3, e4) {
      var r3, n3 = e4, i3 = An.assert;
      function o3(t4) {
        "short" === t4.type ? this.curve = new Hn.short(t4) : "edwards" === t4.type ? this.curve = new Hn.edwards(t4) : this.curve = new Hn.mont(t4), this.g = this.curve.g, this.n = this.curve.n, this.hash = t4.hash, i3(this.g.validate(), "Invalid curve"), i3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      function s3(t4, e6) {
        Object.defineProperty(n3, t4, { configurable: true, enumerable: true, get: function() {
          var r4 = new o3(e6);
          return Object.defineProperty(n3, t4, { configurable: true, enumerable: true, value: r4 }), r4;
        } });
      }
      n3.PresetCurve = o3, s3("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: So.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), s3("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: So.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), s3("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: So.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), s3("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: So.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), s3("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: So.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), s3("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: So.sha256, gRed: false, g: ["9"] }), s3("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: So.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
      try {
        r3 = Eo;
      } catch (t4) {
        r3 = void 0;
      }
      s3("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: So.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", r3] });
    });
    function Io(t3) {
      if (!(this instanceof Io))
        return new Io(t3);
      this.hash = t3.hash, this.predResist = !!t3.predResist, this.outLen = this.hash.outSize, this.minEntropy = t3.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e4 = _n.toArray(t3.entropy, t3.entropyEnc || "hex"), r3 = _n.toArray(t3.nonce, t3.nonceEnc || "hex"), n3 = _n.toArray(t3.pers, t3.persEnc || "hex");
      vn(e4.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e4, r3, n3);
    }
    var ko = Io;
    Io.prototype._init = function(t3, e4, r3) {
      var n3 = t3.concat(e4).concat(r3);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var i3 = 0; i3 < this.V.length; i3++)
        this.K[i3] = 0, this.V[i3] = 1;
      this._update(n3), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, Io.prototype._hmac = function() {
      return new So.hmac(this.hash, this.K);
    }, Io.prototype._update = function(t3) {
      var e4 = this._hmac().update(this.V).update([0]);
      t3 && (e4 = e4.update(t3)), this.K = e4.digest(), this.V = this._hmac().update(this.V).digest(), t3 && (this.K = this._hmac().update(this.V).update([1]).update(t3).digest(), this.V = this._hmac().update(this.V).digest());
    }, Io.prototype.reseed = function(t3, e4, r3, n3) {
      "string" != typeof e4 && (n3 = r3, r3 = e4, e4 = null), t3 = _n.toArray(t3, e4), r3 = _n.toArray(r3, n3), vn(t3.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t3.concat(r3 || [])), this._reseed = 1;
    }, Io.prototype.generate = function(t3, e4, r3, n3) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      "string" != typeof e4 && (n3 = r3, r3 = e4, e4 = null), r3 && (r3 = _n.toArray(r3, n3 || "hex"), this._update(r3));
      for (var i3 = []; i3.length < t3; )
        this.V = this._hmac().update(this.V).digest(), i3 = i3.concat(this.V);
      var o3 = i3.slice(0, t3);
      return this._update(r3), this._reseed++, _n.encode(o3, e4);
    };
    var Ro = An.assert;
    function To(t3, e4) {
      this.ec = t3, this.priv = null, this.pub = null, e4.priv && this._importPrivate(e4.priv, e4.privEnc), e4.pub && this._importPublic(e4.pub, e4.pubEnc);
    }
    var Bo = To;
    To.fromPublic = function(t3, e4, r3) {
      return e4 instanceof To ? e4 : new To(t3, { pub: e4, pubEnc: r3 });
    }, To.fromPrivate = function(t3, e4, r3) {
      return e4 instanceof To ? e4 : new To(t3, { priv: e4, privEnc: r3 });
    }, To.prototype.validate = function() {
      var t3 = this.getPublic();
      return t3.isInfinity() ? { result: false, reason: "Invalid public key" } : t3.validate() ? t3.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    }, To.prototype.getPublic = function(t3, e4) {
      return "string" == typeof t3 && (e4 = t3, t3 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e4 ? this.pub.encode(e4, t3) : this.pub;
    }, To.prototype.getPrivate = function(t3) {
      return "hex" === t3 ? this.priv.toString(16, 2) : this.priv;
    }, To.prototype._importPrivate = function(t3, e4) {
      this.priv = new gn(t3, e4 || 16), this.priv = this.priv.umod(this.ec.curve.n);
    }, To.prototype._importPublic = function(t3, e4) {
      if (t3.x || t3.y)
        return "mont" === this.ec.curve.type ? Ro(t3.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || Ro(t3.x && t3.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(t3.x, t3.y));
      this.pub = this.ec.curve.decodePoint(t3, e4);
    }, To.prototype.derive = function(t3) {
      return t3.validate() || Ro(t3.validate(), "public point not validated"), t3.mul(this.priv).getX();
    }, To.prototype.sign = function(t3, e4, r3) {
      return this.ec.sign(t3, this, e4, r3);
    }, To.prototype.verify = function(t3, e4) {
      return this.ec.verify(t3, e4, this);
    }, To.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    var Po = An.assert;
    function Oo(t3, e4) {
      if (t3 instanceof Oo)
        return t3;
      this._importDER(t3, e4) || (Po(t3.r && t3.s, "Signature without r or s"), this.r = new gn(t3.r, 16), this.s = new gn(t3.s, 16), void 0 === t3.recoveryParam ? this.recoveryParam = null : this.recoveryParam = t3.recoveryParam);
    }
    var Uo = Oo;
    function Lo2() {
      this.place = 0;
    }
    function No(t3, e4) {
      var r3 = t3[e4.place++];
      if (!(128 & r3))
        return r3;
      var n3 = 15 & r3;
      if (0 === n3 || n3 > 4)
        return false;
      for (var i3 = 0, o3 = 0, s3 = e4.place; o3 < n3; o3++, s3++)
        i3 <<= 8, i3 |= t3[s3], i3 >>>= 0;
      return !(i3 <= 127) && (e4.place = s3, i3);
    }
    function zo(t3) {
      for (var e4 = 0, r3 = t3.length - 1; !t3[e4] && !(128 & t3[e4 + 1]) && e4 < r3; )
        e4++;
      return 0 === e4 ? t3 : t3.slice(e4);
    }
    function Co(t3, e4) {
      if (e4 < 128)
        t3.push(e4);
      else {
        var r3 = 1 + (Math.log(e4) / Math.LN2 >>> 3);
        for (t3.push(128 | r3); --r3; )
          t3.push(e4 >>> (r3 << 3) & 255);
        t3.push(e4);
      }
    }
    Oo.prototype._importDER = function(t3, e4) {
      t3 = An.toArray(t3, e4);
      var r3 = new Lo2();
      if (48 !== t3[r3.place++])
        return false;
      var n3 = No(t3, r3);
      if (false === n3)
        return false;
      if (n3 + r3.place !== t3.length)
        return false;
      if (2 !== t3[r3.place++])
        return false;
      var i3 = No(t3, r3);
      if (false === i3)
        return false;
      var o3 = t3.slice(r3.place, i3 + r3.place);
      if (r3.place += i3, 2 !== t3[r3.place++])
        return false;
      var s3 = No(t3, r3);
      if (false === s3)
        return false;
      if (t3.length !== s3 + r3.place)
        return false;
      var a3 = t3.slice(r3.place, s3 + r3.place);
      if (0 === o3[0]) {
        if (!(128 & o3[1]))
          return false;
        o3 = o3.slice(1);
      }
      if (0 === a3[0]) {
        if (!(128 & a3[1]))
          return false;
        a3 = a3.slice(1);
      }
      return this.r = new gn(o3), this.s = new gn(a3), this.recoveryParam = null, true;
    }, Oo.prototype.toDER = function(t3) {
      var e4 = this.r.toArray(), r3 = this.s.toArray();
      for (128 & e4[0] && (e4 = [0].concat(e4)), 128 & r3[0] && (r3 = [0].concat(r3)), e4 = zo(e4), r3 = zo(r3); !(r3[0] || 128 & r3[1]); )
        r3 = r3.slice(1);
      var n3 = [2];
      Co(n3, e4.length), (n3 = n3.concat(e4)).push(2), Co(n3, r3.length);
      var i3 = n3.concat(r3), o3 = [48];
      return Co(o3, i3.length), o3 = o3.concat(i3), An.encode(o3, t3);
    };
    var qo = An.assert;
    function jo(t3) {
      if (!(this instanceof jo))
        return new jo(t3);
      "string" == typeof t3 && (qo(Object.prototype.hasOwnProperty.call(xo, t3), "Unknown curve " + t3), t3 = xo[t3]), t3 instanceof xo.PresetCurve && (t3 = { curve: t3 }), this.curve = t3.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t3.curve.g, this.g.precompute(t3.curve.n.bitLength() + 1), this.hash = t3.hash || t3.curve.hash;
    }
    var Do = jo;
    jo.prototype.keyPair = function(t3) {
      return new Bo(this, t3);
    }, jo.prototype.keyFromPrivate = function(t3, e4) {
      return Bo.fromPrivate(this, t3, e4);
    }, jo.prototype.keyFromPublic = function(t3, e4) {
      return Bo.fromPublic(this, t3, e4);
    }, jo.prototype.genKeyPair = function(t3) {
      t3 || (t3 = {});
      for (var e4 = new ko({ hash: this.hash, pers: t3.pers, persEnc: t3.persEnc || "utf8", entropy: t3.entropy || Sn(this.hash.hmacStrength), entropyEnc: t3.entropy && t3.entropyEnc || "utf8", nonce: this.n.toArray() }), r3 = this.n.byteLength(), n3 = this.n.sub(new gn(2)); ; ) {
        var i3 = new gn(e4.generate(r3));
        if (!(i3.cmp(n3) > 0))
          return i3.iaddn(1), this.keyFromPrivate(i3);
      }
    }, jo.prototype._truncateToN = function(t3, e4) {
      var r3 = 8 * t3.byteLength() - this.n.bitLength();
      return r3 > 0 && (t3 = t3.ushrn(r3)), !e4 && t3.cmp(this.n) >= 0 ? t3.sub(this.n) : t3;
    }, jo.prototype.sign = function(t3, e4, r3, n3) {
      "object" == typeof r3 && (n3 = r3, r3 = null), n3 || (n3 = {}), e4 = this.keyFromPrivate(e4, r3), t3 = this._truncateToN(new gn(t3, 16));
      for (var i3 = this.n.byteLength(), o3 = e4.getPrivate().toArray("be", i3), s3 = t3.toArray("be", i3), a3 = new ko({ hash: this.hash, entropy: o3, nonce: s3, pers: n3.pers, persEnc: n3.persEnc || "utf8" }), h3 = this.n.sub(new gn(1)), f3 = 0; ; f3++) {
        var u3 = n3.k ? n3.k(f3) : new gn(a3.generate(this.n.byteLength()));
        if (!((u3 = this._truncateToN(u3, true)).cmpn(1) <= 0 || u3.cmp(h3) >= 0)) {
          var c3 = this.g.mul(u3);
          if (!c3.isInfinity()) {
            var d3 = c3.getX(), l3 = d3.umod(this.n);
            if (0 !== l3.cmpn(0)) {
              var p3 = u3.invm(this.n).mul(l3.mul(e4.getPrivate()).iadd(t3));
              if (0 !== (p3 = p3.umod(this.n)).cmpn(0)) {
                var b3 = (c3.getY().isOdd() ? 1 : 0) | (0 !== d3.cmp(l3) ? 2 : 0);
                return n3.canonical && p3.cmp(this.nh) > 0 && (p3 = this.n.sub(p3), b3 ^= 1), new Uo({ r: l3, s: p3, recoveryParam: b3 });
              }
            }
          }
        }
      }
    }, jo.prototype.verify = function(t3, e4, r3, n3) {
      t3 = this._truncateToN(new gn(t3, 16)), r3 = this.keyFromPublic(r3, n3);
      var i3 = (e4 = new Uo(e4, "hex")).r, o3 = e4.s;
      if (i3.cmpn(1) < 0 || i3.cmp(this.n) >= 0)
        return false;
      if (o3.cmpn(1) < 0 || o3.cmp(this.n) >= 0)
        return false;
      var s3, a3 = o3.invm(this.n), h3 = a3.mul(t3).umod(this.n), f3 = a3.mul(i3).umod(this.n);
      return this.curve._maxwellTrick ? !(s3 = this.g.jmulAdd(h3, r3.getPublic(), f3)).isInfinity() && s3.eqXToP(i3) : !(s3 = this.g.mulAdd(h3, r3.getPublic(), f3)).isInfinity() && 0 === s3.getX().umod(this.n).cmp(i3);
    }, jo.prototype.recoverPubKey = function(t3, e4, r3, n3) {
      qo((3 & r3) === r3, "The recovery param is more than two bits"), e4 = new Uo(e4, n3);
      var i3 = this.n, o3 = new gn(t3), s3 = e4.r, a3 = e4.s, h3 = 1 & r3, f3 = r3 >> 1;
      if (s3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && f3)
        throw new Error("Unable to find sencond key candinate");
      s3 = f3 ? this.curve.pointFromX(s3.add(this.curve.n), h3) : this.curve.pointFromX(s3, h3);
      var u3 = e4.r.invm(i3), c3 = i3.sub(o3).mul(u3).umod(i3), d3 = a3.mul(u3).umod(i3);
      return this.g.mulAdd(c3, s3, d3);
    }, jo.prototype.getKeyRecoveryParam = function(t3, e4, r3, n3) {
      if (null !== (e4 = new Uo(e4, n3)).recoveryParam)
        return e4.recoveryParam;
      for (var i3 = 0; i3 < 4; i3++) {
        var o3;
        try {
          o3 = this.recoverPubKey(t3, e4, i3);
        } catch (t4) {
          continue;
        }
        if (o3.eq(r3))
          return i3;
      }
      throw new Error("Unable to find valid recovery factor");
    };
    var Fo = An.assert, Ko = An.parseBytes, Yo = An.cachedProperty;
    function Vo(t3, e4) {
      this.eddsa = t3, this._secret = Ko(e4.secret), t3.isPoint(e4.pub) ? this._pub = e4.pub : this._pubBytes = Ko(e4.pub);
    }
    Vo.fromPublic = function(t3, e4) {
      return e4 instanceof Vo ? e4 : new Vo(t3, { pub: e4 });
    }, Vo.fromSecret = function(t3, e4) {
      return e4 instanceof Vo ? e4 : new Vo(t3, { secret: e4 });
    }, Vo.prototype.secret = function() {
      return this._secret;
    }, Yo(Vo, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    }), Yo(Vo, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    }), Yo(Vo, "privBytes", function() {
      var t3 = this.eddsa, e4 = this.hash(), r3 = t3.encodingLength - 1, n3 = e4.slice(0, t3.encodingLength);
      return n3[0] &= 248, n3[r3] &= 127, n3[r3] |= 64, n3;
    }), Yo(Vo, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    }), Yo(Vo, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    }), Yo(Vo, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    }), Vo.prototype.sign = function(t3) {
      return Fo(this._secret, "KeyPair can only verify"), this.eddsa.sign(t3, this);
    }, Vo.prototype.verify = function(t3, e4) {
      return this.eddsa.verify(t3, e4, this);
    }, Vo.prototype.getSecret = function(t3) {
      return Fo(this._secret, "KeyPair is public only"), An.encode(this.secret(), t3);
    }, Vo.prototype.getPublic = function(t3) {
      return An.encode(this.pubBytes(), t3);
    };
    var Wo = Vo, Ho = An.assert, $o = An.cachedProperty, Go = An.parseBytes;
    function Zo(t3, e4) {
      this.eddsa = t3, "object" != typeof e4 && (e4 = Go(e4)), Array.isArray(e4) && (e4 = { R: e4.slice(0, t3.encodingLength), S: e4.slice(t3.encodingLength) }), Ho(e4.R && e4.S, "Signature without R or S"), t3.isPoint(e4.R) && (this._R = e4.R), e4.S instanceof gn && (this._S = e4.S), this._Rencoded = Array.isArray(e4.R) ? e4.R : e4.Rencoded, this._Sencoded = Array.isArray(e4.S) ? e4.S : e4.Sencoded;
    }
    $o(Zo, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    }), $o(Zo, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    }), $o(Zo, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    }), $o(Zo, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    }), Zo.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    }, Zo.prototype.toHex = function() {
      return An.encode(this.toBytes(), "hex").toUpperCase();
    };
    var Jo = Zo, Xo = An.assert, Qo = An.parseBytes;
    function ts(t3) {
      if (Xo("ed25519" === t3, "only tested with ed25519 so far"), !(this instanceof ts))
        return new ts(t3);
      t3 = xo[t3].curve, this.curve = t3, this.g = t3.g, this.g.precompute(t3.n.bitLength() + 1), this.pointClass = t3.point().constructor, this.encodingLength = Math.ceil(t3.n.bitLength() / 8), this.hash = So.sha512;
    }
    var es = ts;
    ts.prototype.sign = function(t3, e4) {
      t3 = Qo(t3);
      var r3 = this.keyFromSecret(e4), n3 = this.hashInt(r3.messagePrefix(), t3), i3 = this.g.mul(n3), o3 = this.encodePoint(i3), s3 = this.hashInt(o3, r3.pubBytes(), t3).mul(r3.priv()), a3 = n3.add(s3).umod(this.curve.n);
      return this.makeSignature({ R: i3, S: a3, Rencoded: o3 });
    }, ts.prototype.verify = function(t3, e4, r3) {
      t3 = Qo(t3), e4 = this.makeSignature(e4);
      var n3 = this.keyFromPublic(r3), i3 = this.hashInt(e4.Rencoded(), n3.pubBytes(), t3), o3 = this.g.mul(e4.S());
      return e4.R().add(n3.pub().mul(i3)).eq(o3);
    }, ts.prototype.hashInt = function() {
      for (var t3 = this.hash(), e4 = 0; e4 < arguments.length; e4++)
        t3.update(arguments[e4]);
      return An.intFromLE(t3.digest()).umod(this.curve.n);
    }, ts.prototype.keyFromPublic = function(t3) {
      return Wo.fromPublic(this, t3);
    }, ts.prototype.keyFromSecret = function(t3) {
      return Wo.fromSecret(this, t3);
    }, ts.prototype.makeSignature = function(t3) {
      return t3 instanceof Jo ? t3 : new Jo(this, t3);
    }, ts.prototype.encodePoint = function(t3) {
      var e4 = t3.getY().toArray("le", this.encodingLength);
      return e4[this.encodingLength - 1] |= t3.getX().isOdd() ? 128 : 0, e4;
    }, ts.prototype.decodePoint = function(t3) {
      var e4 = (t3 = An.parseBytes(t3)).length - 1, r3 = t3.slice(0, e4).concat(-129 & t3[e4]), n3 = 0 != (128 & t3[e4]), i3 = An.intFromLE(r3);
      return this.curve.pointFromY(i3, n3);
    }, ts.prototype.encodeInt = function(t3) {
      return t3.toArray("le", this.encodingLength);
    }, ts.prototype.decodeInt = function(t3) {
      return An.intFromLE(t3);
    }, ts.prototype.isPoint = function(t3) {
      return t3 instanceof this.pointClass;
    };
    var rs = te2(yn);
    new (Qt(function(t3, e4) {
      var r3 = e4;
      r3.version = rs.version, r3.utils = An, r3.rand = Sn, r3.curve = Hn, r3.curves = xo, r3.ec = Do, r3.eddsa = es;
    })).ec("secp256k1").curve.n.constructor, Qt(function(t3) {
      /**
         * [js-sha3]{@link https://github.com/emn178/js-sha3}
         *
         * @version 0.8.0
         * @author Chen, Yi-Cyuan [emn178@gmail.com]
         * @copyright Chen, Yi-Cyuan 2015-2018
         * @license MIT
         */
      !function() {
        var e4 = "input is invalid type", r3 = "object" == typeof window, n3 = r3 ? window : {};
        n3.JS_SHA3_NO_WINDOW && (r3 = false);
        var i3 = !r3 && "object" == typeof self;
        !n3.JS_SHA3_NO_NODE_JS && "object" == typeof S2 && S2.versions && S2.versions.node ? n3 = Jt : i3 && (n3 = self);
        var o3 = !n3.JS_SHA3_NO_COMMON_JS && t3.exports, s3 = !n3.JS_SHA3_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer, a3 = "0123456789abcdef".split(""), h3 = [4, 1024, 262144, 67108864], f3 = [0, 8, 16, 24], u3 = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], c3 = [224, 256, 384, 512], d3 = [128, 256], l3 = ["hex", "buffer", "arrayBuffer", "array", "digest"], p3 = { 128: 168, 256: 136 };
        !n3.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function(t4) {
          return "[object Array]" === Object.prototype.toString.call(t4);
        }), !s3 || !n3.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(t4) {
          return "object" == typeof t4 && t4.buffer && t4.buffer.constructor === ArrayBuffer;
        });
        for (var b3 = function(t4, e6, r4) {
          return function(n4) {
            return new B3(t4, e6, t4).update(n4)[r4]();
          };
        }, m3 = function(t4, e6, r4) {
          return function(n4, i4) {
            return new B3(t4, e6, i4).update(n4)[r4]();
          };
        }, y3 = function(t4, e6, r4) {
          return function(e7, n4, i4, o4) {
            return _3["cshake" + t4].update(e7, n4, i4, o4)[r4]();
          };
        }, g2 = function(t4, e6, r4) {
          return function(e7, n4, i4, o4) {
            return _3["kmac" + t4].update(e7, n4, i4, o4)[r4]();
          };
        }, v3 = function(t4, e6, r4, n4) {
          for (var i4 = 0; i4 < l3.length; ++i4) {
            var o4 = l3[i4];
            t4[o4] = e6(r4, n4, o4);
          }
          return t4;
        }, w3 = function(t4, e6) {
          var r4 = b3(t4, e6, "hex");
          return r4.create = function() {
            return new B3(t4, e6, t4);
          }, r4.update = function(t5) {
            return r4.create().update(t5);
          }, v3(r4, b3, t4, e6);
        }, M3 = [{ name: "keccak", padding: [1, 256, 65536, 16777216], bits: c3, createMethod: w3 }, { name: "sha3", padding: [6, 1536, 393216, 100663296], bits: c3, createMethod: w3 }, { name: "shake", padding: [31, 7936, 2031616, 520093696], bits: d3, createMethod: function(t4, e6) {
          var r4 = m3(t4, e6, "hex");
          return r4.create = function(r5) {
            return new B3(t4, e6, r5);
          }, r4.update = function(t5, e7) {
            return r4.create(e7).update(t5);
          }, v3(r4, m3, t4, e6);
        } }, { name: "cshake", padding: h3, bits: d3, createMethod: function(t4, e6) {
          var r4 = p3[t4], n4 = y3(t4, 0, "hex");
          return n4.create = function(n5, i4, o4) {
            return i4 || o4 ? new B3(t4, e6, n5).bytepad([i4, o4], r4) : _3["shake" + t4].create(n5);
          }, n4.update = function(t5, e7, r5, i4) {
            return n4.create(e7, r5, i4).update(t5);
          }, v3(n4, y3, t4, e6);
        } }, { name: "kmac", padding: h3, bits: d3, createMethod: function(t4, e6) {
          var r4 = p3[t4], n4 = g2(t4, 0, "hex");
          return n4.create = function(n5, i4, o4) {
            return new P3(t4, e6, i4).bytepad(["KMAC", o4], r4).bytepad([n5], r4);
          }, n4.update = function(t5, e7, r5, i4) {
            return n4.create(t5, r5, i4).update(e7);
          }, v3(n4, g2, t4, e6);
        } }], _3 = {}, A3 = [], E3 = 0; E3 < M3.length; ++E3)
          for (var x3 = M3[E3], I3 = x3.bits, k3 = 0; k3 < I3.length; ++k3) {
            var R3 = x3.name + "_" + I3[k3];
            if (A3.push(R3), _3[R3] = x3.createMethod(I3[k3], x3.padding), "sha3" !== x3.name) {
              var T3 = x3.name + I3[k3];
              A3.push(T3), _3[T3] = _3[R3];
            }
          }
        function B3(t4, e6, r4) {
          this.blocks = [], this.s = [], this.padding = e6, this.outputBits = r4, this.reset = true, this.finalized = false, this.block = 0, this.start = 0, this.blockCount = 1600 - (t4 << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = r4 >> 5, this.extraBytes = (31 & r4) >> 3;
          for (var n4 = 0; n4 < 50; ++n4)
            this.s[n4] = 0;
        }
        function P3(t4, e6, r4) {
          B3.call(this, t4, e6, r4);
        }
        B3.prototype.update = function(t4) {
          if (this.finalized)
            throw new Error("finalize already called");
          var r4, n4 = typeof t4;
          if ("string" !== n4) {
            if ("object" !== n4)
              throw new Error(e4);
            if (null === t4)
              throw new Error(e4);
            if (s3 && t4.constructor === ArrayBuffer)
              t4 = new Uint8Array(t4);
            else if (!(Array.isArray(t4) || s3 && ArrayBuffer.isView(t4)))
              throw new Error(e4);
            r4 = true;
          }
          for (var i4, o4, a4 = this.blocks, h4 = this.byteCount, u4 = t4.length, c4 = this.blockCount, d4 = 0, l4 = this.s; d4 < u4; ) {
            if (this.reset)
              for (this.reset = false, a4[0] = this.block, i4 = 1; i4 < c4 + 1; ++i4)
                a4[i4] = 0;
            if (r4)
              for (i4 = this.start; d4 < u4 && i4 < h4; ++d4)
                a4[i4 >> 2] |= t4[d4] << f3[3 & i4++];
            else
              for (i4 = this.start; d4 < u4 && i4 < h4; ++d4)
                (o4 = t4.charCodeAt(d4)) < 128 ? a4[i4 >> 2] |= o4 << f3[3 & i4++] : o4 < 2048 ? (a4[i4 >> 2] |= (192 | o4 >> 6) << f3[3 & i4++], a4[i4 >> 2] |= (128 | 63 & o4) << f3[3 & i4++]) : o4 < 55296 || o4 >= 57344 ? (a4[i4 >> 2] |= (224 | o4 >> 12) << f3[3 & i4++], a4[i4 >> 2] |= (128 | o4 >> 6 & 63) << f3[3 & i4++], a4[i4 >> 2] |= (128 | 63 & o4) << f3[3 & i4++]) : (o4 = 65536 + ((1023 & o4) << 10 | 1023 & t4.charCodeAt(++d4)), a4[i4 >> 2] |= (240 | o4 >> 18) << f3[3 & i4++], a4[i4 >> 2] |= (128 | o4 >> 12 & 63) << f3[3 & i4++], a4[i4 >> 2] |= (128 | o4 >> 6 & 63) << f3[3 & i4++], a4[i4 >> 2] |= (128 | 63 & o4) << f3[3 & i4++]);
            if (this.lastByteIndex = i4, i4 >= h4) {
              for (this.start = i4 - h4, this.block = a4[c4], i4 = 0; i4 < c4; ++i4)
                l4[i4] ^= a4[i4];
              O3(l4), this.reset = true;
            } else
              this.start = i4;
          }
          return this;
        }, B3.prototype.encode = function(t4, e6) {
          var r4 = 255 & t4, n4 = 1, i4 = [r4];
          for (r4 = 255 & (t4 >>= 8); r4 > 0; )
            i4.unshift(r4), r4 = 255 & (t4 >>= 8), ++n4;
          return e6 ? i4.push(n4) : i4.unshift(n4), this.update(i4), i4.length;
        }, B3.prototype.encodeString = function(t4) {
          var r4, n4 = typeof t4;
          if ("string" !== n4) {
            if ("object" !== n4)
              throw new Error(e4);
            if (null === t4)
              throw new Error(e4);
            if (s3 && t4.constructor === ArrayBuffer)
              t4 = new Uint8Array(t4);
            else if (!(Array.isArray(t4) || s3 && ArrayBuffer.isView(t4)))
              throw new Error(e4);
            r4 = true;
          }
          var i4 = 0, o4 = t4.length;
          if (r4)
            i4 = o4;
          else
            for (var a4 = 0; a4 < t4.length; ++a4) {
              var h4 = t4.charCodeAt(a4);
              h4 < 128 ? i4 += 1 : h4 < 2048 ? i4 += 2 : h4 < 55296 || h4 >= 57344 ? i4 += 3 : (h4 = 65536 + ((1023 & h4) << 10 | 1023 & t4.charCodeAt(++a4)), i4 += 4);
            }
          return i4 += this.encode(8 * i4), this.update(t4), i4;
        }, B3.prototype.bytepad = function(t4, e6) {
          for (var r4 = this.encode(e6), n4 = 0; n4 < t4.length; ++n4)
            r4 += this.encodeString(t4[n4]);
          var i4 = e6 - r4 % e6, o4 = [];
          return o4.length = i4, this.update(o4), this;
        }, B3.prototype.finalize = function() {
          if (!this.finalized) {
            this.finalized = true;
            var t4 = this.blocks, e6 = this.lastByteIndex, r4 = this.blockCount, n4 = this.s;
            if (t4[e6 >> 2] |= this.padding[3 & e6], this.lastByteIndex === this.byteCount)
              for (t4[0] = t4[r4], e6 = 1; e6 < r4 + 1; ++e6)
                t4[e6] = 0;
            for (t4[r4 - 1] |= 2147483648, e6 = 0; e6 < r4; ++e6)
              n4[e6] ^= t4[e6];
            O3(n4);
          }
        }, B3.prototype.toString = B3.prototype.hex = function() {
          this.finalize();
          for (var t4, e6 = this.blockCount, r4 = this.s, n4 = this.outputBlocks, i4 = this.extraBytes, o4 = 0, s4 = 0, h4 = ""; s4 < n4; ) {
            for (o4 = 0; o4 < e6 && s4 < n4; ++o4, ++s4)
              t4 = r4[o4], h4 += a3[t4 >> 4 & 15] + a3[15 & t4] + a3[t4 >> 12 & 15] + a3[t4 >> 8 & 15] + a3[t4 >> 20 & 15] + a3[t4 >> 16 & 15] + a3[t4 >> 28 & 15] + a3[t4 >> 24 & 15];
            s4 % e6 == 0 && (O3(r4), o4 = 0);
          }
          return i4 && (t4 = r4[o4], h4 += a3[t4 >> 4 & 15] + a3[15 & t4], i4 > 1 && (h4 += a3[t4 >> 12 & 15] + a3[t4 >> 8 & 15]), i4 > 2 && (h4 += a3[t4 >> 20 & 15] + a3[t4 >> 16 & 15])), h4;
        }, B3.prototype.arrayBuffer = function() {
          this.finalize();
          var t4, e6 = this.blockCount, r4 = this.s, n4 = this.outputBlocks, i4 = this.extraBytes, o4 = 0, s4 = 0, a4 = this.outputBits >> 3;
          t4 = i4 ? new ArrayBuffer(n4 + 1 << 2) : new ArrayBuffer(a4);
          for (var h4 = new Uint32Array(t4); s4 < n4; ) {
            for (o4 = 0; o4 < e6 && s4 < n4; ++o4, ++s4)
              h4[s4] = r4[o4];
            s4 % e6 == 0 && O3(r4);
          }
          return i4 && (h4[o4] = r4[o4], t4 = t4.slice(0, a4)), t4;
        }, B3.prototype.buffer = B3.prototype.arrayBuffer, B3.prototype.digest = B3.prototype.array = function() {
          this.finalize();
          for (var t4, e6, r4 = this.blockCount, n4 = this.s, i4 = this.outputBlocks, o4 = this.extraBytes, s4 = 0, a4 = 0, h4 = []; a4 < i4; ) {
            for (s4 = 0; s4 < r4 && a4 < i4; ++s4, ++a4)
              t4 = a4 << 2, e6 = n4[s4], h4[t4] = 255 & e6, h4[t4 + 1] = e6 >> 8 & 255, h4[t4 + 2] = e6 >> 16 & 255, h4[t4 + 3] = e6 >> 24 & 255;
            a4 % r4 == 0 && O3(n4);
          }
          return o4 && (t4 = a4 << 2, e6 = n4[s4], h4[t4] = 255 & e6, o4 > 1 && (h4[t4 + 1] = e6 >> 8 & 255), o4 > 2 && (h4[t4 + 2] = e6 >> 16 & 255)), h4;
        }, P3.prototype = new B3(), P3.prototype.finalize = function() {
          return this.encode(this.outputBits, true), B3.prototype.finalize.call(this);
        };
        var O3 = function(t4) {
          var e6, r4, n4, i4, o4, s4, a4, h4, f4, c4, d4, l4, p4, b4, m4, y4, g3, v4, w4, M4, _4, A4, S3, E4, x4, I4, k4, R4, T4, B4, P4, O4, U3, L3, N3, z3, C3, q3, j3, D3, F3, K3, Y3, V3, W3, H3, $3, G3, Z3, J3, X3, Q3, tt2, et2, rt2, nt2, it2, ot2, st2, at2, ht2, ft2, ut2;
          for (n4 = 0; n4 < 48; n4 += 2)
            i4 = t4[0] ^ t4[10] ^ t4[20] ^ t4[30] ^ t4[40], o4 = t4[1] ^ t4[11] ^ t4[21] ^ t4[31] ^ t4[41], s4 = t4[2] ^ t4[12] ^ t4[22] ^ t4[32] ^ t4[42], a4 = t4[3] ^ t4[13] ^ t4[23] ^ t4[33] ^ t4[43], h4 = t4[4] ^ t4[14] ^ t4[24] ^ t4[34] ^ t4[44], f4 = t4[5] ^ t4[15] ^ t4[25] ^ t4[35] ^ t4[45], c4 = t4[6] ^ t4[16] ^ t4[26] ^ t4[36] ^ t4[46], d4 = t4[7] ^ t4[17] ^ t4[27] ^ t4[37] ^ t4[47], e6 = (l4 = t4[8] ^ t4[18] ^ t4[28] ^ t4[38] ^ t4[48]) ^ (s4 << 1 | a4 >>> 31), r4 = (p4 = t4[9] ^ t4[19] ^ t4[29] ^ t4[39] ^ t4[49]) ^ (a4 << 1 | s4 >>> 31), t4[0] ^= e6, t4[1] ^= r4, t4[10] ^= e6, t4[11] ^= r4, t4[20] ^= e6, t4[21] ^= r4, t4[30] ^= e6, t4[31] ^= r4, t4[40] ^= e6, t4[41] ^= r4, e6 = i4 ^ (h4 << 1 | f4 >>> 31), r4 = o4 ^ (f4 << 1 | h4 >>> 31), t4[2] ^= e6, t4[3] ^= r4, t4[12] ^= e6, t4[13] ^= r4, t4[22] ^= e6, t4[23] ^= r4, t4[32] ^= e6, t4[33] ^= r4, t4[42] ^= e6, t4[43] ^= r4, e6 = s4 ^ (c4 << 1 | d4 >>> 31), r4 = a4 ^ (d4 << 1 | c4 >>> 31), t4[4] ^= e6, t4[5] ^= r4, t4[14] ^= e6, t4[15] ^= r4, t4[24] ^= e6, t4[25] ^= r4, t4[34] ^= e6, t4[35] ^= r4, t4[44] ^= e6, t4[45] ^= r4, e6 = h4 ^ (l4 << 1 | p4 >>> 31), r4 = f4 ^ (p4 << 1 | l4 >>> 31), t4[6] ^= e6, t4[7] ^= r4, t4[16] ^= e6, t4[17] ^= r4, t4[26] ^= e6, t4[27] ^= r4, t4[36] ^= e6, t4[37] ^= r4, t4[46] ^= e6, t4[47] ^= r4, e6 = c4 ^ (i4 << 1 | o4 >>> 31), r4 = d4 ^ (o4 << 1 | i4 >>> 31), t4[8] ^= e6, t4[9] ^= r4, t4[18] ^= e6, t4[19] ^= r4, t4[28] ^= e6, t4[29] ^= r4, t4[38] ^= e6, t4[39] ^= r4, t4[48] ^= e6, t4[49] ^= r4, b4 = t4[0], m4 = t4[1], H3 = t4[11] << 4 | t4[10] >>> 28, $3 = t4[10] << 4 | t4[11] >>> 28, R4 = t4[20] << 3 | t4[21] >>> 29, T4 = t4[21] << 3 | t4[20] >>> 29, at2 = t4[31] << 9 | t4[30] >>> 23, ht2 = t4[30] << 9 | t4[31] >>> 23, K3 = t4[40] << 18 | t4[41] >>> 14, Y3 = t4[41] << 18 | t4[40] >>> 14, L3 = t4[2] << 1 | t4[3] >>> 31, N3 = t4[3] << 1 | t4[2] >>> 31, y4 = t4[13] << 12 | t4[12] >>> 20, g3 = t4[12] << 12 | t4[13] >>> 20, G3 = t4[22] << 10 | t4[23] >>> 22, Z3 = t4[23] << 10 | t4[22] >>> 22, B4 = t4[33] << 13 | t4[32] >>> 19, P4 = t4[32] << 13 | t4[33] >>> 19, ft2 = t4[42] << 2 | t4[43] >>> 30, ut2 = t4[43] << 2 | t4[42] >>> 30, et2 = t4[5] << 30 | t4[4] >>> 2, rt2 = t4[4] << 30 | t4[5] >>> 2, z3 = t4[14] << 6 | t4[15] >>> 26, C3 = t4[15] << 6 | t4[14] >>> 26, v4 = t4[25] << 11 | t4[24] >>> 21, w4 = t4[24] << 11 | t4[25] >>> 21, J3 = t4[34] << 15 | t4[35] >>> 17, X3 = t4[35] << 15 | t4[34] >>> 17, O4 = t4[45] << 29 | t4[44] >>> 3, U3 = t4[44] << 29 | t4[45] >>> 3, E4 = t4[6] << 28 | t4[7] >>> 4, x4 = t4[7] << 28 | t4[6] >>> 4, nt2 = t4[17] << 23 | t4[16] >>> 9, it2 = t4[16] << 23 | t4[17] >>> 9, q3 = t4[26] << 25 | t4[27] >>> 7, j3 = t4[27] << 25 | t4[26] >>> 7, M4 = t4[36] << 21 | t4[37] >>> 11, _4 = t4[37] << 21 | t4[36] >>> 11, Q3 = t4[47] << 24 | t4[46] >>> 8, tt2 = t4[46] << 24 | t4[47] >>> 8, V3 = t4[8] << 27 | t4[9] >>> 5, W3 = t4[9] << 27 | t4[8] >>> 5, I4 = t4[18] << 20 | t4[19] >>> 12, k4 = t4[19] << 20 | t4[18] >>> 12, ot2 = t4[29] << 7 | t4[28] >>> 25, st2 = t4[28] << 7 | t4[29] >>> 25, D3 = t4[38] << 8 | t4[39] >>> 24, F3 = t4[39] << 8 | t4[38] >>> 24, A4 = t4[48] << 14 | t4[49] >>> 18, S3 = t4[49] << 14 | t4[48] >>> 18, t4[0] = b4 ^ ~y4 & v4, t4[1] = m4 ^ ~g3 & w4, t4[10] = E4 ^ ~I4 & R4, t4[11] = x4 ^ ~k4 & T4, t4[20] = L3 ^ ~z3 & q3, t4[21] = N3 ^ ~C3 & j3, t4[30] = V3 ^ ~H3 & G3, t4[31] = W3 ^ ~$3 & Z3, t4[40] = et2 ^ ~nt2 & ot2, t4[41] = rt2 ^ ~it2 & st2, t4[2] = y4 ^ ~v4 & M4, t4[3] = g3 ^ ~w4 & _4, t4[12] = I4 ^ ~R4 & B4, t4[13] = k4 ^ ~T4 & P4, t4[22] = z3 ^ ~q3 & D3, t4[23] = C3 ^ ~j3 & F3, t4[32] = H3 ^ ~G3 & J3, t4[33] = $3 ^ ~Z3 & X3, t4[42] = nt2 ^ ~ot2 & at2, t4[43] = it2 ^ ~st2 & ht2, t4[4] = v4 ^ ~M4 & A4, t4[5] = w4 ^ ~_4 & S3, t4[14] = R4 ^ ~B4 & O4, t4[15] = T4 ^ ~P4 & U3, t4[24] = q3 ^ ~D3 & K3, t4[25] = j3 ^ ~F3 & Y3, t4[34] = G3 ^ ~J3 & Q3, t4[35] = Z3 ^ ~X3 & tt2, t4[44] = ot2 ^ ~at2 & ft2, t4[45] = st2 ^ ~ht2 & ut2, t4[6] = M4 ^ ~A4 & b4, t4[7] = _4 ^ ~S3 & m4, t4[16] = B4 ^ ~O4 & E4, t4[17] = P4 ^ ~U3 & x4, t4[26] = D3 ^ ~K3 & L3, t4[27] = F3 ^ ~Y3 & N3, t4[36] = J3 ^ ~Q3 & V3, t4[37] = X3 ^ ~tt2 & W3, t4[46] = at2 ^ ~ft2 & et2, t4[47] = ht2 ^ ~ut2 & rt2, t4[8] = A4 ^ ~b4 & y4, t4[9] = S3 ^ ~m4 & g3, t4[18] = O4 ^ ~E4 & I4, t4[19] = U3 ^ ~x4 & k4, t4[28] = K3 ^ ~L3 & z3, t4[29] = Y3 ^ ~N3 & C3, t4[38] = Q3 ^ ~V3 & H3, t4[39] = tt2 ^ ~W3 & $3, t4[48] = ft2 ^ ~et2 & nt2, t4[49] = ut2 ^ ~rt2 & it2, t4[0] ^= u3[n4], t4[1] ^= u3[n4 + 1];
        };
        if (o3)
          t3.exports = _3;
        else
          for (E3 = 0; E3 < A3.length; ++E3)
            n3[A3[E3]] = _3[A3[E3]];
      }();
    }).keccak_256;
    const ns = (t3) => ct.isBuffer(t3) ? t3 : t3 instanceof Uint8Array ? ct.from(t3.buffer, t3.byteOffset, t3.byteLength) : ct.from(t3);
    var is2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t2 ? t2 : "undefined" != typeof self ? self : {}, os = {}, ss = {}, as = hs;
    function hs(t3, e4) {
      if (!t3)
        throw new Error(e4 || "Assertion failed");
    }
    hs.equal = function(t3, e4, r3) {
      if (t3 != e4)
        throw new Error(r3 || "Assertion failed: " + t3 + " != " + e4);
    };
    var fs = { exports: {} };
    "function" == typeof Object.create ? fs.exports = function(t3, e4) {
      e4 && (t3.super_ = e4, t3.prototype = Object.create(e4.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }));
    } : fs.exports = function(t3, e4) {
      if (e4) {
        t3.super_ = e4;
        var r3 = function() {
        };
        r3.prototype = e4.prototype, t3.prototype = new r3(), t3.prototype.constructor = t3;
      }
    };
    var us = as, cs = fs.exports;
    function ds(t3, e4) {
      return 55296 == (64512 & t3.charCodeAt(e4)) && (!(e4 < 0 || e4 + 1 >= t3.length) && 56320 == (64512 & t3.charCodeAt(e4 + 1)));
    }
    function ls(t3) {
      return (t3 >>> 24 | t3 >>> 8 & 65280 | t3 << 8 & 16711680 | (255 & t3) << 24) >>> 0;
    }
    function ps(t3) {
      return 1 === t3.length ? "0" + t3 : t3;
    }
    function bs(t3) {
      return 7 === t3.length ? "0" + t3 : 6 === t3.length ? "00" + t3 : 5 === t3.length ? "000" + t3 : 4 === t3.length ? "0000" + t3 : 3 === t3.length ? "00000" + t3 : 2 === t3.length ? "000000" + t3 : 1 === t3.length ? "0000000" + t3 : t3;
    }
    ss.inherits = cs, ss.toArray = function(t3, e4) {
      if (Array.isArray(t3))
        return t3.slice();
      if (!t3)
        return [];
      var r3 = [];
      if ("string" == typeof t3)
        if (e4) {
          if ("hex" === e4)
            for ((t3 = t3.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t3 = "0" + t3), i3 = 0; i3 < t3.length; i3 += 2)
              r3.push(parseInt(t3[i3] + t3[i3 + 1], 16));
        } else
          for (var n3 = 0, i3 = 0; i3 < t3.length; i3++) {
            var o3 = t3.charCodeAt(i3);
            o3 < 128 ? r3[n3++] = o3 : o3 < 2048 ? (r3[n3++] = o3 >> 6 | 192, r3[n3++] = 63 & o3 | 128) : ds(t3, i3) ? (o3 = 65536 + ((1023 & o3) << 10) + (1023 & t3.charCodeAt(++i3)), r3[n3++] = o3 >> 18 | 240, r3[n3++] = o3 >> 12 & 63 | 128, r3[n3++] = o3 >> 6 & 63 | 128, r3[n3++] = 63 & o3 | 128) : (r3[n3++] = o3 >> 12 | 224, r3[n3++] = o3 >> 6 & 63 | 128, r3[n3++] = 63 & o3 | 128);
          }
      else
        for (i3 = 0; i3 < t3.length; i3++)
          r3[i3] = 0 | t3[i3];
      return r3;
    }, ss.toHex = function(t3) {
      for (var e4 = "", r3 = 0; r3 < t3.length; r3++)
        e4 += ps(t3[r3].toString(16));
      return e4;
    }, ss.htonl = ls, ss.toHex32 = function(t3, e4) {
      for (var r3 = "", n3 = 0; n3 < t3.length; n3++) {
        var i3 = t3[n3];
        "little" === e4 && (i3 = ls(i3)), r3 += bs(i3.toString(16));
      }
      return r3;
    }, ss.zero2 = ps, ss.zero8 = bs, ss.join32 = function(t3, e4, r3, n3) {
      var i3 = r3 - e4;
      us(i3 % 4 == 0);
      for (var o3 = new Array(i3 / 4), s3 = 0, a3 = e4; s3 < o3.length; s3++, a3 += 4) {
        var h3;
        h3 = "big" === n3 ? t3[a3] << 24 | t3[a3 + 1] << 16 | t3[a3 + 2] << 8 | t3[a3 + 3] : t3[a3 + 3] << 24 | t3[a3 + 2] << 16 | t3[a3 + 1] << 8 | t3[a3], o3[s3] = h3 >>> 0;
      }
      return o3;
    }, ss.split32 = function(t3, e4) {
      for (var r3 = new Array(4 * t3.length), n3 = 0, i3 = 0; n3 < t3.length; n3++, i3 += 4) {
        var o3 = t3[n3];
        "big" === e4 ? (r3[i3] = o3 >>> 24, r3[i3 + 1] = o3 >>> 16 & 255, r3[i3 + 2] = o3 >>> 8 & 255, r3[i3 + 3] = 255 & o3) : (r3[i3 + 3] = o3 >>> 24, r3[i3 + 2] = o3 >>> 16 & 255, r3[i3 + 1] = o3 >>> 8 & 255, r3[i3] = 255 & o3);
      }
      return r3;
    }, ss.rotr32 = function(t3, e4) {
      return t3 >>> e4 | t3 << 32 - e4;
    }, ss.rotl32 = function(t3, e4) {
      return t3 << e4 | t3 >>> 32 - e4;
    }, ss.sum32 = function(t3, e4) {
      return t3 + e4 >>> 0;
    }, ss.sum32_3 = function(t3, e4, r3) {
      return t3 + e4 + r3 >>> 0;
    }, ss.sum32_4 = function(t3, e4, r3, n3) {
      return t3 + e4 + r3 + n3 >>> 0;
    }, ss.sum32_5 = function(t3, e4, r3, n3, i3) {
      return t3 + e4 + r3 + n3 + i3 >>> 0;
    }, ss.sum64 = function(t3, e4, r3, n3) {
      var i3 = t3[e4], o3 = n3 + t3[e4 + 1] >>> 0, s3 = (o3 < n3 ? 1 : 0) + r3 + i3;
      t3[e4] = s3 >>> 0, t3[e4 + 1] = o3;
    }, ss.sum64_hi = function(t3, e4, r3, n3) {
      return (e4 + n3 >>> 0 < e4 ? 1 : 0) + t3 + r3 >>> 0;
    }, ss.sum64_lo = function(t3, e4, r3, n3) {
      return e4 + n3 >>> 0;
    }, ss.sum64_4_hi = function(t3, e4, r3, n3, i3, o3, s3, a3) {
      var h3 = 0, f3 = e4;
      return h3 += (f3 = f3 + n3 >>> 0) < e4 ? 1 : 0, h3 += (f3 = f3 + o3 >>> 0) < o3 ? 1 : 0, t3 + r3 + i3 + s3 + (h3 += (f3 = f3 + a3 >>> 0) < a3 ? 1 : 0) >>> 0;
    }, ss.sum64_4_lo = function(t3, e4, r3, n3, i3, o3, s3, a3) {
      return e4 + n3 + o3 + a3 >>> 0;
    }, ss.sum64_5_hi = function(t3, e4, r3, n3, i3, o3, s3, a3, h3, f3) {
      var u3 = 0, c3 = e4;
      return u3 += (c3 = c3 + n3 >>> 0) < e4 ? 1 : 0, u3 += (c3 = c3 + o3 >>> 0) < o3 ? 1 : 0, u3 += (c3 = c3 + a3 >>> 0) < a3 ? 1 : 0, t3 + r3 + i3 + s3 + h3 + (u3 += (c3 = c3 + f3 >>> 0) < f3 ? 1 : 0) >>> 0;
    }, ss.sum64_5_lo = function(t3, e4, r3, n3, i3, o3, s3, a3, h3, f3) {
      return e4 + n3 + o3 + a3 + f3 >>> 0;
    }, ss.rotr64_hi = function(t3, e4, r3) {
      return (e4 << 32 - r3 | t3 >>> r3) >>> 0;
    }, ss.rotr64_lo = function(t3, e4, r3) {
      return (t3 << 32 - r3 | e4 >>> r3) >>> 0;
    }, ss.shr64_hi = function(t3, e4, r3) {
      return t3 >>> r3;
    }, ss.shr64_lo = function(t3, e4, r3) {
      return (t3 << 32 - r3 | e4 >>> r3) >>> 0;
    };
    var ms = {}, ys = ss, gs = as;
    function vs() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    ms.BlockHash = vs, vs.prototype.update = function(t3, e4) {
      if (t3 = ys.toArray(t3, e4), this.pending ? this.pending = this.pending.concat(t3) : this.pending = t3, this.pendingTotal += t3.length, this.pending.length >= this._delta8) {
        var r3 = (t3 = this.pending).length % this._delta8;
        this.pending = t3.slice(t3.length - r3, t3.length), 0 === this.pending.length && (this.pending = null), t3 = ys.join32(t3, 0, t3.length - r3, this.endian);
        for (var n3 = 0; n3 < t3.length; n3 += this._delta32)
          this._update(t3, n3, n3 + this._delta32);
      }
      return this;
    }, vs.prototype.digest = function(t3) {
      return this.update(this._pad()), gs(null === this.pending), this._digest(t3);
    }, vs.prototype._pad = function() {
      var t3 = this.pendingTotal, e4 = this._delta8, r3 = e4 - (t3 + this.padLength) % e4, n3 = new Array(r3 + this.padLength);
      n3[0] = 128;
      for (var i3 = 1; i3 < r3; i3++)
        n3[i3] = 0;
      if (t3 <<= 3, "big" === this.endian) {
        for (var o3 = 8; o3 < this.padLength; o3++)
          n3[i3++] = 0;
        n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = t3 >>> 24 & 255, n3[i3++] = t3 >>> 16 & 255, n3[i3++] = t3 >>> 8 & 255, n3[i3++] = 255 & t3;
      } else
        for (n3[i3++] = 255 & t3, n3[i3++] = t3 >>> 8 & 255, n3[i3++] = t3 >>> 16 & 255, n3[i3++] = t3 >>> 24 & 255, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, n3[i3++] = 0, o3 = 8; o3 < this.padLength; o3++)
          n3[i3++] = 0;
      return n3;
    };
    var ws = {}, Ms = {}, _s = ss.rotr32;
    function As(t3, e4, r3) {
      return t3 & e4 ^ ~t3 & r3;
    }
    function Ss(t3, e4, r3) {
      return t3 & e4 ^ t3 & r3 ^ e4 & r3;
    }
    function Es(t3, e4, r3) {
      return t3 ^ e4 ^ r3;
    }
    Ms.ft_1 = function(t3, e4, r3, n3) {
      return 0 === t3 ? As(e4, r3, n3) : 1 === t3 || 3 === t3 ? Es(e4, r3, n3) : 2 === t3 ? Ss(e4, r3, n3) : void 0;
    }, Ms.ch32 = As, Ms.maj32 = Ss, Ms.p32 = Es, Ms.s0_256 = function(t3) {
      return _s(t3, 2) ^ _s(t3, 13) ^ _s(t3, 22);
    }, Ms.s1_256 = function(t3) {
      return _s(t3, 6) ^ _s(t3, 11) ^ _s(t3, 25);
    }, Ms.g0_256 = function(t3) {
      return _s(t3, 7) ^ _s(t3, 18) ^ t3 >>> 3;
    }, Ms.g1_256 = function(t3) {
      return _s(t3, 17) ^ _s(t3, 19) ^ t3 >>> 10;
    };
    var xs = ss, Is = ms, ks = Ms, Rs = xs.rotl32, Ts = xs.sum32, Bs = xs.sum32_5, Ps = ks.ft_1, Os = Is.BlockHash, Us = [1518500249, 1859775393, 2400959708, 3395469782];
    function Ls() {
      if (!(this instanceof Ls))
        return new Ls();
      Os.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    xs.inherits(Ls, Os);
    var Ns = Ls;
    Ls.blockSize = 512, Ls.outSize = 160, Ls.hmacStrength = 80, Ls.padLength = 64, Ls.prototype._update = function(t3, e4) {
      for (var r3 = this.W, n3 = 0; n3 < 16; n3++)
        r3[n3] = t3[e4 + n3];
      for (; n3 < r3.length; n3++)
        r3[n3] = Rs(r3[n3 - 3] ^ r3[n3 - 8] ^ r3[n3 - 14] ^ r3[n3 - 16], 1);
      var i3 = this.h[0], o3 = this.h[1], s3 = this.h[2], a3 = this.h[3], h3 = this.h[4];
      for (n3 = 0; n3 < r3.length; n3++) {
        var f3 = ~~(n3 / 20), u3 = Bs(Rs(i3, 5), Ps(f3, o3, s3, a3), h3, r3[n3], Us[f3]);
        h3 = a3, a3 = s3, s3 = Rs(o3, 30), o3 = i3, i3 = u3;
      }
      this.h[0] = Ts(this.h[0], i3), this.h[1] = Ts(this.h[1], o3), this.h[2] = Ts(this.h[2], s3), this.h[3] = Ts(this.h[3], a3), this.h[4] = Ts(this.h[4], h3);
    }, Ls.prototype._digest = function(t3) {
      return "hex" === t3 ? xs.toHex32(this.h, "big") : xs.split32(this.h, "big");
    };
    var zs = ss, Cs = ms, qs = Ms, js = as, Ds = zs.sum32, Fs = zs.sum32_4, Ks = zs.sum32_5, Ys = qs.ch32, Vs = qs.maj32, Ws = qs.s0_256, Hs = qs.s1_256, $s = qs.g0_256, Gs = qs.g1_256, Zs = Cs.BlockHash, Js = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function Xs() {
      if (!(this instanceof Xs))
        return new Xs();
      Zs.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = Js, this.W = new Array(64);
    }
    zs.inherits(Xs, Zs);
    var Qs = Xs;
    Xs.blockSize = 512, Xs.outSize = 256, Xs.hmacStrength = 192, Xs.padLength = 64, Xs.prototype._update = function(t3, e4) {
      for (var r3 = this.W, n3 = 0; n3 < 16; n3++)
        r3[n3] = t3[e4 + n3];
      for (; n3 < r3.length; n3++)
        r3[n3] = Fs(Gs(r3[n3 - 2]), r3[n3 - 7], $s(r3[n3 - 15]), r3[n3 - 16]);
      var i3 = this.h[0], o3 = this.h[1], s3 = this.h[2], a3 = this.h[3], h3 = this.h[4], f3 = this.h[5], u3 = this.h[6], c3 = this.h[7];
      for (js(this.k.length === r3.length), n3 = 0; n3 < r3.length; n3++) {
        var d3 = Ks(c3, Hs(h3), Ys(h3, f3, u3), this.k[n3], r3[n3]), l3 = Ds(Ws(i3), Vs(i3, o3, s3));
        c3 = u3, u3 = f3, f3 = h3, h3 = Ds(a3, d3), a3 = s3, s3 = o3, o3 = i3, i3 = Ds(d3, l3);
      }
      this.h[0] = Ds(this.h[0], i3), this.h[1] = Ds(this.h[1], o3), this.h[2] = Ds(this.h[2], s3), this.h[3] = Ds(this.h[3], a3), this.h[4] = Ds(this.h[4], h3), this.h[5] = Ds(this.h[5], f3), this.h[6] = Ds(this.h[6], u3), this.h[7] = Ds(this.h[7], c3);
    }, Xs.prototype._digest = function(t3) {
      return "hex" === t3 ? zs.toHex32(this.h, "big") : zs.split32(this.h, "big");
    };
    var ta2 = ss, ea2 = Qs;
    function ra2() {
      if (!(this instanceof ra2))
        return new ra2();
      ea2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    ta2.inherits(ra2, ea2);
    var na = ra2;
    ra2.blockSize = 512, ra2.outSize = 224, ra2.hmacStrength = 192, ra2.padLength = 64, ra2.prototype._digest = function(t3) {
      return "hex" === t3 ? ta2.toHex32(this.h.slice(0, 7), "big") : ta2.split32(this.h.slice(0, 7), "big");
    };
    var ia2 = ss, oa2 = ms, sa2 = as, aa2 = ia2.rotr64_hi, ha2 = ia2.rotr64_lo, fa2 = ia2.shr64_hi, ua2 = ia2.shr64_lo, ca2 = ia2.sum64, da2 = ia2.sum64_hi, la2 = ia2.sum64_lo, pa2 = ia2.sum64_4_hi, ba = ia2.sum64_4_lo, ma2 = ia2.sum64_5_hi, ya2 = ia2.sum64_5_lo, ga = oa2.BlockHash, va2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function wa2() {
      if (!(this instanceof wa2))
        return new wa2();
      ga.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = va2, this.W = new Array(160);
    }
    ia2.inherits(wa2, ga);
    var Ma2 = wa2;
    function _a2(t3, e4, r3, n3, i3) {
      var o3 = t3 & r3 ^ ~t3 & i3;
      return o3 < 0 && (o3 += 4294967296), o3;
    }
    function Aa2(t3, e4, r3, n3, i3, o3) {
      var s3 = e4 & n3 ^ ~e4 & o3;
      return s3 < 0 && (s3 += 4294967296), s3;
    }
    function Sa2(t3, e4, r3, n3, i3) {
      var o3 = t3 & r3 ^ t3 & i3 ^ r3 & i3;
      return o3 < 0 && (o3 += 4294967296), o3;
    }
    function Ea2(t3, e4, r3, n3, i3, o3) {
      var s3 = e4 & n3 ^ e4 & o3 ^ n3 & o3;
      return s3 < 0 && (s3 += 4294967296), s3;
    }
    function xa(t3, e4) {
      var r3 = aa2(t3, e4, 28) ^ aa2(e4, t3, 2) ^ aa2(e4, t3, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Ia2(t3, e4) {
      var r3 = ha2(t3, e4, 28) ^ ha2(e4, t3, 2) ^ ha2(e4, t3, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function ka2(t3, e4) {
      var r3 = aa2(t3, e4, 14) ^ aa2(t3, e4, 18) ^ aa2(e4, t3, 9);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Ra2(t3, e4) {
      var r3 = ha2(t3, e4, 14) ^ ha2(t3, e4, 18) ^ ha2(e4, t3, 9);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Ta2(t3, e4) {
      var r3 = aa2(t3, e4, 1) ^ aa2(t3, e4, 8) ^ fa2(t3, e4, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Ba2(t3, e4) {
      var r3 = ha2(t3, e4, 1) ^ ha2(t3, e4, 8) ^ ua2(t3, e4, 7);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Pa2(t3, e4) {
      var r3 = aa2(t3, e4, 19) ^ aa2(e4, t3, 29) ^ fa2(t3, e4, 6);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    function Oa2(t3, e4) {
      var r3 = ha2(t3, e4, 19) ^ ha2(e4, t3, 29) ^ ua2(t3, e4, 6);
      return r3 < 0 && (r3 += 4294967296), r3;
    }
    wa2.blockSize = 1024, wa2.outSize = 512, wa2.hmacStrength = 192, wa2.padLength = 128, wa2.prototype._prepareBlock = function(t3, e4) {
      for (var r3 = this.W, n3 = 0; n3 < 32; n3++)
        r3[n3] = t3[e4 + n3];
      for (; n3 < r3.length; n3 += 2) {
        var i3 = Pa2(r3[n3 - 4], r3[n3 - 3]), o3 = Oa2(r3[n3 - 4], r3[n3 - 3]), s3 = r3[n3 - 14], a3 = r3[n3 - 13], h3 = Ta2(r3[n3 - 30], r3[n3 - 29]), f3 = Ba2(r3[n3 - 30], r3[n3 - 29]), u3 = r3[n3 - 32], c3 = r3[n3 - 31];
        r3[n3] = pa2(i3, o3, s3, a3, h3, f3, u3, c3), r3[n3 + 1] = ba(i3, o3, s3, a3, h3, f3, u3, c3);
      }
    }, wa2.prototype._update = function(t3, e4) {
      this._prepareBlock(t3, e4);
      var r3 = this.W, n3 = this.h[0], i3 = this.h[1], o3 = this.h[2], s3 = this.h[3], a3 = this.h[4], h3 = this.h[5], f3 = this.h[6], u3 = this.h[7], c3 = this.h[8], d3 = this.h[9], l3 = this.h[10], p3 = this.h[11], b3 = this.h[12], m3 = this.h[13], y3 = this.h[14], g2 = this.h[15];
      sa2(this.k.length === r3.length);
      for (var v3 = 0; v3 < r3.length; v3 += 2) {
        var w3 = y3, M3 = g2, _3 = ka2(c3, d3), A3 = Ra2(c3, d3), S3 = _a2(c3, d3, l3, p3, b3), E3 = Aa2(c3, d3, l3, p3, b3, m3), x3 = this.k[v3], I3 = this.k[v3 + 1], k3 = r3[v3], R3 = r3[v3 + 1], T3 = ma2(w3, M3, _3, A3, S3, E3, x3, I3, k3, R3), B3 = ya2(w3, M3, _3, A3, S3, E3, x3, I3, k3, R3);
        w3 = xa(n3, i3), M3 = Ia2(n3, i3), _3 = Sa2(n3, i3, o3, s3, a3), A3 = Ea2(n3, i3, o3, s3, a3, h3);
        var P3 = da2(w3, M3, _3, A3), O3 = la2(w3, M3, _3, A3);
        y3 = b3, g2 = m3, b3 = l3, m3 = p3, l3 = c3, p3 = d3, c3 = da2(f3, u3, T3, B3), d3 = la2(u3, u3, T3, B3), f3 = a3, u3 = h3, a3 = o3, h3 = s3, o3 = n3, s3 = i3, n3 = da2(T3, B3, P3, O3), i3 = la2(T3, B3, P3, O3);
      }
      ca2(this.h, 0, n3, i3), ca2(this.h, 2, o3, s3), ca2(this.h, 4, a3, h3), ca2(this.h, 6, f3, u3), ca2(this.h, 8, c3, d3), ca2(this.h, 10, l3, p3), ca2(this.h, 12, b3, m3), ca2(this.h, 14, y3, g2);
    }, wa2.prototype._digest = function(t3) {
      return "hex" === t3 ? ia2.toHex32(this.h, "big") : ia2.split32(this.h, "big");
    };
    var Ua2 = ss, La2 = Ma2;
    function Na2() {
      if (!(this instanceof Na2))
        return new Na2();
      La2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Ua2.inherits(Na2, La2);
    var za2 = Na2;
    Na2.blockSize = 1024, Na2.outSize = 384, Na2.hmacStrength = 192, Na2.padLength = 128, Na2.prototype._digest = function(t3) {
      return "hex" === t3 ? Ua2.toHex32(this.h.slice(0, 12), "big") : Ua2.split32(this.h.slice(0, 12), "big");
    }, ws.sha1 = Ns, ws.sha224 = na, ws.sha256 = Qs, ws.sha384 = za2, ws.sha512 = Ma2;
    var Ca2 = {}, qa2 = ss, ja2 = ms, Da2 = qa2.rotl32, Fa2 = qa2.sum32, Ka2 = qa2.sum32_3, Ya2 = qa2.sum32_4, Va2 = ja2.BlockHash;
    function Wa2() {
      if (!(this instanceof Wa2))
        return new Wa2();
      Va2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    function Ha2(t3, e4, r3, n3) {
      return t3 <= 15 ? e4 ^ r3 ^ n3 : t3 <= 31 ? e4 & r3 | ~e4 & n3 : t3 <= 47 ? (e4 | ~r3) ^ n3 : t3 <= 63 ? e4 & n3 | r3 & ~n3 : e4 ^ (r3 | ~n3);
    }
    function $a(t3) {
      return t3 <= 15 ? 0 : t3 <= 31 ? 1518500249 : t3 <= 47 ? 1859775393 : t3 <= 63 ? 2400959708 : 2840853838;
    }
    function Ga2(t3) {
      return t3 <= 15 ? 1352829926 : t3 <= 31 ? 1548603684 : t3 <= 47 ? 1836072691 : t3 <= 63 ? 2053994217 : 0;
    }
    qa2.inherits(Wa2, Va2), Ca2.ripemd160 = Wa2, Wa2.blockSize = 512, Wa2.outSize = 160, Wa2.hmacStrength = 192, Wa2.padLength = 64, Wa2.prototype._update = function(t3, e4) {
      for (var r3 = this.h[0], n3 = this.h[1], i3 = this.h[2], o3 = this.h[3], s3 = this.h[4], a3 = r3, h3 = n3, f3 = i3, u3 = o3, c3 = s3, d3 = 0; d3 < 80; d3++) {
        var l3 = Fa2(Da2(Ya2(r3, Ha2(d3, n3, i3, o3), t3[Za2[d3] + e4], $a(d3)), Xa2[d3]), s3);
        r3 = s3, s3 = o3, o3 = Da2(i3, 10), i3 = n3, n3 = l3, l3 = Fa2(Da2(Ya2(a3, Ha2(79 - d3, h3, f3, u3), t3[Ja2[d3] + e4], Ga2(d3)), Qa2[d3]), c3), a3 = c3, c3 = u3, u3 = Da2(f3, 10), f3 = h3, h3 = l3;
      }
      l3 = Ka2(this.h[1], i3, u3), this.h[1] = Ka2(this.h[2], o3, c3), this.h[2] = Ka2(this.h[3], s3, a3), this.h[3] = Ka2(this.h[4], r3, h3), this.h[4] = Ka2(this.h[0], n3, f3), this.h[0] = l3;
    }, Wa2.prototype._digest = function(t3) {
      return "hex" === t3 ? qa2.toHex32(this.h, "little") : qa2.split32(this.h, "little");
    };
    var Za2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Ja2 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], Xa2 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], Qa2 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], th2 = ss, eh2 = as;
    function rh2(t3, e4, r3) {
      if (!(this instanceof rh2))
        return new rh2(t3, e4, r3);
      this.Hash = t3, this.blockSize = t3.blockSize / 8, this.outSize = t3.outSize / 8, this.inner = null, this.outer = null, this._init(th2.toArray(e4, r3));
    }
    var nh2 = rh2;
    rh2.prototype._init = function(t3) {
      t3.length > this.blockSize && (t3 = new this.Hash().update(t3).digest()), eh2(t3.length <= this.blockSize);
      for (var e4 = t3.length; e4 < this.blockSize; e4++)
        t3.push(0);
      for (e4 = 0; e4 < t3.length; e4++)
        t3[e4] ^= 54;
      for (this.inner = new this.Hash().update(t3), e4 = 0; e4 < t3.length; e4++)
        t3[e4] ^= 106;
      this.outer = new this.Hash().update(t3);
    }, rh2.prototype.update = function(t3, e4) {
      return this.inner.update(t3, e4), this;
    }, rh2.prototype.digest = function(t3) {
      return this.outer.update(this.inner.digest()), this.outer.digest(t3);
    }, function(t3) {
      var e4 = t3;
      e4.utils = ss, e4.common = ms, e4.sha = ws, e4.ripemd = Ca2, e4.hmac = nh2, e4.sha1 = e4.sha.sha1, e4.sha256 = e4.sha.sha256, e4.sha224 = e4.sha.sha224, e4.sha384 = e4.sha.sha384, e4.sha512 = e4.sha.sha512, e4.ripemd160 = e4.ripemd.ripemd160;
    }(os);
    var ih2 = os;
    let oh2 = false, sh2 = false;
    const ah2 = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
    let hh2 = ah2.default, fh2 = null;
    const uh2 = function() {
      try {
        const t3 = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e4) => {
          try {
            if ("test" !== "test".normalize(e4))
              throw new Error("bad normalize");
          } catch (r3) {
            t3.push(e4);
          }
        }), t3.length)
          throw new Error("missing " + t3.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
          throw new Error("broken implementation");
      } catch (t3) {
        return t3.message;
      }
      return null;
    }();
    var ch2, dh2;
    !function(t3) {
      t3.DEBUG = "DEBUG", t3.INFO = "INFO", t3.WARNING = "WARNING", t3.ERROR = "ERROR", t3.OFF = "OFF";
    }(ch2 || (ch2 = {})), function(t3) {
      t3.UNKNOWN_ERROR = "UNKNOWN_ERROR", t3.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t3.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t3.NETWORK_ERROR = "NETWORK_ERROR", t3.SERVER_ERROR = "SERVER_ERROR", t3.TIMEOUT = "TIMEOUT", t3.BUFFER_OVERRUN = "BUFFER_OVERRUN", t3.NUMERIC_FAULT = "NUMERIC_FAULT", t3.MISSING_NEW = "MISSING_NEW", t3.INVALID_ARGUMENT = "INVALID_ARGUMENT", t3.MISSING_ARGUMENT = "MISSING_ARGUMENT", t3.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t3.CALL_EXCEPTION = "CALL_EXCEPTION", t3.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t3.NONCE_EXPIRED = "NONCE_EXPIRED", t3.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t3.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t3.TRANSACTION_REPLACED = "TRANSACTION_REPLACED";
    }(dh2 || (dh2 = {}));
    const lh2 = "0123456789abcdef";
    class ph2 {
      constructor(t3) {
        Object.defineProperty(this, "version", { enumerable: true, value: t3, writable: false });
      }
      _log(t3, e4) {
        const r3 = t3.toLowerCase();
        null == ah2[r3] && this.throwArgumentError("invalid log level name", "logLevel", t3), hh2 > ah2[r3] || console.log.apply(console, e4);
      }
      debug(...t3) {
        this._log(ph2.levels.DEBUG, t3);
      }
      info(...t3) {
        this._log(ph2.levels.INFO, t3);
      }
      warn(...t3) {
        this._log(ph2.levels.WARNING, t3);
      }
      makeError(t3, e4, r3) {
        if (sh2)
          return this.makeError("censored error", e4, {});
        e4 || (e4 = ph2.errors.UNKNOWN_ERROR), r3 || (r3 = {});
        const n3 = [];
        Object.keys(r3).forEach((t4) => {
          const e6 = r3[t4];
          try {
            if (e6 instanceof Uint8Array) {
              let r4 = "";
              for (let t5 = 0; t5 < e6.length; t5++)
                r4 += lh2[e6[t5] >> 4], r4 += lh2[15 & e6[t5]];
              n3.push(t4 + "=Uint8Array(0x" + r4 + ")");
            } else
              n3.push(t4 + "=" + JSON.stringify(e6));
          } catch (e7) {
            n3.push(t4 + "=" + JSON.stringify(r3[t4].toString()));
          }
        }), n3.push(`code=${e4}`), n3.push(`version=${this.version}`);
        const i3 = t3;
        let o3 = "";
        switch (e4) {
          case dh2.NUMERIC_FAULT: {
            o3 = "NUMERIC_FAULT";
            const e6 = t3;
            switch (e6) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                o3 += "-" + e6;
                break;
              case "negative-power":
              case "negative-width":
                o3 += "-unsupported";
                break;
              case "unbound-bitwise-result":
                o3 += "-unbound-result";
            }
            break;
          }
          case dh2.CALL_EXCEPTION:
          case dh2.INSUFFICIENT_FUNDS:
          case dh2.MISSING_NEW:
          case dh2.NONCE_EXPIRED:
          case dh2.REPLACEMENT_UNDERPRICED:
          case dh2.TRANSACTION_REPLACED:
          case dh2.UNPREDICTABLE_GAS_LIMIT:
            o3 = e4;
        }
        o3 && (t3 += " [ See: https://links.ethers.org/v5-errors-" + o3 + " ]"), n3.length && (t3 += " (" + n3.join(", ") + ")");
        const s3 = new Error(t3);
        return s3.reason = i3, s3.code = e4, Object.keys(r3).forEach(function(t4) {
          s3[t4] = r3[t4];
        }), s3;
      }
      throwError(t3, e4, r3) {
        throw this.makeError(t3, e4, r3);
      }
      throwArgumentError(t3, e4, r3) {
        return this.throwError(t3, ph2.errors.INVALID_ARGUMENT, { argument: e4, value: r3 });
      }
      assert(t3, e4, r3, n3) {
        t3 || this.throwError(e4, r3, n3);
      }
      assertArgument(t3, e4, r3, n3) {
        t3 || this.throwArgumentError(e4, r3, n3);
      }
      checkNormalize(t3) {
        uh2 && this.throwError("platform missing String.prototype.normalize", ph2.errors.UNSUPPORTED_OPERATION, { operation: "String.prototype.normalize", form: uh2 });
      }
      checkSafeUint53(t3, e4) {
        "number" == typeof t3 && (null == e4 && (e4 = "value not safe"), (t3 < 0 || t3 >= 9007199254740991) && this.throwError(e4, ph2.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: t3 }), t3 % 1 && this.throwError(e4, ph2.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: t3 }));
      }
      checkArgumentCount(t3, e4, r3) {
        r3 = r3 ? ": " + r3 : "", t3 < e4 && this.throwError("missing argument" + r3, ph2.errors.MISSING_ARGUMENT, { count: t3, expectedCount: e4 }), t3 > e4 && this.throwError("too many arguments" + r3, ph2.errors.UNEXPECTED_ARGUMENT, { count: t3, expectedCount: e4 });
      }
      checkNew(t3, e4) {
        t3 !== Object && null != t3 || this.throwError("missing new", ph2.errors.MISSING_NEW, { name: e4.name });
      }
      checkAbstract(t3, e4) {
        t3 === e4 ? this.throwError("cannot instantiate abstract class " + JSON.stringify(e4.name) + " directly; use a sub-class", ph2.errors.UNSUPPORTED_OPERATION, { name: t3.name, operation: "new" }) : t3 !== Object && null != t3 || this.throwError("missing new", ph2.errors.MISSING_NEW, { name: e4.name });
      }
      static globalLogger() {
        return fh2 || (fh2 = new ph2("logger/5.6.0")), fh2;
      }
      static setCensorship(t3, e4) {
        if (!t3 && e4 && this.globalLogger().throwError("cannot permanently disable censorship", ph2.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" }), oh2) {
          if (!t3)
            return;
          this.globalLogger().throwError("error censorship permanent", ph2.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" });
        }
        sh2 = !!t3, oh2 = !!e4;
      }
      static setLogLevel(t3) {
        const e4 = ah2[t3.toLowerCase()];
        null != e4 ? hh2 = e4 : ph2.globalLogger().warn("invalid log level - " + t3);
      }
      static from(t3) {
        return new ph2(t3);
      }
    }
    ph2.errors = dh2, ph2.levels = ch2;
    const bh2 = new ph2("bytes/5.6.0");
    function mh2(t3) {
      return t3.slice || (t3.slice = function() {
        const e4 = Array.prototype.slice.call(arguments);
        return mh2(new Uint8Array(Array.prototype.slice.apply(t3, e4)));
      }), t3;
    }
    function yh2(t3) {
      return "number" == typeof t3 && t3 == t3 && t3 % 1 == 0;
    }
    function gh2(t3, e4) {
      if (e4 || (e4 = {}), "number" == typeof t3) {
        bh2.checkSafeUint53(t3, "invalid arrayify value");
        const e6 = [];
        for (; t3; )
          e6.unshift(255 & t3), t3 = parseInt(String(t3 / 256));
        return 0 === e6.length && e6.push(0), mh2(new Uint8Array(e6));
      }
      if (e4.allowMissingPrefix && "string" == typeof t3 && "0x" !== t3.substring(0, 2) && (t3 = "0x" + t3), function(t4) {
        return !!t4.toHexString;
      }(t3) && (t3 = t3.toHexString()), function(t4, e6) {
        if ("string" != typeof t4 || !t4.match(/^0x[0-9A-Fa-f]*$/))
          return false;
        if (e6 && t4.length !== 2 + 2 * e6)
          return false;
        return true;
      }(t3)) {
        let r3 = t3.substring(2);
        r3.length % 2 && ("left" === e4.hexPad ? r3 = "0x0" + r3.substring(2) : "right" === e4.hexPad ? r3 += "0" : bh2.throwArgumentError("hex data is odd-length", "value", t3));
        const n3 = [];
        for (let t4 = 0; t4 < r3.length; t4 += 2)
          n3.push(parseInt(r3.substring(t4, t4 + 2), 16));
        return mh2(new Uint8Array(n3));
      }
      return function(t4) {
        if (null == t4)
          return false;
        if (t4.constructor === Uint8Array)
          return true;
        if ("string" == typeof t4)
          return false;
        if (!yh2(t4.length) || t4.length < 0)
          return false;
        for (let e6 = 0; e6 < t4.length; e6++) {
          const r3 = t4[e6];
          if (!yh2(r3) || r3 < 0 || r3 >= 256)
            return false;
        }
        return true;
      }(t3) ? mh2(new Uint8Array(t3)) : bh2.throwArgumentError("invalid arrayify value", "value", t3);
    }
    function vh2(t3) {
      return "0x" + ih2.sha256().update(gh2(t3)).digest("hex");
    }
    new ph2("sha2/5.6.0");
    const wh2 = /* @__PURE__ */ new Map();
    class Mh2 extends class {
      constructor(t3) {
        Object.assign(this, t3);
      }
      encode() {
        return ct.from(_e2(wh2, this));
      }
      static decode(t3) {
        return Me2(wh2, this, t3);
      }
      static decodeUnchecked(t3) {
        return we2(wh2, this, t3);
      }
    } {
      constructor(t3) {
        if (super({}), this._bn = void 0, function(t4) {
          return void 0 !== t4._bn;
        }(t3))
          this._bn = t3._bn;
        else {
          if ("string" == typeof t3) {
            const e4 = ae2.decode(t3);
            if (32 != e4.length)
              throw new Error("Invalid public key input");
            this._bn = new ne2(e4);
          } else
            this._bn = new ne2(t3);
          if (this._bn.byteLength() > 32)
            throw new Error("Invalid public key input");
        }
      }
      equals(t3) {
        return this._bn.eq(t3._bn);
      }
      toBase58() {
        return ae2.encode(this.toBytes());
      }
      toJSON() {
        return this.toBase58();
      }
      toBytes() {
        return this.toBuffer();
      }
      toBuffer() {
        const t3 = this._bn.toArrayLike(ct);
        if (32 === t3.length)
          return t3;
        const e4 = ct.alloc(32);
        return t3.copy(e4, 32 - t3.length), e4;
      }
      toString() {
        return this.toBase58();
      }
      static async createWithSeed(t3, e4, r3) {
        const n3 = ct.concat([t3.toBuffer(), ct.from(e4), r3.toBuffer()]), i3 = vh2(new Uint8Array(n3)).slice(2);
        return new Mh2(ct.from(i3, "hex"));
      }
      static async createProgramAddress(t3, e4) {
        let r3 = ct.alloc(0);
        t3.forEach(function(t4) {
          if (t4.length > 32)
            throw new TypeError("Max seed length exceeded");
          r3 = ct.concat([r3, ns(t4)]);
        }), r3 = ct.concat([r3, e4.toBuffer(), ct.from("ProgramDerivedAddress")]);
        let n3 = vh2(new Uint8Array(r3)).slice(2), i3 = new ne2(n3, 16).toArray(void 0, 32);
        if (Ah2(i3))
          throw new Error("Invalid seeds, address must fall off the curve");
        return new Mh2(i3);
      }
      static async findProgramAddress(t3, e4) {
        let r3, n3 = 255;
        for (; 0 != n3; ) {
          try {
            const i3 = t3.concat(ct.from([n3]));
            r3 = await this.createProgramAddress(i3, e4);
          } catch (t4) {
            if (t4 instanceof TypeError)
              throw t4;
            n3--;
            continue;
          }
          return [r3, n3];
        }
        throw new Error("Unable to find a viable program address nonce");
      }
      static isOnCurve(t3) {
        return 1 == Ah2(t3);
      }
    }
    Mh2.default = new Mh2("11111111111111111111111111111111"), wh2.set(Mh2, { kind: "struct", fields: [["_bn", "u256"]] });
    let _h = re2.lowlevel;
    function Ah2(t3) {
      var e4 = [_h.gf(), _h.gf(), _h.gf(), _h.gf()], r3 = _h.gf(), n3 = _h.gf(), i3 = _h.gf(), o3 = _h.gf(), s3 = _h.gf(), a3 = _h.gf(), h3 = _h.gf();
      return _h.set25519(e4[2], Sh2), _h.unpack25519(e4[1], t3), _h.S(i3, e4[1]), _h.M(o3, i3, _h.D), _h.Z(i3, i3, e4[2]), _h.A(o3, e4[2], o3), _h.S(s3, o3), _h.S(a3, s3), _h.M(h3, a3, s3), _h.M(r3, h3, i3), _h.M(r3, r3, o3), _h.pow2523(r3, r3), _h.M(r3, r3, i3), _h.M(r3, r3, o3), _h.M(r3, r3, o3), _h.M(e4[0], r3, o3), _h.S(n3, e4[0]), _h.M(n3, n3, o3), xh2(n3, i3) && _h.M(e4[0], e4[0], Eh2), _h.S(n3, e4[0]), _h.M(n3, n3, o3), xh2(n3, i3) ? 0 : 1;
    }
    let Sh2 = _h.gf([1]), Eh2 = _h.gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function xh2(t3, e4) {
      var r3 = new Uint8Array(32), n3 = new Uint8Array(32);
      return _h.pack25519(r3, t3), _h.pack25519(n3, e4), _h.crypto_verify_32(r3, 0, n3, 0);
    }
    new Mh2("BPFLoader1111111111111111111111111111111111");
    const Ih2 = (t3 = "publicKey") => Re2(32, t3), kh2 = (t3 = "string") => {
      const e4 = Be2([Ee2("length"), Ee2("lengthPadding"), Re2(ke2(Ee2(), -8), "chars")], t3), r3 = e4.decode.bind(e4), n3 = e4.encode.bind(e4), i3 = e4;
      return i3.decode = (t4, e6) => r3(t4, e6).chars.toString(), i3.encode = (t4, e6, r4) => {
        const i4 = { chars: ct.from(t4, "utf8") };
        return n3(i4, e6, r4);
      }, i3.alloc = (t4) => Ee2().span + Ee2().span + ct.from(t4, "utf8").length, i3;
    };
    function Rh2(t3) {
      let e4 = 0, r3 = 0;
      for (; ; ) {
        let n3 = t3.shift();
        if (e4 |= (127 & n3) << 7 * r3, r3 += 1, 0 == (128 & n3))
          break;
      }
      return e4;
    }
    function Th2(t3, e4) {
      let r3 = e4;
      for (; ; ) {
        let e6 = 127 & r3;
        if (r3 >>= 7, 0 == r3) {
          t3.push(e6);
          break;
        }
        e6 |= 128, t3.push(e6);
      }
    }
    class Bh2 {
      constructor(t3) {
        this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = t3.header, this.accountKeys = t3.accountKeys.map((t4) => new Mh2(t4)), this.recentBlockhash = t3.recentBlockhash, this.instructions = t3.instructions, this.instructions.forEach((t4) => this.indexToProgramIds.set(t4.programIdIndex, this.accountKeys[t4.programIdIndex]));
      }
      isAccountSigner(t3) {
        return t3 < this.header.numRequiredSignatures;
      }
      isAccountWritable(t3) {
        return t3 < this.header.numRequiredSignatures - this.header.numReadonlySignedAccounts || t3 >= this.header.numRequiredSignatures && t3 < this.accountKeys.length - this.header.numReadonlyUnsignedAccounts;
      }
      isProgramId(t3) {
        return this.indexToProgramIds.has(t3);
      }
      programIds() {
        return [...this.indexToProgramIds.values()];
      }
      nonProgramIds() {
        return this.accountKeys.filter((t3, e4) => !this.isProgramId(e4));
      }
      serialize() {
        const t3 = this.accountKeys.length;
        let e4 = [];
        Th2(e4, t3);
        const r3 = this.instructions.map((t4) => {
          const { accounts: e6, programIdIndex: r4 } = t4, n4 = Array.from(ae2.decode(t4.data));
          let i4 = [];
          Th2(i4, e6.length);
          let o4 = [];
          return Th2(o4, n4.length), { programIdIndex: r4, keyIndicesCount: ct.from(i4), keyIndices: e6, dataLength: ct.from(o4), data: n4 };
        });
        let n3 = [];
        Th2(n3, r3.length);
        let i3 = ct.alloc(Uh2);
        ct.from(n3).copy(i3);
        let o3 = n3.length;
        r3.forEach((t4) => {
          const e6 = Be2([Ie2("programIdIndex"), Re2(t4.keyIndicesCount.length, "keyIndicesCount"), Te2(Ie2("keyIndex"), t4.keyIndices.length, "keyIndices"), Re2(t4.dataLength.length, "dataLength"), Te2(Ie2("userdatum"), t4.data.length, "data")]).encode(t4, i3, o3);
          o3 += e6;
        }), i3 = i3.slice(0, o3);
        const s3 = Be2([Re2(1, "numRequiredSignatures"), Re2(1, "numReadonlySignedAccounts"), Re2(1, "numReadonlyUnsignedAccounts"), Re2(e4.length, "keyCount"), Te2(Ih2("key"), t3, "keys"), Ih2("recentBlockhash")]), a3 = { numRequiredSignatures: ct.from([this.header.numRequiredSignatures]), numReadonlySignedAccounts: ct.from([this.header.numReadonlySignedAccounts]), numReadonlyUnsignedAccounts: ct.from([this.header.numReadonlyUnsignedAccounts]), keyCount: ct.from(e4), keys: this.accountKeys.map((t4) => ns(t4.toBytes())), recentBlockhash: ae2.decode(this.recentBlockhash) };
        let h3 = ct.alloc(2048);
        const f3 = s3.encode(a3, h3);
        return i3.copy(h3, f3), h3.slice(0, f3 + i3.length);
      }
      static from(t3) {
        let e4 = [...t3];
        const r3 = e4.shift(), n3 = e4.shift(), i3 = e4.shift(), o3 = Rh2(e4);
        let s3 = [];
        for (let t4 = 0; t4 < o3; t4++) {
          const t5 = e4.slice(0, 32);
          e4 = e4.slice(32), s3.push(ae2.encode(ct.from(t5)));
        }
        const a3 = e4.slice(0, 32);
        e4 = e4.slice(32);
        const h3 = Rh2(e4);
        let f3 = [];
        for (let t4 = 0; t4 < h3; t4++) {
          const t5 = e4.shift(), r4 = Rh2(e4), n4 = e4.slice(0, r4);
          e4 = e4.slice(r4);
          const i4 = Rh2(e4), o4 = e4.slice(0, i4), s4 = ae2.encode(ct.from(o4));
          e4 = e4.slice(i4), f3.push({ programIdIndex: t5, accounts: n4, data: s4 });
        }
        const u3 = { header: { numRequiredSignatures: r3, numReadonlySignedAccounts: n3, numReadonlyUnsignedAccounts: i3 }, recentBlockhash: ae2.encode(ct.from(a3)), accountKeys: s3, instructions: f3 };
        return new Bh2(u3);
      }
    }
    function Ph2(t3, e4) {
      if (!t3)
        throw new Error(e4 || "Assertion failed");
    }
    const Oh2 = ct.alloc(64).fill(0), Uh2 = 1232;
    class Lh2 {
      constructor(t3) {
        this.keys = void 0, this.programId = void 0, this.data = ct.alloc(0), this.programId = t3.programId, this.keys = t3.keys, t3.data && (this.data = t3.data);
      }
    }
    class Nh2 {
      get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null;
      }
      constructor(t3) {
        this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.nonceInfo = void 0, t3 && Object.assign(this, t3);
      }
      add(...t3) {
        if (0 === t3.length)
          throw new Error("No instructions");
        return t3.forEach((t4) => {
          "instructions" in t4 ? this.instructions = this.instructions.concat(t4.instructions) : "data" in t4 && "programId" in t4 && "keys" in t4 ? this.instructions.push(t4) : this.instructions.push(new Lh2(t4));
        }), this;
      }
      compileMessage() {
        const { nonceInfo: t3 } = this;
        t3 && this.instructions[0] != t3.nonceInstruction && (this.recentBlockhash = t3.nonce, this.instructions.unshift(t3.nonceInstruction));
        const { recentBlockhash: e4 } = this;
        if (!e4)
          throw new Error("Transaction recentBlockhash required");
        let r3;
        if (this.instructions.length < 1 && console.warn("No instructions provided"), this.feePayer)
          r3 = this.feePayer;
        else {
          if (!(this.signatures.length > 0 && this.signatures[0].publicKey))
            throw new Error("Transaction fee payer required");
          r3 = this.signatures[0].publicKey;
        }
        for (let t4 = 0; t4 < this.instructions.length; t4++)
          if (void 0 === this.instructions[t4].programId)
            throw new Error(`Transaction instruction index ${t4} has undefined program id`);
        const n3 = [], i3 = [];
        this.instructions.forEach((t4) => {
          t4.keys.forEach((t5) => {
            i3.push({ ...t5 });
          });
          const e6 = t4.programId.toString();
          n3.includes(e6) || n3.push(e6);
        }), n3.forEach((t4) => {
          i3.push({ pubkey: new Mh2(t4), isSigner: false, isWritable: false });
        }), i3.sort(function(t4, e6) {
          const r4 = t4.pubkey.toBase58().localeCompare(e6.pubkey.toBase58()), n4 = t4.isSigner === e6.isSigner ? 0 : t4.isSigner ? -1 : 1, i4 = t4.isWritable === e6.isWritable ? r4 : t4.isWritable ? -1 : 1;
          return n4 || i4;
        });
        const o3 = [];
        i3.forEach((t4) => {
          const e6 = t4.pubkey.toString(), r4 = o3.findIndex((t5) => t5.pubkey.toString() === e6);
          r4 > -1 ? o3[r4].isWritable = o3[r4].isWritable || t4.isWritable : o3.push(t4);
        });
        const s3 = o3.findIndex((t4) => t4.pubkey.equals(r3));
        if (s3 > -1) {
          const [t4] = o3.splice(s3, 1);
          t4.isSigner = true, t4.isWritable = true, o3.unshift(t4);
        } else
          o3.unshift({ pubkey: r3, isSigner: true, isWritable: true });
        for (const t4 of this.signatures) {
          const e6 = o3.findIndex((e7) => e7.pubkey.equals(t4.publicKey));
          if (!(e6 > -1))
            throw new Error(`unknown signer: ${t4.publicKey.toString()}`);
          o3[e6].isSigner || (o3[e6].isSigner = true, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
        }
        let a3 = 0, h3 = 0, f3 = 0;
        const u3 = [], c3 = [];
        o3.forEach(({ pubkey: t4, isSigner: e6, isWritable: r4 }) => {
          e6 ? (u3.push(t4.toString()), a3 += 1, r4 || (h3 += 1)) : (c3.push(t4.toString()), r4 || (f3 += 1));
        });
        const d3 = u3.concat(c3), l3 = this.instructions.map((t4) => {
          const { data: e6, programId: r4 } = t4;
          return { programIdIndex: d3.indexOf(r4.toString()), accounts: t4.keys.map((t5) => d3.indexOf(t5.pubkey.toString())), data: ae2.encode(e6) };
        });
        return l3.forEach((t4) => {
          Ph2(t4.programIdIndex >= 0), t4.accounts.forEach((t5) => Ph2(t5 >= 0));
        }), new Bh2({ header: { numRequiredSignatures: a3, numReadonlySignedAccounts: h3, numReadonlyUnsignedAccounts: f3 }, accountKeys: d3, recentBlockhash: e4, instructions: l3 });
      }
      _compile() {
        const t3 = this.compileMessage(), e4 = t3.accountKeys.slice(0, t3.header.numRequiredSignatures);
        if (this.signatures.length === e4.length) {
          if (this.signatures.every((t4, r3) => e4[r3].equals(t4.publicKey)))
            return t3;
        }
        return this.signatures = e4.map((t4) => ({ signature: null, publicKey: t4 })), t3;
      }
      serializeMessage() {
        return this._compile().serialize();
      }
      async getEstimatedFee(t3) {
        return (await t3.getFeeForMessage(this.compileMessage())).value;
      }
      setSigners(...t3) {
        if (0 === t3.length)
          throw new Error("No signers");
        const e4 = /* @__PURE__ */ new Set();
        this.signatures = t3.filter((t4) => {
          const r3 = t4.toString();
          return !e4.has(r3) && (e4.add(r3), true);
        }).map((t4) => ({ signature: null, publicKey: t4 }));
      }
      sign(...t3) {
        if (0 === t3.length)
          throw new Error("No signers");
        const e4 = /* @__PURE__ */ new Set(), r3 = [];
        for (const n4 of t3) {
          const t4 = n4.publicKey.toString();
          e4.has(t4) || (e4.add(t4), r3.push(n4));
        }
        this.signatures = r3.map((t4) => ({ signature: null, publicKey: t4.publicKey }));
        const n3 = this._compile();
        this._partialSign(n3, ...r3), this._verifySignatures(n3.serialize(), true);
      }
      partialSign(...t3) {
        if (0 === t3.length)
          throw new Error("No signers");
        const e4 = /* @__PURE__ */ new Set(), r3 = [];
        for (const n4 of t3) {
          const t4 = n4.publicKey.toString();
          e4.has(t4) || (e4.add(t4), r3.push(n4));
        }
        const n3 = this._compile();
        this._partialSign(n3, ...r3);
      }
      _partialSign(t3, ...e4) {
        const r3 = t3.serialize();
        e4.forEach((t4) => {
          const e6 = re2.sign.detached(r3, t4.secretKey);
          this._addSignature(t4.publicKey, ns(e6));
        });
      }
      addSignature(t3, e4) {
        this._compile(), this._addSignature(t3, e4);
      }
      _addSignature(t3, e4) {
        Ph2(64 === e4.length);
        const r3 = this.signatures.findIndex((e6) => t3.equals(e6.publicKey));
        if (r3 < 0)
          throw new Error(`unknown signer: ${t3.toString()}`);
        this.signatures[r3].signature = ct.from(e4);
      }
      verifySignatures() {
        return this._verifySignatures(this.serializeMessage(), true);
      }
      _verifySignatures(t3, e4) {
        for (const { signature: r3, publicKey: n3 } of this.signatures)
          if (null === r3) {
            if (e4)
              return false;
          } else if (!re2.sign.detached.verify(t3, r3, n3.toBuffer()))
            return false;
        return true;
      }
      serialize(t3) {
        const { requireAllSignatures: e4, verifySignatures: r3 } = Object.assign({ requireAllSignatures: true, verifySignatures: true }, t3), n3 = this.serializeMessage();
        if (r3 && !this._verifySignatures(n3, e4))
          throw new Error("Signature verification failed");
        return this._serialize(n3);
      }
      _serialize(t3) {
        const { signatures: e4 } = this, r3 = [];
        Th2(r3, e4.length);
        const n3 = r3.length + 64 * e4.length + t3.length, i3 = ct.alloc(n3);
        return Ph2(e4.length < 256), ct.from(r3).copy(i3, 0), e4.forEach(({ signature: t4 }, e6) => {
          null !== t4 && (Ph2(64 === t4.length, "signature has invalid length"), ct.from(t4).copy(i3, r3.length + 64 * e6));
        }), t3.copy(i3, r3.length + 64 * e4.length), Ph2(i3.length <= Uh2, `Transaction too large: ${i3.length} > ${Uh2}`), i3;
      }
      get keys() {
        return Ph2(1 === this.instructions.length), this.instructions[0].keys.map((t3) => t3.pubkey);
      }
      get programId() {
        return Ph2(1 === this.instructions.length), this.instructions[0].programId;
      }
      get data() {
        return Ph2(1 === this.instructions.length), this.instructions[0].data;
      }
      static from(t3) {
        let e4 = [...t3];
        const r3 = Rh2(e4);
        let n3 = [];
        for (let t4 = 0; t4 < r3; t4++) {
          const t5 = e4.slice(0, 64);
          e4 = e4.slice(64), n3.push(ae2.encode(ct.from(t5)));
        }
        return Nh2.populate(Bh2.from(e4), n3);
      }
      static populate(t3, e4 = []) {
        const r3 = new Nh2();
        return r3.recentBlockhash = t3.recentBlockhash, t3.header.numRequiredSignatures > 0 && (r3.feePayer = t3.accountKeys[0]), e4.forEach((e6, n3) => {
          const i3 = { signature: e6 == ae2.encode(Oh2) ? null : ae2.decode(e6), publicKey: t3.accountKeys[n3] };
          r3.signatures.push(i3);
        }), t3.instructions.forEach((e6) => {
          const n3 = e6.accounts.map((e7) => {
            const n4 = t3.accountKeys[e7];
            return { pubkey: n4, isSigner: r3.signatures.some((t4) => t4.publicKey.toString() === n4.toString()) || t3.isAccountSigner(e7), isWritable: t3.isAccountWritable(e7) };
          });
          r3.instructions.push(new Lh2({ keys: n3, programId: t3.accountKeys[e6.programIdIndex], data: ae2.decode(e6.data) }));
        }), r3;
      }
    }
    new Mh2("SysvarC1ock11111111111111111111111111111111"), new Mh2("SysvarEpochSchedu1e111111111111111111111111"), new Mh2("Sysvar1nstructions1111111111111111111111111"), new Mh2("SysvarRecentB1ockHashes11111111111111111111"), new Mh2("SysvarRent111111111111111111111111111111111"), new Mh2("SysvarRewards111111111111111111111111111111"), new Mh2("SysvarS1otHashes111111111111111111111111111"), new Mh2("SysvarS1otHistory11111111111111111111111111"), new Mh2("SysvarStakeHistory1111111111111111111111111");
    const zh2 = Se2("lamportsPerSignature");
    Be2([Ee2("version"), Ee2("state"), Ih2("authorizedPubkey"), Ih2("nonce"), Be2([zh2], "feeCalculator")]).span, Object.freeze({ Create: { index: 0, layout: Be2([Ee2("instruction"), Pe2("lamports"), Pe2("space"), Ih2("programId")]) }, Assign: { index: 1, layout: Be2([Ee2("instruction"), Ih2("programId")]) }, Transfer: { index: 2, layout: Be2([Ee2("instruction"), Pe2("lamports")]) }, CreateWithSeed: { index: 3, layout: Be2([Ee2("instruction"), Ih2("base"), kh2("seed"), Pe2("lamports"), Pe2("space"), Ih2("programId")]) }, AdvanceNonceAccount: { index: 4, layout: Be2([Ee2("instruction")]) }, WithdrawNonceAccount: { index: 5, layout: Be2([Ee2("instruction"), Pe2("lamports")]) }, InitializeNonceAccount: { index: 6, layout: Be2([Ee2("instruction"), Ih2("authorized")]) }, AuthorizeNonceAccount: { index: 7, layout: Be2([Ee2("instruction"), Ih2("authorized")]) }, Allocate: { index: 8, layout: Be2([Ee2("instruction"), Pe2("space")]) }, AllocateWithSeed: { index: 9, layout: Be2([Ee2("instruction"), Ih2("base"), kh2("seed"), Pe2("space"), Ih2("programId")]) }, AssignWithSeed: { index: 10, layout: Be2([Ee2("instruction"), Ih2("base"), kh2("seed"), Ih2("programId")]) }, TransferWithSeed: { index: 11, layout: Be2([Ee2("instruction"), Pe2("lamports"), kh2("seed"), Ih2("programId")]) } }), new Mh2("11111111111111111111111111111111"), new Mh2("BPFLoader2111111111111111111111111111111111");
    var Ch2 = { exports: {} };
    !function(t3, e4) {
      var r3 = "undefined" != typeof self ? self : is2, n3 = function() {
        function t4() {
          this.fetch = false, this.DOMException = r3.DOMException;
        }
        return t4.prototype = r3, new t4();
      }();
      !function(t4) {
        !function(e6) {
          var r4 = "URLSearchParams" in t4, n4 = "Symbol" in t4 && "iterator" in Symbol, i4 = "FileReader" in t4 && "Blob" in t4 && function() {
            try {
              return new Blob(), true;
            } catch (t5) {
              return false;
            }
          }(), o3 = "FormData" in t4, s3 = "ArrayBuffer" in t4;
          if (s3)
            var a3 = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], h3 = ArrayBuffer.isView || function(t5) {
              return t5 && a3.indexOf(Object.prototype.toString.call(t5)) > -1;
            };
          function f3(t5) {
            if ("string" != typeof t5 && (t5 = String(t5)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t5))
              throw new TypeError("Invalid character in header field name");
            return t5.toLowerCase();
          }
          function u3(t5) {
            return "string" != typeof t5 && (t5 = String(t5)), t5;
          }
          function c3(t5) {
            var e7 = { next: function() {
              var e8 = t5.shift();
              return { done: void 0 === e8, value: e8 };
            } };
            return n4 && (e7[Symbol.iterator] = function() {
              return e7;
            }), e7;
          }
          function d3(t5) {
            this.map = {}, t5 instanceof d3 ? t5.forEach(function(t6, e7) {
              this.append(e7, t6);
            }, this) : Array.isArray(t5) ? t5.forEach(function(t6) {
              this.append(t6[0], t6[1]);
            }, this) : t5 && Object.getOwnPropertyNames(t5).forEach(function(e7) {
              this.append(e7, t5[e7]);
            }, this);
          }
          function l3(t5) {
            if (t5.bodyUsed)
              return Promise.reject(new TypeError("Already read"));
            t5.bodyUsed = true;
          }
          function p3(t5) {
            return new Promise(function(e7, r5) {
              t5.onload = function() {
                e7(t5.result);
              }, t5.onerror = function() {
                r5(t5.error);
              };
            });
          }
          function b3(t5) {
            var e7 = new FileReader(), r5 = p3(e7);
            return e7.readAsArrayBuffer(t5), r5;
          }
          function m3(t5) {
            if (t5.slice)
              return t5.slice(0);
            var e7 = new Uint8Array(t5.byteLength);
            return e7.set(new Uint8Array(t5)), e7.buffer;
          }
          function y3() {
            return this.bodyUsed = false, this._initBody = function(t5) {
              var e7;
              this._bodyInit = t5, t5 ? "string" == typeof t5 ? this._bodyText = t5 : i4 && Blob.prototype.isPrototypeOf(t5) ? this._bodyBlob = t5 : o3 && FormData.prototype.isPrototypeOf(t5) ? this._bodyFormData = t5 : r4 && URLSearchParams.prototype.isPrototypeOf(t5) ? this._bodyText = t5.toString() : s3 && i4 && ((e7 = t5) && DataView.prototype.isPrototypeOf(e7)) ? (this._bodyArrayBuffer = m3(t5.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s3 && (ArrayBuffer.prototype.isPrototypeOf(t5) || h3(t5)) ? this._bodyArrayBuffer = m3(t5) : this._bodyText = t5 = Object.prototype.toString.call(t5) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof t5 ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : r4 && URLSearchParams.prototype.isPrototypeOf(t5) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
            }, i4 && (this.blob = function() {
              var t5 = l3(this);
              if (t5)
                return t5;
              if (this._bodyBlob)
                return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return Promise.resolve(new Blob([this._bodyText]));
            }, this.arrayBuffer = function() {
              return this._bodyArrayBuffer ? l3(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(b3);
            }), this.text = function() {
              var t5, e7, r5, n5 = l3(this);
              if (n5)
                return n5;
              if (this._bodyBlob)
                return t5 = this._bodyBlob, e7 = new FileReader(), r5 = p3(e7), e7.readAsText(t5), r5;
              if (this._bodyArrayBuffer)
                return Promise.resolve(function(t6) {
                  for (var e8 = new Uint8Array(t6), r6 = new Array(e8.length), n6 = 0; n6 < e8.length; n6++)
                    r6[n6] = String.fromCharCode(e8[n6]);
                  return r6.join("");
                }(this._bodyArrayBuffer));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return Promise.resolve(this._bodyText);
            }, o3 && (this.formData = function() {
              return this.text().then(w3);
            }), this.json = function() {
              return this.text().then(JSON.parse);
            }, this;
          }
          d3.prototype.append = function(t5, e7) {
            t5 = f3(t5), e7 = u3(e7);
            var r5 = this.map[t5];
            this.map[t5] = r5 ? r5 + ", " + e7 : e7;
          }, d3.prototype.delete = function(t5) {
            delete this.map[f3(t5)];
          }, d3.prototype.get = function(t5) {
            return t5 = f3(t5), this.has(t5) ? this.map[t5] : null;
          }, d3.prototype.has = function(t5) {
            return this.map.hasOwnProperty(f3(t5));
          }, d3.prototype.set = function(t5, e7) {
            this.map[f3(t5)] = u3(e7);
          }, d3.prototype.forEach = function(t5, e7) {
            for (var r5 in this.map)
              this.map.hasOwnProperty(r5) && t5.call(e7, this.map[r5], r5, this);
          }, d3.prototype.keys = function() {
            var t5 = [];
            return this.forEach(function(e7, r5) {
              t5.push(r5);
            }), c3(t5);
          }, d3.prototype.values = function() {
            var t5 = [];
            return this.forEach(function(e7) {
              t5.push(e7);
            }), c3(t5);
          }, d3.prototype.entries = function() {
            var t5 = [];
            return this.forEach(function(e7, r5) {
              t5.push([r5, e7]);
            }), c3(t5);
          }, n4 && (d3.prototype[Symbol.iterator] = d3.prototype.entries);
          var g2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function v3(t5, e7) {
            var r5, n5, i5 = (e7 = e7 || {}).body;
            if (t5 instanceof v3) {
              if (t5.bodyUsed)
                throw new TypeError("Already read");
              this.url = t5.url, this.credentials = t5.credentials, e7.headers || (this.headers = new d3(t5.headers)), this.method = t5.method, this.mode = t5.mode, this.signal = t5.signal, i5 || null == t5._bodyInit || (i5 = t5._bodyInit, t5.bodyUsed = true);
            } else
              this.url = String(t5);
            if (this.credentials = e7.credentials || this.credentials || "same-origin", !e7.headers && this.headers || (this.headers = new d3(e7.headers)), this.method = (r5 = e7.method || this.method || "GET", n5 = r5.toUpperCase(), g2.indexOf(n5) > -1 ? n5 : r5), this.mode = e7.mode || this.mode || null, this.signal = e7.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && i5)
              throw new TypeError("Body not allowed for GET or HEAD requests");
            this._initBody(i5);
          }
          function w3(t5) {
            var e7 = new FormData();
            return t5.trim().split("&").forEach(function(t6) {
              if (t6) {
                var r5 = t6.split("="), n5 = r5.shift().replace(/\+/g, " "), i5 = r5.join("=").replace(/\+/g, " ");
                e7.append(decodeURIComponent(n5), decodeURIComponent(i5));
              }
            }), e7;
          }
          function M3(t5, e7) {
            e7 || (e7 = {}), this.type = "default", this.status = void 0 === e7.status ? 200 : e7.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in e7 ? e7.statusText : "OK", this.headers = new d3(e7.headers), this.url = e7.url || "", this._initBody(t5);
          }
          v3.prototype.clone = function() {
            return new v3(this, { body: this._bodyInit });
          }, y3.call(v3.prototype), y3.call(M3.prototype), M3.prototype.clone = function() {
            return new M3(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new d3(this.headers), url: this.url });
          }, M3.error = function() {
            var t5 = new M3(null, { status: 0, statusText: "" });
            return t5.type = "error", t5;
          };
          var _3 = [301, 302, 303, 307, 308];
          M3.redirect = function(t5, e7) {
            if (-1 === _3.indexOf(e7))
              throw new RangeError("Invalid status code");
            return new M3(null, { status: e7, headers: { location: t5 } });
          }, e6.DOMException = t4.DOMException;
          try {
            new e6.DOMException();
          } catch (t5) {
            e6.DOMException = function(t6, e7) {
              this.message = t6, this.name = e7;
              var r5 = Error(t6);
              this.stack = r5.stack;
            }, e6.DOMException.prototype = Object.create(Error.prototype), e6.DOMException.prototype.constructor = e6.DOMException;
          }
          function A3(t5, r5) {
            return new Promise(function(n5, o4) {
              var s4 = new v3(t5, r5);
              if (s4.signal && s4.signal.aborted)
                return o4(new e6.DOMException("Aborted", "AbortError"));
              var a4 = new XMLHttpRequest();
              function h4() {
                a4.abort();
              }
              a4.onload = function() {
                var t6, e7, r6 = { status: a4.status, statusText: a4.statusText, headers: (t6 = a4.getAllResponseHeaders() || "", e7 = new d3(), t6.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(t7) {
                  var r7 = t7.split(":"), n6 = r7.shift().trim();
                  if (n6) {
                    var i6 = r7.join(":").trim();
                    e7.append(n6, i6);
                  }
                }), e7) };
                r6.url = "responseURL" in a4 ? a4.responseURL : r6.headers.get("X-Request-URL");
                var i5 = "response" in a4 ? a4.response : a4.responseText;
                n5(new M3(i5, r6));
              }, a4.onerror = function() {
                o4(new TypeError("Network request failed"));
              }, a4.ontimeout = function() {
                o4(new TypeError("Network request failed"));
              }, a4.onabort = function() {
                o4(new e6.DOMException("Aborted", "AbortError"));
              }, a4.open(s4.method, s4.url, true), "include" === s4.credentials ? a4.withCredentials = true : "omit" === s4.credentials && (a4.withCredentials = false), "responseType" in a4 && i4 && (a4.responseType = "blob"), s4.headers.forEach(function(t6, e7) {
                a4.setRequestHeader(e7, t6);
              }), s4.signal && (s4.signal.addEventListener("abort", h4), a4.onreadystatechange = function() {
                4 === a4.readyState && s4.signal.removeEventListener("abort", h4);
              }), a4.send(void 0 === s4._bodyInit ? null : s4._bodyInit);
            });
          }
          A3.polyfill = true, t4.fetch || (t4.fetch = A3, t4.Headers = d3, t4.Request = v3, t4.Response = M3), e6.Headers = d3, e6.Request = v3, e6.Response = M3, e6.fetch = A3, Object.defineProperty(e6, "__esModule", { value: true });
        }({});
      }(n3), n3.fetch.ponyfill = true, delete n3.fetch.polyfill;
      var i3 = n3;
      (e4 = i3.fetch).default = i3.fetch, e4.fetch = i3.fetch, e4.Headers = i3.Headers, e4.Request = i3.Request, e4.Response = i3.Response, t3.exports = e4;
    }(Ch2, Ch2.exports);
    const qh2 = nr(We2(Mh2), Xe2(), (t3) => new Mh2(t3)), jh2 = Qe2([Xe2(), He2("base64")]), Dh2 = nr(We2(ct), jh2, (t3) => ct.from(t3[0], "base64"));
    function Fh2(t3) {
      return er([tr({ jsonrpc: He2("2.0"), id: Xe2(), result: t3 }), tr({ jsonrpc: He2("2.0"), id: Xe2(), error: tr({ code: rr(), message: Xe2(), data: Ze2(Ke2("any", () => true)) }) })]);
    }
    const Kh2 = Fh2(rr());
    function Yh2(t3) {
      return nr(Fh2(t3), Kh2, (e4) => "error" in e4 ? e4 : { ...e4, result: je2(e4.result, t3) });
    }
    function Vh2(t3) {
      return Yh2(tr({ context: tr({ slot: Ge2() }), value: t3 }));
    }
    const Wh2 = tr({ foundation: Ge2(), foundationTerm: Ge2(), initial: Ge2(), taper: Ge2(), terminal: Ge2() });
    Yh2(Ye2($e2(tr({ epoch: Ge2(), effectiveSlot: Ge2(), amount: Ge2(), postBalance: Ge2() }))));
    const Hh2 = tr({ epoch: Ge2(), slotIndex: Ge2(), slotsInEpoch: Ge2(), absoluteSlot: Ge2(), blockHeight: Ze2(Ge2()), transactionCount: Ze2(Ge2()) }), $h2 = tr({ slotsPerEpoch: Ge2(), leaderScheduleSlotOffset: Ge2(), warmup: Ve2(), firstNormalEpoch: Ge2(), firstNormalSlot: Ge2() }), Gh2 = Je2(Xe2(), Ye2(Ge2())), Zh2 = $e2(er([tr({}), Xe2()])), Jh2 = tr({ err: Zh2 }), Xh2 = He2("receivedSignature");
    Vh2(tr({ err: $e2(er([tr({}), Xe2()])), logs: $e2(Ye2(Xe2())), accounts: Ze2($e2(Ye2($e2(tr({ executable: Ve2(), owner: Xe2(), lamports: Ge2(), data: Ye2(Xe2()), rentEpoch: Ze2(Ge2()) }))))), unitsConsumed: Ze2(Ge2()) })), Vh2(tr({ byIdentity: Je2(Xe2(), Ye2(Ge2())), range: tr({ firstSlot: Ge2(), lastSlot: Ge2() }) })), Yh2(Wh2), Yh2(Hh2), Yh2($h2), Yh2(Gh2), Yh2(Ge2()), Vh2(tr({ total: Ge2(), circulating: Ge2(), nonCirculating: Ge2(), nonCirculatingAccounts: Ye2(qh2) }));
    const Qh2 = tr({ amount: Xe2(), uiAmount: $e2(Ge2()), decimals: Ge2(), uiAmountString: Ze2(Xe2()) });
    Vh2(Ye2(tr({ address: qh2, amount: Xe2(), uiAmount: $e2(Ge2()), decimals: Ge2(), uiAmountString: Ze2(Xe2()) }))), Vh2(Ye2(tr({ pubkey: qh2, account: tr({ executable: Ve2(), owner: qh2, lamports: Ge2(), data: Dh2, rentEpoch: Ge2() }) })));
    const tf2 = tr({ program: Xe2(), parsed: rr(), space: Ge2() });
    var ef2;
    Vh2(Ye2(tr({ pubkey: qh2, account: tr({ executable: Ve2(), owner: qh2, lamports: Ge2(), data: tf2, rentEpoch: Ge2() }) }))), Vh2(Ye2(tr({ lamports: Ge2(), address: qh2 }))), nr(er([We2(ct), tf2]), er([jh2, tf2]), (t3) => Array.isArray(t3) ? je2(t3, Dh2) : t3), tr({ state: er([He2("active"), He2("inactive"), He2("activating"), He2("deactivating")]), active: Ge2(), inactive: Ge2() }), Yh2(Ye2(tr({ signature: Xe2(), slot: Ge2(), err: Zh2, memo: $e2(Xe2()), blockTime: Ze2($e2(Ge2())) }))), Yh2(Ye2(tr({ signature: Xe2(), slot: Ge2(), err: Zh2, memo: $e2(Xe2()), blockTime: Ze2($e2(Ge2())) }))), er([tr({ type: er([He2("firstShredReceived"), He2("completed"), He2("optimisticConfirmation"), He2("root")]), slot: Ge2(), timestamp: Ge2() }), tr({ type: He2("createdBank"), parent: Ge2(), slot: Ge2(), timestamp: Ge2() }), tr({ type: He2("frozen"), slot: Ge2(), timestamp: Ge2(), stats: tr({ numTransactionEntries: Ge2(), numSuccessfulTransactions: Ge2(), numFailedTransactions: Ge2(), maxTransactionsPerEntry: Ge2() }) }), tr({ type: He2("dead"), slot: Ge2(), timestamp: Ge2(), err: Xe2() })]), tr({ subscription: Ge2(), result: (ef2 = er([Jh2, Xh2]), tr({ context: tr({ slot: Ge2() }), value: ef2 })) });
    const rf2 = tr({ votePubkey: Xe2(), nodePubkey: Xe2(), activatedStake: Ge2(), epochVoteAccount: Ve2(), epochCredits: Ye2(Qe2([Ge2(), Ge2(), Ge2()])), commission: Ge2(), lastVote: Ge2(), rootSlot: $e2(Ge2()) });
    Yh2(tr({ current: Ye2(rf2), delinquent: Ye2(rf2) }));
    const nf2 = er([He2("processed"), He2("confirmed"), He2("finalized")]), of2 = tr({ slot: Ge2(), confirmations: $e2(Ge2()), err: Zh2, confirmationStatus: Ze2(nf2) });
    Vh2(Ye2($e2(of2))), Yh2(Ge2());
    const sf2 = tr({ signatures: Ye2(Xe2()), message: tr({ accountKeys: Ye2(Xe2()), header: tr({ numRequiredSignatures: Ge2(), numReadonlySignedAccounts: Ge2(), numReadonlyUnsignedAccounts: Ge2() }), instructions: Ye2(tr({ accounts: Ye2(Ge2()), data: Xe2(), programIdIndex: Ge2() })), recentBlockhash: Xe2() }) }), af2 = tr({ parsed: rr(), program: Xe2(), programId: qh2 }), hf = tr({ accounts: Ye2(qh2), data: Xe2(), programId: qh2 }), ff2 = nr(er([hf, af2]), er([tr({ parsed: rr(), program: Xe2(), programId: Xe2() }), tr({ accounts: Ye2(Xe2()), data: Xe2(), programId: Xe2() })]), (t3) => je2(t3, "accounts" in t3 ? hf : af2)), uf2 = tr({ signatures: Ye2(Xe2()), message: tr({ accountKeys: Ye2(tr({ pubkey: qh2, signer: Ve2(), writable: Ve2() })), instructions: Ye2(ff2), recentBlockhash: Xe2() }) }), cf2 = tr({ accountIndex: Ge2(), mint: Xe2(), owner: Ze2(Xe2()), uiTokenAmount: Qh2 }), df2 = tr({ err: Zh2, fee: Ge2(), innerInstructions: Ze2($e2(Ye2(tr({ index: Ge2(), instructions: Ye2(tr({ accounts: Ye2(Ge2()), data: Xe2(), programIdIndex: Ge2() })) })))), preBalances: Ye2(Ge2()), postBalances: Ye2(Ge2()), logMessages: Ze2($e2(Ye2(Xe2()))), preTokenBalances: Ze2($e2(Ye2(cf2))), postTokenBalances: Ze2($e2(Ye2(cf2))) }), lf2 = tr({ err: Zh2, fee: Ge2(), innerInstructions: Ze2($e2(Ye2(tr({ index: Ge2(), instructions: Ye2(ff2) })))), preBalances: Ye2(Ge2()), postBalances: Ye2(Ge2()), logMessages: Ze2($e2(Ye2(Xe2()))), preTokenBalances: Ze2($e2(Ye2(cf2))), postTokenBalances: Ze2($e2(Ye2(cf2))) });
    Yh2($e2(tr({ blockhash: Xe2(), previousBlockhash: Xe2(), parentSlot: Ge2(), transactions: Ye2(tr({ transaction: sf2, meta: $e2(df2) })), rewards: Ze2(Ye2(tr({ pubkey: Xe2(), lamports: Ge2(), postBalance: $e2(Ge2()), rewardType: $e2(Xe2()) }))), blockTime: $e2(Ge2()), blockHeight: $e2(Ge2()) }))), Yh2($e2(tr({ blockhash: Xe2(), previousBlockhash: Xe2(), parentSlot: Ge2(), transactions: Ye2(tr({ transaction: sf2, meta: $e2(df2) })), rewards: Ze2(Ye2(tr({ pubkey: Xe2(), lamports: Ge2(), postBalance: $e2(Ge2()), rewardType: $e2(Xe2()) }))), blockTime: $e2(Ge2()) }))), Yh2($e2(tr({ blockhash: Xe2(), previousBlockhash: Xe2(), parentSlot: Ge2(), signatures: Ye2(Xe2()), blockTime: $e2(Ge2()) }))), Yh2($e2(tr({ slot: Ge2(), meta: df2, blockTime: Ze2($e2(Ge2())), transaction: sf2 }))), Yh2($e2(tr({ slot: Ge2(), transaction: uf2, meta: $e2(lf2), blockTime: Ze2($e2(Ge2())) }))), Vh2(tr({ blockhash: Xe2(), feeCalculator: tr({ lamportsPerSignature: Ge2() }) })), Vh2(tr({ blockhash: Xe2(), lastValidBlockHeight: Ge2() }));
    Yh2(Ye2(tr({ slot: Ge2(), numTransactions: Ge2(), numSlots: Ge2(), samplePeriodSecs: Ge2() }))), Vh2($e2(tr({ feeCalculator: tr({ lamportsPerSignature: Ge2() }) }))), Yh2(Xe2()), Yh2(Xe2()), Be2([Ie2("numSignatures"), Ie2("padding"), xe2("signatureOffset"), xe2("signatureInstructionIndex"), xe2("publicKeyOffset"), xe2("publicKeyInstructionIndex"), xe2("messageDataOffset"), xe2("messageDataSize"), xe2("messageInstructionIndex")]), new Mh2("Ed25519SigVerify111111111111111111111111111"), new Mh2("StakeConfig11111111111111111111111111111111"), Object.freeze({ Initialize: { index: 0, layout: Be2([Ee2("instruction"), ((t3 = "authorized") => Be2([Ih2("staker"), Ih2("withdrawer")], t3))(), ((t3 = "lockup") => Be2([Pe2("unixTimestamp"), Pe2("epoch"), Ih2("custodian")], t3))()]) }, Authorize: { index: 1, layout: Be2([Ee2("instruction"), Ih2("newAuthorized"), Ee2("stakeAuthorizationType")]) }, Delegate: { index: 2, layout: Be2([Ee2("instruction")]) }, Split: { index: 3, layout: Be2([Ee2("instruction"), Pe2("lamports")]) }, Withdraw: { index: 4, layout: Be2([Ee2("instruction"), Pe2("lamports")]) }, Deactivate: { index: 5, layout: Be2([Ee2("instruction")]) }, Merge: { index: 7, layout: Be2([Ee2("instruction")]) }, AuthorizeWithSeed: { index: 8, layout: Be2([Ee2("instruction"), Ih2("newAuthorized"), Ee2("stakeAuthorizationType"), kh2("authoritySeed"), Ih2("authorityOwner")]) } }), Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } }), new Mh2("Stake11111111111111111111111111111111111111"), Be2([Ie2("numSignatures"), xe2("signatureOffset"), Ie2("signatureInstructionIndex"), xe2("ethAddressOffset"), Ie2("ethAddressInstructionIndex"), xe2("messageDataOffset"), xe2("messageDataSize"), Ie2("messageInstructionIndex"), Re2(20, "ethAddress"), Re2(64, "signature"), Ie2("recoveryId")]), new Mh2("KeccakSecp256k11111111111111111111111111111"), new Mh2("Va1idator1nfo111111111111111111111111111111"), new Mh2("Vote111111111111111111111111111111111111111"), Be2([Ih2("nodePubkey"), Ih2("authorizedWithdrawer"), Ie2("commission"), Se2(), Te2(Be2([Se2("slot"), Ee2("confirmationCount")]), ke2(Ee2(), -8), "votes"), Ie2("rootSlotValid"), Se2("rootSlot"), Se2(), Te2(Be2([Se2("epoch"), Ih2("authorizedVoter")]), ke2(Ee2(), -8), "authorizedVoters"), Be2([Te2(Be2([Ih2("authorizedPubkey"), Se2("epochOfLastAuthorizedSwitch"), Se2("targetEpoch")]), 32, "buf"), Se2("idx"), Ie2("isEmpty")], "priorVoters"), Se2(), Te2(Be2([Se2("epoch"), Se2("credits"), Se2("prevCredits")]), ke2(Ee2(), -8), "epochCredits"), Be2([Se2("slot"), Se2("timestamp")], "lastTimestamp")]), Object.freeze({ InitializeAccount: { index: 0, layout: Be2([Ee2("instruction"), ((t3 = "voteInit") => Be2([Ih2("nodePubkey"), Ih2("authorizedVoter"), Ih2("authorizedWithdrawer"), Ie2("commission")], t3))()]) }, Authorize: { index: 1, layout: Be2([Ee2("instruction"), Ih2("newAuthorized"), Ee2("voteAuthorizationType")]) }, Withdraw: { index: 3, layout: Be2([Ee2("instruction"), Pe2("lamports")]) } }), Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } }), new Mh2("Vote111111111111111111111111111111111111111");
    class pf2 extends C2 {
      constructor({ net: t3 = "mainnet-beta", server: e4, appId: r3, rpc: n3 }) {
        super(), this.accounts = [], E2(t3, "'net' is required"), E2(B2.includes(t3), "unsupported net"), this.net = t3, this.rpc = n3 || ("mainnet-beta" === t3 ? "https://free.rpcpool.com" : `https://api.${t3}.solana.com`), this.server = e4 || T2[this.net] || "https://wallet.blocto.app", this.appId = r3 || process.env.APP_ID;
      }
      tryRetrieveSessionFromStorage() {
        const t3 = V2(this.sessionKey, {}), e4 = t3 && t3.code, r3 = t3 && t3.address && t3.address.solana;
        this.connected = Boolean(e4 && r3), this.code = e4 || null, this.accounts = r3 ? [r3] : [];
      }
      async request(t3) {
        this.connected || await this.connect();
        try {
          let e4 = null, r3 = null;
          switch (t3.method) {
            case "connect":
              r3 = await this.fetchAccounts();
              break;
            case "disconnect":
              this.disconnect();
              break;
            case "getAccounts":
              r3 = this.accounts.length ? this.accounts : await this.fetchAccounts();
              break;
            case "getAccountInfo": {
              const e6 = await this.handleReadRequests(t3), [n3, i3] = e6.result.value.data;
              r3 = { ...e6.result.value, data: ct.from(n3, i3), owner: new Mh2(e6.result.value.owner) };
              break;
            }
            case "convertToProgramWalletTransaction":
              r3 = await this.handleConvertTransaction(t3);
              break;
            case "signAndSendTransaction":
              r3 = await this.handleSignAndSendTransaction(t3);
              break;
            case "signTransaction":
            case "signAllTransactions":
              throw new Error(`Blocto is program wallet, which doesn't support ${t3.method}. Use signAndSendTransaction instead.`);
            default:
              e4 = await this.handleReadRequests(t3);
          }
          if (e4 && !e4.result && e4.error) {
            const t4 = e4.error.message ? e4.error.message : "Request failed";
            throw new Error(t4);
          }
          return e4 ? e4.result : r3;
        } catch (t4) {
          throw console.error(t4), t4;
        }
      }
      async connect() {
        const t3 = window.solana;
        return t3 && t3.isBlocto ? new Promise((e4) => {
          t3.once("connect", (t4) => {
            this.accounts = [t4.toBase58()], e4();
          }), t3.connect();
        }) : (this.tryRetrieveSessionFromStorage(), new Promise((t4, e4) => {
          if ("undefined" == typeof window && e4("Currently only supported in browser"), this.connected)
            return t4();
          const r3 = encodeURIComponent(window.location.origin), n3 = q2(`${this.server}/authn?l6n=${r3}&chain=solana`);
          j2(n3), F2("message", (r4, i3) => {
            const o3 = r4;
            if (o3.origin === this.server) {
              if ("FCL::CHALLENGE::RESPONSE" === o3.data.type) {
                i3(), D2(n3), this.code = o3.data.code, this.connected = true, this.eventListeners.connect.forEach((t5) => t5(this.net));
                const e6 = o3.data.address;
                this.accounts = e6 ? [e6.solana] : [], H2(this.sessionKey, { code: this.code, address: e6 }, z2), t4();
              }
              "FCL::CHALLENGE::CANCEL" === o3.data.type && (i3(), D2(n3), e4(new Error("User declined the login request")));
            }
          });
        }));
      }
      async disconnect() {
        const t3 = window.solana;
        t3 && t3.isBlocto ? await t3.disconnect() : (this.code = null, this.accounts = [], this.eventListeners.disconnect.forEach((t4) => t4()));
      }
      async fetchAccounts() {
        const { accounts: t3 } = await fetch(`${this.server}/api/solana/accounts?code=${this.code}`).then((t4) => t4.json());
        return this.accounts = t3, t3;
      }
      async handleReadRequests(t3) {
        return fetch(this.rpc, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ id: 1, jsonrpc: "2.0", ...t3 }) }).then((t4) => t4.json());
      }
      async convertToProgramWalletTransaction(t3) {
        const e4 = window.solana;
        if (e4 && e4.isBlocto)
          return e4.convertToProgramWalletTransaction(t3);
        const r3 = await this.request({ method: "convertToProgramWalletTransaction", params: { message: t3.serializeMessage().toString("hex") } });
        return this.toTransaction(r3, []);
      }
      async signAndSendTransaction(t3, e4) {
        const r3 = window.solana;
        if (r3 && r3.isBlocto)
          return r3.signAndSendTransaction(t3);
        const n3 = {};
        if (e4) {
          e4.commitment && (n3.commitment = e4.commitment);
          const t4 = e4 ? e4._rpcEndpoint : null;
          t4 && t4 !== this.rpc && (this.rpc = t4, this.disconnect(), await this.connect());
        }
        return this.request({ method: "signAndSendTransaction", params: { signatures: await this.collectSignatures(t3), message: t3.serializeMessage().toString("hex"), ...n3 } });
      }
      toTransaction(t3, e4) {
        const r3 = Bh2.from(ct.from(t3, "hex")), n3 = new Nh2();
        return n3.recentBlockhash = r3.recentBlockhash, r3.header.numRequiredSignatures > 0 && (n3.feePayer = r3.accountKeys[0]), e4.forEach((t4, e6) => {
          const i3 = { signature: t4 === Mh2.default.toBase58() ? null : ae2.decode(t4), publicKey: r3.accountKeys[e6] };
          n3.signatures.push(i3);
        }), r3.instructions.forEach((t4) => {
          const e6 = t4.accounts.map((t5) => ({ pubkey: r3.accountKeys[t5], isSigner: t5 < r3.header.numRequiredSignatures, isWritable: r3.isAccountWritable(t5) }));
          n3.instructions.push(new Lh2({ keys: e6, programId: r3.accountKeys[t4.programIdIndex], data: ae2.decode(t4.data) }));
        }), n3;
      }
      async collectSignatures(t3) {
        return t3.signatures.reduce((t4, e4) => (e4.signature && (t4[e4.publicKey.toBase58()] = e4.signature.toString("hex")), t4), {});
      }
      async handleConvertTransaction(t3) {
        return fetch(`${this.server}/api/solana/convertToWalletTx?code=${this.code}`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ sessionId: this.code, ...t3.params }) }).then((t4) => G2(t4, this));
      }
      async handleSignAndSendTransaction(t3) {
        const { authorizationId: e4 } = await fetch(`${this.server}/api/solana/authz?code=${this.code}`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ sessionId: this.code, ...t3.params }) }).then((t4) => G2(t4, this));
        if ("undefined" == typeof window)
          throw new Error("Currently only supported in browser");
        const r3 = q2(`${this.server}/authz/solana/${e4}`);
        return j2(r3), new Promise((t4, e6) => F2("message", (n3, i3) => {
          const o3 = n3;
          o3.origin === this.server && "SOL:FRAME:RESPONSE" === o3.data.type && ("APPROVED" === o3.data.status && (i3(), D2(r3), t4(o3.data.txHash)), "DECLINED" === o3.data.status && (i3(), D2(r3), e6(new Error("User declined to send the transaction"))));
        }));
      }
    }
    class bf2 extends C2 {
      constructor({ chainId: t3, server: e4, appId: r3 }) {
        super(), this.publicKey = [], this.authKey = "", E2(t3, "'chainId' is required"), E2(r3, "It is necessary to interact with Blocto wallet via your app id."), this.chainId = t3, this.networkName = U2[t3], this.api = L2[t3];
        const n3 = P2[t3];
        this.appId = r3 || process.env.APP_ID, this.server = e4 || n3 || "https://wallet.blocto.app";
      }
      tryRetrieveSessionFromStorage() {
        const t3 = V2(this.sessionKey, {}), e4 = t3 && t3.code, r3 = t3 && t3.address && t3.address[this.chainId];
        this.code = e4 || null, this.address = r3 || void 0;
      }
      get publicAccount() {
        return { address: this.address || null, publicKey: this.publicKey.length ? this.publicKey : null, authKey: null, minKeysRequired: 2 };
      }
      async network() {
        return { name: this.networkName, api: this.api, chainId: this.chainId.toString() };
      }
      async isConnected() {
        return !!this.address;
      }
      async signTransaction(t3) {
        const e4 = window.bloctoAptos;
        if (e4)
          return e4.signTransaction(t3);
        if (await this.isConnected() || await this.connect(), !this.address)
          throw new Error("Fail to get account");
        throw new Error("signTransaction method not supported.");
      }
      async disconnect() {
        const t3 = window.bloctoAptos;
        t3 ? await t3.disconnect() : (this.code = null, this.address = void 0);
      }
      async signAndSubmitTransaction(t3) {
        const e4 = window.bloctoAptos;
        if (e4)
          return e4.signAndSubmitTransaction(t3);
        if (await this.isConnected() || await this.connect(), !this.address)
          throw new Error("Fail to get account");
        const { authorizationId: r3 } = await fetch(`${this.server}/api/aptos/authz?code=${this.code}`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(t3) }).then((t4) => G2(t4, this));
        if ("undefined" == typeof window)
          throw new Error("Currently only supported in browser");
        const n3 = q2(`${this.server}/authz/aptos/${r3}`);
        return j2(n3), new Promise((t4, e6) => F2("message", (r4, i3) => {
          const o3 = r4;
          o3.origin === this.server && "APTOS:FRAME:RESPONSE" === o3.data.type && ("APPROVED" === o3.data.status && (i3(), D2(n3), t4({ hash: o3.data.txHash })), "DECLINED" === o3.data.status && (i3(), D2(n3), e6(new Error("User declined to send the transaction"))));
        }));
      }
      async signMessage(t3) {
        const e4 = window.bloctoAptos;
        if (e4)
          return e4.signMessage(t3);
        if (await this.isConnected() || await this.connect(), !this.address)
          throw new Error("Fail to get account");
        const r3 = `${this.server}/user-signature/aptos`, n3 = q2(r3);
        return j2(n3), F2("message", (e6, i3) => {
          const o3 = e6;
          o3.origin === this.server && "APTOS:FRAME:READY" === o3.data.type && (n3.contentWindow && n3.contentWindow.postMessage({ type: "APTOS:FRAME:READY:RESPONSE", ...t3 }, r3), i3());
        }), new Promise((e6, r4) => F2("message", (i3, o3) => {
          const s3 = i3;
          s3.origin === this.server && "APTOS:FRAME:RESPONSE" === s3.data.type && ("APPROVED" === s3.data.status && (o3(), D2(n3), e6({ address: s3.data.address, application: s3.data.application, chainId: s3.data.chainId, fullMessage: s3.data.fullMessage, message: t3.message, nonce: t3.nonce, prefix: "APTOS", signature: s3.data.signature, bitmap: s3.data.bitmap })), "DECLINED" === s3.data.status && (o3(), D2(n3), r4(new Error("User declined the signing request"))));
        }));
      }
      async connect() {
        const t3 = window.bloctoAptos;
        return t3 ? new Promise((e4, r3) => setTimeout(() => t3.connect().then(e4).catch(r3), 10)) : (this.tryRetrieveSessionFromStorage(), new Promise((t4, e4) => {
          "undefined" == typeof window && e4("Currently only supported in browser"), this.connected && this.address && t4({ address: this.address, publicKey: this.publicKey, authKey: null, minKeysRequired: 2 });
          const r3 = encodeURIComponent(window.location.origin), n3 = q2(`${this.server}/authn?l6n=${r3}&chain=aptos&appId=${this.appId}`);
          j2(n3), F2("message", async (r4, i3) => {
            const o3 = r4;
            if (o3.origin === this.server) {
              if ("APTOS:FRAME:RESPONSE" === o3.data.type) {
                i3(), D2(n3), this.code = o3.data.code, this.connected = true;
                const r5 = o3.data.address;
                if (this.address = r5 ? r5.aptos : void 0, !this.address)
                  return e4();
                try {
                  const { public_keys: e6 } = await fetch(`${this.server}/blocto/aptos/accounts/${this.address}`).then((t5) => t5.json());
                  this.publicKey = e6 || [], t4({ address: this.address || "", publicKey: this.publicKey, authKey: null, minKeysRequired: 2 });
                } catch (t5) {
                  e4(o3);
                }
                H2(this.sessionKey, { code: this.code, address: r5 }, z2);
              }
              "APTOS:FRAME:CLOSE" === o3.data.type && (i3(), D2(n3), e4(new Error("User declined the login request")));
            }
          });
        }));
      }
      async fetchAddress() {
        const { accounts: t3 } = await fetch(`${this.server}/api/aptos/accounts?code=${this.code}`).then((t4) => G2(t4, this));
        return this.address = t3[0] || void 0, this.address;
      }
    }
    var mf2 = Object.freeze({ __proto__: null, default: {} });
    function yf2(t3, e4) {
      for (var r3 = 0, n3 = t3.length - 1; n3 >= 0; n3--) {
        var i3 = t3[n3];
        "." === i3 ? t3.splice(n3, 1) : ".." === i3 ? (t3.splice(n3, 1), r3++) : r3 && (t3.splice(n3, 1), r3--);
      }
      if (e4)
        for (; r3--; r3)
          t3.unshift("..");
      return t3;
    }
    var gf = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, vf2 = function(t3) {
      return gf.exec(t3).slice(1);
    };
    function wf2() {
      for (var t3 = "", e4 = false, r3 = arguments.length - 1; r3 >= -1 && !e4; r3--) {
        var n3 = r3 >= 0 ? arguments[r3] : "/";
        if ("string" != typeof n3)
          throw new TypeError("Arguments to path.resolve must be strings");
        n3 && (t3 = n3 + "/" + t3, e4 = "/" === n3.charAt(0));
      }
      return (e4 ? "/" : "") + (t3 = yf2(Rf2(t3.split("/"), function(t4) {
        return !!t4;
      }), !e4).join("/")) || ".";
    }
    function Mf2(t3) {
      var e4 = _f(t3), r3 = "/" === Bf2(t3, -1);
      return (t3 = yf2(Rf2(t3.split("/"), function(t4) {
        return !!t4;
      }), !e4).join("/")) || e4 || (t3 = "."), t3 && r3 && (t3 += "/"), (e4 ? "/" : "") + t3;
    }
    function _f(t3) {
      return "/" === t3.charAt(0);
    }
    function Af2() {
      var t3 = Array.prototype.slice.call(arguments, 0);
      return Mf2(Rf2(t3, function(t4, e4) {
        if ("string" != typeof t4)
          throw new TypeError("Arguments to path.join must be strings");
        return t4;
      }).join("/"));
    }
    function Sf2(t3, e4) {
      function r3(t4) {
        for (var e6 = 0; e6 < t4.length && "" === t4[e6]; e6++)
          ;
        for (var r4 = t4.length - 1; r4 >= 0 && "" === t4[r4]; r4--)
          ;
        return e6 > r4 ? [] : t4.slice(e6, r4 - e6 + 1);
      }
      t3 = wf2(t3).substr(1), e4 = wf2(e4).substr(1);
      for (var n3 = r3(t3.split("/")), i3 = r3(e4.split("/")), o3 = Math.min(n3.length, i3.length), s3 = o3, a3 = 0; a3 < o3; a3++)
        if (n3[a3] !== i3[a3]) {
          s3 = a3;
          break;
        }
      var h3 = [];
      for (a3 = s3; a3 < n3.length; a3++)
        h3.push("..");
      return (h3 = h3.concat(i3.slice(s3))).join("/");
    }
    function Ef2(t3) {
      var e4 = vf2(t3), r3 = e4[0], n3 = e4[1];
      return r3 || n3 ? (n3 && (n3 = n3.substr(0, n3.length - 1)), r3 + n3) : ".";
    }
    function xf2(t3, e4) {
      var r3 = vf2(t3)[2];
      return e4 && r3.substr(-1 * e4.length) === e4 && (r3 = r3.substr(0, r3.length - e4.length)), r3;
    }
    function If2(t3) {
      return vf2(t3)[3];
    }
    var kf = { extname: If2, basename: xf2, dirname: Ef2, sep: "/", delimiter: ":", relative: Sf2, join: Af2, isAbsolute: _f, normalize: Mf2, resolve: wf2 };
    function Rf2(t3, e4) {
      if (t3.filter)
        return t3.filter(e4);
      for (var r3 = [], n3 = 0; n3 < t3.length; n3++)
        e4(t3[n3], n3, t3) && r3.push(t3[n3]);
      return r3;
    }
    var Tf2, Bf2 = "b" === "ab".substr(-1) ? function(t3, e4, r3) {
      return t3.substr(e4, r3);
    } : function(t3, e4, r3) {
      return e4 < 0 && (e4 = t3.length + e4), t3.substr(e4, r3);
    }, Pf2 = Object.freeze({ __proto__: null, resolve: wf2, normalize: Mf2, isAbsolute: _f, join: Af2, relative: Sf2, sep: "/", delimiter: ":", dirname: Ef2, basename: xf2, extname: If2, default: kf });
    function Of2() {
      if (void 0 === Tf2) {
        var t3 = new ArrayBuffer(2), e4 = new Uint8Array(t3), r3 = new Uint16Array(t3);
        if (e4[0] = 1, e4[1] = 2, 258 === r3[0])
          Tf2 = "BE";
        else {
          if (513 !== r3[0])
            throw new Error("unable to figure out endianess");
          Tf2 = "LE";
        }
      }
      return Tf2;
    }
    function Uf2() {
      return void 0 !== t2.location ? t2.location.hostname : "";
    }
    function Lf2() {
      return [];
    }
    function Nf2() {
      return 0;
    }
    function zf2() {
      return Number.MAX_VALUE;
    }
    function Cf2() {
      return Number.MAX_VALUE;
    }
    function qf2() {
      return [];
    }
    function jf() {
      return "Browser";
    }
    function Df2() {
      return void 0 !== t2.navigator ? t2.navigator.appVersion : "";
    }
    function Ff2() {
    }
    function Kf2() {
    }
    function Yf2() {
      return "/tmp";
    }
    var Vf2 = Yf2, Wf2 = { EOL: "\n", tmpdir: Vf2, tmpDir: Yf2, networkInterfaces: Ff2, getNetworkInterfaces: Kf2, release: Df2, type: jf, cpus: qf2, totalmem: Cf2, freemem: zf2, uptime: Nf2, loadavg: Lf2, hostname: Uf2, endianness: Of2 }, Hf2 = Object.freeze({ __proto__: null, endianness: Of2, hostname: Uf2, loadavg: Lf2, uptime: Nf2, freemem: zf2, totalmem: Cf2, cpus: qf2, type: jf, release: Df2, networkInterfaces: Ff2, getNetworkInterfaces: Kf2, arch: function() {
      return "javascript";
    }, platform: function() {
      return "browser";
    }, tmpDir: Yf2, tmpdir: Vf2, EOL: "\n", default: Wf2 }), $f2 = te2(mf2), Gf2 = te2(Pf2), Zf2 = te2(Hf2);
    function Jf2(t3) {
      console.log(`[dotenv][DEBUG] ${t3}`);
    }
    const Xf2 = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/, Qf2 = /\\n/g, tu = /\r\n|\n|\r/;
    function eu(t3, e4) {
      const r3 = Boolean(e4 && e4.debug), n3 = {};
      return t3.toString().split(tu).forEach(function(t4, e6) {
        const i3 = t4.match(Xf2);
        if (null != i3) {
          const t5 = i3[1];
          let e7 = i3[2] || "";
          const r4 = e7.length - 1, o3 = '"' === e7[0] && '"' === e7[r4];
          "'" === e7[0] && "'" === e7[r4] || o3 ? (e7 = e7.substring(1, r4), o3 && (e7 = e7.replace(Qf2, "\n"))) : e7 = e7.trim(), n3[t5] = e7;
        } else
          r3 && Jf2(`did not match key and value when parsing line ${e6 + 1}: ${t4}`);
      }), n3;
    }
    ({ config: function(t3) {
      let e4 = Gf2.resolve(S2.cwd(), ".env"), r3 = "utf8", n3 = false;
      var i3;
      t3 && (null != t3.path && (e4 = "~" === (i3 = t3.path)[0] ? Gf2.join(Zf2.homedir(), i3.slice(1)) : i3), null != t3.encoding && (r3 = t3.encoding), null != t3.debug && (n3 = true));
      try {
        const t4 = eu($f2.readFileSync(e4, { encoding: r3 }), { debug: n3 });
        return Object.keys(t4).forEach(function(e6) {
          Object.prototype.hasOwnProperty.call(S2.env, e6) ? n3 && Jf2(`"${e6}" is already defined in \`process.env\` and will not be overwritten`) : S2.env[e6] = t4[e6];
        }), { parsed: t4 };
      } catch (t4) {
        return { error: t4 };
      }
    }, parse: eu }).config();
    return class {
      constructor({ appId: t3, ethereum: e4, solana: r3, aptos: n3 }) {
        e4 && (this.ethereum = new Z2({ ...e4, appId: t3 })), r3 && (this.solana = new pf2({ ...r3, appId: t3 })), n3 && (this.aptos = new bf2({ ...n3, appId: t3 }));
      }
    };
  });
})(bloctoSdk_umd);
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest2 = commonjsGlobal && commonjsGlobal.__rest || function(s2, e3) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BloctoWalletAdapter = exports.APTOS_NETWORK_CHAIN_ID_MAPPING = exports.BloctoWalletName = void 0;
  const sdk_1 = __importDefault2(bloctoSdk_umd.exports);
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.BloctoWalletName = "Blocto";
  exports.APTOS_NETWORK_CHAIN_ID_MAPPING = {
    [BaseAdapter_12.WalletAdapterNetwork.Mainnet]: 1,
    [BaseAdapter_12.WalletAdapterNetwork.Testnet]: 2
  };
  class BloctoWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({ network, timeout = 1e4, bloctoAppId = "" } = {
      network: BaseAdapter_12.WalletAdapterNetwork.Testnet
    }) {
      super();
      this.name = exports.BloctoWalletName;
      this.url = "https://portto.com/download";
      this.icon = "https://raw.githubusercontent.com/hippospace/aptos-wallet-adapter/main/logos/blocto.svg";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      const sdk = new sdk_1.default({
        aptos: {
          chainId: exports.APTOS_NETWORK_CHAIN_ID_MAPPING[network]
        },
        appId: bloctoAppId
      });
      this._provider = sdk.aptos;
      this._network = network;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          if (window) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c, _d;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null,
        minKeysRequired: (_d = this._wallet) === null || _d === void 0 ? void 0 : _d.minKeysRequired
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider;
          const isConnected = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          if (isConnected) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const _a2 = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect(), { publicKey } = _a2, rest = __rest2(_a2, ["publicKey"]);
          this._wallet = Object.assign(Object.assign({}, rest), { publicKey, isConnected: true });
          const { api, chainId } = yield provider2.network();
          this._api = api;
          this._chainId = chainId;
          this.emit("connect", this._wallet);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          try {
            const provider2 = this._provider;
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(transaction);
            if (response) {
              return new Uint8Array([]);
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          try {
            const provider2 = this._provider;
            const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(transaction);
            if (response) {
              return { hash: response.hash };
            } else {
              throw new Error("Transaction failed");
            }
          } catch (error) {
            throw new errors_12.WalletSignAndSubmitMessageError(error.message || error);
          }
        } catch (error) {
          this.emit("error", error);
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const provider2 = this._provider;
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(message);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.BloctoWalletAdapter = BloctoWalletAdapter;
})(BloctoWallet);
var Coin98Wallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Coin98WalletAdapter = exports.Coin98WalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.Coin98WalletName = "Coin98";
  class Coin98WalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      var _a2;
      super();
      this.name = exports.Coin98WalletName;
      this.url = "https://chrome.google.com/webstore/detail/coin98-wallet/aeachknmefphepccionboohckonoeemg";
      this.icon = "https://coin98.s3.ap-southeast-1.amazonaws.com/Coin/c98wallet.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? (_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          var _a3;
          if ((_a3 = window.coin98) === null || _a3 === void 0 ? void 0 : _a3.aptos) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || ((_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          let response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect({ network: this._network });
          if (typeof response === "boolean") {
            response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.account();
          }
          this._wallet = {
            address: response === null || response === void 0 ? void 0 : response.address,
            publicKey: response === null || response === void 0 ? void 0 : response.publicKey,
            isConnected: true
          };
          try {
            const chainId = null;
            const api = null;
            this._chainId = chainId;
            this._api = api;
          } catch (error) {
            const errMsg = error.message;
            this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
            throw error;
          }
          this.emit("connect", this._wallet.publicKey);
        } catch (error) {
          this.emit("error", error);
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || ((_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos);
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transaction, options) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignTransactionError(errMsg));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transaction, options) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const response = yield provider2.signAndSubmitTransaction(transaction, options);
          if (response.code) {
            throw new Error(response.message);
          }
          return response;
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(errMsg));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleAccountChange = (newAccount) => __awaiter2(this, void 0, void 0, function* () {
            var _b, _c, _d, _e2;
            if (newAccount === null || newAccount === void 0 ? void 0 : newAccount.publicKey) {
              this._wallet = Object.assign(Object.assign({}, this._wallet), { publicKey: newAccount.publicKey || ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.publicKey), address: newAccount.address || ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.address) });
            } else {
              const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
              this._wallet = Object.assign(Object.assign({}, this._wallet), { address: (response === null || response === void 0 ? void 0 : response.address) || ((_d = this._wallet) === null || _d === void 0 ? void 0 : _d.address), publicKey: (response === null || response === void 0 ? void 0 : response.publicKey) || ((_e2 = this._wallet) === null || _e2 === void 0 ? void 0 : _e2.publicKey) });
            }
            this.emit("accountChange", newAccount.publicKey);
          });
          provider2.on("accountChange", handleAccountChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || ((_a2 = window.coin98) === null || _a2 === void 0 ? void 0 : _a2.aptos);
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.Coin98WalletAdapter = Coin98WalletAdapter;
})(Coin98Wallet);
var SafePalWallet = {};
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SafePalWalletAdapter = exports.SafePalWalletName = void 0;
  const errors_12 = errors;
  const BaseAdapter_12 = BaseAdapter;
  exports.SafePalWalletName = "SafePal";
  class SafePalWalletAdapter extends BaseAdapter_12.BaseWalletAdapter {
    constructor({
      timeout = 1e4
    } = {}) {
      super();
      this.name = exports.SafePalWalletName;
      this.url = "https://chrome.google.com/webstore/detail/safepal-extension-wallet/lgmpcpglpngdoalbgeoldeajfclnhafa";
      this.icon = "https://raw.githubusercontent.com/hippospace/aptos-wallet-adapter/main/logos/safePal.png";
      this._readyState = typeof window === "undefined" || typeof document === "undefined" ? BaseAdapter_12.WalletReadyState.Unsupported : BaseAdapter_12.WalletReadyState.NotDetected;
      this._provider = typeof window !== "undefined" ? window.safePal : void 0;
      this._network = void 0;
      this._timeout = timeout;
      this._connecting = false;
      this._wallet = null;
      if (typeof window !== "undefined" && this._readyState !== BaseAdapter_12.WalletReadyState.Unsupported) {
        (0, BaseAdapter_12.scopePollingDetectionStrategy)(() => {
          this._provider = typeof window !== "undefined" ? window.safePal : void 0;
          if (this._provider) {
            this._readyState = BaseAdapter_12.WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
    get publicAccount() {
      var _a2, _b, _c;
      return {
        publicKey: ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.publicKey) || null,
        address: ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.address) || null,
        authKey: ((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.authKey) || null
      };
    }
    get network() {
      return {
        name: this._network,
        api: this._api,
        chainId: this._chainId
      };
    }
    get connecting() {
      return this._connecting;
    }
    get connected() {
      var _a2;
      return !!((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.isConnected);
    }
    get readyState() {
      return this._readyState;
    }
    connect() {
      var _a2;
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (this.connected || this.connecting)
            return;
          if (!(this._readyState === BaseAdapter_12.WalletReadyState.Loadable || this._readyState === BaseAdapter_12.WalletReadyState.Installed))
            throw new errors_12.WalletNotReadyError();
          this._connecting = true;
          const provider2 = this._provider || window.safePal;
          const isConnected = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.isConnected();
          if (isConnected) {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.connect();
          if (!response) {
            throw new errors_12.WalletNotConnectedError("No connect response");
          }
          const walletAccount = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.account();
          if (walletAccount) {
            this._wallet = Object.assign(Object.assign({}, walletAccount), { isConnected: true });
            try {
              const name = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.network();
              const { chainId } = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.getChainId();
              const api = null;
              this._network = name;
              this._chainId = chainId.toString();
              this._api = api;
            } catch (error) {
              const errMsg = error.message;
              this.emit("error", new errors_12.WalletGetNetworkError(errMsg));
              throw error;
            }
          }
          this.emit("connect", ((_a2 = this._wallet) === null || _a2 === void 0 ? void 0 : _a2.address) || "");
        } catch (error) {
          this.emit("error", new Error(error));
          throw error;
        } finally {
          this._connecting = false;
        }
      });
    }
    disconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        const wallet = this._wallet;
        const provider2 = this._provider || window.safePal;
        if (wallet) {
          this._wallet = null;
          try {
            yield provider2 === null || provider2 === void 0 ? void 0 : provider2.disconnect();
          } catch (error) {
            this.emit("error", new errors_12.WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
          }
        }
        this.emit("disconnect");
      });
    }
    signTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.safePal;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const tx = yield provider2.generateTransaction(wallet.address || "", transactionPyld, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signTransaction(tx);
          if (!response) {
            throw new Error("No response");
          }
          return response;
        } catch (error) {
          this.emit("error", new errors_12.WalletSignTransactionError(error));
          throw error;
        }
      });
    }
    signAndSubmitTransaction(transactionPyld, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.safePal;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const tx = yield provider2.generateTransaction(wallet.address || "", transactionPyld, options);
          if (!tx)
            throw new Error("Cannot generate transaction");
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signAndSubmitTransaction(tx);
          if (!response) {
            throw new Error("No response");
          }
          return { hash: response };
        } catch (error) {
          this.emit("error", new errors_12.WalletSignAndSubmitMessageError(error));
          throw error;
        }
      });
    }
    signMessage(msgPayload) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.safePal;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          if (typeof msgPayload !== "object" || !msgPayload.nonce) {
            throw new errors_12.WalletSignMessageError("Invalid signMessage Payload");
          }
          const response = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.signMessage(msgPayload);
          if (response) {
            return response;
          } else {
            throw new Error("Sign Message failed");
          }
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletSignMessageError(errMsg));
          throw error;
        }
      });
    }
    onAccountChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.safePal;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleChangeAccount = (newAccount) => __awaiter2(this, void 0, void 0, function* () {
            const { publicKey } = yield provider2 === null || provider2 === void 0 ? void 0 : provider2.account();
            this._wallet = Object.assign(Object.assign({}, this._wallet), { address: newAccount, publicKey });
            this.emit("accountChange", newAccount);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onAccountChange(handleChangeAccount);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletAccountChangeError(errMsg));
          throw error;
        }
      });
    }
    onNetworkChange() {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          const wallet = this._wallet;
          const provider2 = this._provider || window.safePal;
          if (!wallet || !provider2)
            throw new errors_12.WalletNotConnectedError();
          const handleNetworkChange = (newNetwork) => __awaiter2(this, void 0, void 0, function* () {
            this._network = newNetwork;
            this.emit("networkChange", this._network);
          });
          yield provider2 === null || provider2 === void 0 ? void 0 : provider2.onNetworkChange(handleNetworkChange);
        } catch (error) {
          const errMsg = error.message;
          this.emit("error", new errors_12.WalletNetworkChangeError(errMsg));
          throw error;
        }
      });
    }
  }
  exports.SafePalWalletAdapter = SafePalWalletAdapter;
})(SafePalWallet);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(PetraWallet, exports);
  __exportStar(BaseAdapter, exports);
  __exportStar(HippoExtensionWallet, exports);
  __exportStar(HippoWallet, exports);
  __exportStar(MartianWallet, exports);
  __exportStar(FewchaWallet, exports);
  __exportStar(PontemWallet, exports);
  __exportStar(NightlyWallet, exports);
  __exportStar(RiseWallet, exports);
  __exportStar(SpikaWallet, exports);
  __exportStar(HyperPayWallet, exports);
  __exportStar(FletchWallet, exports);
  __exportStar(AptosSnap, exports);
  __exportStar(BitkeepWallet, exports);
  __exportStar(TokenPocketWallet, exports);
  __exportStar(ONTOWallet, exports);
  __exportStar(BloctoWallet, exports);
  __exportStar(Coin98Wallet, exports);
  __exportStar(SafePalWallet, exports);
})(WalletAdapters);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(WalletProviders, exports);
  __exportStar(WalletAdapters, exports);
})(dist$2);
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && React.createContext(DefaultContext);
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i2) {
    return React.createElement(node.tag, __assign({
      key: i2
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data2) {
  return function(props) {
    return /* @__PURE__ */ jsx(IconBase, {
      ...__assign({
        attr: __assign({}, data2.attr)
      }, props),
      children: Tree2Element(data2.child)
    });
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return /* @__PURE__ */ jsxs("svg", {
      ...__assign({
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0"
      }, conf.attr, attr, svgProps, {
        className,
        style: __assign(__assign({
          color: props.color || conf.color
        }, conf.style), props.style),
        height: computedSize,
        width: computedSize,
        xmlns: "http://www.w3.org/2000/svg"
      }),
      children: [title && /* @__PURE__ */ jsx("title", {
        children: title
      }), props.children]
    });
  };
  return IconContext !== void 0 ? /* @__PURE__ */ jsx(IconContext.Consumer, {
    children: function(conf) {
      return elem(conf);
    }
  }) : elem(DefaultContext);
}
function HiChevronDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z", "clipRule": "evenodd" } }] })(props);
}
function HiStar(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" } }] })(props);
}
function HiX(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z", "clipRule": "evenodd" } }] })(props);
}
function HiOutlineChevronDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "stroke": "currentColor" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "strokeWidth": "2", "d": "M19 9l-7 7-7-7" } }] })(props);
}
function HiOutlineChevronLeft(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "stroke": "currentColor" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "strokeWidth": "2", "d": "M15 19l-7-7 7-7" } }] })(props);
}
function HiOutlineChevronRight(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "stroke": "currentColor" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "strokeWidth": "2", "d": "M9 5l7 7-7 7" } }] })(props);
}
function HiOutlineChevronUp(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "stroke": "currentColor" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "strokeWidth": "2", "d": "M5 15l7-7 7 7" } }] })(props);
}
function HiOutlineX(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "stroke": "currentColor" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "strokeWidth": "2", "d": "M6 18L18 6M6 6l12 12" } }] })(props);
}
const excludeClassName = (props) => {
  return exclude({
    key: "className",
    source: props
  });
};
const exclude = ({ key, source }) => {
  delete source[key];
  return source;
};
const theme = {
  accordion: {
    base: "divide-y divide-gray-200 border-gray-200 dark:divide-gray-700 dark:border-gray-700",
    content: {
      base: "py-5 px-5 last:rounded-b-lg dark:bg-gray-900 first:rounded-t-lg"
    },
    flush: {
      off: "rounded-lg border",
      on: "border-b"
    },
    title: {
      arrow: {
        base: "h-6 w-6 shrink-0",
        open: {
          off: "",
          on: "rotate-180"
        }
      },
      base: "flex w-full items-center justify-between first:rounded-t-lg last:rounded-b-lg py-5 px-5 text-left font-medium text-gray-500 dark:text-gray-400",
      flush: {
        off: "hover:bg-gray-100 focus:ring-4 focus:ring-gray-200 dark:hover:bg-gray-800 dark:focus:ring-gray-800",
        on: "!bg-transparent dark:!bg-transparent"
      },
      heading: "",
      open: {
        off: "",
        on: "text-gray-900 bg-gray-100 dark:bg-gray-800 dark:text-white"
      }
    }
  },
  alert: {
    base: "flex flex-col gap-2 p-4 text-sm",
    borderAccent: "border-t-4",
    closeButton: {
      base: "-mx-1.5 -my-1.5 ml-auto inline-flex h-8 w-8 rounded-lg p-1.5 focus:ring-2",
      color: {
        info: "bg-blue-100 text-blue-500 hover:bg-blue-200 focus:ring-blue-400 dark:bg-blue-200 dark:text-blue-600 dark:hover:bg-blue-300",
        gray: "bg-gray-100 text-gray-500 hover:bg-gray-200 focus:ring-gray-400 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-800 dark:hover:text-white",
        failure: "bg-red-100 text-red-500 hover:bg-red-200 focus:ring-red-400 dark:bg-red-200 dark:text-red-600 dark:hover:bg-red-300",
        success: "bg-green-100 text-green-500 hover:bg-green-200 focus:ring-green-400 dark:bg-green-200 dark:text-green-600 dark:hover:bg-green-300",
        warning: "bg-yellow-100 text-yellow-500 hover:bg-yellow-200 focus:ring-yellow-400 dark:bg-yellow-200 dark:text-yellow-600 dark:hover:bg-yellow-300"
      }
    },
    color: {
      info: "text-blue-700 bg-blue-100 border-blue-500 dark:bg-blue-200 dark:text-blue-800",
      gray: "text-gray-700 bg-gray-100 border-gray-500 dark:bg-gray-700 dark:text-gray-300",
      failure: "text-red-700 bg-red-100 border-red-500 dark:bg-red-200 dark:text-red-800",
      success: "text-green-700 bg-green-100 border-green-500 dark:bg-green-200 dark:text-green-800",
      warning: "text-yellow-700 bg-yellow-100 border-yellow-500 dark:bg-yellow-200 dark:text-yellow-800"
    },
    icon: "mr-3 inline h-5 w-5 flex-shrink-0",
    rounded: "rounded-lg"
  },
  avatar: {
    base: "flex items-center space-x-4",
    bordered: "p-1 ring-2 ring-gray-300 dark:ring-gray-500",
    img: {
      off: "rounded relative overflow-hidden bg-gray-100 dark:bg-gray-600",
      on: "rounded"
    },
    rounded: "!rounded-full",
    size: {
      xs: "w-6 h-6",
      sm: "w-8 h-8",
      md: "w-10 h-10",
      lg: "w-20 h-20",
      xl: "w-36 h-36"
    },
    stacked: "ring-2 ring-gray-300 dark:ring-gray-500",
    status: {
      away: "bg-yellow-400",
      base: "absolute h-3.5 w-3.5 rounded-full border-2 border-white dark:border-gray-800",
      busy: "bg-red-400",
      offline: "bg-gray-400",
      online: "bg-green-400"
    },
    statusPosition: {
      "bottom-left": "-bottom-1 -left-1",
      "bottom-center": "-botton-1 center",
      "bottom-right": "-bottom-1 -right-1",
      "top-left": "-top-1 -left-1",
      "top-center": "-top-1 center",
      "top-right": "-top-1 -right-1",
      "center-right": "center -right-1",
      center: "center center",
      "center-left": "center -left-1"
    },
    initials: {
      text: "font-medium text-gray-600 dark:text-gray-300",
      base: "inline-flex overflow-hidden relative justify-center items-center w-10 h-10 bg-gray-100 dark:bg-gray-600"
    }
  },
  badge: {
    base: "flex h-fit items-center gap-1 font-semibold",
    color: {
      info: "bg-blue-100 text-blue-800 dark:bg-blue-200 dark:text-blue-800 group-hover:bg-blue-200 dark:group-hover:bg-blue-300",
      gray: "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300 group-hover:bg-gray-200 dark:group-hover:bg-gray-600",
      failure: "bg-red-100 text-red-800 dark:bg-red-200 dark:text-red-900 group-hover:bg-red-200 dark:group-hover:bg-red-300",
      success: "bg-green-100 text-green-800 dark:bg-green-200 dark:text-green-900 group-hover:bg-green-200 dark:group-hover:bg-green-300",
      warning: "bg-yellow-100 text-yellow-800 dark:bg-yellow-200 dark:text-yellow-900 group-hover:bg-yellow-200 dark:group-hover:bg-yellow-300",
      indigo: "bg-indigo-100 text-indigo-800 dark:bg-indigo-200 dark:text-indigo-900 group-hover:bg-indigo-200 dark:group-hover:bg-indigo-300",
      purple: "bg-purple-100 text-purple-800 dark:bg-purple-200 dark:text-purple-900 group-hover:bg-purple-200 dark:group-hover:bg-purple-300",
      pink: "bg-pink-100 text-pink-800 dark:bg-pink-200 dark:text-pink-900 group-hover:bg-pink-200 dark:group-hover:bg-pink-300"
    },
    href: "group",
    icon: {
      off: "rounded px-2 py-0.5",
      on: "rounded-full p-1.5",
      size: {
        xs: "w-3 h-3",
        sm: "w-3.5 h-3.5"
      }
    },
    size: {
      xs: "p-1 text-xs",
      sm: "p-1.5 text-sm"
    }
  },
  breadcrumb: {
    item: {
      base: "group flex items-center",
      chevron: "mx-1 h-6 w-6 text-gray-400 group-first:hidden md:mx-2",
      href: {
        off: "flex items-center text-sm font-medium text-gray-500 dark:text-gray-400",
        on: "flex items-center text-sm font-medium text-gray-700 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white"
      },
      icon: "mr-2 h-4 w-4"
    },
    list: "flex items-center"
  },
  button: {
    base: "w-full group flex h-min items-center justify-center p-0.5 text-center font-medium focus:z-10",
    color: {
      dark: "text-white bg-gray-800 border border-transparent hover:bg-gray-900 focus:ring-4 focus:ring-gray-300 disabled:hover:bg-gray-800 dark:bg-gray-800 dark:hover:bg-gray-700 dark:focus:ring-gray-800 dark:border-gray-700 dark:disabled:hover:bg-gray-800",
      failure: "text-white bg-red-700 border border-transparent hover:bg-red-800 focus:ring-4 focus:ring-red-300 disabled:hover:bg-red-800 dark:bg-red-600 dark:hover:bg-red-700 dark:focus:ring-red-900 dark:disabled:hover:bg-red-600",
      gray: "text-gray-900 bg-white border border-gray-200 hover:bg-gray-100 hover:text-blue-700 disabled:hover:bg-white focus:ring-blue-700 focus:text-blue-700 dark:bg-transparent dark:text-gray-400 dark:border-gray-600 dark:hover:text-white dark:hover:bg-gray-700 focus:ring-2 dark:disabled:hover:bg-gray-800",
      info: "text-white bg-blue-700 border border-transparent hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 disabled:hover:bg-blue-700 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 dark:disabled:hover:bg-blue-600",
      light: "text-gray-900 bg-white border border-gray-300 hover:bg-gray-100 focus:ring-4 focus:ring-blue-300 disabled:hover:bg-white dark:bg-gray-600 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-700 dark:focus:ring-gray-700",
      purple: "text-white bg-purple-700 border border-transparent hover:bg-purple-800 focus:ring-4 focus:ring-purple-300 disabled:hover:bg-purple-700 dark:bg-purple-600 dark:hover:bg-purple-700 dark:focus:ring-purple-900 dark:disabled:hover:bg-purple-600",
      success: "text-white bg-green-700 border border-transparent hover:bg-green-800 focus:ring-4 focus:ring-green-300 disabled:hover:bg-green-700 dark:bg-green-600 dark:hover:bg-green-700 dark:focus:ring-green-800 dark:disabled:hover:bg-green-600",
      warning: "text-white bg-yellow-400 border border-transparent hover:bg-yellow-500 focus:ring-4 focus:ring-yellow-300 disabled:hover:bg-yellow-400 dark:focus:ring-yellow-900 dark:disabled:hover:bg-yellow-400"
    },
    disabled: "cursor-not-allowed opacity-50",
    gradient: {
      cyan: "text-white bg-gradient-to-r from-cyan-400 via-cyan-500 to-cyan-600 hover:bg-gradient-to-br focus:ring-4 focus:ring-cyan-300 dark:focus:ring-cyan-800",
      failure: "text-white bg-gradient-to-r from-red-400 via-red-500 to-red-600 hover:bg-gradient-to-br focus:ring-4 focus:ring-red-300 dark:focus:ring-red-800",
      info: "text-white bg-gradient-to-r from-blue-500 via-blue-600 to-blue-700 hover:bg-gradient-to-br focus:ring-4 focus:ring-blue-300 dark:focus:ring-blue-800 ",
      lime: "text-gray-900 bg-gradient-to-r from-lime-200 via-lime-400 to-lime-500 hover:bg-gradient-to-br focus:ring-4 focus:ring-lime-300 dark:focus:ring-lime-800",
      pink: "text-white bg-gradient-to-r from-pink-400 via-pink-500 to-pink-600 hover:bg-gradient-to-br focus:ring-4 focus:ring-pink-300 dark:focus:ring-pink-800",
      purple: "text-white bg-gradient-to-r from-purple-500 via-purple-600 to-purple-700 hover:bg-gradient-to-br focus:ring-4 focus:ring-purple-300 dark:focus:ring-purple-800",
      success: "text-white bg-gradient-to-r from-green-400 via-green-500 to-green-600 hover:bg-gradient-to-br focus:ring-4 focus:ring-green-300 dark:focus:ring-green-800",
      teal: "text-white bg-gradient-to-r from-teal-400 via-teal-500 to-teal-600 hover:bg-gradient-to-br focus:ring-4 focus:ring-teal-300 dark:focus:ring-teal-800"
    },
    gradientDuoTone: {
      cyanToBlue: "text-white bg-gradient-to-r from-cyan-500 to-blue-500 hover:bg-gradient-to-bl focus:ring-4 focus:ring-cyan-300 dark:focus:ring-cyan-800",
      greenToBlue: "text-white bg-gradient-to-br from-green-400 to-blue-600 hover:bg-gradient-to-bl focus:ring-4 focus:ring-green-200 dark:focus:ring-green-800",
      pinkToOrange: "text-white bg-gradient-to-br from-pink-500 to-orange-400 hover:bg-gradient-to-bl focus:ring-4 focus:ring-pink-200 dark:focus:ring-pink-800",
      purpleToBlue: "text-white bg-gradient-to-br from-purple-600 to-blue-500 hover:bg-gradient-to-bl focus:ring-4 focus:ring-blue-300 dark:focus:ring-blue-800",
      purpleToPink: "text-white bg-gradient-to-r from-purple-500 to-pink-500 hover:bg-gradient-to-l focus:ring-4 focus:ring-purple-200 dark:focus:ring-purple-800",
      redToYellow: "text-gray-900 bg-gradient-to-r from-red-200 via-red-300 to-yellow-200 hover:bg-gradient-to-bl focus:ring-4 focus:ring-red-100 dark:focus:ring-red-400",
      tealToLime: "text-gray-900 bg-gradient-to-r from-teal-200 to-lime-200 hover:bg-gradient-to-l hover:from-teal-200 hover:to-lime-200 hover:!text-gray-900 focus:ring-4 focus:ring-lime-200 dark:focus:ring-teal-700"
    },
    inner: {
      base: "flex items-center",
      position: {
        none: "",
        start: "rounded-r-none",
        middle: "!rounded-none",
        end: "rounded-l-none"
      },
      outline: "border border-transparent"
    },
    label: "ml-2 inline-flex h-4 w-4 items-center justify-center rounded-full bg-blue-200 text-xs font-semibold text-blue-800",
    outline: {
      color: {
        gray: "border border-gray-900 dark:border-white",
        default: "border-0",
        light: ""
      },
      off: "",
      on: "bg-white text-gray-900 transition-all duration-75 ease-in group-hover:bg-opacity-0 group-hover:text-inherit dark:bg-gray-900 dark:text-white",
      pill: {
        off: "rounded-md",
        on: "rounded-full"
      }
    },
    pill: {
      off: "rounded-lg",
      on: "rounded-full"
    },
    size: {
      xs: "text-xs px-2 py-1",
      sm: "text-sm px-3 py-1.5",
      md: "text-sm px-4 py-2",
      lg: "text-base px-5 py-2.5",
      xl: "text-base px-6 py-3"
    }
  },
  buttonGroup: {
    base: "inline-flex",
    position: {
      none: "focus:!ring-2",
      start: "rounded-r-none",
      middle: "!rounded-none border-l-0 pl-0",
      end: "rounded-l-none border-l-0 pl-0"
    }
  },
  card: {
    base: "flex rounded-lg border border-gray-200 bg-white shadow-md dark:border-gray-700 dark:bg-gray-800",
    children: "flex h-full flex-col justify-center gap-4 p-6",
    horizontal: {
      off: "flex-col",
      on: "flex-col md:max-w-xl md:flex-row"
    },
    href: "hover:bg-gray-100 dark:hover:bg-gray-700",
    img: {
      base: "",
      horizontal: {
        off: "rounded-t-lg",
        on: "h-96 w-full rounded-t-lg object-cover md:h-auto md:w-48 md:rounded-none md:rounded-l-lg"
      }
    }
  },
  carousel: {
    base: "relative h-full w-full",
    indicators: {
      active: {
        off: "bg-white/50 hover:bg-white dark:bg-gray-800/50 dark:hover:bg-gray-800",
        on: "bg-white dark:bg-gray-800"
      },
      base: "h-3 w-3 rounded-full",
      wrapper: "absolute bottom-5 left-1/2 flex -translate-x-1/2 space-x-3"
    },
    item: {
      base: "absolute top-1/2 left-1/2 block w-full -translate-x-1/2 -translate-y-1/2",
      wrapper: "w-full flex-shrink-0 transform cursor-grab snap-center"
    },
    control: {
      base: "inline-flex h-8 w-8 items-center justify-center rounded-full bg-white/30 group-hover:bg-white/50 group-focus:outline-none group-focus:ring-4 group-focus:ring-white dark:bg-gray-800/30 dark:group-hover:bg-gray-800/60 dark:group-focus:ring-gray-800/70 sm:h-10 sm:w-10",
      icon: "h-5 w-5 text-white dark:text-gray-800 sm:h-6 sm:w-6"
    },
    leftControl: "absolute top-0 left-0 flex h-full items-center justify-center px-4 focus:outline-none",
    rightControl: "absolute top-0 right-0 flex h-full items-center justify-center px-4 focus:outline-none",
    scrollContainer: {
      base: "flex h-full snap-mandatory overflow-y-hidden overflow-x-scroll scroll-smooth rounded-lg",
      snap: "snap-x"
    }
  },
  darkThemeToggle: {
    base: "rounded-lg p-2.5 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-700",
    icon: "h-5 w-5"
  },
  dropdown: {
    floating: {
      target: "w-fit",
      base: "z-10 w-fit rounded divide-y divide-gray-100 shadow",
      animation: "transition-opacity",
      hidden: "invisible opacity-0",
      style: {
        dark: "bg-gray-900 text-white dark:bg-gray-700",
        light: "border border-gray-200 bg-white text-gray-900",
        auto: "border border-gray-200 bg-white text-gray-900 dark:border-none dark:bg-gray-700 dark:text-white"
      },
      header: "block py-2 px-4 text-sm text-gray-700 dark:text-gray-200",
      content: "py-1 text-sm text-gray-700 dark:text-gray-200",
      arrow: {
        base: "absolute z-10 h-2 w-2 rotate-45",
        style: {
          dark: "bg-gray-900 dark:bg-gray-700",
          light: "bg-white",
          auto: "bg-white dark:bg-gray-700"
        },
        placement: "-4px"
      },
      item: {
        base: "flex items-center justify-start py-2 px-4 text-sm text-gray-700 cursor-pointer hover:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-600 dark:hover:text-white",
        icon: "mr-2 h-4 w-4"
      },
      divider: "my-1 h-px bg-gray-100 dark:bg-gray-600"
    },
    arrowIcon: "ml-2 h-4 w-4",
    inlineWrapper: "flex items-center",
    content: "py-1"
  },
  footer: {
    base: "w-full rounded-lg bg-white shadow dark:bg-gray-800 md:flex md:items-center md:justify-between",
    container: "w-full p-6",
    bgDark: "bg-gray-800",
    groupLink: {
      base: "flex flex-wrap text-sm text-gray-500 dark:text-white",
      link: {
        base: "last:mr-0 md:mr-6",
        href: "hover:underline"
      },
      col: "flex-col space-y-4"
    },
    icon: {
      base: "text-gray-500 dark:hover:text-white",
      size: "h-5 w-5"
    },
    title: {
      base: "mb-6 text-sm font-semibold uppercase text-gray-500 dark:text-white"
    },
    divider: {
      base: "w-full my-6 border-gray-200 sm:mx-auto dark:border-gray-700 lg:my-8"
    },
    copyright: {
      base: "text-sm text-gray-500 dark:text-gray-400 sm:text-center",
      href: "ml-1 hover:underline",
      span: "ml-1"
    },
    brand: {
      base: "mb-4 flex items-center sm:mb-0",
      img: "mr-3 h-8",
      span: "self-center whitespace-nowrap text-2xl font-semibold text-gray-800 dark:text-white"
    }
  },
  formControls: {
    helperText: {
      base: "mt-2 text-sm",
      colors: {
        gray: "text-gray-500 dark:text-gray-400",
        info: "text-blue-700 dark:text-blue-800",
        success: "text-green-600 dark:text-green-500",
        failure: "text-red-600 dark:text-red-500",
        warning: "text-yellow-500 dark:text-yellow-600"
      }
    },
    label: {
      base: "text-sm font-medium",
      colors: {
        default: "text-gray-900 dark:text-gray-300",
        info: "text-blue-500 dark:text-blue-600",
        failure: "text-red-700 dark:text-red-500",
        warning: "text-yellow-500 dark:text-yellow-600",
        success: "text-green-700 dark:text-green-500"
      },
      disabled: "opacity-50"
    },
    radio: {
      base: "h-4 w-4 border border-gray-300 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:focus:bg-blue-600 dark:focus:ring-blue-600"
    },
    checkbox: {
      base: "h-4 w-4 rounded border border-gray-300 bg-gray-100 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:ring-offset-gray-800 dark:focus:ring-blue-600"
    },
    textInput: {
      base: "flex",
      addon: "inline-flex items-center rounded-l-md border border-r-0 border-gray-300 bg-gray-200 px-3 text-sm text-gray-900 dark:border-gray-600 dark:bg-gray-600 dark:text-gray-400",
      field: {
        base: "relative w-full",
        icon: {
          base: "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3",
          svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
        },
        input: {
          base: "block w-full border disabled:cursor-not-allowed disabled:opacity-50",
          sizes: {
            sm: "p-2 sm:text-xs",
            md: "p-2.5 text-sm",
            lg: "sm:text-md p-4"
          },
          colors: {
            gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500",
            info: "border-blue-500 bg-blue-50 text-blue-900 placeholder-blue-700 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-400 dark:bg-blue-100 dark:focus:border-blue-500 dark:focus:ring-blue-500",
            failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
            warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
            success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
          },
          withIcon: {
            on: "pl-10",
            off: ""
          },
          withAddon: {
            on: "rounded-r-lg",
            off: "rounded-lg"
          },
          withShadow: {
            on: "shadow-sm dark:shadow-sm-light",
            off: ""
          }
        }
      }
    },
    fileInput: {
      base: "flex",
      field: {
        base: "relative w-full",
        input: {
          base: "rounded-lg block w-full border disabled:cursor-not-allowed disabled:opacity-50",
          sizes: {
            sm: "sm:text-xs",
            md: "text-sm",
            lg: "sm:text-md"
          },
          colors: {
            gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500",
            info: "border-blue-500 bg-blue-50 text-blue-900 placeholder-blue-700 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-400 dark:bg-blue-100 dark:focus:border-blue-500 dark:focus:ring-blue-500",
            failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
            warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
            success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
          }
        }
      }
    },
    toggleSwitch: {
      base: "group relative flex items-center rounded-lg focus:outline-none",
      active: {
        on: "cursor-pointer",
        off: "cursor-not-allowed opacity-50"
      },
      toggle: {
        base: "toggle-bg h-6 w-11 rounded-full border group-focus:ring-4 group-focus:ring-blue-500/25",
        checked: {
          on: "border-blue-700 bg-blue-700 after:translate-x-full after:border-white",
          off: "border-gray-200 bg-gray-200 dark:border-gray-600 dark:bg-gray-700"
        }
      },
      label: "ml-3 text-sm font-medium text-gray-900 dark:text-gray-300"
    },
    textarea: {
      base: "block w-full rounded-lg border disabled:cursor-not-allowed disabled:opacity-50",
      colors: {
        gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500",
        info: "border-blue-500 bg-blue-50 text-blue-900 placeholder-blue-700 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-400 dark:bg-blue-100 dark:focus:border-blue-500 dark:focus:ring-blue-500",
        failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
        warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
        success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
      },
      withShadow: {
        on: "shadow-sm dark:shadow-sm-light",
        off: ""
      }
    },
    select: {
      base: "flex",
      addon: "inline-flex items-center rounded-l-md border border-r-0 border-gray-300 bg-gray-200 px-3 text-sm text-gray-900 dark:border-gray-600 dark:bg-gray-600 dark:text-gray-400",
      field: {
        base: "relative w-full",
        icon: {
          base: "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3",
          svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
        },
        select: {
          base: "block w-full border disabled:cursor-not-allowed disabled:opacity-50",
          withIcon: {
            on: "pl-10",
            off: ""
          },
          withAddon: {
            on: "rounded-r-lg",
            off: "rounded-lg"
          },
          withShadow: {
            on: "shadow-sm dark:shadow-sm-light",
            off: ""
          },
          sizes: {
            sm: "p-2 sm:text-xs",
            md: "p-2.5 text-sm",
            lg: "sm:text-md p-4"
          },
          colors: {
            gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500",
            info: "border-blue-500 bg-blue-50 text-blue-900 placeholder-blue-700 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-400 dark:bg-blue-100 dark:focus:border-blue-500 dark:focus:ring-blue-500",
            failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
            warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
            success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
          }
        }
      }
    }
  },
  listGroup: {
    base: "list-none rounded-lg border border-gray-200 bg-white text-sm font-medium text-gray-900 dark:border-gray-600 dark:bg-gray-700 dark:text-white",
    item: {
      active: {
        off: "hover:bg-gray-100 hover:text-blue-700 focus:text-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-700 dark:border-gray-600 dark:hover:bg-gray-600 dark:hover:text-white dark:focus:text-white dark:focus:ring-gray-500",
        on: "bg-blue-700 text-white dark:bg-gray-800"
      },
      base: "flex w-full cursor-pointer border-b border-gray-200 py-2 px-4 first:rounded-t-lg last:rounded-b-lg last:border-b-0 dark:border-gray-600",
      href: {
        off: "",
        on: ""
      },
      icon: "mr-2 h-4 w-4 fill-current"
    }
  },
  modal: {
    base: "fixed top-0 right-0 left-0 z-50 h-modal overflow-y-auto overflow-x-hidden md:inset-0 md:h-full",
    show: {
      on: "flex bg-gray-900 bg-opacity-50 dark:bg-opacity-80",
      off: "hidden"
    },
    content: {
      base: "relative h-full w-full p-4 md:h-auto",
      inner: "relative rounded-lg bg-white shadow dark:bg-gray-700"
    },
    body: {
      base: "p-6",
      popup: "pt-0"
    },
    header: {
      base: "flex items-start justify-between rounded-t dark:border-gray-600 border-b p-5",
      popup: "!p-2 !border-b-0",
      title: "text-xl font-medium text-gray-900 dark:text-white",
      close: {
        base: "ml-auto inline-flex items-center rounded-lg bg-transparent p-1.5 text-sm text-gray-400 hover:bg-gray-200 hover:text-gray-900 dark:hover:bg-gray-600 dark:hover:text-white",
        icon: "h-5 w-5"
      }
    },
    footer: {
      base: "flex items-center space-x-2 rounded-b border-gray-200 p-6 dark:border-gray-600",
      popup: "border-t"
    },
    sizes: {
      sm: "max-w-sm",
      md: "max-w-md",
      lg: "max-w-lg",
      xl: "max-w-xl",
      "2xl": "max-w-2xl",
      "3xl": "max-w-3xl",
      "4xl": "max-w-4xl",
      "5xl": "max-w-5xl",
      "6xl": "max-w-6xl",
      "7xl": "max-w-7xl"
    },
    positions: {
      "top-left": "items-start justify-start",
      "top-center": "items-start justify-center",
      "top-right": "items-start justify-end",
      "center-left": "items-center justify-start",
      center: "items-center justify-center",
      "center-right": "items-center justify-end",
      "bottom-right": "items-end justify-end",
      "bottom-center": "items-end justify-center",
      "bottom-left": "items-end justify-start"
    }
  },
  navbar: {
    base: "border-gray-200 bg-white px-2 py-2.5 dark:border-gray-700 dark:bg-gray-800 sm:px-4",
    rounded: {
      on: "rounded",
      off: ""
    },
    bordered: {
      on: "border",
      off: ""
    },
    inner: {
      base: "mx-auto flex flex-wrap items-center justify-between",
      fluid: {
        on: "",
        off: "container"
      }
    },
    brand: "flex items-center",
    collapse: {
      base: "w-full md:block md:w-auto",
      list: "mt-4 flex flex-col md:mt-0 md:flex-row md:space-x-8 md:text-sm md:font-medium",
      hidden: {
        on: "hidden",
        off: ""
      }
    },
    link: {
      base: "block py-2 pr-4 pl-3 md:p-0",
      active: {
        on: "bg-blue-700 text-white dark:text-white md:bg-transparent md:text-blue-700",
        off: "border-b border-gray-100  text-gray-700 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:border-0 md:hover:bg-transparent md:hover:text-blue-700 md:dark:hover:bg-transparent md:dark:hover:text-white"
      },
      disabled: {
        on: "text-gray-400 hover:cursor-not-allowed dark:text-gray-600",
        off: ""
      }
    },
    toggle: {
      base: "inline-flex items-center rounded-lg p-2 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600 md:hidden",
      icon: "h-6 w-6 shrink-0"
    }
  },
  rating: {
    base: "flex items-center",
    star: {
      sizes: {
        sm: "w-5 h-5",
        md: "w-7 h-7",
        lg: "w-10 h-10"
      },
      filled: "text-yellow-400",
      empty: "text-gray-300 dark:text-gray-500"
    },
    advanced: {
      base: "flex items-center",
      label: "text-sm font-medium text-blue-600 dark:text-blue-500",
      progress: {
        base: "mx-4 h-5 w-2/4 rounded bg-gray-200 dark:bg-gray-700",
        fill: "h-5 rounded bg-yellow-400",
        label: "text-sm font-medium text-blue-600 dark:text-blue-500"
      }
    }
  },
  pagination: {
    base: "",
    layout: {
      table: {
        base: "text-sm text-gray-700 dark:text-gray-400",
        span: "font-semibold text-gray-900 dark:text-white"
      }
    },
    pages: {
      base: "xs:mt-0 mt-2 inline-flex items-center -space-x-px",
      showIcon: "inline-flex",
      previous: {
        base: "ml-0 rounded-l-lg border border-gray-300 bg-white py-2 px-3 leading-tight text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white",
        icon: "h-5 w-5"
      },
      next: {
        base: "rounded-r-lg border border-gray-300 bg-white py-2 px-3 leading-tight text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white",
        icon: "h-5 w-5"
      },
      selector: {
        base: "w-12 border border-gray-300 bg-white py-2 leading-tight text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white",
        active: "bg-blue-50 text-blue-600 hover:bg-blue-100 hover:text-blue-700 dark:border-gray-700 dark:bg-gray-700 dark:text-white"
      }
    }
  },
  sidebar: {
    base: "h-full",
    inner: "h-full overflow-y-auto overflow-x-hidden rounded bg-white py-4 px-3 dark:bg-gray-800",
    collapsed: {
      on: "w-16",
      off: "w-64"
    },
    collapse: {
      button: "group flex w-full items-center rounded-lg p-2 text-base font-normal text-gray-900 transition duration-75 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700",
      icon: {
        base: "h-6 w-6 text-gray-500 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white",
        open: {
          off: "",
          on: "text-gray-900"
        }
      },
      label: {
        base: "ml-3 flex-1 whitespace-nowrap text-left",
        icon: "h-6 w-6"
      },
      list: "space-y-2 py-2"
    },
    cta: {
      base: "mt-6 rounded-lg p-4",
      color: {
        blue: "bg-blue-50 dark:bg-blue-900",
        dark: "bg-dark-50 dark:bg-dark-900",
        failure: "bg-red-50 dark:bg-red-900",
        gray: "bg-alternative-50 dark:bg-alternative-900",
        green: "bg-green-50 dark:bg-green-900",
        light: "bg-light-50 dark:bg-light-900",
        red: "bg-red-50 dark:bg-red-900",
        purple: "bg-purple-50 dark:bg-purple-900",
        success: "bg-green-50 dark:bg-green-900",
        yellow: "bg-yellow-50 dark:bg-yellow-900",
        warning: "bg-yellow-50 dark:bg-yellow-900"
      }
    },
    item: {
      base: "flex items-center justify-center rounded-lg p-2 text-base font-normal text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700",
      active: "bg-gray-100 dark:bg-gray-700",
      collapsed: {
        insideCollapse: "group w-full pl-8 transition duration-75",
        noIcon: "font-bold"
      },
      content: {
        base: "px-3 flex-1 whitespace-nowrap"
      },
      icon: {
        base: "h-6 w-6 flex-shrink-0 text-gray-500 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white",
        active: "text-gray-700 dark:text-gray-100"
      }
    },
    items: "",
    itemGroup: "mt-4 space-y-2 border-t border-gray-200 pt-4 first:mt-0 first:border-t-0 first:pt-0 dark:border-gray-700",
    logo: {
      base: "mb-5 flex items-center pl-2.5",
      collapsed: {
        on: "hidden",
        off: "self-center whitespace-nowrap text-xl font-semibold dark:text-white"
      },
      img: "mr-3 h-6 sm:h-7"
    }
  },
  progress: {
    base: "w-full overflow-hidden rounded-full bg-gray-200 dark:bg-gray-700",
    label: "mb-1 flex justify-between font-medium dark:text-white",
    bar: "flex items-center justify-center rounded-full text-center font-medium leading-none text-blue-100",
    color: {
      dark: "bg-gray-600 dark:bg-gray-300",
      blue: "bg-blue-600",
      red: "bg-red-600 dark:bg-red-500",
      green: "bg-green-600 dark:bg-green-500",
      yellow: "bg-yellow-400",
      indigo: "bg-indigo-600 dark:bg-indigo-500",
      purple: "bg-purple-600 dark:bg-purple-500"
    },
    size: {
      sm: "h-1.5",
      md: "h-2.5",
      lg: "h-4",
      xl: "h-6"
    }
  },
  spinner: {
    base: "inline animate-spin text-gray-200",
    color: {
      failure: "fill-red-600",
      gray: "fill-gray-600",
      info: "fill-blue-600",
      pink: "fill-pink-600",
      purple: "fill-purple-600",
      success: "fill-green-500",
      warning: "fill-yellow-400"
    },
    light: {
      off: {
        base: "dark:text-gray-600",
        color: {
          failure: "",
          gray: "dark:fill-gray-300",
          info: "",
          pink: "",
          purple: "",
          success: "",
          warning: ""
        }
      },
      on: {
        base: "",
        color: {
          failure: "",
          gray: "",
          info: "",
          pink: "",
          purple: "",
          success: "",
          warning: ""
        }
      }
    },
    size: {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-6 h-6",
      lg: "w-8 h-8",
      xl: "w-10 h-10"
    }
  },
  tab: {
    base: "flex flex-col gap-2",
    tablist: {
      base: "flex text-center",
      styles: {
        default: "flex-wrap border-b border-gray-200 dark:border-gray-700",
        underline: "flex-wrap -mb-px border-b border-gray-200 dark:border-gray-700",
        pills: "flex-wrap font-medium text-sm text-gray-500 dark:text-gray-400",
        fullWidth: "hidden text-sm font-medium rounded-lg divide-x divide-gray-200 shadow sm:flex dark:divide-gray-700 dark:text-gray-400"
      },
      tabitem: {
        base: "flex items-center justify-center p-4 text-sm font-medium first:ml-0 disabled:cursor-not-allowed disabled:text-gray-400 disabled:dark:text-gray-500",
        styles: {
          default: {
            base: "rounded-t-lg",
            active: {
              on: "bg-gray-100 text-blue-600 dark:bg-gray-800 dark:text-blue-500",
              off: "text-gray-500 hover:bg-gray-50 hover:text-gray-600 dark:text-gray-400 dark:hover:bg-gray-800  dark:hover:text-gray-300"
            }
          },
          underline: {
            base: "rounded-t-lg",
            active: {
              on: "text-blue-600 rounded-t-lg border-b-2 border-blue-600 active dark:text-blue-500 dark:border-blue-500",
              off: "border-b-2 border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-600 dark:text-gray-400 dark:hover:text-gray-300"
            }
          },
          pills: {
            base: "",
            active: {
              on: "rounded-lg bg-blue-600 text-white",
              off: "rounded-lg hover:text-gray-900 hover:bg-gray-100 dark:hover:bg-gray-800 dark:hover:text-white"
            }
          },
          fullWidth: {
            base: "ml-2 first:ml-0 w-full first:rounded-l-lg last:rounded-r-lg",
            active: {
              on: "inline-block p-4 w-full text-gray-900 bg-gray-100 focus:ring-4 focus:ring-blue-300 active focus:outline-none dark:bg-gray-700 dark:text-white",
              off: "bg-white hover:text-gray-700 hover:bg-gray-50 focus:ring-4 focus:ring-blue-300 focus:outline-none dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700"
            }
          }
        },
        icon: "mr-2 h-5 w-5"
      }
    },
    tabpanel: "p-4"
  },
  toast: {
    base: "flex w-full max-w-xs items-center rounded-lg bg-white p-4 text-gray-500 shadow dark:bg-gray-800 dark:text-gray-400",
    closed: "opacity-0 ease-out",
    removed: "hidden",
    toggle: {
      base: "-mx-1.5 -my-1.5 ml-auto inline-flex h-8 w-8 rounded-lg bg-white p-1.5 text-gray-400 hover:bg-gray-100 hover:text-gray-900 focus:ring-2 focus:ring-gray-300 dark:bg-gray-800 dark:text-gray-500 dark:hover:bg-gray-700 dark:hover:text-white",
      icon: "h-5 w-5 shrink-0"
    }
  },
  tooltip: {
    target: "w-fit",
    base: "absolute inline-block z-10 rounded-lg py-2 px-3 text-sm font-medium shadow-sm",
    animation: "transition-opacity",
    hidden: "invisible opacity-0",
    style: {
      dark: "bg-gray-900 text-white dark:bg-gray-700",
      light: "border border-gray-200 bg-white text-gray-900",
      auto: "border border-gray-200 bg-white text-gray-900 dark:border-none dark:bg-gray-700 dark:text-white"
    },
    content: "relative z-20",
    arrow: {
      base: "absolute z-10 h-2 w-2 rotate-45",
      style: {
        dark: "bg-gray-900 dark:bg-gray-700",
        light: "bg-white",
        auto: "bg-white dark:bg-gray-700"
      },
      placement: "-4px"
    }
  }
};
const ThemeContext = react.exports.createContext({
  theme
});
function useTheme() {
  return react.exports.useContext(ThemeContext);
}
const AccordionPanelContext = react.exports.createContext(void 0);
function useAccordionContext() {
  const context = react.exports.useContext(AccordionPanelContext);
  if (!context) {
    throw new Error("useAccordionContext should be used within the AccordionPanelContext provider!");
  }
  return context;
}
const AccordionContent = ({ children, ...props }) => {
  const theirProps = excludeClassName(props);
  const { isOpen } = useAccordionContext();
  const theme2 = useTheme().theme.accordion.content;
  return jsx("div", { className: theme2.base, "data-testid": "flowbite-accordion-content", hidden: !isOpen, ...theirProps, children });
};
const AccordionPanel = ({ children, ...props }) => {
  const { alwaysOpen } = props;
  const [isOpen, setOpen] = react.exports.useState(props.isOpen);
  const provider2 = alwaysOpen ? {
    ...props,
    isOpen,
    setOpen: () => setOpen(!isOpen)
  } : props;
  return jsx(AccordionPanelContext.Provider, { value: provider2, children });
};
const AccordionTitle = ({ as: Heading = "h2", children, ...props }) => {
  const theirProps = excludeClassName(props);
  const { arrowIcon: ArrowIcon, flush, isOpen, setOpen } = useAccordionContext();
  const theme2 = useTheme().theme.accordion.title;
  const onClick = () => typeof setOpen !== "undefined" && setOpen();
  return jsxs("button", { className: classNames(theme2.base, theme2.flush[flush ? "on" : "off"], theme2.open[isOpen ? "on" : "off"]), onClick, type: "button", ...theirProps, children: [jsx(Heading, { className: theme2.heading, "data-testid": "flowbite-accordion-heading", children }), ArrowIcon && jsx(ArrowIcon, { "aria-hidden": true, className: classNames(theme2.arrow.base, theme2.arrow.open[isOpen ? "on" : "off"]), "data-testid": "flowbite-accordion-arrow" })] });
};
const AccordionComponent = ({ alwaysOpen = false, arrowIcon = HiChevronDown, children, flush = false, ...props }) => {
  const theirProps = excludeClassName(props);
  const [isOpen, setOpen] = react.exports.useState(0);
  const panels = react.exports.useMemo(() => react.exports.Children.map(children, (child, i2) => react.exports.cloneElement(child, { alwaysOpen, arrowIcon, flush, isOpen: isOpen === i2, setOpen: () => setOpen(i2) })), [alwaysOpen, arrowIcon, children, flush, isOpen]);
  const theme2 = useTheme().theme.accordion;
  return jsx("div", { className: classNames(theme2.base, theme2.flush[flush ? "on" : "off"]), "data-testid": "flowbite-accordion", ...theirProps, children: panels });
};
AccordionComponent.displayName = "Accordion";
AccordionPanel.displayName = "Accordion.Panel";
AccordionTitle.displayName = "Accordion.Title";
AccordionContent.displayName = "Accordion.Content";
Object.assign(AccordionComponent, {
  Panel: AccordionPanel,
  Title: AccordionTitle,
  Content: AccordionContent
});
const AvatarGroup = ({ children }) => {
  return jsx("div", { "data-testid": "avatar-group-element", className: "mb-5 flex -space-x-4", children });
};
AvatarGroup.displayName = "Avatar.Group";
const AvatarGroupCounter = ({ total, href }) => {
  return jsxs("a", { className: "relative flex h-10 w-10 items-center justify-center rounded-full bg-gray-700 text-xs font-medium text-white ring-2 ring-gray-300 hover:bg-gray-600  dark:ring-gray-500 ", href, children: ["+", total] });
};
AvatarGroupCounter.displayName = "Avatar.GroupCounter";
const AvatarComponent = ({ alt = "", bordered = false, children, img, rounded = false, size = "md", stacked = false, status, statusPosition = "top-left", placeholderInitials = "", ...props }) => {
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.avatar;
  return jsxs("div", { className: theme2.base, "data-testid": "flowbite-avatar", ...theirProps, children: [jsxs("div", { className: "relative", children: [img ? jsx("img", { alt, className: classNames(bordered && theme2.bordered, rounded && theme2.rounded, stacked && theme2.stacked, theme2.img.on, theme2.size[size]), "data-testid": "flowbite-avatar-img", src: img }) : placeholderInitials ? jsx("div", { className: classNames(theme2.img.off, theme2.initials.base, rounded && theme2.rounded, stacked && theme2.stacked, bordered && theme2.bordered), children: jsx("span", { className: classNames(theme2.initials.text), "data-testid": "flowbite-avatar-initials-placeholder", children: placeholderInitials }) }) : jsx("div", { className: classNames(bordered && theme2.bordered, rounded && theme2.rounded, stacked && theme2.stacked, theme2.img.off, theme2.size[size]), "data-testid": "flowbite-avatar-img", children: jsx("svg", { className: "absolute -bottom-1 h-auto w-auto text-gray-400", fill: "currentColor", viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z", clipRule: "evenodd" }) }) }), status && jsx("span", { className: classNames(theme2.status.base, theme2.status[status], theme2.statusPosition[statusPosition]) })] }), children && jsx("div", { children })] });
};
AvatarComponent.displayName = "Avatar";
Object.assign(AvatarComponent, {
  Group: AvatarGroup,
  Counter: AvatarGroupCounter
});
const Badge = ({ children, color: color2 = "info", href, icon: Icon, size = "xs", ...props }) => {
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.badge;
  const Content = () => jsxs("span", { className: classNames(theme2.base, theme2.color[color2], theme2.icon[Icon ? "on" : "off"], theme2.size[size]), "data-testid": "flowbite-badge", ...theirProps, children: [Icon && jsx(Icon, { "aria-hidden": true, className: theme2.icon.size[size], "data-testid": "flowbite-badge-icon" }), children && jsx("span", { children })] });
  return href ? jsx("a", { className: theme2.href, href, children: jsx(Content, {}) }) : jsx(Content, {});
};
const BreadcrumbItem = ({ children, href, icon: Icon, ...props }) => {
  const isLink = typeof href !== "undefined";
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.breadcrumb.item;
  const Component = isLink ? "a" : "span";
  return jsxs("li", { className: theme2.base, ...theirProps, children: [jsx(HiOutlineChevronRight, { "aria-hidden": true, className: theme2.chevron, "data-testid": "flowbite-breadcrumb-separator" }), jsxs(Component, { className: theme2.href[isLink ? "on" : "off"], "data-testid": "flowbite-breadcrumb-item", href, children: [Icon && jsx(Icon, { "aria-hidden": true, className: theme2.icon }), children] })] });
};
BreadcrumbItem.displayName = "Breadcrumb.Item";
const BreadcrumbComponent = ({ children, ...props }) => {
  const theme2 = useTheme().theme.breadcrumb;
  return jsx("nav", { "aria-label": "Breadcrumb", ...props, children: jsx("ol", { className: theme2.list, children }) });
};
BreadcrumbComponent.displayName = "Breadcrumb";
Object.assign(BreadcrumbComponent, { Item: BreadcrumbItem });
const ButtonGroup = ({ children, outline, pill, ...props }) => {
  const theirProps = excludeClassName(props);
  const items = react.exports.useMemo(() => react.exports.Children.map(children, (child, index2) => react.exports.cloneElement(child, {
    outline,
    pill,
    positionInGroup: index2 === 0 ? "start" : index2 === children.length - 1 ? "end" : "middle"
  })), [children, outline, pill]);
  const theme2 = useTheme().theme.buttonGroup;
  return jsx("div", { className: theme2.base, role: "group", ...theirProps, children: items });
};
ButtonGroup.displayName = "Button.Group";
const ButtonComponent = react.exports.forwardRef(({ children, color: color2 = "info", disabled = false, gradientDuoTone, gradientMonochrome, href, label, outline = false, pill = false, positionInGroup = "none", size = "md", ...props }, ref) => {
  var _a2;
  const isLink = typeof href !== "undefined";
  const theirProps = excludeClassName(props);
  const { buttonGroup: groupTheme, button: theme2 } = useTheme().theme;
  const Component = isLink ? "a" : "button";
  return jsx(Component, { className: classNames(disabled && theme2.disabled, !gradientDuoTone && !gradientMonochrome && theme2.color[color2], gradientDuoTone && !gradientMonochrome && theme2.gradientDuoTone[gradientDuoTone], !gradientDuoTone && gradientMonochrome && theme2.gradient[gradientMonochrome], groupTheme.position[positionInGroup], outline && ((_a2 = theme2.outline.color[color2]) != null ? _a2 : theme2.outline.color.default), theme2.base, theme2.pill[pill ? "on" : "off"]), disabled, href, type: isLink ? void 0 : "button", ref, ...theirProps, children: jsx("span", { className: classNames(theme2.inner.base, theme2.inner.position[positionInGroup], theme2.outline[outline ? "on" : "off"], theme2.outline.pill[outline && pill ? "on" : "off"], theme2.size[size], outline && !theme2.outline.color[color2] && theme2.inner.outline), children: jsxs(Fragment, { children: [typeof children !== "undefined" && children, typeof label !== "undefined" && jsx("span", { className: theme2.label, "data-testid": "flowbite-button-label", children: label })] }) }) });
});
ButtonComponent.displayName = "Button";
const Button = Object.assign(ButtonComponent, {
  Group: ButtonGroup
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var n$1 = function(t2, e3) {
  return (n$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t3, e4) {
    t3.__proto__ = e4;
  } || function(t3, e4) {
    for (var n2 in e4)
      e4.hasOwnProperty(n2) && (t3[n2] = e4[n2]);
  })(t2, e3);
};
var o, r, i = (function(t2) {
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  !function() {
    var e3 = {}.hasOwnProperty;
    function n2() {
      for (var t3 = [], o2 = 0; o2 < arguments.length; o2++) {
        var r2 = arguments[o2];
        if (r2) {
          var i2 = typeof r2;
          if ("string" === i2 || "number" === i2)
            t3.push(r2);
          else if (Array.isArray(r2) && r2.length) {
            var s2 = n2.apply(null, r2);
            s2 && t3.push(s2);
          } else if ("object" === i2)
            for (var l2 in r2)
              e3.call(r2, l2) && r2[l2] && t3.push(l2);
        }
      }
      return t3.join(" ");
    }
    t2.exports ? (n2.default = n2, t2.exports = n2) : window.classNames = n2;
  }();
}(r = {
  path: o,
  exports: {},
  require: function(t2, e3) {
    return function() {
      throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
    }(null == e3 && r.path);
  }
}, r.exports), r.exports);
function s$1(t2, e3, n2) {
  var o2, r2, i2, s2, l2;
  function a2() {
    var c3 = Date.now() - s2;
    c3 < e3 && c3 >= 0 ? o2 = setTimeout(a2, e3 - c3) : (o2 = null, n2 || (l2 = t2.apply(i2, r2), i2 = r2 = null));
  }
  null == e3 && (e3 = 100);
  var c2 = function() {
    i2 = this, r2 = arguments, s2 = Date.now();
    var c3 = n2 && !o2;
    return o2 || (o2 = setTimeout(a2, e3)), c3 && (l2 = t2.apply(i2, r2), i2 = r2 = null), l2;
  };
  return c2.clear = function() {
    o2 && (clearTimeout(o2), o2 = null);
  }, c2.flush = function() {
    o2 && (l2 = t2.apply(i2, r2), i2 = r2 = null, clearTimeout(o2), o2 = null);
  }, c2;
}
s$1.debounce = s$1;
var l$1 = s$1;
!function(t2, e3) {
  void 0 === e3 && (e3 = {});
  var n2 = e3.insertAt;
  if (t2 && "undefined" != typeof document) {
    var o2 = document.head || document.getElementsByTagName("head")[0], r2 = document.createElement("style");
    r2.type = "text/css", "top" === n2 && o2.firstChild ? o2.insertBefore(r2, o2.firstChild) : o2.appendChild(r2), r2.styleSheet ? r2.styleSheet.cssText = t2 : r2.appendChild(document.createTextNode(t2));
  }
}(".indiana-scroll-container {\n  overflow: auto; }\n  .indiana-scroll-container--dragging {\n    scroll-behavior: auto !important; }\n    .indiana-scroll-container--dragging > * {\n      pointer-events: none;\n      cursor: -webkit-grab;\n      cursor: grab; }\n  .indiana-scroll-container--hide-scrollbars {\n    overflow: hidden;\n    overflow: -moz-scrollbars-none;\n    -ms-overflow-style: none;\n    scrollbar-width: none; }\n    .indiana-scroll-container--hide-scrollbars::-webkit-scrollbar {\n      display: none !important;\n      height: 0 !important;\n      width: 0 !important;\n      background: transparent !important;\n      -webkit-appearance: none !important; }\n  .indiana-scroll-container--native-scroll {\n    overflow: auto; }\n\n.indiana-dragging {\n  cursor: -webkit-grab;\n  cursor: grab; }\n");
var a, c = (a = "indiana-scroll-container", function(t2, e3) {
  if (!t2)
    return a;
  var n2;
  "string" == typeof t2 ? n2 = t2 : e3 = t2;
  var o2 = a;
  return n2 && (o2 += "__" + n2), o2 + (e3 ? Object.keys(e3).reduce(function(t3, n3) {
    var r2 = e3[n3];
    return r2 && (t3 += " " + ("boolean" == typeof r2 ? o2 + "--" + n3 : o2 + "--" + n3 + "_" + r2)), t3;
  }, "") : "");
});
(function(e3) {
  function o2(n2) {
    var o3 = e3.call(this, n2) || this;
    return o3.onEndScroll = function() {
      o3.scrolling = false, !o3.pressed && o3.started && o3.processEnd();
    }, o3.onScroll = function(t2) {
      var e4 = o3.container.current;
      e4.scrollLeft === o3.scrollLeft && e4.scrollTop === o3.scrollTop || (o3.scrolling = true, o3.processScroll(t2), o3.onEndScroll());
    }, o3.onTouchStart = function(t2) {
      var e4 = o3.props.nativeMobileScroll;
      if (o3.isDraggable(t2.target))
        if (o3.internal = true, e4 && o3.scrolling)
          o3.pressed = true;
        else {
          var n3 = t2.touches[0];
          o3.processClick(t2, n3.clientX, n3.clientY), !e4 && o3.props.stopPropagation && t2.stopPropagation();
        }
    }, o3.onTouchEnd = function(t2) {
      var e4 = o3.props.nativeMobileScroll;
      o3.pressed && (!o3.started || o3.scrolling && e4 ? o3.pressed = false : o3.processEnd(), o3.forceUpdate());
    }, o3.onTouchMove = function(t2) {
      var e4 = o3.props.nativeMobileScroll;
      if (o3.pressed && (!e4 || !o3.isMobile)) {
        var n3 = t2.touches[0];
        n3 && o3.processMove(t2, n3.clientX, n3.clientY), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation();
      }
    }, o3.onMouseDown = function(t2) {
      o3.isDraggable(t2.target) && o3.isScrollable() && (o3.internal = true, -1 !== o3.props.buttons.indexOf(t2.button) && (o3.processClick(t2, t2.clientX, t2.clientY), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation()));
    }, o3.onMouseMove = function(t2) {
      o3.pressed && (o3.processMove(t2, t2.clientX, t2.clientY), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation());
    }, o3.onMouseUp = function(t2) {
      o3.pressed && (o3.started ? o3.processEnd() : (o3.internal = false, o3.pressed = false, o3.forceUpdate(), o3.props.onClick && o3.props.onClick(t2)), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation());
    }, o3.container = React.createRef(), o3.onEndScroll = l$1(o3.onEndScroll, 300), o3.scrolling = false, o3.started = false, o3.pressed = false, o3.internal = false, o3.getRef = o3.getRef.bind(o3), o3;
  }
  return function(t2, e4) {
    function o3() {
      this.constructor = t2;
    }
    n$1(t2, e4), t2.prototype = null === e4 ? Object.create(e4) : (o3.prototype = e4.prototype, new o3());
  }(o2, e3), o2.prototype.componentDidMount = function() {
    var t2 = this.props.nativeMobileScroll, e4 = this.container.current;
    window.addEventListener("mouseup", this.onMouseUp), window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("touchmove", this.onTouchMove, {
      passive: false
    }), window.addEventListener("touchend", this.onTouchEnd), e4.addEventListener("touchstart", this.onTouchStart, {
      passive: false
    }), e4.addEventListener("mousedown", this.onMouseDown, {
      passive: false
    }), t2 && (this.isMobile = this.isMobileDevice(), this.isMobile && this.forceUpdate());
  }, o2.prototype.componentWillUnmount = function() {
    window.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd);
  }, o2.prototype.getElement = function() {
    return this.container.current;
  }, o2.prototype.isMobileDevice = function() {
    return void 0 !== window.orientation || -1 !== navigator.userAgent.indexOf("IEMobile");
  }, o2.prototype.isDraggable = function(t2) {
    var e4 = this.props.ignoreElements;
    if (e4) {
      var n2 = t2.closest(e4);
      return null === n2 || n2.contains(this.getElement());
    }
    return true;
  }, o2.prototype.isScrollable = function() {
    var t2 = this.container.current;
    return t2 && (t2.scrollWidth > t2.clientWidth || t2.scrollHeight > t2.clientHeight);
  }, o2.prototype.processClick = function(t2, e4, n2) {
    var o3 = this.container.current;
    this.scrollLeft = o3.scrollLeft, this.scrollTop = o3.scrollTop, this.clientX = e4, this.clientY = n2, this.pressed = true;
  }, o2.prototype.processStart = function(t2) {
    void 0 === t2 && (t2 = true);
    var e4 = this.props.onStartScroll;
    this.started = true, t2 && document.body.classList.add("indiana-dragging"), e4 && e4({
      external: !this.internal
    }), this.forceUpdate();
  }, o2.prototype.processScroll = function(t2) {
    if (this.started) {
      var e4 = this.props.onScroll;
      e4 && e4({
        external: !this.internal
      });
    } else
      this.processStart(false);
  }, o2.prototype.processMove = function(t2, e4, n2) {
    var o3 = this.props, r2 = o3.horizontal, i2 = o3.vertical, s2 = o3.activationDistance, l2 = o3.onScroll, a2 = this.container.current;
    this.started ? (r2 && (a2.scrollLeft -= e4 - this.clientX), i2 && (a2.scrollTop -= n2 - this.clientY), l2 && l2({
      external: !this.internal
    }), this.clientX = e4, this.clientY = n2, this.scrollLeft = a2.scrollLeft, this.scrollTop = a2.scrollTop) : (r2 && Math.abs(e4 - this.clientX) > s2 || i2 && Math.abs(n2 - this.clientY) > s2) && (this.clientX = e4, this.clientY = n2, this.processStart());
  }, o2.prototype.processEnd = function() {
    var t2 = this.props.onEndScroll;
    this.container.current && t2 && t2({
      external: !this.internal
    }), this.pressed = false, this.started = false, this.scrolling = false, this.internal = false, document.body.classList.remove("indiana-dragging"), this.forceUpdate();
  }, o2.prototype.getRef = function(t2) {
    [this.container, this.props.innerRef].forEach(function(e4) {
      e4 && ("function" == typeof e4 ? e4(t2) : e4.current = t2);
    });
  }, o2.prototype.render = function() {
    var e4 = this.props, n2 = e4.children, o3 = e4.draggingClassName, r2 = e4.className, s2 = e4.style, l2 = e4.hideScrollbars, a2 = e4.component;
    return React.createElement(a2, {
      className: i(r2, this.pressed && o3, c({
        dragging: this.pressed,
        "hide-scrollbars": l2,
        "native-scroll": this.isMobile
      })),
      style: s2,
      ref: this.getRef,
      onScroll: this.onScroll
    }, n2);
  }, o2.defaultProps = {
    nativeMobileScroll: true,
    hideScrollbars: true,
    activationDistance: 10,
    vertical: true,
    horizontal: true,
    stopPropagation: false,
    style: {},
    component: "div",
    buttons: [0]
  }, o2;
})(react.exports.PureComponent);
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    const r2 = Math.random() * 16 | 0, v2 = c2 == "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < middleware.length; i2++) {
    const {
      name,
      fn
    } = middleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data2
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x: x2,
      y: y2
    } : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$1 = Math.min;
const max$1 = Math.max;
function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getMainAxisFromPlacement(placement);
    const alignment = getAlignment(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min2, center, max2);
    const alignmentPadding = alignment === "start" ? paddingObject[minProp] : paddingObject[maxProp];
    const shouldAddOffset = alignmentPadding > 0 && center !== offset2 && rects.reference[length] <= rects.floating[length];
    const alignmentOffset = shouldAddOffset ? center < min2 ? min2 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
const hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
const sides = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;
      const {
        x: x2,
        y: y2,
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
      const currentPlacement = placements[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          x: x2,
          y: y2,
          reset: {
            placement: placements[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a2, b2) => a2.overflows[0] - b2.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$map$so;
            const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = middlewareArguments;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function getUAString() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
  }
  return navigator.userAgent;
}
function isHTMLElement$1(value) {
  return value instanceof getWindow$1(value).HTMLElement;
}
function isElement$1(value) {
  return value instanceof getWindow$1(value).Element;
}
function isNode(value) {
  return value instanceof getWindow$1(value).Node;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective"].some((value) => css.willChange.includes(value)) || ["paint", "layout", "strict", "content"].some(
    (value) => {
      const contain = css.contain;
      return contain != null ? contain.includes(value) : false;
    }
  );
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  const win = isElement$1(element) ? getWindow$1(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x2 = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y2 = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(
    element,
    isOffsetParentAnElement && isScaled(offsetParent),
    strategy === "fixed"
  );
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      const parent = currentNode.parentNode;
      currentNode = isShadowRoot(parent) ? parent.host : parent;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow$1(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement$1(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow$1(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));
}
function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {
  let currentNode = element;
  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {
    if (isElement$1(currentNode) && ["absolute", "fixed"].includes(getComputedStyle$1(currentNode).position)) {
      break;
    }
    const parentNode = getParentNode(currentNode);
    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;
  }
  return currentNode;
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement$1(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);
  let clipperElement = null;
  if (nearestEscapableParent && isHTMLElement$1(nearestEscapableParent)) {
    const offsetParent = getOffsetParent(nearestEscapableParent);
    if (isOverflowElement(nearestEscapableParent)) {
      clipperElement = nearestEscapableParent;
    } else if (isHTMLElement$1(offsetParent)) {
      clipperElement = offsetParent;
    }
  }
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => clipperElement && isElement$1(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement: isElement$1,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement$1(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }
      initialUpdate = false;
    });
    isElement$1(reference) && !animationFrame && observer.observe(reference);
    if (!isElement$1(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
  platform,
  ...options
});
var index$1 = typeof document !== "undefined" ? react.exports.useLayoutEffect : react.exports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length, i2, keys;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function useLatestRef$1(value) {
  const ref = react.exports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(_temp) {
  let {
    middleware,
    placement = "bottom",
    strategy = "absolute",
    whileElementsMounted
  } = _temp === void 0 ? {} : _temp;
  const [data2, setData] = react.exports.useState({
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = react.exports.useState(middleware);
  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {
    let {
      name,
      options
    } = _ref;
    return {
      name,
      options
    };
  }), middleware == null ? void 0 : middleware.map((_ref2) => {
    let {
      name,
      options
    } = _ref2;
    return {
      name,
      options
    };
  }))) {
    setLatestMiddleware(middleware);
  }
  const reference = react.exports.useRef(null);
  const floating = react.exports.useRef(null);
  const cleanupRef = react.exports.useRef(null);
  const dataRef = react.exports.useRef(data2);
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const update = react.exports.useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }
    computePosition(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then((data3) => {
      if (isMountedRef.current && !deepEqual(dataRef.current, data3)) {
        dataRef.current = data3;
        reactDom.exports.flushSync(() => {
          setData(data3);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index$1(() => {
    if (isMountedRef.current) {
      update();
    }
  }, [update]);
  const isMountedRef = react.exports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const runElementMountCallback = react.exports.useCallback(() => {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (reference.current && floating.current) {
      if (whileElementsMountedRef.current) {
        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
        cleanupRef.current = cleanupFn;
      } else {
        update();
      }
    }
  }, [update, whileElementsMountedRef]);
  const setReference = react.exports.useCallback((node) => {
    reference.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const setFloating = react.exports.useCallback((node) => {
    floating.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const refs = react.exports.useMemo(() => ({
    reference,
    floating
  }), []);
  return react.exports.useMemo(() => ({
    ...data2,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data2, update, refs, setReference, setFloating]);
}
var index = typeof document !== "undefined" ? react.exports.useLayoutEffect : react.exports.useEffect;
function createPubSub() {
  const map2 = /* @__PURE__ */ new Map();
  return {
    emit(event, data2) {
      var _map$get;
      (_map$get = map2.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data2));
    },
    on(event, listener) {
      map2.set(event, [...map2.get(event) || [], listener]);
    },
    off(event, listener) {
      map2.set(event, (map2.get(event) || []).filter((l2) => l2 !== listener));
    }
  };
}
let serverHandoffComplete = false;
let count = 0;
const genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [id2, setId] = react.exports.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id2 == null) {
      setId(genId());
    }
  }, []);
  react.exports.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id2;
}
const useReactId = React$1[/* @__PURE__ */ "useId".toString()];
const useId = useReactId != null ? useReactId : useFloatingId;
const FloatingNodeContext = /* @__PURE__ */ react.exports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ react.exports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext$id, _React$useContext;
  return (_React$useContext$id = (_React$useContext = react.exports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) != null ? _React$useContext$id : null;
};
const useFloatingTree = () => react.exports.useContext(FloatingTreeContext);
function getDocument(floating) {
  var _floating$ownerDocume;
  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;
}
function getWindow(value) {
  var _getDocument$defaultV;
  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;
}
function isElement(value) {
  return value ? value instanceof getWindow(value).Element : false;
}
function isHTMLElement(value) {
  return value ? value instanceof getWindow(value).HTMLElement : false;
}
const useInsertionEffect = React$1[/* @__PURE__ */ "useInsertionEffect".toString()];
function useEvent(callback) {
  const ref = react.exports.useRef(() => {
  });
  if (useInsertionEffect) {
    useInsertionEffect(() => {
      ref.current = callback;
    });
  } else {
    ref.current = callback;
  }
  return react.exports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function useFloating(_temp) {
  let {
    open = false,
    onOpenChange: unstable_onOpenChange,
    whileElementsMounted,
    placement,
    middleware,
    strategy,
    nodeId
  } = _temp === void 0 ? {} : _temp;
  const [domReference, setDomReference] = react.exports.useState(null);
  const tree = useFloatingTree();
  const domReferenceRef = react.exports.useRef(null);
  const dataRef = react.exports.useRef({});
  const events = react.exports.useState(() => createPubSub())[0];
  const position = useFloating$1({
    placement,
    middleware,
    strategy,
    whileElementsMounted
  });
  const onOpenChange = useEvent(unstable_onOpenChange);
  const refs = react.exports.useMemo(() => ({
    ...position.refs,
    domReference: domReferenceRef
  }), [position.refs]);
  const context = react.exports.useMemo(() => ({
    ...position,
    refs,
    dataRef,
    nodeId,
    events,
    open,
    onOpenChange,
    _: {
      domReference
    }
  }), [position, nodeId, events, open, onOpenChange, refs, domReference]);
  index(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  const {
    reference
  } = position;
  const setReference = react.exports.useCallback((node) => {
    if (isElement(node) || node === null) {
      context.refs.domReference.current = node;
      setDomReference(node);
    }
    reference(node);
  }, [reference, context.refs]);
  return react.exports.useMemo(() => ({
    ...position,
    context,
    refs,
    reference: setReference
  }), [position, refs, context, setReference]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map2 = /* @__PURE__ */ new Map();
  return {
    ...elementKey === "floating" && {
      tabIndex: -1
    },
    ...userProps,
    ...propsList.map((value) => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (key.indexOf("on") === 0) {
          if (!map2.has(key)) {
            map2.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map2.get(key)) == null ? void 0 : _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_map$get2 = map2.get(key)) == null ? void 0 : _map$get2.forEach((fn) => fn(...args));
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
const useInteractions = function(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  return {
    getReferenceProps: (userProps) => mergeProps(userProps, propsList, "reference"),
    getFloatingProps: (userProps) => mergeProps(userProps, propsList, "floating"),
    getItemProps: (userProps) => mergeProps(userProps, propsList, "item")
  };
};
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function useLatestRef(value) {
  const ref = react.exports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function usePrevious(value) {
  const ref = react.exports.useRef();
  index(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function getDelay(value, prop, pointerType) {
  if (pointerType && pointerType !== "mouse") {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
const useHover = function(context, _temp) {
  let {
    enabled = true,
    delay: delay2 = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = _temp === void 0 ? {} : _temp;
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    refs,
    _: _2
  } = context;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay2);
  const previousOpen = usePrevious(open);
  const pointerTypeRef = react.exports.useRef();
  const timeoutRef = react.exports.useRef();
  const handlerRef = react.exports.useRef();
  const restTimeoutRef = react.exports.useRef();
  const blockMouseMoveRef = react.exports.useRef(true);
  const performedPointerEventsMutationRef = react.exports.useRef(false);
  const isHoverOpen = react.exports.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  react.exports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss() {
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      blockMouseMoveRef.current = true;
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
    };
  }, [enabled, events, refs]);
  react.exports.useEffect(() => {
    if (!enabled || !handleCloseRef.current) {
      return;
    }
    function onLeave() {
      if (isHoverOpen()) {
        onOpenChange(false);
      }
    }
    const html = getDocument(refs.floating.current).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [refs, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);
  const closeWithDelay = react.exports.useCallback(function(runElseBranch) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false);
    }
  }, [delayRef, onOpenChange]);
  const cleanupPointerMoveHandler = react.exports.useCallback(() => {
    if (handlerRef.current) {
      getDocument(refs.floating.current).removeEventListener("pointermove", handlerRef.current);
      handlerRef.current = void 0;
    }
  }, [refs]);
  const clearPointerEvents = react.exports.useCallback(() => {
    getDocument(refs.floating.current).body.style.pointerEvents = "";
    performedPointerEventsMutationRef.current = false;
  }, [refs]);
  react.exports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
    }
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && pointerTypeRef.current !== "mouse" || restMs > 0 && getDelay(delayRef.current, "open") === 0) {
        return;
      }
      dataRef.current.openEvent = event;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true);
        }, openDelay);
      } else {
        onOpenChange(true);
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      const doc = getDocument(refs.floating.current);
      clearTimeout(restTimeoutRef.current);
      if (handleCloseRef.current) {
        clearTimeout(timeoutRef.current);
        handlerRef.current && doc.removeEventListener("pointermove", handlerRef.current);
        handlerRef.current = handleCloseRef.current({
          ...context,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupPointerMoveHandler();
            closeWithDelay();
          }
        });
        doc.addEventListener("pointermove", handlerRef.current);
        return;
      }
      closeWithDelay();
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      handleCloseRef.current == null ? void 0 : handleCloseRef.current({
        ...context,
        tree,
        x: event.clientX,
        y: event.clientY,
        leave: true,
        onClose() {
          clearPointerEvents();
          cleanupPointerMoveHandler();
          closeWithDelay();
        }
      })(event);
    }
    const floating = refs.floating.current;
    const reference = refs.domReference.current;
    if (isElement(reference)) {
      open && reference.addEventListener("mouseleave", onScrollMouseLeave);
      floating == null ? void 0 : floating.addEventListener("mouseleave", onScrollMouseLeave);
      move && reference.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      reference.addEventListener("mouseenter", onMouseEnter);
      reference.addEventListener("mouseleave", onMouseLeave);
      return () => {
        open && reference.removeEventListener("mouseleave", onScrollMouseLeave);
        floating == null ? void 0 : floating.removeEventListener("mouseleave", onScrollMouseLeave);
        move && reference.removeEventListener("mousemove", onMouseEnter);
        reference.removeEventListener("mouseenter", onMouseEnter);
        reference.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [
    _2.domReference,
    enabled,
    context,
    mouseOnly,
    restMs,
    move,
    closeWithDelay,
    cleanupPointerMoveHandler,
    clearPointerEvents,
    onOpenChange,
    open,
    tree,
    refs,
    delayRef,
    handleCloseRef,
    dataRef
  ]);
  index(() => {
    if (!enabled) {
      return;
    }
    if (open && handleCloseRef.current && handleCloseRef.current.__options.blockPointerEvents && isHoverOpen()) {
      getDocument(refs.floating.current).body.style.pointerEvents = "none";
      performedPointerEventsMutationRef.current = true;
      const reference = refs.domReference.current;
      const floating = refs.floating.current;
      if (isElement(reference) && floating) {
        var _tree$nodesRef$curren, _tree$nodesRef$curren2;
        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        reference.style.pointerEvents = "auto";
        floating.style.pointerEvents = "auto";
        return () => {
          reference.style.pointerEvents = "";
          floating.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, refs, tree, handleCloseRef, dataRef, isHoverOpen]);
  index(() => {
    if (previousOpen && !open) {
      pointerTypeRef.current = void 0;
      cleanupPointerMoveHandler();
      clearPointerEvents();
    }
  });
  react.exports.useEffect(() => {
    return () => {
      cleanupPointerMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      if (performedPointerEventsMutationRef.current) {
        clearPointerEvents();
      }
    };
  }, [enabled, cleanupPointerMoveHandler, clearPointerEvents]);
  if (!enabled) {
    return {};
  }
  function setPointerRef(event) {
    pointerTypeRef.current = event.pointerType;
  }
  return {
    reference: {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove() {
        if (open || restMs === 0) {
          return;
        }
        clearTimeout(restTimeoutRef.current);
        restTimeoutRef.current = setTimeout(() => {
          if (!blockMouseMoveRef.current) {
            onOpenChange(true);
          }
        }, restMs);
      }
    },
    floating: {
      onMouseEnter() {
        clearTimeout(timeoutRef.current);
      },
      onMouseLeave() {
        closeWithDelay(false);
      }
    }
  };
};
const useRole = function(_ref, _temp) {
  let {
    open
  } = _ref;
  let {
    enabled = true,
    role = "dialog"
  } = _temp === void 0 ? {} : _temp;
  const rootId = useId();
  const referenceId = useId();
  const floatingProps = {
    id: rootId,
    role
  };
  if (!enabled) {
    return {};
  }
  if (role === "tooltip") {
    return {
      reference: {
        "aria-describedby": open ? rootId : void 0
      },
      floating: floatingProps
    };
  }
  return {
    reference: {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": role === "alertdialog" ? "dialog" : role,
      "aria-controls": open ? rootId : void 0,
      ...role === "listbox" && {
        role: "combobox"
      },
      ...role === "menu" && {
        id: referenceId
      }
    },
    floating: {
      ...floatingProps,
      ...role === "menu" && {
        "aria-labelledby": referenceId
      }
    }
  };
};
function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "BUTTON";
}
const useClick = function(_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    refs
  } = _ref;
  let {
    enabled = true,
    pointerDown = false,
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = react.exports.useRef();
  function isSpaceIgnored() {
    return isTypeableElement(refs.domReference.current);
  }
  if (!enabled) {
    return {};
  }
  return {
    reference: {
      onPointerDown(event) {
        pointerTypeRef.current = event.pointerType;
      },
      onMouseDown(event) {
        if (event.button !== 0) {
          return;
        }
        if (pointerTypeRef.current === "mouse" && ignoreMouse) {
          return;
        }
        if (!pointerDown) {
          return;
        }
        if (open) {
          if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "mousedown" : true)) {
            onOpenChange(false);
          }
        } else {
          onOpenChange(true);
        }
        dataRef.current.openEvent = event.nativeEvent;
      },
      onClick(event) {
        if (pointerDown && pointerTypeRef.current) {
          pointerTypeRef.current = void 0;
          return;
        }
        if (pointerTypeRef.current === "mouse" && ignoreMouse) {
          return;
        }
        if (open) {
          if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "click" : true)) {
            onOpenChange(false);
          }
        } else {
          onOpenChange(true);
        }
        dataRef.current.openEvent = event.nativeEvent;
      },
      onKeyDown(event) {
        pointerTypeRef.current = void 0;
        if (!keyboardHandlers) {
          return;
        }
        if (isButtonTarget(event)) {
          return;
        }
        if (event.key === " " && !isSpaceIgnored()) {
          event.preventDefault();
        }
        if (event.key === "Enter") {
          if (open) {
            if (toggle) {
              onOpenChange(false);
            }
          } else {
            onOpenChange(true);
          }
        }
      },
      onKeyUp(event) {
        if (!keyboardHandlers) {
          return;
        }
        if (isButtonTarget(event) || isSpaceIgnored()) {
          return;
        }
        if (event.key === " ") {
          if (open) {
            if (toggle) {
              onOpenChange(false);
            }
          } else {
            onOpenChange(true);
          }
        }
      }
    }
  };
};
const useFocus = function(_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    refs,
    events
  } = _ref;
  let {
    enabled = true,
    keyboardOnly = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = react.exports.useRef("");
  const blockFocusRef = react.exports.useRef(false);
  const timeoutRef = react.exports.useRef();
  react.exports.useEffect(() => {
    var _doc$defaultView;
    if (!enabled) {
      return;
    }
    const doc = getDocument(refs.floating.current);
    const win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window;
    function onBlur() {
      if (!open && isHTMLElement(refs.domReference.current)) {
        refs.domReference.current.blur();
      }
    }
    win.addEventListener("blur", onBlur);
    return () => {
      win.removeEventListener("blur", onBlur);
    };
  }, [refs, open, enabled]);
  react.exports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss() {
      blockFocusRef.current = true;
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
    };
  }, [events, enabled]);
  react.exports.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  if (!enabled) {
    return {};
  }
  return {
    reference: {
      onPointerDown(_ref2) {
        let {
          pointerType
        } = _ref2;
        pointerTypeRef.current = pointerType;
        blockFocusRef.current = !!(pointerType && keyboardOnly);
      },
      onPointerLeave() {
        blockFocusRef.current = false;
      },
      onFocus(event) {
        var _dataRef$current$open, _refs$domReference$cu, _dataRef$current$open2;
        if (blockFocusRef.current) {
          return;
        }
        if (event.type === "focus" && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === "mousedown" && (_refs$domReference$cu = refs.domReference.current) != null && _refs$domReference$cu.contains((_dataRef$current$open2 = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open2.target)) {
          return;
        }
        dataRef.current.openEvent = event.nativeEvent;
        onOpenChange(true);
      },
      onBlur(event) {
        const target = event.relatedTarget;
        timeoutRef.current = setTimeout(() => {
          var _refs$floating$curren, _refs$domReference$cu2;
          if ((_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(target) || (_refs$domReference$cu2 = refs.domReference.current) != null && _refs$domReference$cu2.contains(target)) {
            return;
          }
          blockFocusRef.current = false;
          onOpenChange(false);
        });
      }
    }
  };
};
const getMiddleware = ({ arrowRef, placement }) => {
  const middleware = [];
  middleware.push(offset$1(8));
  middleware.push(placement === "auto" ? autoPlacement() : flip());
  middleware.push(shift({ padding: 8 }));
  if (arrowRef.current) {
    middleware.push(arrow({ element: arrowRef.current }));
  }
  return middleware;
};
const getPlacement = ({ placement }) => {
  return placement === "auto" ? void 0 : placement;
};
const getArrowPlacement = ({ placement }) => {
  return {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }[placement.split("-")[0]];
};
const Floating = ({ children, content, theme: theme2, animation = "duration-300", arrow: arrow2 = true, placement = "top", style = "dark", trigger = "hover", closeRequestKey, ...props }) => {
  const theirProps = excludeClassName(props);
  const arrowRef = react.exports.useRef(null);
  const [open, setOpen] = react.exports.useState(false);
  const floatingTooltip = useFloating({
    middleware: getMiddleware({ arrowRef, placement }),
    onOpenChange: setOpen,
    open,
    placement: getPlacement({ placement })
  });
  const { context, floating, middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }, reference, refs, strategy, update, x: x2, y: y2 } = floatingTooltip;
  const { getFloatingProps, getReferenceProps } = useInteractions([
    useClick(context, { enabled: trigger === "click" }),
    useFocus(context),
    useHover(context, { enabled: trigger === "hover" }),
    useRole(context, { role: "tooltip" })
  ]);
  react.exports.useEffect(() => {
    if (refs.reference.current && refs.floating.current && open) {
      return autoUpdate(refs.reference.current, refs.floating.current, update);
    }
  }, [open, refs.floating, refs.reference, update]);
  react.exports.useEffect(() => {
    if (closeRequestKey !== void 0)
      setOpen(false);
  }, [closeRequestKey]);
  return jsxs(Fragment, { children: [jsx("div", { className: theme2.target, ...getReferenceProps({ ref: reference }), "data-testid": "flowbite-tooltip-target", children }), jsxs("div", { "data-testid": "flowbite-tooltip", ...getFloatingProps({
    className: classNames(theme2.base, animation && `${theme2.animation} ${animation}`, !open && theme2.hidden, theme2.style[style]),
    ref: floating,
    style: {
      position: strategy,
      top: y2 != null ? y2 : " ",
      left: x2 != null ? x2 : " "
    },
    ...theirProps
  }), children: [jsx("div", { className: theme2.content, children: content }), arrow2 && jsx("div", { className: classNames(theme2.arrow.base, {
    [theme2.arrow.style.dark]: style === "dark",
    [theme2.arrow.style.light]: style === "light",
    [theme2.arrow.style.auto]: style === "auto"
  }), "data-testid": "flowbite-tooltip-arrow", ref: arrowRef, style: {
    top: arrowY != null ? arrowY : " ",
    left: arrowX != null ? arrowX : " ",
    right: " ",
    bottom: " ",
    [getArrowPlacement({ placement: floatingTooltip.placement })]: theme2.arrow.placement
  }, children: "\xA0" })] })] });
};
const DropdownDivider = () => {
  const theme2 = useTheme().theme.dropdown.floating.divider;
  return jsx("div", { className: theme2 });
};
const DropdownHeader = ({ children, ...props }) => {
  const theme2 = useTheme().theme.dropdown.floating.header;
  const theirProps = excludeClassName(props);
  return jsxs(Fragment, { children: [jsx("div", { className: theme2, ...theirProps, children }), jsx(DropdownDivider, {})] });
};
const DropdownItem = ({ children, onClick, icon: Icon }) => {
  const theme2 = useTheme().theme.dropdown.floating.item;
  return jsxs("li", { className: theme2.base, onClick, children: [Icon && jsx(Icon, { className: theme2.icon }), children] });
};
const icons = {
  top: HiOutlineChevronUp,
  right: HiOutlineChevronRight,
  bottom: HiOutlineChevronDown,
  left: HiOutlineChevronLeft
};
const DropdownComponent = ({ children, ...props }) => {
  const theme2 = useTheme().theme.dropdown;
  const theirProps = excludeClassName(props);
  const { placement = props.inline ? "bottom-start" : "bottom", trigger = "click", label, inline, floatingArrow = false, arrowIcon = true, ...buttonProps } = theirProps;
  const Icon = react.exports.useMemo(() => {
    var _a2;
    const [p2] = placement.split("-");
    return (_a2 = icons[p2]) != null ? _a2 : HiOutlineChevronDown;
  }, [placement]);
  const [closeRequestKey, setCloseRequestKey] = react.exports.useState(void 0);
  const attachCloseListener = (node) => {
    if (!React.isValidElement(node))
      return node;
    if (node.type === DropdownItem)
      return React.cloneElement(node, {
        onClick: () => {
          var _a2, _b;
          (_b = (_a2 = node.props).onClick) == null ? void 0 : _b.call(_a2);
          setCloseRequestKey(uuid());
        }
      });
    if (node.props.children && typeof node.props.children === "object") {
      return React.cloneElement(node, { children: react.exports.Children.map(node.props.children, attachCloseListener) });
    }
    return node;
  };
  const content = react.exports.useMemo(() => jsx("ul", { className: theme2.content, children: react.exports.Children.map(children, attachCloseListener) }), [children, theme2]);
  const TriggerWrapper = ({ children: children2 }) => inline ? jsx("button", { className: theme2.inlineWrapper, children: children2 }) : jsx(Button, { ...buttonProps, children: children2 });
  return jsx(Floating, { content, style: "auto", animation: "duration-100", placement, arrow: floatingArrow, trigger, theme: theme2.floating, closeRequestKey, children: jsxs(TriggerWrapper, { children: [label, arrowIcon && jsx(Icon, { className: theme2.arrowIcon })] }) });
};
DropdownComponent.displayName = "Dropdown";
DropdownItem.displayName = "Dropdown.Item";
DropdownHeader.displayName = "Dropdown.Header";
DropdownDivider.displayName = "Dropdown.Divider";
Object.assign(DropdownComponent, {
  Item: DropdownItem,
  Header: DropdownHeader,
  Divider: DropdownDivider
});
const FooterBrand = ({ alt, children, href, name, src }) => {
  const theme2 = useTheme().theme.footer.brand;
  return jsx("div", { children: href ? jsxs("a", { "data-testid": "flowbite-footer-brand", href, className: theme2.base, children: [jsx("img", { alt, src, className: theme2.img }), jsx("span", { "data-testid": "flowbite-footer-brand-span", className: theme2.span, children: name }), children] }) : jsx("img", { alt, "data-testid": "flowbite-footer-brand", src, className: theme2.img }) });
};
const FooterCopyright = ({ href, by, year }) => {
  const theme2 = useTheme().theme.footer.copyright;
  return jsx("div", { children: jsxs("span", { className: theme2.base, "data-testid": "flowbite-footer-copyright", children: ["\xA9 ", year, href ? jsx("a", { href, className: theme2.href, children: by }) : jsx("span", { "data-testid": "flowbite-footer-copyright-span", className: theme2.span, children: by })] }) });
};
const FooterDivider = () => {
  const theme2 = useTheme().theme.footer.divider;
  return jsx("hr", { "data-testid": "footer-divider", className: theme2.base });
};
const FooterIcon = ({ href, ariaLabel, icon: Icon }) => {
  const theme2 = useTheme().theme.footer.icon;
  return jsx("div", { children: href ? jsx("a", { "aria-label": ariaLabel, "data-testid": "flowbite-footer-icon", href, className: theme2.base, children: jsx(Icon, { className: theme2.size }) }) : jsx(Icon, { "data-testid": "flowbite-footer-icon", className: theme2.size }) });
};
const FooterLink = ({ children, href }) => {
  const theme2 = useTheme().theme.footer.groupLink.link;
  return jsx("li", { className: theme2.base, children: jsx("a", { href, className: theme2.href, children }) });
};
const FooterLinkGroup = ({ children, col = false }) => {
  const theme2 = useTheme().theme.footer.groupLink;
  return jsx("ul", { "data-testid": "footer-groupLink", className: classNames(theme2.base, col && theme2.col), children });
};
const FooterTitle = ({ title }) => {
  const theme2 = useTheme().theme.footer.title;
  return jsx("h2", { "data-testid": "flowbite-footer-title", className: theme2.base, children: title });
};
const FooterComponent = ({ children, bgDark = false, container = false }) => {
  const theme2 = useTheme().theme.footer;
  return jsx("footer", { "data-testid": "flowbite-footer", className: classNames(theme2.base, bgDark && theme2.bgDark, container && theme2.container), children });
};
FooterComponent.displayName = "Footer";
FooterCopyright.displayName = "Footer.Copyright";
FooterLink.displayName = "Footer.Link";
FooterBrand.displayName = "Footer.Brand";
FooterLinkGroup.displayName = "Footer.LinkGroup";
FooterIcon.displayName = "Footer.Icon";
FooterTitle.displayName = "Footer.Title";
FooterDivider.displayName = "Footer.Divider";
Object.assign(FooterComponent, {
  Copyright: FooterCopyright,
  Link: FooterLink,
  LinkGroup: FooterLinkGroup,
  Brand: FooterBrand,
  Icon: FooterIcon,
  Title: FooterTitle,
  Divider: FooterDivider
});
const Checkbox = react.exports.forwardRef((props, ref) => {
  const theme2 = useTheme().theme.formControls.checkbox;
  const theirProps = excludeClassName(props);
  return jsx("input", { ref, className: theme2.base, type: "checkbox", ...theirProps });
});
Checkbox.displayName = "Checkbox";
const HelperText = ({ value, children, color: color2 = "default", ...props }) => {
  var _a2;
  const theme2 = useTheme().theme.formControls.helperText;
  const theirProps = excludeClassName(props);
  return jsx("p", { className: classNames(theme2.base, theme2.colors[color2]), ...theirProps, children: (_a2 = value != null ? value : children) != null ? _a2 : "" });
};
const FileInput = react.exports.forwardRef(({ sizing = "md", helperText, color: color2 = "gray", ...props }, ref) => {
  const theme2 = useTheme().theme.formControls.fileInput;
  const theirProps = excludeClassName(props);
  return jsxs(Fragment, { children: [jsx("div", { className: theme2.base, children: jsx("div", { className: theme2.field.base, children: jsx("input", { className: classNames(theme2.field.input.base, theme2.field.input.colors[color2], theme2.field.input.sizes[sizing]), ...theirProps, type: "file", ref }) }) }), helperText && jsx(HelperText, { color: color2, children: helperText })] });
});
FileInput.displayName = "FileInput";
const Radio = react.exports.forwardRef((props, ref) => {
  const theme2 = useTheme().theme.formControls.radio;
  const theirProps = excludeClassName(props);
  return jsx("input", { ref, className: theme2.base, type: "radio", ...theirProps });
});
Radio.displayName = "Radio";
const Select = react.exports.forwardRef(({ children, sizing = "md", shadow, helperText, addon, icon: Icon, color: color2 = "gray", ...props }, ref) => {
  const theme2 = useTheme().theme.formControls.select;
  const theirProps = excludeClassName(props);
  return jsxs("div", { className: theme2.base, children: [addon && jsx("span", { className: theme2.addon, children: addon }), jsxs("div", { className: theme2.field.base, children: [Icon && jsx("div", { className: theme2.field.icon.base, children: jsx(Icon, { className: theme2.field.icon.svg }) }), jsx("select", { className: classNames(theme2.field.select.base, theme2.field.select.colors[color2], theme2.field.select.withIcon[Icon ? "on" : "off"], theme2.field.select.withAddon[addon ? "on" : "off"], theme2.field.select.withShadow[shadow ? "on" : "off"], theme2.field.select.sizes[sizing]), ...theirProps, ref, children }), helperText && jsx(HelperText, { color: color2, children: helperText })] })] });
});
Select.displayName = "Select";
const Textarea = react.exports.forwardRef(({ shadow, helperText, color: color2 = "gray", ...props }, ref) => {
  const theme2 = useTheme().theme.formControls.textarea;
  const theirProps = excludeClassName(props);
  return jsxs(Fragment, { children: [jsx("textarea", { ref, className: classNames(theme2.base, theme2.colors[color2], theme2.withShadow[shadow ? "on" : "off"]), ...theirProps }), helperText && jsx(HelperText, { color: color2, children: helperText })] });
});
Textarea.displayName = "Textarea";
const TextInput = react.exports.forwardRef(({ sizing = "md", shadow, helperText, addon, icon: Icon, color: color2 = "gray", ...props }, ref) => {
  const theme2 = useTheme().theme.formControls.textInput;
  const theirProps = excludeClassName(props);
  return jsxs(Fragment, { children: [jsxs("div", { className: theme2.base, children: [addon && jsx("span", { className: theme2.addon, children: addon }), jsxs("div", { className: theme2.field.base, children: [Icon && jsx("div", { className: theme2.field.icon.base, children: jsx(Icon, { className: theme2.field.icon.svg }) }), jsx("input", { className: classNames(theme2.field.input.base, theme2.field.input.colors[color2], theme2.field.input.withIcon[Icon ? "on" : "off"], theme2.field.input.withAddon[addon ? "on" : "off"], theme2.field.input.withShadow[shadow ? "on" : "off"], theme2.field.input.sizes[sizing]), ...theirProps, ref })] })] }), helperText && jsx(HelperText, { color: color2, children: helperText })] });
});
TextInput.displayName = "TextInput";
const ListGroupItem = ({ active: isActive, children, href, icon: Icon, onClick, ...props }) => {
  const isLink = typeof href !== "undefined";
  const Component = isLink ? "a" : "button";
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.listGroup.item;
  return jsx("li", { children: jsxs(Component, { className: classNames(theme2.active[isActive ? "on" : "off"], theme2.base, theme2.href[isLink ? "on" : "off"]), href, onClick, type: isLink ? void 0 : "button", ...theirProps, children: [Icon && jsx(Icon, { "aria-hidden": true, className: theme2.icon, "data-testid": "flowbite-list-group-item-icon" }), children] }) });
};
const ListGroupComponent = ({ children, ...props }) => {
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.listGroup.base;
  return jsx("ul", { className: theme2, ...theirProps, children });
};
ListGroupComponent.displayName = "ListGroup";
ListGroupItem.displayName = "ListGroup.Item";
Object.assign(ListGroupComponent, { Item: ListGroupItem });
const ModalContext = react.exports.createContext(void 0);
function useModalContext() {
  const context = react.exports.useContext(ModalContext);
  if (!context) {
    throw new Error("useModalContext should be used within the ModalContext provider!");
  }
  return context;
}
const ModalBody = ({ children, ...props }) => {
  const { popup } = useModalContext();
  const theme2 = useTheme().theme.modal.body;
  const theirProps = excludeClassName(props);
  return jsx("div", { className: classNames(theme2.base, {
    [theme2.popup]: popup
  }), ...theirProps, children });
};
const ModalFooter = ({ children, ...props }) => {
  const { popup } = useModalContext();
  const theme2 = useTheme().theme.modal.footer;
  const theirProps = excludeClassName(props);
  return jsx("div", { className: classNames(theme2.base, {
    [theme2.popup]: !popup
  }), ...theirProps, children });
};
const ModalHeader = ({ children, ...props }) => {
  const { popup, onClose } = useModalContext();
  const theme2 = useTheme().theme.modal.header;
  const theirProps = excludeClassName(props);
  return jsxs("div", { className: classNames(theme2.base, {
    [theme2.popup]: popup
  }), ...theirProps, children: [jsx("h3", { className: theme2.title, children }), jsx("button", { "aria-label": "Close", className: theme2.close.base, type: "button", onClick: onClose, children: jsx(HiOutlineX, { "aria-hidden": true, className: theme2.close.icon }) })] });
};
const ModalComponent = ({ children, show, root: root2, popup, size = "2xl", position = "center", onClose, ...props }) => {
  const [parent, setParent] = react.exports.useState(root2);
  const [container, setContainer] = react.exports.useState();
  const theme2 = useTheme().theme.modal;
  const theirProps = excludeClassName(props);
  react.exports.useEffect(() => {
    if (!parent)
      setParent(document.body);
    if (!container)
      setContainer(document.createElement("div"));
  }, []);
  react.exports.useEffect(() => {
    if (!container || !parent || !show) {
      return;
    }
    parent.appendChild(container);
    return () => {
      if (container) {
        parent.removeChild(container);
      }
    };
  }, [container, parent, show]);
  return container ? reactDom.exports.createPortal(jsx(ModalContext.Provider, { value: { popup, onClose }, children: jsx("div", { "aria-hidden": !show, className: classNames(theme2.base, theme2.positions[position], show ? theme2.show.on : theme2.show.off), "data-testid": "modal", role: "dialog", ...theirProps, children: jsx("div", { className: classNames(theme2.content.base, theme2.sizes[size]), children: jsx("div", { className: theme2.content.inner, children }) }) }) }), container) : null;
};
ModalComponent.displayName = "Modal";
ModalHeader.displayName = "Modal.Header";
ModalBody.displayName = "Modal.Body";
ModalFooter.displayName = "Modal.Footer";
Object.assign(ModalComponent, { Header: ModalHeader, Body: ModalBody, Footer: ModalFooter });
const NavbarBrand = ({ children, href, ...props }) => {
  const theme2 = useTheme().theme.navbar;
  const theirProps = excludeClassName(props);
  return jsx("a", { href, className: theme2.brand, ...theirProps, children });
};
const NavbarContext = react.exports.createContext(void 0);
function useNavbarContext() {
  const context = react.exports.useContext(NavbarContext);
  if (!context) {
    throw new Error("useNavBarContext should be used within the NavbarContext provider!");
  }
  return context;
}
const NavbarCollapse = ({ children, ...props }) => {
  const { isOpen } = useNavbarContext();
  const theme2 = useTheme().theme.navbar.collapse;
  const theirProps = excludeClassName(props);
  return jsx("div", { className: classNames(theme2.base, theme2.hidden[!isOpen ? "on" : "off"]), "data-testid": "flowbite-navbar-collapse", ...theirProps, children: jsx("ul", { className: theme2.list, children }) });
};
const NavbarLink = ({ active, disabled, href, children, ...props }) => {
  const theme2 = useTheme().theme.navbar.link;
  const theirProps = excludeClassName(props);
  return jsx("li", { children: jsx("a", { href, className: classNames(theme2.base, {
    [theme2.active.on]: active,
    [theme2.active.off]: !active && !disabled
  }, theme2.disabled[disabled ? "on" : "off"]), ...theirProps, children }) });
};
function GoThreeBars(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 12 16" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M11.41 9H.59C0 9 0 8.59 0 8c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zm0-4H.59C0 5 0 4.59 0 4c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zM.59 11H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1H.59C0 13 0 12.59 0 12c0-.59 0-1 .59-1z" } }] })(props);
}
const NavbarToggle = ({ barIcon: BarIcon = GoThreeBars, ...props }) => {
  const { isOpen, setIsOpen } = useNavbarContext();
  const handleClick = () => {
    setIsOpen(!isOpen);
  };
  const theme2 = useTheme().theme.navbar.toggle;
  const theirProps = excludeClassName(props);
  return jsxs("button", { className: theme2.base, "data-testid": "flowbite-navbar-toggle", onClick: handleClick, ...theirProps, children: [jsx("span", { className: "sr-only", children: "Open main menu" }), jsx(BarIcon, { className: theme2.icon })] });
};
const NavbarComponent = ({ children, menuOpen, fluid = false, rounded, border, ...props }) => {
  const [isOpen, setIsOpen] = react.exports.useState(menuOpen);
  const theme2 = useTheme().theme.navbar;
  const theirProps = excludeClassName(props);
  return jsx(NavbarContext.Provider, { value: { isOpen, setIsOpen }, children: jsx("nav", { className: classNames(theme2.base, theme2.bordered[border ? "on" : "off"], theme2.rounded[rounded ? "on" : "off"]), ...theirProps, children: jsx("div", { className: classNames(theme2.inner.base, theme2.inner.fluid[fluid ? "on" : "off"]), children }) }) });
};
NavbarComponent.displayName = "Navbar";
NavbarBrand.displayName = "Navbar.Brand";
NavbarCollapse.displayName = "Navbar.Collapse";
NavbarLink.displayName = "Navbar.Link";
NavbarToggle.displayName = "Navbar.Toggle";
Object.assign(NavbarComponent, {
  Brand: NavbarBrand,
  Collapse: NavbarCollapse,
  Link: NavbarLink,
  Toggle: NavbarToggle
});
const RatingAdvanced = ({ percentFilled = 0, children, ...props }) => {
  const theme2 = useTheme().theme.rating.advanced;
  const theirProps = excludeClassName(props);
  return jsxs("div", { className: theme2.base, ...theirProps, children: [jsx("span", { className: theme2.label, children }), jsx("div", { className: theme2.progress.base, children: jsx("div", { className: theme2.progress.fill, "data-testid": "flowbite-rating-fill", style: { width: `${percentFilled}%` } }) }), jsx("span", { className: theme2.progress.label, children: `${percentFilled}%` })] });
};
const RatingContext = react.exports.createContext(void 0);
function useRatingContext() {
  const context = react.exports.useContext(RatingContext);
  if (!context) {
    throw new Error("useRatingContext should be used within the RatingContext provider!");
  }
  return context;
}
const RatingStar = ({ filled = true, starIcon: Icon = HiStar }) => {
  const { size = "sm" } = useRatingContext();
  const theme2 = useTheme().theme.rating.star;
  return jsx(Icon, { className: classNames(theme2.sizes[size], theme2[filled ? "filled" : "empty"]), "data-testid": "flowbite-rating-star" });
};
const RatingComponent = ({ children, size = "sm", ...props }) => {
  const theme2 = useTheme().theme.rating;
  const theirProps = excludeClassName(props);
  return jsx(RatingContext.Provider, { value: { size }, children: jsx("div", { className: theme2.base, ...theirProps, children }) });
};
RatingComponent.displayName = "Rating";
RatingStar.displayName = "Rating.Star";
RatingAdvanced.displayName = "Rating.Advanced";
Object.assign(RatingComponent, {
  Star: RatingStar,
  Advanced: RatingAdvanced
});
const Tooltip = ({ animation = "duration-300", arrow: arrow2 = true, children, content, placement = "top", style = "dark", trigger = "hover", ...props }) => {
  const theme2 = useTheme().theme.tooltip;
  const theirProps = excludeClassName(props);
  return jsx(Floating, { content, style, animation, placement, arrow: arrow2, trigger, theme: theme2, ...theirProps, children });
};
const SidebarContext = react.exports.createContext(void 0);
function useSidebarContext() {
  const context = react.exports.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebarContext should be used within the SidebarContext provider!");
  }
  return context;
}
const SidebarItemContext = react.exports.createContext(void 0);
function useSidebarItemContext() {
  const context = react.exports.useContext(SidebarItemContext);
  if (!context) {
    throw new Error("useSidebarItemContext should be used within the SidebarItemContext provider!");
  }
  return context;
}
const SidebarCollapse = ({ children, icon: Icon, label, ...props }) => {
  const theirProps = excludeClassName(props);
  const id2 = react.exports.useId();
  const { isCollapsed } = useSidebarContext();
  const [isOpen, setOpen] = react.exports.useState(false);
  const theme2 = useTheme().theme.sidebar.collapse;
  const Wrapper = ({ children: children2 }) => jsx("li", { children: isCollapsed ? jsx(Tooltip, { content: label, placement: "right", children: children2 }) : children2 });
  return jsxs(Wrapper, { children: [jsxs("button", { className: theme2.button, id: `flowbite-sidebar-collapse-${id2}`, onClick: () => setOpen(!isOpen), type: "button", ...theirProps, children: [Icon && jsx(Icon, { "aria-hidden": true, className: classNames(theme2.icon.base, theme2.icon.open[isOpen ? "on" : "off"]), "data-testid": "flowbite-sidebar-collapse-icon" }), isCollapsed ? jsx("span", { className: "sr-only", children: label }) : jsxs(Fragment, { children: [jsx("span", { className: theme2.label.base, "data-testid": "flowbite-sidebar-collapse-label", children: label }), jsx(HiChevronDown, { "aria-hidden": true, className: theme2.label.icon })] })] }), jsx("ul", { "aria-labelledby": `flowbite-sidebar-collapse-${id2}`, className: theme2.list, hidden: !isOpen, children: jsx(SidebarItemContext.Provider, { value: { isInsideCollapse: true }, children }) })] });
};
SidebarCollapse.displayName = "Sidebar.Collapse";
const SidebarCTA = ({ children, color: color2 = "info", ...props }) => {
  const theirProps = excludeClassName(props);
  const { isCollapsed } = useSidebarContext();
  const theme2 = useTheme().theme.sidebar.cta;
  return jsx("div", { className: classNames(theme2.base, theme2.color[color2]), "data-testid": "sidebar-cta", hidden: isCollapsed, ...theirProps, children });
};
SidebarCTA.displayName = "Sidebar.CTA";
const SidebarItem = ({ as: Component = "a", children, icon: Icon, active: isActive, label, labelColor = "info", ...props }) => {
  var _a2;
  const theirProps = excludeClassName(props);
  const id2 = react.exports.useId();
  const { isCollapsed } = useSidebarContext();
  const { isInsideCollapse } = useSidebarItemContext();
  const theme2 = useTheme().theme.sidebar.item;
  const ListItem = ({ children: wrapperChildren }) => jsx("li", { children: isCollapsed ? jsx(Tooltip, { content: jsx(TooltipContent, { children }), placement: "right", children: wrapperChildren }) : wrapperChildren });
  const TooltipContent = ({ children: children2 }) => jsx(Children, { children: children2 });
  const Children = ({ children: children2 }) => jsx("span", { className: classNames(theme2.content.base), "data-testid": "flowbite-sidebar-item-content", id: `flowbite-sidebar-item-${id2}`, children: children2 });
  return jsx(ListItem, { children: jsxs(Component, { "aria-labelledby": `flowbite-sidebar-item-${id2}`, className: classNames(theme2.base, isActive && theme2.active, !isCollapsed && isInsideCollapse && theme2.collapsed.insideCollapse), ...theirProps, children: [Icon && jsx(Icon, { "aria-hidden": true, className: classNames(theme2.icon.base, isActive && theme2.icon.active), "data-testid": "flowbite-sidebar-item-icon" }), isCollapsed && !Icon && jsx("span", { className: theme2.collapsed.noIcon, children: (_a2 = children.charAt(0).toLocaleUpperCase()) != null ? _a2 : "?" }), !isCollapsed && jsx(Children, { children }), !isCollapsed && label && jsx(Badge, { color: labelColor, "data-testid": "flowbite-sidebar-label", hidden: isCollapsed, children: label })] }) });
};
SidebarItem.displayName = "Sidebar.Item";
const SidebarItemGroup = ({ children, ...props }) => {
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.sidebar.itemGroup;
  return jsx("ul", { className: theme2, "data-testid": "flowbite-sidebar-item-group", ...theirProps, children: jsx(SidebarItemContext.Provider, { value: { isInsideCollapse: false }, children }) });
};
SidebarItemGroup.displayName = "Sidebar.ItemGroup";
const SidebarItems = ({ children, ...props }) => {
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.sidebar.items;
  return jsx("div", { className: theme2, "data-testid": "flowbite-sidebar-items", ...theirProps, children });
};
SidebarItems.displayName = "Sidebar.Items";
const SidebarLogo = ({ children, href, img, imgAlt = "", ...props }) => {
  const theirProps = excludeClassName(props);
  const id2 = react.exports.useId();
  const { isCollapsed } = useSidebarContext();
  const theme2 = useTheme().theme.sidebar.logo;
  return jsxs("a", { "aria-labelledby": `flowbite-sidebar-logo-${id2}`, className: theme2.base, href, ...theirProps, children: [jsx("img", { alt: imgAlt, className: theme2.img, src: img }), jsx("span", { className: theme2.collapsed[isCollapsed ? "on" : "off"], id: `flowbite-sidebar-logo-${id2}`, children })] });
};
SidebarLogo.displayName = "Sidebar.Logo";
const SidebarComponent = ({ children, collapseBehavior = "collapse", collapsed: isCollapsed = false, ...props }) => {
  const theirProps = excludeClassName(props);
  const theme2 = useTheme().theme.sidebar;
  return jsx(SidebarContext.Provider, { value: { isCollapsed }, children: jsx("aside", { "aria-label": "Sidebar", className: classNames(theme2.base, theme2.collapsed[isCollapsed ? "on" : "off"]), hidden: isCollapsed && collapseBehavior === "hide", ...theirProps, children: jsx("div", { className: theme2.inner, children }) }) });
};
SidebarComponent.displayName = "Sidebar";
Object.assign(SidebarComponent, {
  Collapse: SidebarCollapse,
  CTA: SidebarCTA,
  Item: SidebarItem,
  Items: SidebarItems,
  ItemGroup: SidebarItemGroup,
  Logo: SidebarLogo
});
const TableBody = ({ children, ...props }) => {
  return jsx("tbody", { ...props, children });
};
const TableCell = ({ children, className, ...props }) => {
  return jsx("td", { className: classNames("px-6 py-4", className), ...props, children });
};
const TableContext = react.exports.createContext(void 0);
function useTableContext() {
  const context = react.exports.useContext(TableContext);
  if (!context) {
    throw new Error("useTableContext should be used within the TableContext provider!");
  }
  return context;
}
const TableHead = ({ children, className, ...props }) => {
  return jsx("thead", { className: classNames("bg-gray-50 text-xs uppercase text-gray-700 dark:bg-gray-700 dark:text-gray-400", className), ...props, children: jsx("tr", { children }) });
};
const TableHeadCell = ({ children, className, ...props }) => {
  return jsx("th", { className: classNames("px-6 py-3", className), ...props, children });
};
const TableRow = ({ children, className, ...props }) => {
  const { striped, hoverable } = useTableContext();
  return jsx("tr", { "data-testid": "table-row-element", className: classNames({
    "odd:bg-white even:bg-gray-50 odd:dark:bg-gray-800 even:dark:bg-gray-700": striped,
    "hover:bg-gray-50 dark:hover:bg-gray-600": hoverable
  }, className), ...props, children });
};
const TableComponent = ({ children, striped, hoverable, className, ...props }) => {
  return jsx("div", { "data-testid": "table-element", className: "relative overflow-x-auto shadow-md sm:rounded-lg", children: jsx(TableContext.Provider, { value: { striped, hoverable }, children: jsx("table", { className: classNames("w-full text-left text-sm text-gray-500 dark:text-gray-400", className), ...props, children }) }) });
};
TableComponent.displayName = "Table";
TableHead.displayName = "Table.Head";
TableBody.displayName = "Table.Body";
TableRow.displayName = "Table.Row";
TableCell.displayName = "Table.Cell";
TableHeadCell.displayName = "Table.HeadCell";
Object.assign(TableComponent, {
  Head: TableHead,
  Body: TableBody,
  Row: TableRow,
  Cell: TableCell,
  HeadCell: TableHeadCell
});
const TimelineBody = ({ children, className, ...props }) => {
  return jsx("p", { className: classNames("mb-4 text-base font-normal text-gray-500 dark:text-gray-400", className), ...props, children });
};
const TimelineContext = react.exports.createContext(void 0);
function useTimelineContext() {
  const context = react.exports.useContext(TimelineContext);
  if (!context) {
    throw new Error("useTimelineContext should be used within the TimelineContext providor!");
  }
  return context;
}
const TimelineContent = ({ children, className, ...props }) => {
  const { horizontal } = useTimelineContext();
  return jsx("div", { "data-testid": "timeline-content", className: classNames({ "mt-3 sm:pr-8": horizontal }, className), ...props, children });
};
const TimelineItem = ({ children, className, ...props }) => {
  const { horizontal } = useTimelineContext();
  return jsx("li", { "data-testid": "timeline-item", className: classNames({ "mb-10 ml-6": !horizontal, "relative mb-6 sm:mb-0": horizontal }, className), ...props, children });
};
const TimelinePoint = ({ children, className, icon: Icon, ...props }) => {
  const { horizontal } = useTimelineContext();
  return jsxs("div", { "data-testid": "timeline-point", className: classNames({ "flex items-center": horizontal }, className), ...props, children: [children, Icon ? jsx("span", { className: "absolute -left-3 flex h-6 w-6 items-center justify-center rounded-full bg-blue-200 ring-8 ring-white dark:bg-blue-900 dark:ring-gray-900", children: jsx(Icon, { "aria-hidden": true, className: "h-3 w-3 text-blue-600 dark:text-blue-300" }) }) : jsx("div", { className: "absolute -left-1.5 mt-1.5 h-3 w-3 rounded-full border border-white bg-gray-200 dark:border-gray-900 dark:bg-gray-700" }), horizontal ? jsx("div", { className: "hidden h-0.5 w-full bg-gray-200 dark:bg-gray-700 sm:flex" }) : ""] });
};
const TimelineTime = ({ children, className, ...props }) => {
  return jsx("time", { className: classNames("mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500", className), ...props, children });
};
const TimelineTitle = ({ children, className, as = "h3", ...props }) => {
  const Tag = as;
  return jsx(Tag, { className: classNames("text-lg font-semibold text-gray-900 dark:text-white", className), ...props, children });
};
const TimelineComponent = ({ children, horizontal }) => {
  return jsx(TimelineContext.Provider, { value: { horizontal }, children: jsx("ol", { "data-testid": "timeline-component", className: classNames({
    "relative border-l border-gray-200 dark:border-gray-700": !horizontal,
    "items-center sm:flex": horizontal
  }), children }) });
};
TimelineComponent.displayName = "Timeline";
TimelineItem.displayName = "Timeline.Item";
TimelinePoint.displayName = "Timeline.Point";
TimelineContent.displayName = "Timeline.Content";
TimelineTime.displayName = "Timeline.Time";
TimelineTitle.displayName = "Timeline.Title";
TimelineBody.displayName = "Timeline.Body";
Object.assign(TimelineComponent, {
  Item: TimelineItem,
  Point: TimelinePoint,
  Content: TimelineContent,
  Time: TimelineTime,
  Title: TimelineTitle,
  Body: TimelineBody
});
const ToastContext = react.exports.createContext(void 0);
function useToastContext() {
  const context = react.exports.useContext(ToastContext);
  if (!context) {
    throw new Error("useToastContext should be used within the ToastContext provider!");
  }
  return context;
}
const ToastToggle = ({ xIcon: XIcon = HiX }) => {
  const { duration, isClosed, isRemoved, setIsClosed, setIsRemoved } = useToastContext();
  const theme2 = useTheme().theme.toast.toggle;
  const handleClick = () => {
    setIsClosed(!isClosed);
    setTimeout(() => setIsRemoved(!isRemoved), duration);
  };
  return jsx("button", { "aria-label": "Close", onClick: handleClick, type: "button", className: theme2.base, children: jsx(XIcon, { className: theme2.icon }) });
};
const durationClasses = {
  75: "duration-75",
  100: "duration-100",
  150: "duration-150",
  200: "duration-200",
  300: "duration-300",
  500: "duration-500",
  700: "duration-700",
  1e3: "duration-1000"
};
const ToastComponent = ({ children, duration = 300, ...props }) => {
  const [isClosed, setIsClosed] = react.exports.useState(false);
  const [isRemoved, setIsRemoved] = react.exports.useState(false);
  const theme2 = useTheme().theme.toast;
  const theirProps = excludeClassName(props);
  return jsx(ToastContext.Provider, { value: { duration, isClosed, isRemoved, setIsClosed, setIsRemoved }, children: jsx("div", { "data-testid": "flowbite-toast", className: classNames(theme2.base, durationClasses[duration], { [theme2.closed]: isClosed }, { [theme2.removed]: isRemoved }), ...theirProps, children }) });
};
ToastComponent.displayName = "Toast";
ToastToggle.displayName = "Toast.Toggle";
Object.assign(ToastComponent, {
  Toggle: ToastToggle
});
function ArrowDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M12 2.25a.75.75 0 01.75.75v16.19l6.22-6.22a.75.75 0 111.06 1.06l-7.5 7.5a.75.75 0 01-1.06 0l-7.5-7.5a.75.75 0 111.06-1.06l6.22 6.22V3a.75.75 0 01.75-.75z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$8 = react.exports.forwardRef(ArrowDownIcon);
const ArrowDownIcon$1 = ForwardRef$8;
function ArrowLongLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M7.28 7.72a.75.75 0 010 1.06l-2.47 2.47H21a.75.75 0 010 1.5H4.81l2.47 2.47a.75.75 0 11-1.06 1.06l-3.75-3.75a.75.75 0 010-1.06l3.75-3.75a.75.75 0 011.06 0z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$7 = react.exports.forwardRef(ArrowLongLeftIcon);
const ArrowLongLeftIcon$1 = ForwardRef$7;
function ArrowLongRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M16.72 7.72a.75.75 0 011.06 0l3.75 3.75a.75.75 0 010 1.06l-3.75 3.75a.75.75 0 11-1.06-1.06l2.47-2.47H3a.75.75 0 010-1.5h16.19l-2.47-2.47a.75.75 0 010-1.06z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$6 = react.exports.forwardRef(ArrowLongRightIcon);
const ArrowLongRightIcon$1 = ForwardRef$6;
function ArrowTopRightOnSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M15.75 2.25H21a.75.75 0 01.75.75v5.25a.75.75 0 01-1.5 0V4.81L8.03 17.03a.75.75 0 01-1.06-1.06L19.19 3.75h-3.44a.75.75 0 010-1.5zm-10.5 4.5a1.5 1.5 0 00-1.5 1.5v10.5a1.5 1.5 0 001.5 1.5h10.5a1.5 1.5 0 001.5-1.5V10.5a.75.75 0 011.5 0v8.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V8.25a3 3 0 013-3h8.25a.75.75 0 010 1.5H5.25z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$5 = react.exports.forwardRef(ArrowTopRightOnSquareIcon);
const ArrowTopRightOnSquareIcon$1 = ForwardRef$5;
function ArrowsUpDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M6.97 2.47a.75.75 0 011.06 0l4.5 4.5a.75.75 0 01-1.06 1.06L8.25 4.81V16.5a.75.75 0 01-1.5 0V4.81L3.53 8.03a.75.75 0 01-1.06-1.06l4.5-4.5zm9.53 4.28a.75.75 0 01.75.75v11.69l3.22-3.22a.75.75 0 111.06 1.06l-4.5 4.5a.75.75 0 01-1.06 0l-4.5-4.5a.75.75 0 111.06-1.06l3.22 3.22V7.5a.75.75 0 01.75-.75z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$4 = react.exports.forwardRef(ArrowsUpDownIcon);
const ArrowsUpDownIcon$1 = ForwardRef$4;
function ChevronDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M12.53 16.28a.75.75 0 01-1.06 0l-7.5-7.5a.75.75 0 011.06-1.06L12 14.69l6.97-6.97a.75.75 0 111.06 1.06l-7.5 7.5z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$3 = react.exports.forwardRef(ChevronDownIcon);
const ChevronDownIcon$1 = ForwardRef$3;
function ChevronUpIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M11.47 7.72a.75.75 0 011.06 0l7.5 7.5a.75.75 0 11-1.06 1.06L12 9.31l-6.97 6.97a.75.75 0 01-1.06-1.06l7.5-7.5z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$2 = react.exports.forwardRef(ChevronUpIcon);
const ChevronUpIcon$1 = ForwardRef$2;
function FireIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M12.963 2.286a.75.75 0 00-1.071-.136 9.742 9.742 0 00-3.539 6.177A7.547 7.547 0 016.648 6.61a.75.75 0 00-1.152-.082A9 9 0 1015.68 4.534a7.46 7.46 0 01-2.717-2.248zM15.75 14.25a3.75 3.75 0 11-7.313-1.172c.628.465 1.35.81 2.133 1a5.99 5.99 0 011.925-3.545 3.75 3.75 0 013.255 3.717z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef$1 = react.exports.forwardRef(FireIcon);
const FireIcon$1 = ForwardRef$1;
function MagnifyingGlassIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ jsxs("svg", {
    ...Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props),
    children: [title ? /* @__PURE__ */ jsx("title", {
      id: titleId,
      children: title
    }) : null, /* @__PURE__ */ jsx("path", {
      fillRule: "evenodd",
      d: "M10.5 3.75a6.75 6.75 0 100 13.5 6.75 6.75 0 000-13.5zM2.25 10.5a8.25 8.25 0 1114.59 5.28l4.69 4.69a.75.75 0 11-1.06 1.06l-4.69-4.69A8.25 8.25 0 012.25 10.5z",
      clipRule: "evenodd"
    })]
  });
}
const ForwardRef = react.exports.forwardRef(MagnifyingGlassIcon);
const MagnifyingGlassIcon$1 = ForwardRef;
function isLikeCloseEvent$1(val) {
  return isNonNullObject(val) && "code" in val && "reason" in val;
}
var GraphQLWsLink = function(_super) {
  __extends(GraphQLWsLink2, _super);
  function GraphQLWsLink2(client2) {
    var _this = _super.call(this) || this;
    _this.client = client2;
    return _this;
  }
  GraphQLWsLink2.prototype.request = function(operation) {
    var _this = this;
    return new Observable(function(observer) {
      return _this.client.subscribe(__assign$1(__assign$1({}, operation), { query: print(operation.query) }), {
        next: observer.next.bind(observer),
        complete: observer.complete.bind(observer),
        error: function(err) {
          if (err instanceof Error) {
            return observer.error(err);
          }
          if (isLikeCloseEvent$1(err)) {
            return observer.error(new Error("Socket closed with event ".concat(err.code, " ").concat(err.reason || "")));
          }
          return observer.error(new ApolloError({
            graphQLErrors: Array.isArray(err) ? err : [err]
          }));
        }
      });
    });
  };
  return GraphQLWsLink2;
}(ApolloLink);
function extendedTypeof(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
}
function isObject(val) {
  return extendedTypeof(val) === "object";
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.every((ob2) => "message" in ob2);
}
function limitCloseReason(reason, whenTooLong) {
  return reason.length < 124 ? reason : whenTooLong;
}
const GRAPHQL_TRANSPORT_WS_PROTOCOL = "graphql-transport-ws";
var CloseCode;
(function(CloseCode2) {
  CloseCode2[CloseCode2["InternalServerError"] = 4500] = "InternalServerError";
  CloseCode2[CloseCode2["InternalClientError"] = 4005] = "InternalClientError";
  CloseCode2[CloseCode2["BadRequest"] = 4400] = "BadRequest";
  CloseCode2[CloseCode2["BadResponse"] = 4004] = "BadResponse";
  CloseCode2[CloseCode2["Unauthorized"] = 4401] = "Unauthorized";
  CloseCode2[CloseCode2["Forbidden"] = 4403] = "Forbidden";
  CloseCode2[CloseCode2["SubprotocolNotAcceptable"] = 4406] = "SubprotocolNotAcceptable";
  CloseCode2[CloseCode2["ConnectionInitialisationTimeout"] = 4408] = "ConnectionInitialisationTimeout";
  CloseCode2[CloseCode2["ConnectionAcknowledgementTimeout"] = 4504] = "ConnectionAcknowledgementTimeout";
  CloseCode2[CloseCode2["SubscriberAlreadyExists"] = 4409] = "SubscriberAlreadyExists";
  CloseCode2[CloseCode2["TooManyInitialisationRequests"] = 4429] = "TooManyInitialisationRequests";
})(CloseCode || (CloseCode = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["ConnectionInit"] = "connection_init";
  MessageType2["ConnectionAck"] = "connection_ack";
  MessageType2["Ping"] = "ping";
  MessageType2["Pong"] = "pong";
  MessageType2["Subscribe"] = "subscribe";
  MessageType2["Next"] = "next";
  MessageType2["Error"] = "error";
  MessageType2["Complete"] = "complete";
})(MessageType || (MessageType = {}));
function validateMessage(val) {
  if (!isObject(val)) {
    throw new Error(`Message is expected to be an object, but got ${extendedTypeof(val)}`);
  }
  if (!val.type) {
    throw new Error(`Message is missing the 'type' property`);
  }
  if (typeof val.type !== "string") {
    throw new Error(`Message is expects the 'type' property to be a string, but got ${extendedTypeof(val.type)}`);
  }
  switch (val.type) {
    case MessageType.ConnectionInit:
    case MessageType.ConnectionAck:
    case MessageType.Ping:
    case MessageType.Pong: {
      if ("payload" in val && !isObject(val.payload)) {
        throw new Error(`"${val.type}" message expects the 'payload' property to be an object or missing, but got "${val.payload}"`);
      }
      break;
    }
    case MessageType.Subscribe: {
      if (typeof val.id !== "string") {
        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
      }
      if (!val.id) {
        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
      }
      if (!isObject(val.payload)) {
        throw new Error(`"${val.type}" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);
      }
      if (typeof val.payload.query !== "string") {
        throw new Error(`"${val.type}" message payload expects the 'query' property to be a string, but got ${extendedTypeof(val.payload.query)}`);
      }
      if (val.payload.variables != null && !isObject(val.payload.variables)) {
        throw new Error(`"${val.type}" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.variables)}`);
      }
      if (val.payload.operationName != null && extendedTypeof(val.payload.operationName) !== "string") {
        throw new Error(`"${val.type}" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(val.payload.operationName)}`);
      }
      if (val.payload.extensions != null && !isObject(val.payload.extensions)) {
        throw new Error(`"${val.type}" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.extensions)}`);
      }
      break;
    }
    case MessageType.Next: {
      if (typeof val.id !== "string") {
        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
      }
      if (!val.id) {
        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
      }
      if (!isObject(val.payload)) {
        throw new Error(`"${val.type}" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);
      }
      break;
    }
    case MessageType.Error: {
      if (typeof val.id !== "string") {
        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
      }
      if (!val.id) {
        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
      }
      if (!areGraphQLErrors(val.payload)) {
        throw new Error(`"${val.type}" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);
      }
      break;
    }
    case MessageType.Complete: {
      if (typeof val.id !== "string") {
        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
      }
      if (!val.id) {
        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
      }
      break;
    }
    default:
      throw new Error(`Invalid message 'type' property "${val.type}"`);
  }
  return val;
}
function parseMessage(data2, reviver) {
  return validateMessage(typeof data2 === "string" ? JSON.parse(data2, reviver) : data2);
}
function stringifyMessage(msg, replacer) {
  validateMessage(msg);
  return JSON.stringify(msg, replacer);
}
function createClient(options) {
  const {
    url,
    connectionParams,
    lazy = true,
    onNonLazyError = console.error,
    lazyCloseTimeout: lazyCloseTimeoutMs = 0,
    keepAlive = 0,
    disablePong,
    connectionAckWaitTimeout = 0,
    retryAttempts = 5,
    retryWait = async function randomisedExponentialBackoff(retries2) {
      let retryDelay = 1e3;
      for (let i2 = 0; i2 < retries2; i2++) {
        retryDelay *= 2;
      }
      await new Promise((resolve2) => setTimeout(resolve2, retryDelay + Math.floor(Math.random() * (3e3 - 300) + 300)));
    },
    shouldRetry = isLikeCloseEvent,
    isFatalConnectionProblem,
    on,
    webSocketImpl,
    generateID = function generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
        const r2 = Math.random() * 16 | 0, v2 = c2 == "x" ? r2 : r2 & 3 | 8;
        return v2.toString(16);
      });
    },
    jsonMessageReplacer: replacer,
    jsonMessageReviver: reviver
  } = options;
  let ws;
  if (webSocketImpl) {
    if (!isWebSocket(webSocketImpl)) {
      throw new Error("Invalid WebSocket implementation provided");
    }
    ws = webSocketImpl;
  } else if (typeof WebSocket !== "undefined") {
    ws = WebSocket;
  } else if (typeof global !== "undefined") {
    ws = global.WebSocket || global.MozWebSocket;
  } else if (typeof window !== "undefined") {
    ws = window.WebSocket || window.MozWebSocket;
  }
  if (!ws)
    throw new Error("WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`");
  const WebSocketImpl = ws;
  const emitter = (() => {
    const message = (() => {
      const listeners2 = {};
      return {
        on(id2, listener) {
          listeners2[id2] = listener;
          return () => {
            delete listeners2[id2];
          };
        },
        emit(message2) {
          var _a2;
          if ("id" in message2)
            (_a2 = listeners2[message2.id]) === null || _a2 === void 0 ? void 0 : _a2.call(listeners2, message2);
        }
      };
    })();
    const listeners = {
      connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],
      opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],
      connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],
      ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],
      pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],
      message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],
      closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],
      error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []
    };
    return {
      onMessage: message.on,
      on(event, listener) {
        const l2 = listeners[event];
        l2.push(listener);
        return () => {
          l2.splice(l2.indexOf(listener), 1);
        };
      },
      emit(event, ...args) {
        for (const listener of [...listeners[event]]) {
          listener(...args);
        }
      }
    };
  })();
  function errorOrClosed(cb2) {
    const listening = [
      emitter.on("error", (err) => {
        listening.forEach((unlisten) => unlisten());
        cb2(err);
      }),
      emitter.on("closed", (event) => {
        listening.forEach((unlisten) => unlisten());
        cb2(event);
      })
    ];
  }
  let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;
  async function connect() {
    clearTimeout(lazyCloseTimeout);
    const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {
      if (retrying) {
        await retryWait(retries);
        if (!locks) {
          connecting = void 0;
          return denied({ code: 1e3, reason: "All Subscriptions Gone" });
        }
        retries++;
      }
      emitter.emit("connecting");
      const socket2 = new WebSocketImpl(typeof url === "function" ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);
      let connectionAckTimeout, queuedPing;
      function enqueuePing() {
        if (isFinite(keepAlive) && keepAlive > 0) {
          clearTimeout(queuedPing);
          queuedPing = setTimeout(() => {
            if (socket2.readyState === WebSocketImpl.OPEN) {
              socket2.send(stringifyMessage({ type: MessageType.Ping }));
              emitter.emit("ping", false, void 0);
            }
          }, keepAlive);
        }
      }
      errorOrClosed((errOrEvent) => {
        connecting = void 0;
        clearTimeout(connectionAckTimeout);
        clearTimeout(queuedPing);
        denied(errOrEvent);
        if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {
          socket2.close(4499, "Terminated");
          socket2.onerror = null;
          socket2.onclose = null;
        }
      });
      socket2.onerror = (err) => emitter.emit("error", err);
      socket2.onclose = (event) => emitter.emit("closed", event);
      socket2.onopen = async () => {
        try {
          emitter.emit("opened", socket2);
          const payload = typeof connectionParams === "function" ? await connectionParams() : connectionParams;
          if (socket2.readyState !== WebSocketImpl.OPEN)
            return;
          socket2.send(stringifyMessage(payload ? {
            type: MessageType.ConnectionInit,
            payload
          } : {
            type: MessageType.ConnectionInit
          }, replacer));
          if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {
            connectionAckTimeout = setTimeout(() => {
              socket2.close(CloseCode.ConnectionAcknowledgementTimeout, "Connection acknowledgement timeout");
            }, connectionAckWaitTimeout);
          }
          enqueuePing();
        } catch (err) {
          emitter.emit("error", err);
          socket2.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, "Internal client error"));
        }
      };
      let acknowledged = false;
      socket2.onmessage = ({ data: data2 }) => {
        try {
          const message = parseMessage(data2, reviver);
          emitter.emit("message", message);
          if (message.type === "ping" || message.type === "pong") {
            emitter.emit(message.type, true, message.payload);
            if (message.type === "pong") {
              enqueuePing();
            } else if (!disablePong) {
              socket2.send(stringifyMessage(message.payload ? {
                type: MessageType.Pong,
                payload: message.payload
              } : {
                type: MessageType.Pong
              }));
              emitter.emit("pong", false, message.payload);
            }
            return;
          }
          if (acknowledged)
            return;
          if (message.type !== MessageType.ConnectionAck)
            throw new Error(`First message cannot be of type ${message.type}`);
          clearTimeout(connectionAckTimeout);
          acknowledged = true;
          emitter.emit("connected", socket2, message.payload);
          retrying = false;
          retries = 0;
          connected([
            socket2,
            new Promise((_2, reject) => errorOrClosed(reject))
          ]);
        } catch (err) {
          socket2.onmessage = null;
          emitter.emit("error", err);
          socket2.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, "Bad response"));
        }
      };
    })()));
    if (socket.readyState === WebSocketImpl.CLOSING)
      await throwOnClose;
    let release = () => {
    };
    const released = new Promise((resolve2) => release = resolve2);
    return [
      socket,
      release,
      Promise.race([
        released.then(() => {
          if (!locks) {
            const complete = () => socket.close(1e3, "Normal Closure");
            if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {
              lazyCloseTimeout = setTimeout(() => {
                if (socket.readyState === WebSocketImpl.OPEN)
                  complete();
              }, lazyCloseTimeoutMs);
            } else {
              complete();
            }
          }
        }),
        throwOnClose
      ])
    ];
  }
  function shouldRetryConnectOrThrow(errOrCloseEvent) {
    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [
      CloseCode.InternalServerError,
      CloseCode.InternalClientError,
      CloseCode.BadRequest,
      CloseCode.BadResponse,
      CloseCode.Unauthorized,
      CloseCode.SubprotocolNotAcceptable,
      CloseCode.SubscriberAlreadyExists,
      CloseCode.TooManyInitialisationRequests
    ].includes(errOrCloseEvent.code)))
      throw errOrCloseEvent;
    if (disposed)
      return false;
    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)
      return locks > 0;
    if (!retryAttempts || retries >= retryAttempts)
      throw errOrCloseEvent;
    if (!shouldRetry(errOrCloseEvent))
      throw errOrCloseEvent;
    if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))
      throw errOrCloseEvent;
    return retrying = true;
  }
  if (!lazy) {
    (async () => {
      locks++;
      for (; ; ) {
        try {
          const [, , throwOnClose] = await connect();
          await throwOnClose;
        } catch (errOrCloseEvent) {
          try {
            if (!shouldRetryConnectOrThrow(errOrCloseEvent))
              return;
          } catch (errOrCloseEvent2) {
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent2);
          }
        }
      }
    })();
  }
  return {
    on: emitter.on,
    subscribe(payload, sink) {
      const id2 = generateID(payload);
      let done = false, errored = false, releaser = () => {
        locks--;
        done = true;
      };
      (async () => {
        locks++;
        for (; ; ) {
          try {
            const [socket, release, waitForReleaseOrThrowOnClose] = await connect();
            if (done)
              return release();
            const unlisten = emitter.onMessage(id2, (message) => {
              switch (message.type) {
                case MessageType.Next: {
                  sink.next(message.payload);
                  return;
                }
                case MessageType.Error: {
                  errored = true, done = true;
                  sink.error(message.payload);
                  releaser();
                  return;
                }
                case MessageType.Complete: {
                  done = true;
                  releaser();
                  return;
                }
              }
            });
            socket.send(stringifyMessage({
              id: id2,
              type: MessageType.Subscribe,
              payload
            }, replacer));
            releaser = () => {
              if (!done && socket.readyState === WebSocketImpl.OPEN)
                socket.send(stringifyMessage({
                  id: id2,
                  type: MessageType.Complete
                }, replacer));
              locks--;
              done = true;
              release();
            };
            await waitForReleaseOrThrowOnClose.finally(unlisten);
            return;
          } catch (errOrCloseEvent) {
            if (!shouldRetryConnectOrThrow(errOrCloseEvent))
              return;
          }
        }
      })().then(() => {
        if (!errored)
          sink.complete();
      }).catch((err) => {
        sink.error(err);
      });
      return () => {
        if (!done)
          releaser();
      };
    },
    async dispose() {
      disposed = true;
      if (connecting) {
        const [socket] = await connecting;
        socket.close(1e3, "Normal Closure");
      }
    },
    terminate() {
      if (connecting) {
        emitter.emit("closed", {
          code: 4499,
          reason: "Terminated",
          wasClean: false
        });
      }
    }
  };
}
function isLikeCloseEvent(val) {
  return isObject(val) && "code" in val && "reason" in val;
}
function isFatalInternalCloseCode(code) {
  if ([
    1e3,
    1001,
    1006,
    1005,
    1012,
    1013,
    1013
  ].includes(code))
    return false;
  return code >= 1e3 && code <= 1999;
}
function isWebSocket(val) {
  return typeof val === "function" && "constructor" in val && "CLOSED" in val && "CLOSING" in val && "CONNECTING" in val && "OPEN" in val;
}
class LuxonError extends Error {
}
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}
class ConflictingSpecificationError extends LuxonError {
}
class InvalidUnitError extends LuxonError {
  constructor(unit2) {
    super(`Invalid unit ${unit2}`);
  }
}
class InvalidArgumentError extends LuxonError {
}
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
const n = "numeric", s = "short", l = "long";
const DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
const DATE_MED = {
  year: n,
  month: s,
  day: n
};
const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
const DATE_FULL = {
  year: n,
  month: l,
  day: n
};
const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n,
  minute: n
};
const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
function isUndefined(o2) {
  return typeof o2 === "undefined";
}
function isNumber(o2) {
  return typeof o2 === "number";
}
function isInteger(o2) {
  return typeof o2 === "number" && o2 % 1 === 0;
}
function isString(o2) {
  return typeof o2 === "string";
}
function isDate(o2) {
  return Object.prototype.toString.call(o2) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e3) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a2, k2) => {
    a2[k2] = obj[k2];
    return a2;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x2, n2) {
  return x2 - n2 * Math.floor(x2 / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f2 = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f2);
  }
}
function roundTo(number2, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number2 * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d2 = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d2 = new Date(d2);
    d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
  }
  return +d2;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > 60 ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale2, timeZone = null) {
  const date2 = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale2, modified).formatToParts(date2).find((m2) => m2.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u2 in obj) {
    if (hasOwnProperty(obj, u2)) {
      const v2 = obj[u2];
      if (v2 === void 0 || v2 === null)
        continue;
      normalized[normalizer(u2)] = asNumber(v2);
    }
  }
  return normalized;
}
function formatOffset(offset2, format2) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format2) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format2} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit2, count2, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit2) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit2 === "days";
    switch (count2) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit2][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit2][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit2][0]}`;
    }
  }
  const isInPast = Object.is(count2, -0) || count2 < 0, fmtValue = Math.abs(count2), singular = fmtValue === 1, lilUnits = units[unit2], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit2][0] : unit2;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
class Formatter {
  static create(locale2, opts = {}) {
    return new Formatter(locale2, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i2 = 0; i2 < fmt.length; i2++) {
      const c2 = fmt.charAt(i2);
      if (c2 === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c2;
      } else if (c2 === current) {
        currentFull += c2;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c2;
        current = c2;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale2, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale2;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df2 = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df2.format();
  }
  formatDateTime(dt, opts = {}) {
    const df2 = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df2.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df2 = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df2.formatToParts();
  }
  resolvedOptions(dt, opts = {}) {
    const df2 = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df2.resolvedOptions();
  }
  num(n2, p2 = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p2);
    }
    const opts = { ...this.opts };
    if (p2 > 0) {
      opts.padTo = p2;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}
class Zone {
  get type() {
    throw new ZoneIsAbstractError();
  }
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  formatOffset(ts, format2) {
    throw new ZoneIsAbstractError();
  }
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let singleton$1 = null;
class SystemZone extends Zone {
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format: format2, locale: locale2 }) {
    return parseZoneInfo(ts, format2, locale2);
  }
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  equals(otherZone) {
    return otherZone.type === "system";
  }
  get isValid() {
    return true;
  }
}
let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  const filled = [];
  for (let i2 = 0; i2 < formatted.length; i2++) {
    const { type, value } = formatted[i2];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
let ianaZoneCache = {};
class IANAZone extends Zone {
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e3) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format: format2, locale: locale2 }) {
    return parseZoneInfo(ts, format2, locale2, this.name);
  }
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  offset(ts) {
    const date2 = new Date(ts);
    if (isNaN(date2))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date2;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let singleton = null;
class FixedOffsetZone extends Zone {
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  static parseSpecifier(s2) {
    if (s2) {
      const r2 = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r2) {
        return new FixedOffsetZone(signedOffset(r2[1], r2[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  offsetName() {
    return this.name;
  }
  formatOffset(ts, format2) {
    return formatOffset(this.fixed, format2);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
}
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
}
function normalizeZone(input, defaultZone2) {
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}
let now = () => Date.now(), defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, throwOnInvalid;
class Settings {
  static get now() {
    return now;
  }
  static set now(n2) {
    now = n2;
  }
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  static get defaultLocale() {
    return defaultLocale;
  }
  static set defaultLocale(locale2) {
    defaultLocale = locale2;
  }
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  static set throwOnInvalid(t2) {
    throwOnInvalid = t2;
  }
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}
let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e3) {
      options = getCachedDTF(smaller).resolvedOptions();
    }
    const { numberingSystem, calendar } = options;
    return [smaller, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f2) {
  const ms = [];
  for (let i2 = 1; i2 <= 12; i2++) {
    const dt = DateTime.utc(2016, i2, 1);
    ms.push(f2(dt));
  }
  return ms;
}
function mapWeekdays(f2) {
  const ms = [];
  for (let i2 = 1; i2 <= 7; i2++) {
    const dt = DateTime.utc(2016, 11, 13 + i2);
    ms.push(f2(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i2) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i2) : i2;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i2) : roundTo(i2, 3);
      return padStart(fixed, this.padTo);
    }
  }
}
class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z2;
    if (dt.zone.isUniversal) {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z2 = offsetZ;
        this.dt = dt;
      } else {
        z2 = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z2 = dt.zone.name;
    }
    const intlOpts = { ...this.opts };
    if (z2) {
      intlOpts.timeZone = z2;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count2, unit2) {
    if (this.rtf) {
      return this.rtf.format(count2, unit2);
    } else {
      return formatRelativeTime(unit2, count2, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count2, unit2) {
    if (this.rtf) {
      return this.rtf.formatToParts(count2, unit2);
    } else {
      return [];
    }
  }
}
class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale2, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale2 || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale: locale2, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale2, numberingSystem, outputCalendar);
  }
  constructor(locale2, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale2);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format2 = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format2 ? { month: length, day: "numeric" } : { month: length }, formatStr = format2 ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format2 = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format2 ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format2 ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(
      this,
      void 0,
      defaultOK,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df2 = this.dtFormatter(dt, intlOpts), results = df2.formatToParts(), matching = results.find((m2) => m2.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
}
function combineRegexes(...regexes) {
  const full = regexes.reduce((f2, r2) => f2 + r2.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m2) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m2, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m2 = regex.exec(s2);
    if (m2) {
      return extractor(m2);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i2;
    for (i2 = 0; i2 < keys.length; i2++) {
      ret[keys[i2]] = parseInteger(match2[cursor + i2]);
    }
    return [ret, null, cursor + i2];
  };
}
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m2 = match2[pos];
  return isUndefined(m2) ? fallback : parseInteger(m2);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}
const INVALID$2 = "Invalid Duration";
const lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
}, daysInYearAccurate = 146097 / 400, daysInMonthAccurate = 146097 / 4800, accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
const orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
const reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(dur, alts, clear2 = false) {
  const conf = {
    values: clear2 ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function antiTrunc(n2) {
  return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
}
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
class Duration {
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  static fromMillis(count2, opts) {
    return Duration.fromObject({ milliseconds: count2 }, opts);
  }
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  static normalizeUnit(unit2) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit2 ? unit2.toLowerCase() : unit2];
    if (!normalized)
      throw new InvalidUnitError(unit2);
    return normalized;
  }
  static isDuration(o2) {
    return o2 && o2.isLuxonDuration || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
  }
  toHuman(opts = {}) {
    const l2 = orderedUnits$1.map((unit2) => {
      const val = this.values[unit2];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit2.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    return this.as("milliseconds");
  }
  valueOf() {
    return this.toMillis();
  }
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k2 of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k2) || hasOwnProperty(this.values, k2)) {
        result[k2] = dur.get(k2) + this.get(k2);
      }
    }
    return clone$1(this, { values: result }, true);
  }
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k2 of Object.keys(this.values)) {
      result[k2] = asNumber(fn(this.values[k2], k2));
    }
    return clone$1(this, { values: result }, true);
  }
  get(unit2) {
    return this[Duration.normalizeUnit(unit2)];
  }
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone$1(this, { values: mixed });
  }
  reconfigure({ locale: locale2, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale: locale2, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone$1(this, opts);
  }
  as(unit2) {
    return this.isValid ? this.shiftTo(unit2).get(unit2) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, { values: vals }, true);
  }
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, { values: vals }, true);
  }
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u2) => Duration.normalizeUnit(u2));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k2 of orderedUnits$1) {
      if (units.indexOf(k2) >= 0) {
        lastUnit = k2;
        let own = 0;
        for (const ak2 in accumulated) {
          own += this.matrix[ak2][k2] * accumulated[ak2];
          accumulated[ak2] = 0;
        }
        if (isNumber(vals[k2])) {
          own += vals[k2];
        }
        const i2 = Math.trunc(own);
        built[k2] = i2;
        accumulated[k2] = (own * 1e3 - i2 * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k2)) {
            convert(this.matrix, vals, down, built, k2);
          }
        }
      } else if (isNumber(vals[k2])) {
        accumulated[k2] = vals[k2];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone$1(this, { values: built }, true).normalize();
  }
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k2 of Object.keys(this.values)) {
      negated[k2] = this.values[k2] === 0 ? 0 : -this.values[k2];
    }
    return clone$1(this, { values: negated }, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u2 of orderedUnits$1) {
      if (!eq(this.values[u2], other.values[u2])) {
        return false;
      }
    }
    return true;
  }
}
const INVALID$1 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
class Interval {
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  static fromISO(text2, opts) {
    const [s2, e3] = (text2 || "").split("/", 2);
    if (s2 && e3) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e4) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e3, opts);
        endIsValid = end.isValid;
      } catch (e4) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e3, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  static isInterval(o2) {
    return o2 && o2.isLuxonInterval || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(unit2 = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit2]).get(unit2) : NaN;
  }
  count(unit2 = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit2), end = this.end.startOf(unit2);
    return Math.floor(end.diff(start, unit2).get(unit2)) + 1;
  }
  hasSame(unit2) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit2) : false;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
    let { s: s2 } = this, i2 = 0;
    while (s2 < this.e) {
      const added = sorted[i2] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i2 += 1;
    }
    return results;
  }
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x2) => x2 * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
    if (s2 >= e3) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e3);
    }
  }
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e3);
  }
  static merge(intervals) {
    const [found, final] = intervals.sort((a2, b2) => a2.s - b2.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i2) => [
      { time: i2.s, type: "s" },
      { time: i2.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a2, b2) => a2.time - b2.time);
    for (const i2 of arr) {
      currentCount += i2.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i2.time;
      } else {
        if (start && +start !== +i2.time) {
          results.push(Interval.fromDateTimes(start, i2.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i2) => this.intersection(i2)).filter((i2) => i2 && !i2.isEmpty());
  }
  toString() {
    if (!this.isValid)
      return INVALID$1;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  toISO(opts) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  toISODate() {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  toDuration(unit2, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit2, opts);
  }
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}
class Info {
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  static months(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length);
  }
  static monthsFormat(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length, true);
  }
  static weekdays(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length);
  }
  static weekdaysFormat(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length, true);
  }
  static meridiems({ locale: locale2 = null } = {}) {
    return Locale.create(locale2).meridiems();
  }
  static eras(length = "short", { locale: locale2 = null } = {}) {
    return Locale.create(locale2, null, "gregory").eras(length);
  }
  static features() {
    return { relative: hasRelative() };
  }
}
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a2, b2) => b2.year - a2.year],
    ["quarters", (a2, b2) => b2.quarter - a2.quarter + (b2.year - a2.year) * 4],
    ["months", (a2, b2) => b2.month - a2.month + (b2.year - a2.year) * 12],
    [
      "weeks",
      (a2, b2) => {
        const days = dayDiff(a2, b2);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  let lowestOrder, highWater;
  for (const [unit2, differ] of differs) {
    if (units.indexOf(unit2) >= 0) {
      lowestOrder = unit2;
      let delta = differ(cursor, later);
      highWater = cursor.plus({ [unit2]: delta });
      if (highWater > later) {
        cursor = cursor.plus({ [unit2]: delta - 1 });
        delta -= 1;
      } else {
        cursor = highWater;
      }
      results[unit2] = delta;
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u2) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u2) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}
const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i2 = 0; i2 < str.length; i2++) {
      const code = str.charCodeAt(i2);
      if (str[i2].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i2]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min2, max2] = numberingSystemsUTF16[key];
          if (code >= min2 && code <= max2) {
            value += code - min2;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i2) => i2) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i2) => stripInsensitivities(s2) === stripInsensitivities(i2)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h2, m2]) => signedOffset(h2, m2), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one2 = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t2) => ({ regex: RegExp(escapeToken(t2.val)), deser: ([s2]) => s2, literal: true }), unitate = (t2) => {
    if (token.literal) {
      return literal(t2);
    }
    switch (t2.val) {
      case "G":
        return oneOf(loc.eras("short", false), 0);
      case "GG":
        return oneOf(loc.eras("long", false), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true, false), 1);
      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false, false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one2);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one2);
      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      default:
        return literal(t2);
    }
  };
  const unit2 = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit2.token = token;
  return unit2;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, locale2, formatOpts) {
  const { type, value } = part;
  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re2 = units.map((u2) => u2.regex).reduce((f2, r2) => `${f2}(${r2.source})`, "");
  return [`^${re2}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i2 in handlers) {
      if (hasOwnProperty(handlers, i2)) {
        const h2 = handlers[i2], groups = h2.groups ? h2.groups + 1 : 1;
        if (!h2.literal && h2.token) {
          all[h2.token.val[0]] = h2.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r2, k2) => {
    const f2 = toField(k2);
    if (f2) {
      r2[f2] = matches[k2];
    }
    return r2;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale2) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale2);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale2) {
  return Array.prototype.concat(...tokens.map((t2) => maybeExpandMacroToken(t2, locale2)));
}
function explainFromTokens(locale2, input, format2) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format2), locale2), units = tokens.map((t2) => unitForToken(t2, locale2)), disqualifyingUnit = units.find((t2) => t2.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale2, input, format2) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale2, input, format2);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale2) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale2, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map((p2) => tokenForPart(p2, locale2, formatOpts));
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit2, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit2}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d2 = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
  }
  const js = d2.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i2) => i2 < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}
const INVALID = "Invalid DateTime";
const MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o2, tz) {
  let utcGuess = localTS - o2 * 60 * 1e3;
  const o22 = tz.offset(utcGuess);
  if (o2 === o22) {
    return [utcGuess, o2];
  }
  utcGuess -= (o22 - o2) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o22 === o3) {
    return [utcGuess, o22];
  }
  return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d2 = new Date(ts);
  return {
    year: d2.getUTCFullYear(),
    month: d2.getUTCMonth() + 1,
    day: d2.getUTCDate(),
    hour: d2.getUTCHours(),
    minute: d2.getUTCMinutes(),
    second: d2.getUTCSeconds(),
    millisecond: d2.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c2 = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c2);
  let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o2 = inst.zone.offset(ts);
  }
  return { ts, o: o2 };
}
function parseDataToDateTime(parsed, parsedZone, opts, format2, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format2}`)
    );
  }
}
function toTechFormat(dt, format2, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format2) : null;
}
function toISODate(o2, extended) {
  const longFormat = o2.c.year > 9999 || o2.c.year < 0;
  let c2 = "";
  if (longFormat && o2.c.year >= 0)
    c2 += "+";
  c2 += padStart(o2.c.year, longFormat ? 6 : 4);
  if (extended) {
    c2 += "-";
    c2 += padStart(o2.c.month);
    c2 += "-";
    c2 += padStart(o2.c.day);
  } else {
    c2 += padStart(o2.c.month);
    c2 += padStart(o2.c.day);
  }
  return c2;
}
function toISOTime(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c2 = padStart(o2.c.hour);
  if (extended) {
    c2 += ":";
    c2 += padStart(o2.c.minute);
    if (o2.c.second !== 0 || !suppressSeconds) {
      c2 += ":";
    }
  } else {
    c2 += padStart(o2.c.minute);
  }
  if (o2.c.second !== 0 || !suppressSeconds) {
    c2 += padStart(o2.c.second);
    if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
      c2 += ".";
      c2 += padStart(o2.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
      c2 += "Z";
    } else if (o2.o < 0) {
      c2 += "-";
      c2 += padStart(Math.trunc(-o2.o / 60));
      c2 += ":";
      c2 += padStart(Math.trunc(-o2.o % 60));
    } else {
      c2 += "+";
      c2 += padStart(Math.trunc(o2.o / 60));
      c2 += ":";
      c2 += padStart(Math.trunc(o2.o % 60));
    }
  }
  if (extendedZone) {
    c2 += "[" + o2.zone.ianaName + "]";
  }
  return c2;
}
const defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit2) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit2.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit2);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o2;
  if (!isUndefined(obj.year)) {
    for (const u2 of orderedUnits) {
      if (isUndefined(obj[u2])) {
        obj[u2] = defaultUnitValues[u2];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o2] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o: o2 });
}
function diffRelative(start, end, opts) {
  const round2 = isUndefined(opts.round) ? true : opts.round, format2 = (c2, unit2) => {
    c2 = roundTo(c2, round2 || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c2, unit2);
  }, differ = (unit2) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit2)) {
        return end.startOf(unit2).diff(start.startOf(unit2), unit2).get(unit2);
      } else
        return 0;
    } else {
      return end.diff(start, unit2).get(unit2);
    }
  };
  if (opts.unit) {
    return format2(differ(opts.unit), opts.unit);
  }
  for (const unit2 of opts.units) {
    const count2 = differ(unit2);
    if (Math.abs(count2) >= 1) {
      return format2(count2, unit2);
    }
  }
  return format2(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
class DateTime {
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c2 = null, o2 = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c2, o2] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c2 = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c2.year) ? new Invalid("invalid input") : null;
        c2 = invalid ? null : c2;
        o2 = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c2;
    this.o = o2;
    this.isLuxonDateTime = true;
  }
  static now() {
    return new DateTime({});
  }
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static fromJSDate(date2, options = {}) {
    const ts = isDate(date2) ? date2.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u2 of units) {
      const v2 = normalized[u2];
      if (!isUndefined(v2)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u2] = defaultValues[u2];
      } else {
        normalized[u2] = objNow[u2];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  static fromFormat(text2, fmt, opts = {}) {
    if (isUndefined(text2) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale: locale2 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale: locale2,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
    }
  }
  static fromString(text2, fmt, opts = {}) {
    return DateTime.fromFormat(text2, fmt, opts);
  }
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  static isDateTime(o2) {
    return o2 && o2.isLuxonDateTime || false;
  }
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
  }
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t2) => t2.val).join("");
  }
  get(unit2) {
    return this[unit2];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(opts = {}) {
    const { locale: locale2, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale: locale2, numberingSystem, outputCalendar: calendar };
  }
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, { ts: newTS, zone });
    }
  }
  reconfigure({ locale: locale2, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale: locale2, numberingSystem, outputCalendar });
    return clone(this, { loc });
  }
  setLocale(locale2) {
    return this.reconfigure({ locale: locale2 });
  }
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o2] = objToTS(mixed, this.o, this.zone);
    return clone(this, { ts, o: o2 });
  }
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }
  startOf(unit2) {
    if (!this.isValid)
      return this;
    const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit2);
    switch (normalizedUnit) {
      case "years":
        o2.month = 1;
      case "quarters":
      case "months":
        o2.day = 1;
      case "weeks":
      case "days":
        o2.hour = 0;
      case "hours":
        o2.minute = 0;
      case "minutes":
        o2.second = 0;
      case "seconds":
        o2.millisecond = 0;
        break;
    }
    if (normalizedUnit === "weeks") {
      o2.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q2 = Math.ceil(this.month / 3);
      o2.month = (q2 - 1) * 3 + 1;
    }
    return this.set(o2);
  }
  endOf(unit2) {
    return this.isValid ? this.plus({ [unit2]: 1 }).startOf(unit2).minus(1) : this;
  }
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  toISO({
    format: format2 = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format2 === "extended";
    let c2 = toISODate(this, ext);
    c2 += "T";
    c2 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c2;
  }
  toISODate({ format: format2 = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format2 === "extended");
  }
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format: format2 = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c2 = includePrefix ? "T" : "";
    return c2 + toISOTime(
      this,
      format2 === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(otherDateTime, unit2 = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit2).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  diffNow(unit2 = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit2, opts);
  }
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  hasSame(otherDateTime, unit2) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit2) <= inputMs && inputMs <= adjustedToZone.endOf(unit2);
  }
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit2 = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit2 = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit: unit2
    });
  }
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i2) => i2.valueOf(), Math.min);
  }
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i2) => i2.valueOf(), Math.max);
  }
  static fromFormatExplain(text2, fmt, options = {}) {
    const { locale: locale2 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale: locale2,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt);
  }
  static fromStringExplain(text2, fmt, options = {}) {
    return DateTime.fromFormatExplain(text2, fmt, options);
  }
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  static get DATE_MED() {
    return DATE_MED;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  static get DATE_FULL() {
    return DATE_FULL;
  }
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}
var reactResponsive = { exports: {} };
(function(module2, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module2.exports = factory(react.exports);
  })(commonjsGlobal, (__WEBPACK_EXTERNAL_MODULE_react__) => {
    return (() => {
      var __webpack_modules__ = {
        "./node_modules/css-mediaquery/index.js": (__unused_webpack_module, exports2) => {
          exports2.match = matchQuery;
          exports2.parse = parseQuery;
          var RE_MEDIA_QUERY = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;
          function matchQuery(mediaQuery, values) {
            return parseQuery(mediaQuery).some(function(query) {
              var inverse = query.inverse;
              var typeMatch = query.type === "all" || values.type === query.type;
              if (typeMatch && inverse || !(typeMatch || inverse)) {
                return false;
              }
              var expressionsMatch = query.expressions.every(function(expression) {
                var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];
                if (!value) {
                  return false;
                }
                switch (feature) {
                  case "orientation":
                  case "scan":
                    return value.toLowerCase() === expValue.toLowerCase();
                  case "width":
                  case "height":
                  case "device-width":
                  case "device-height":
                    expValue = toPx(expValue);
                    value = toPx(value);
                    break;
                  case "resolution":
                    expValue = toDpi(expValue);
                    value = toDpi(value);
                    break;
                  case "aspect-ratio":
                  case "device-aspect-ratio":
                  case "device-pixel-ratio":
                    expValue = toDecimal2(expValue);
                    value = toDecimal2(value);
                    break;
                  case "grid":
                  case "color":
                  case "color-index":
                  case "monochrome":
                    expValue = parseInt(expValue, 10) || 1;
                    value = parseInt(value, 10) || 0;
                    break;
                }
                switch (modifier) {
                  case "min":
                    return value >= expValue;
                  case "max":
                    return value <= expValue;
                  default:
                    return value === expValue;
                }
              });
              return expressionsMatch && !inverse || !expressionsMatch && inverse;
            });
          }
          function parseQuery(mediaQuery) {
            return mediaQuery.split(",").map(function(query) {
              query = query.trim();
              var captures = query.match(RE_MEDIA_QUERY), modifier = captures[1], type = captures[2], expressions = captures[3] || "", parsed = {};
              parsed.inverse = !!modifier && modifier.toLowerCase() === "not";
              parsed.type = type ? type.toLowerCase() : "all";
              expressions = expressions.match(/\([^\)]+\)/g) || [];
              parsed.expressions = expressions.map(function(expression) {
                var captures2 = expression.match(RE_MQ_EXPRESSION), feature = captures2[1].toLowerCase().match(RE_MQ_FEATURE);
                return {
                  modifier: feature[1],
                  feature: feature[2],
                  value: captures2[2]
                };
              });
              return parsed;
            });
          }
          function toDecimal2(ratio) {
            var decimal = Number(ratio), numbers;
            if (!decimal) {
              numbers = ratio.match(/^(\d+)\s*\/\s*(\d+)$/);
              decimal = numbers[1] / numbers[2];
            }
            return decimal;
          }
          function toDpi(resolution) {
            var value = parseFloat(resolution), units = String(resolution).match(RE_RESOLUTION_UNIT)[1];
            switch (units) {
              case "dpcm":
                return value / 2.54;
              case "dppx":
                return value * 96;
              default:
                return value;
            }
          }
          function toPx(length) {
            var value = parseFloat(length), units = String(length).match(RE_LENGTH_UNIT)[1];
            switch (units) {
              case "em":
                return value * 16;
              case "rem":
                return value * 16;
              case "cm":
                return value * 96 / 2.54;
              case "mm":
                return value * 96 / 2.54 / 10;
              case "in":
                return value * 96;
              case "pt":
                return value * 72;
              case "pc":
                return value * 72 / 12;
              default:
                return value;
            }
          }
        },
        "./node_modules/hyphenate-style-name/index.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
          __webpack_require__2.r(__webpack_exports__2);
          __webpack_require__2.d(__webpack_exports__2, {
            "default": () => __WEBPACK_DEFAULT_EXPORT__
          });
          var uppercasePattern = /[A-Z]/g;
          var msPattern = /^ms-/;
          var cache2 = {};
          function toHyphenLower(match2) {
            return "-" + match2.toLowerCase();
          }
          function hyphenateStyleName(name) {
            if (cache2.hasOwnProperty(name)) {
              return cache2[name];
            }
            var hName = name.replace(uppercasePattern, toHyphenLower);
            return cache2[name] = msPattern.test(hName) ? "-" + hName : hName;
          }
          const __WEBPACK_DEFAULT_EXPORT__ = hyphenateStyleName;
        },
        "./node_modules/matchmediaquery/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var staticMatch = __webpack_require__2("./node_modules/css-mediaquery/index.js").match;
          var dynamicMatch = typeof window !== "undefined" ? window.matchMedia : null;
          function Mql(query, values, forceStatic) {
            var self2 = this;
            if (dynamicMatch && !forceStatic) {
              var mql = dynamicMatch.call(window, query);
              this.matches = mql.matches;
              this.media = mql.media;
              mql.addListener(update);
            } else {
              this.matches = staticMatch(query, values);
              this.media = query;
            }
            this.addListener = addListener;
            this.removeListener = removeListener;
            this.dispose = dispose;
            function addListener(listener) {
              if (mql) {
                mql.addListener(listener);
              }
            }
            function removeListener(listener) {
              if (mql) {
                mql.removeListener(listener);
              }
            }
            function update(evt) {
              self2.matches = evt.matches;
              self2.media = evt.media;
            }
            function dispose() {
              if (mql) {
                mql.removeListener(update);
              }
            }
          }
          function matchMedia(query, values, forceStatic) {
            return new Mql(query, values, forceStatic);
          }
          module3.exports = matchMedia;
        },
        "./node_modules/object-assign/index.js": (module3) => {
          /*
          object-assign
          (c) Sindre Sorhus
          @license MIT
          */
          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val === null || val === void 0) {
              throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              }
              var test1 = new String("abc");
              test1[5] = "de";
              if (Object.getOwnPropertyNames(test1)[0] === "5") {
                return false;
              }
              var test2 = {};
              for (var i2 = 0; i2 < 10; i2++) {
                test2["_" + String.fromCharCode(i2)] = i2;
              }
              var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
                return test2[n2];
              });
              if (order2.join("") !== "0123456789") {
                return false;
              }
              var test3 = {};
              "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                test3[letter] = letter;
              });
              if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                return false;
              }
              return true;
            } catch (err) {
              return false;
            }
          }
          module3.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s2 = 1; s2 < arguments.length; s2++) {
              from = Object(arguments[s2]);
              for (var key in from) {
                if (hasOwnProperty2.call(from, key)) {
                  to[key] = from[key];
                }
              }
              if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i2 = 0; i2 < symbols.length; i2++) {
                  if (propIsEnumerable.call(from, symbols[i2])) {
                    to[symbols[i2]] = from[symbols[i2]];
                  }
                }
              }
            }
            return to;
          };
        },
        "./node_modules/prop-types/checkPropTypes.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var printWarning = function() {
          };
          {
            var ReactPropTypesSecret = __webpack_require__2("./node_modules/prop-types/lib/ReactPropTypesSecret.js");
            var loggedTypeFailures = {};
            var has = __webpack_require__2("./node_modules/prop-types/lib/has.js");
            printWarning = function(text2) {
              var message = "Warning: " + text2;
              if (typeof console !== "undefined") {
                console.error(message);
              }
              try {
                throw new Error(message);
              } catch (x2) {
              }
            };
          }
          function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
            {
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error(
                        (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                      );
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                  } catch (ex) {
                    error = ex;
                  }
                  if (error && !(error instanceof Error)) {
                    printWarning(
                      (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                    );
                  }
                  if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : "";
                    printWarning(
                      "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
                    );
                  }
                }
              }
            }
          }
          checkPropTypes.resetWarningCache = function() {
            {
              loggedTypeFailures = {};
            }
          };
          module3.exports = checkPropTypes;
        },
        "./node_modules/prop-types/factoryWithTypeCheckers.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var ReactIs = __webpack_require__2("./node_modules/react-is/index.js");
          var assign2 = __webpack_require__2("./node_modules/object-assign/index.js");
          var ReactPropTypesSecret = __webpack_require__2("./node_modules/prop-types/lib/ReactPropTypesSecret.js");
          var has = __webpack_require__2("./node_modules/prop-types/lib/has.js");
          var checkPropTypes = __webpack_require__2("./node_modules/prop-types/checkPropTypes.js");
          var printWarning = function() {
          };
          {
            printWarning = function(text2) {
              var message = "Warning: " + text2;
              if (typeof console !== "undefined") {
                console.error(message);
              }
              try {
                throw new Error(message);
              } catch (x2) {
              }
            };
          }
          function emptyFunctionThatReturnsNull() {
            return null;
          }
          module3.exports = function(isValidElement, throwOnDirectAccess) {
            var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = "@@iterator";
            function getIteratorFn(maybeIterable) {
              var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
              if (typeof iteratorFn === "function") {
                return iteratorFn;
              }
            }
            var ANONYMOUS = "<<anonymous>>";
            var ReactPropTypes = {
              array: createPrimitiveTypeChecker("array"),
              bigint: createPrimitiveTypeChecker("bigint"),
              bool: createPrimitiveTypeChecker("boolean"),
              func: createPrimitiveTypeChecker("function"),
              number: createPrimitiveTypeChecker("number"),
              object: createPrimitiveTypeChecker("object"),
              string: createPrimitiveTypeChecker("string"),
              symbol: createPrimitiveTypeChecker("symbol"),
              any: createAnyTypeChecker(),
              arrayOf: createArrayOfTypeChecker,
              element: createElementTypeChecker(),
              elementType: createElementTypeTypeChecker(),
              instanceOf: createInstanceTypeChecker,
              node: createNodeChecker(),
              objectOf: createObjectOfTypeChecker,
              oneOf: createEnumTypeChecker,
              oneOfType: createUnionTypeChecker,
              shape: createShapeTypeChecker,
              exact: createStrictShapeTypeChecker
            };
            function is2(x2, y2) {
              if (x2 === y2) {
                return x2 !== 0 || 1 / x2 === 1 / y2;
              } else {
                return x2 !== x2 && y2 !== y2;
              }
            }
            function PropTypeError(message, data2) {
              this.message = message;
              this.data = data2 && typeof data2 === "object" ? data2 : {};
              this.stack = "";
            }
            PropTypeError.prototype = Error.prototype;
            function createChainableTypeChecker(validate) {
              {
                var manualPropTypeCallCache = {};
                var manualPropTypeWarningCount = 0;
              }
              function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                componentName = componentName || ANONYMOUS;
                propFullName = propFullName || propName;
                if (secret !== ReactPropTypesSecret) {
                  if (throwOnDirectAccess) {
                    var err = new Error(
                      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                    );
                    err.name = "Invariant Violation";
                    throw err;
                  } else if (typeof console !== "undefined") {
                    var cacheKey = componentName + ":" + propName;
                    if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                      printWarning(
                        "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                      );
                      manualPropTypeCallCache[cacheKey] = true;
                      manualPropTypeWarningCount++;
                    }
                  }
                }
                if (props[propName] == null) {
                  if (isRequired) {
                    if (props[propName] === null) {
                      return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                    }
                    return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
                  }
                  return null;
                } else {
                  return validate(props, propName, componentName, location, propFullName);
                }
              }
              var chainedCheckType = checkType.bind(null, false);
              chainedCheckType.isRequired = checkType.bind(null, true);
              return chainedCheckType;
            }
            function createPrimitiveTypeChecker(expectedType) {
              function validate(props, propName, componentName, location, propFullName, secret) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== expectedType) {
                  var preciseType = getPreciseType(propValue);
                  return new PropTypeError(
                    "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                    { expectedType }
                  );
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createAnyTypeChecker() {
              return createChainableTypeChecker(emptyFunctionThatReturnsNull);
            }
            function createArrayOfTypeChecker(typeChecker) {
              function validate(props, propName, componentName, location, propFullName) {
                if (typeof typeChecker !== "function") {
                  return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
                }
                var propValue = props[propName];
                if (!Array.isArray(propValue)) {
                  var propType = getPropType(propValue);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
                }
                for (var i2 = 0; i2 < propValue.length; i2++) {
                  var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
                  if (error instanceof Error) {
                    return error;
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createElementTypeChecker() {
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                if (!isValidElement(propValue)) {
                  var propType = getPropType(propValue);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createElementTypeTypeChecker() {
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                if (!ReactIs.isValidElementType(propValue)) {
                  var propType = getPropType(propValue);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createInstanceTypeChecker(expectedClass) {
              function validate(props, propName, componentName, location, propFullName) {
                if (!(props[propName] instanceof expectedClass)) {
                  var expectedClassName = expectedClass.name || ANONYMOUS;
                  var actualClassName = getClassName(props[propName]);
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createEnumTypeChecker(expectedValues) {
              if (!Array.isArray(expectedValues)) {
                {
                  if (arguments.length > 1) {
                    printWarning(
                      "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                    );
                  } else {
                    printWarning("Invalid argument supplied to oneOf, expected an array.");
                  }
                }
                return emptyFunctionThatReturnsNull;
              }
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                for (var i2 = 0; i2 < expectedValues.length; i2++) {
                  if (is2(propValue, expectedValues[i2])) {
                    return null;
                  }
                }
                var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                  var type = getPreciseType(value);
                  if (type === "symbol") {
                    return String(value);
                  }
                  return value;
                });
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
              }
              return createChainableTypeChecker(validate);
            }
            function createObjectOfTypeChecker(typeChecker) {
              function validate(props, propName, componentName, location, propFullName) {
                if (typeof typeChecker !== "function") {
                  return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
                }
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
                }
                for (var key in propValue) {
                  if (has(propValue, key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                    if (error instanceof Error) {
                      return error;
                    }
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createUnionTypeChecker(arrayOfTypeCheckers) {
              if (!Array.isArray(arrayOfTypeCheckers)) {
                printWarning("Invalid argument supplied to oneOfType, expected an instance of array.");
                return emptyFunctionThatReturnsNull;
              }
              for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
                var checker = arrayOfTypeCheckers[i2];
                if (typeof checker !== "function") {
                  printWarning(
                    "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
                  );
                  return emptyFunctionThatReturnsNull;
                }
              }
              function validate(props, propName, componentName, location, propFullName) {
                var expectedTypes = [];
                for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
                  var checker2 = arrayOfTypeCheckers[i3];
                  var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
                  if (checkerResult == null) {
                    return null;
                  }
                  if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                    expectedTypes.push(checkerResult.data.expectedType);
                  }
                }
                var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
              }
              return createChainableTypeChecker(validate);
            }
            function createNodeChecker() {
              function validate(props, propName, componentName, location, propFullName) {
                if (!isNode2(props[propName])) {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function invalidValidatorError(componentName, location, propFullName, key, type) {
              return new PropTypeError(
                (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
              );
            }
            function createShapeTypeChecker(shapeTypes) {
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                }
                for (var key in shapeTypes) {
                  var checker = shapeTypes[key];
                  if (typeof checker !== "function") {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                  }
                  var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                  if (error) {
                    return error;
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function createStrictShapeTypeChecker(shapeTypes) {
              function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== "object") {
                  return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                }
                var allKeys = assign2({}, props[propName], shapeTypes);
                for (var key in allKeys) {
                  var checker = shapeTypes[key];
                  if (has(shapeTypes, key) && typeof checker !== "function") {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                  }
                  if (!checker) {
                    return new PropTypeError(
                      "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                    );
                  }
                  var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                  if (error) {
                    return error;
                  }
                }
                return null;
              }
              return createChainableTypeChecker(validate);
            }
            function isNode2(propValue) {
              switch (typeof propValue) {
                case "number":
                case "string":
                case "undefined":
                  return true;
                case "boolean":
                  return !propValue;
                case "object":
                  if (Array.isArray(propValue)) {
                    return propValue.every(isNode2);
                  }
                  if (propValue === null || isValidElement(propValue)) {
                    return true;
                  }
                  var iteratorFn = getIteratorFn(propValue);
                  if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) {
                      while (!(step = iterator.next()).done) {
                        if (!isNode2(step.value)) {
                          return false;
                        }
                      }
                    } else {
                      while (!(step = iterator.next()).done) {
                        var entry = step.value;
                        if (entry) {
                          if (!isNode2(entry[1])) {
                            return false;
                          }
                        }
                      }
                    }
                  } else {
                    return false;
                  }
                  return true;
                default:
                  return false;
              }
            }
            function isSymbol(propType, propValue) {
              if (propType === "symbol") {
                return true;
              }
              if (!propValue) {
                return false;
              }
              if (propValue["@@toStringTag"] === "Symbol") {
                return true;
              }
              if (typeof Symbol === "function" && propValue instanceof Symbol) {
                return true;
              }
              return false;
            }
            function getPropType(propValue) {
              var propType = typeof propValue;
              if (Array.isArray(propValue)) {
                return "array";
              }
              if (propValue instanceof RegExp) {
                return "object";
              }
              if (isSymbol(propType, propValue)) {
                return "symbol";
              }
              return propType;
            }
            function getPreciseType(propValue) {
              if (typeof propValue === "undefined" || propValue === null) {
                return "" + propValue;
              }
              var propType = getPropType(propValue);
              if (propType === "object") {
                if (propValue instanceof Date) {
                  return "date";
                } else if (propValue instanceof RegExp) {
                  return "regexp";
                }
              }
              return propType;
            }
            function getPostfixForTypeWarning(value) {
              var type = getPreciseType(value);
              switch (type) {
                case "array":
                case "object":
                  return "an " + type;
                case "boolean":
                case "date":
                case "regexp":
                  return "a " + type;
                default:
                  return type;
              }
            }
            function getClassName(propValue) {
              if (!propValue.constructor || !propValue.constructor.name) {
                return ANONYMOUS;
              }
              return propValue.constructor.name;
            }
            ReactPropTypes.checkPropTypes = checkPropTypes;
            ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
            ReactPropTypes.PropTypes = ReactPropTypes;
            return ReactPropTypes;
          };
        },
        "./node_modules/prop-types/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          {
            var ReactIs = __webpack_require__2("./node_modules/react-is/index.js");
            var throwOnDirectAccess = true;
            module3.exports = __webpack_require__2("./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
          }
        },
        "./node_modules/prop-types/lib/ReactPropTypesSecret.js": (module3) => {
          var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
          module3.exports = ReactPropTypesSecret;
        },
        "./node_modules/prop-types/lib/has.js": (module3) => {
          module3.exports = Function.call.bind(Object.prototype.hasOwnProperty);
        },
        "./node_modules/react-is/cjs/react-is.development.js": (__unused_webpack_module, exports2) => {
          /** @license React v16.13.1
           * react-is.development.js
           *
           * Copyright (c) Facebook, Inc. and its affiliates.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           */
          {
            (function() {
              var hasSymbol2 = typeof Symbol === "function" && Symbol.for;
              var REACT_ELEMENT_TYPE = hasSymbol2 ? Symbol.for("react.element") : 60103;
              var REACT_PORTAL_TYPE = hasSymbol2 ? Symbol.for("react.portal") : 60106;
              var REACT_FRAGMENT_TYPE = hasSymbol2 ? Symbol.for("react.fragment") : 60107;
              var REACT_STRICT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.strict_mode") : 60108;
              var REACT_PROFILER_TYPE = hasSymbol2 ? Symbol.for("react.profiler") : 60114;
              var REACT_PROVIDER_TYPE = hasSymbol2 ? Symbol.for("react.provider") : 60109;
              var REACT_CONTEXT_TYPE = hasSymbol2 ? Symbol.for("react.context") : 60110;
              var REACT_ASYNC_MODE_TYPE = hasSymbol2 ? Symbol.for("react.async_mode") : 60111;
              var REACT_CONCURRENT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.concurrent_mode") : 60111;
              var REACT_FORWARD_REF_TYPE = hasSymbol2 ? Symbol.for("react.forward_ref") : 60112;
              var REACT_SUSPENSE_TYPE = hasSymbol2 ? Symbol.for("react.suspense") : 60113;
              var REACT_SUSPENSE_LIST_TYPE = hasSymbol2 ? Symbol.for("react.suspense_list") : 60120;
              var REACT_MEMO_TYPE = hasSymbol2 ? Symbol.for("react.memo") : 60115;
              var REACT_LAZY_TYPE = hasSymbol2 ? Symbol.for("react.lazy") : 60116;
              var REACT_BLOCK_TYPE = hasSymbol2 ? Symbol.for("react.block") : 60121;
              var REACT_FUNDAMENTAL_TYPE = hasSymbol2 ? Symbol.for("react.fundamental") : 60117;
              var REACT_RESPONDER_TYPE = hasSymbol2 ? Symbol.for("react.responder") : 60118;
              var REACT_SCOPE_TYPE = hasSymbol2 ? Symbol.for("react.scope") : 60119;
              function isValidElementType(type) {
                return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
              }
              function typeOf(object2) {
                if (typeof object2 === "object" && object2 !== null) {
                  var $$typeof = object2.$$typeof;
                  switch ($$typeof) {
                    case REACT_ELEMENT_TYPE:
                      var type = object2.type;
                      switch (type) {
                        case REACT_ASYNC_MODE_TYPE:
                        case REACT_CONCURRENT_MODE_TYPE:
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                          return type;
                        default:
                          var $$typeofType = type && type.$$typeof;
                          switch ($$typeofType) {
                            case REACT_CONTEXT_TYPE:
                            case REACT_FORWARD_REF_TYPE:
                            case REACT_LAZY_TYPE:
                            case REACT_MEMO_TYPE:
                            case REACT_PROVIDER_TYPE:
                              return $$typeofType;
                            default:
                              return $$typeof;
                          }
                      }
                    case REACT_PORTAL_TYPE:
                      return $$typeof;
                  }
                }
                return void 0;
              }
              var AsyncMode = REACT_ASYNC_MODE_TYPE;
              var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
              var ContextConsumer = REACT_CONTEXT_TYPE;
              var ContextProvider = REACT_PROVIDER_TYPE;
              var Element2 = REACT_ELEMENT_TYPE;
              var ForwardRef2 = REACT_FORWARD_REF_TYPE;
              var Fragment2 = REACT_FRAGMENT_TYPE;
              var Lazy = REACT_LAZY_TYPE;
              var Memo = REACT_MEMO_TYPE;
              var Portal = REACT_PORTAL_TYPE;
              var Profiler = REACT_PROFILER_TYPE;
              var StrictMode = REACT_STRICT_MODE_TYPE;
              var Suspense = REACT_SUSPENSE_TYPE;
              var hasWarnedAboutDeprecatedIsAsyncMode = false;
              function isAsyncMode(object2) {
                {
                  if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true;
                    console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
                  }
                }
                return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
              }
              function isConcurrentMode(object2) {
                return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
              }
              function isContextConsumer(object2) {
                return typeOf(object2) === REACT_CONTEXT_TYPE;
              }
              function isContextProvider(object2) {
                return typeOf(object2) === REACT_PROVIDER_TYPE;
              }
              function isElement2(object2) {
                return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
              }
              function isForwardRef(object2) {
                return typeOf(object2) === REACT_FORWARD_REF_TYPE;
              }
              function isFragment(object2) {
                return typeOf(object2) === REACT_FRAGMENT_TYPE;
              }
              function isLazy(object2) {
                return typeOf(object2) === REACT_LAZY_TYPE;
              }
              function isMemo(object2) {
                return typeOf(object2) === REACT_MEMO_TYPE;
              }
              function isPortal(object2) {
                return typeOf(object2) === REACT_PORTAL_TYPE;
              }
              function isProfiler(object2) {
                return typeOf(object2) === REACT_PROFILER_TYPE;
              }
              function isStrictMode(object2) {
                return typeOf(object2) === REACT_STRICT_MODE_TYPE;
              }
              function isSuspense(object2) {
                return typeOf(object2) === REACT_SUSPENSE_TYPE;
              }
              exports2.AsyncMode = AsyncMode;
              exports2.ConcurrentMode = ConcurrentMode;
              exports2.ContextConsumer = ContextConsumer;
              exports2.ContextProvider = ContextProvider;
              exports2.Element = Element2;
              exports2.ForwardRef = ForwardRef2;
              exports2.Fragment = Fragment2;
              exports2.Lazy = Lazy;
              exports2.Memo = Memo;
              exports2.Portal = Portal;
              exports2.Profiler = Profiler;
              exports2.StrictMode = StrictMode;
              exports2.Suspense = Suspense;
              exports2.isAsyncMode = isAsyncMode;
              exports2.isConcurrentMode = isConcurrentMode;
              exports2.isContextConsumer = isContextConsumer;
              exports2.isContextProvider = isContextProvider;
              exports2.isElement = isElement2;
              exports2.isForwardRef = isForwardRef;
              exports2.isFragment = isFragment;
              exports2.isLazy = isLazy;
              exports2.isMemo = isMemo;
              exports2.isPortal = isPortal;
              exports2.isProfiler = isProfiler;
              exports2.isStrictMode = isStrictMode;
              exports2.isSuspense = isSuspense;
              exports2.isValidElementType = isValidElementType;
              exports2.typeOf = typeOf;
            })();
          }
        },
        "./node_modules/react-is/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          {
            module3.exports = __webpack_require__2("./node_modules/react-is/cjs/react-is.development.js");
          }
        },
        "./node_modules/shallow-equal/dist/index.esm.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
          __webpack_require__2.r(__webpack_exports__2);
          __webpack_require__2.d(__webpack_exports__2, {
            "shallowEqualArrays": () => shallowEqualArrays,
            "shallowEqualObjects": () => shallowEqualObjects
          });
          function shallowEqualObjects(objA, objB) {
            if (objA === objB) {
              return true;
            }
            if (!objA || !objB) {
              return false;
            }
            var aKeys = Object.keys(objA);
            var bKeys = Object.keys(objB);
            var len = aKeys.length;
            if (bKeys.length !== len) {
              return false;
            }
            for (var i2 = 0; i2 < len; i2++) {
              var key = aKeys[i2];
              if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
                return false;
              }
            }
            return true;
          }
          function shallowEqualArrays(arrA, arrB) {
            if (arrA === arrB) {
              return true;
            }
            if (!arrA || !arrB) {
              return false;
            }
            var len = arrA.length;
            if (arrB.length !== len) {
              return false;
            }
            for (var i2 = 0; i2 < len; i2++) {
              if (arrA[i2] !== arrB[i2]) {
                return false;
              }
            }
            return true;
          }
        },
        "./src/Component.ts": function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __rest2 = this && this.__rest || function(s2, e3) {
            var t2 = {};
            for (var p2 in s2)
              if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                t2[p2] = s2[p2];
            if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
              for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                  t2[p2[i2]] = s2[p2[i2]];
              }
            return t2;
          };
          var __importDefault2 = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var useMediaQuery_1 = __importDefault2(__webpack_require__2("./src/useMediaQuery.ts"));
          var MediaQuery = function(_a2) {
            var children = _a2.children, device = _a2.device, onChange = _a2.onChange, settings = __rest2(_a2, ["children", "device", "onChange"]);
            var matches = (0, useMediaQuery_1.default)(settings, device, onChange);
            if (typeof children === "function") {
              return children(matches);
            }
            return matches ? children : null;
          };
          exports2["default"] = MediaQuery;
        },
        "./src/Context.ts": (__unused_webpack_module, exports2, __webpack_require__2) => {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var react_12 = __webpack_require__2("react");
          var Context = (0, react_12.createContext)(void 0);
          exports2["default"] = Context;
        },
        "./src/index.ts": function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __importDefault2 = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Context = exports2.toQuery = exports2.useMediaQuery = exports2["default"] = void 0;
          var useMediaQuery_1 = __importDefault2(__webpack_require__2("./src/useMediaQuery.ts"));
          exports2.useMediaQuery = useMediaQuery_1.default;
          var Component_1 = __importDefault2(__webpack_require__2("./src/Component.ts"));
          exports2["default"] = Component_1.default;
          var toQuery_1 = __importDefault2(__webpack_require__2("./src/toQuery.ts"));
          exports2.toQuery = toQuery_1.default;
          var Context_1 = __importDefault2(__webpack_require__2("./src/Context.ts"));
          exports2.Context = Context_1.default;
        },
        "./src/mediaQuery.ts": function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __assign2 = this && this.__assign || function() {
            __assign2 = Object.assign || function(t2) {
              for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
                s2 = arguments[i2];
                for (var p2 in s2)
                  if (Object.prototype.hasOwnProperty.call(s2, p2))
                    t2[p2] = s2[p2];
              }
              return t2;
            };
            return __assign2.apply(this, arguments);
          };
          var __rest2 = this && this.__rest || function(s2, e3) {
            var t2 = {};
            for (var p2 in s2)
              if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                t2[p2] = s2[p2];
            if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
              for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                  t2[p2[i2]] = s2[p2[i2]];
              }
            return t2;
          };
          var __importDefault2 = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var prop_types_1 = __importDefault2(__webpack_require__2("./node_modules/prop-types/index.js"));
          var stringOrNumber = prop_types_1.default.oneOfType([
            prop_types_1.default.string,
            prop_types_1.default.number
          ]);
          var types2 = {
            all: prop_types_1.default.bool,
            grid: prop_types_1.default.bool,
            aural: prop_types_1.default.bool,
            braille: prop_types_1.default.bool,
            handheld: prop_types_1.default.bool,
            print: prop_types_1.default.bool,
            projection: prop_types_1.default.bool,
            screen: prop_types_1.default.bool,
            tty: prop_types_1.default.bool,
            tv: prop_types_1.default.bool,
            embossed: prop_types_1.default.bool
          };
          var matchers = {
            orientation: prop_types_1.default.oneOf([
              "portrait",
              "landscape"
            ]),
            scan: prop_types_1.default.oneOf([
              "progressive",
              "interlace"
            ]),
            aspectRatio: prop_types_1.default.string,
            deviceAspectRatio: prop_types_1.default.string,
            height: stringOrNumber,
            deviceHeight: stringOrNumber,
            width: stringOrNumber,
            deviceWidth: stringOrNumber,
            color: prop_types_1.default.bool,
            colorIndex: prop_types_1.default.bool,
            monochrome: prop_types_1.default.bool,
            resolution: stringOrNumber,
            type: Object.keys(types2)
          };
          matchers.type;
          var featureMatchers = __rest2(
            matchers,
            ["type"]
          );
          var features2 = __assign2({ minAspectRatio: prop_types_1.default.string, maxAspectRatio: prop_types_1.default.string, minDeviceAspectRatio: prop_types_1.default.string, maxDeviceAspectRatio: prop_types_1.default.string, minHeight: stringOrNumber, maxHeight: stringOrNumber, minDeviceHeight: stringOrNumber, maxDeviceHeight: stringOrNumber, minWidth: stringOrNumber, maxWidth: stringOrNumber, minDeviceWidth: stringOrNumber, maxDeviceWidth: stringOrNumber, minColor: prop_types_1.default.number, maxColor: prop_types_1.default.number, minColorIndex: prop_types_1.default.number, maxColorIndex: prop_types_1.default.number, minMonochrome: prop_types_1.default.number, maxMonochrome: prop_types_1.default.number, minResolution: stringOrNumber, maxResolution: stringOrNumber }, featureMatchers);
          var all = __assign2(__assign2({}, types2), features2);
          exports2["default"] = {
            all,
            types: types2,
            matchers,
            features: features2
          };
        },
        "./src/toQuery.ts": function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __importDefault2 = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var hyphenate_style_name_1 = __importDefault2(__webpack_require__2("./node_modules/hyphenate-style-name/index.js"));
          var mediaQuery_1 = __importDefault2(__webpack_require__2("./src/mediaQuery.ts"));
          var negate = function(cond) {
            return "not ".concat(cond);
          };
          var keyVal = function(k2, v2) {
            var realKey = (0, hyphenate_style_name_1.default)(k2);
            if (typeof v2 === "number") {
              v2 = "".concat(v2, "px");
            }
            if (v2 === true) {
              return realKey;
            }
            if (v2 === false) {
              return negate(realKey);
            }
            return "(".concat(realKey, ": ").concat(v2, ")");
          };
          var join2 = function(conds) {
            return conds.join(" and ");
          };
          var toQuery = function(obj) {
            var rules = [];
            Object.keys(mediaQuery_1.default.all).forEach(function(k2) {
              var v2 = obj[k2];
              if (v2 != null) {
                rules.push(keyVal(k2, v2));
              }
            });
            return join2(rules);
          };
          exports2["default"] = toQuery;
        },
        "./src/useMediaQuery.ts": function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __importDefault2 = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var react_12 = __webpack_require__2("react");
          var matchmediaquery_1 = __importDefault2(__webpack_require__2("./node_modules/matchmediaquery/index.js"));
          var hyphenate_style_name_1 = __importDefault2(__webpack_require__2("./node_modules/hyphenate-style-name/index.js"));
          var shallow_equal_1 = __webpack_require__2("./node_modules/shallow-equal/dist/index.esm.js");
          var toQuery_1 = __importDefault2(__webpack_require__2("./src/toQuery.ts"));
          var Context_1 = __importDefault2(__webpack_require__2("./src/Context.ts"));
          var makeQuery = function(settings) {
            return settings.query || (0, toQuery_1.default)(settings);
          };
          var hyphenateKeys = function(obj) {
            if (!obj)
              return void 0;
            var keys = Object.keys(obj);
            return keys.reduce(function(result, key) {
              result[(0, hyphenate_style_name_1.default)(key)] = obj[key];
              return result;
            }, {});
          };
          var useIsUpdate = function() {
            var ref = (0, react_12.useRef)(false);
            (0, react_12.useEffect)(function() {
              ref.current = true;
            }, []);
            return ref.current;
          };
          var useDevice = function(deviceFromProps) {
            var deviceFromContext = (0, react_12.useContext)(Context_1.default);
            var getDevice = function() {
              return hyphenateKeys(deviceFromProps) || hyphenateKeys(deviceFromContext);
            };
            var _a2 = (0, react_12.useState)(getDevice), device = _a2[0], setDevice = _a2[1];
            (0, react_12.useEffect)(function() {
              var newDevice = getDevice();
              if (!(0, shallow_equal_1.shallowEqualObjects)(device, newDevice)) {
                setDevice(newDevice);
              }
            }, [deviceFromProps, deviceFromContext]);
            return device;
          };
          var useQuery2 = function(settings) {
            var getQuery = function() {
              return makeQuery(settings);
            };
            var _a2 = (0, react_12.useState)(getQuery), query = _a2[0], setQuery = _a2[1];
            (0, react_12.useEffect)(function() {
              var newQuery = getQuery();
              if (query !== newQuery) {
                setQuery(newQuery);
              }
            }, [settings]);
            return query;
          };
          var useMatchMedia = function(query, device) {
            var getMatchMedia = function() {
              return (0, matchmediaquery_1.default)(query, device || {}, !!device);
            };
            var _a2 = (0, react_12.useState)(getMatchMedia), mq = _a2[0], setMq = _a2[1];
            var isUpdate = useIsUpdate();
            (0, react_12.useEffect)(function() {
              if (isUpdate) {
                var newMq_1 = getMatchMedia();
                setMq(newMq_1);
                return function() {
                  if (newMq_1) {
                    newMq_1.dispose();
                  }
                };
              }
            }, [query, device]);
            return mq;
          };
          var useMatches = function(mediaQuery) {
            var _a2 = (0, react_12.useState)(mediaQuery.matches), matches = _a2[0], setMatches = _a2[1];
            (0, react_12.useEffect)(function() {
              var updateMatches = function(ev) {
                setMatches(ev.matches);
              };
              mediaQuery.addListener(updateMatches);
              setMatches(mediaQuery.matches);
              return function() {
                mediaQuery.removeListener(updateMatches);
              };
            }, [mediaQuery]);
            return matches;
          };
          var useMediaQuery = function(settings, device, onChange) {
            var deviceSettings = useDevice(device);
            var query = useQuery2(settings);
            if (!query)
              throw new Error("Invalid or missing MediaQuery!");
            var mq = useMatchMedia(query, deviceSettings);
            var matches = useMatches(mq);
            var isUpdate = useIsUpdate();
            (0, react_12.useEffect)(function() {
              if (isUpdate && onChange) {
                onChange(matches);
              }
            }, [matches]);
            (0, react_12.useEffect)(function() {
              return function() {
                if (mq) {
                  mq.dispose();
                }
              };
            }, []);
            return matches;
          };
          exports2["default"] = useMediaQuery;
        },
        "react": (module3) => {
          module3.exports = __WEBPACK_EXTERNAL_MODULE_react__;
        }
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module3 = __webpack_module_cache__[moduleId] = {
          exports: {}
        };
        __webpack_modules__[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
        return module3.exports;
      }
      (() => {
        __webpack_require__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __webpack_require__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      var __webpack_exports__ = __webpack_require__("./src/index.ts");
      return __webpack_exports__;
    })();
  });
})(reactResponsive);
const useGeoLocation = (options = {}) => {
  const [country, setCountry] = react.exports.useState(options.country);
  const [error, setError] = react.exports.useState(false);
  const [isLoading, setIsLoading] = react.exports.useState(true);
  const api = options.api || "https://api.country.is";
  react.exports.useEffect(() => {
    let isCancelled = false;
    if (country || country === false)
      return;
    async function fetchAPI() {
      setIsLoading(true);
      await fetch(api).then((res) => {
        if (!res.ok) {
          throw Error(res.statusText);
        }
        return res.json();
      }).then((res) => {
        if (res && res.country && !isCancelled)
          setCountry(res.country);
      }).catch((err) => setError(err)).finally(() => setIsLoading(false));
    }
    fetchAPI();
    return () => {
      isCancelled = true;
    };
  }, []);
  return { country, error, isLoading };
};
export {
  ArrowTopRightOnSquareIcon$1 as $,
  ArrowLongRightIcon$3 as A,
  getMainDefinition as B,
  ChevronDownIcon$1 as C,
  ApolloClient as D,
  EllipsisVerticalIcon$1 as E,
  Fragment as F,
  GraphQLWsLink as G,
  HttpLink as H,
  InformationCircleIcon$1 as I,
  InMemoryCache as J,
  ApolloProvider as K,
  Lo as L,
  CheckCircleIcon$1 as M,
  LockClosedIcon$1 as N,
  Oe$2 as O,
  createColumnHelper as P,
  ArrowsUpDownIcon$1 as Q,
  React as R,
  Slider as S,
  Tooltip as T,
  CogIcon$1 as U,
  DateTime as V,
  We as W,
  Link as X,
  XMarkIcon$1 as Y,
  ChevronUpIcon$1 as Z,
  MagnifyingGlassIcon$1 as _,
  jsxs as a,
  ArrowLongRightIcon$1 as a0,
  ArrowDownIcon$1 as a1,
  ArrowLongLeftIcon$1 as a2,
  FireIcon$1 as a3,
  linear$1 as a4,
  ArrowLongRightIcon$5 as a5,
  NavLink as a6,
  Bars3Icon$1 as a7,
  XMarkIcon$3 as a8,
  reactResponsive as a9,
  useGeoLocation as aa,
  BrowserRouter as ab,
  Routes as ac,
  Route as ad,
  client as ae,
  React$1 as b,
  create as c,
  reactDom as d,
  useNavigate as e,
  useLocation as f,
  gt as g,
  be$2 as h,
  qe as i,
  jsx as j,
  useReactTable as k,
  flexRender as l,
  motion as m,
  mt as n,
  getCoreRowModel as o,
  pt as p,
  qe$1 as q,
  react as r,
  getSortedRowModel as s,
  useQuery as t,
  useAnimationControls as u,
  useSubscription as v,
  dist$2 as w,
  useMutation as x,
  createClient as y,
  split as z
};
