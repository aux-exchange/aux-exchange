// Autogenerated from ./docs/concliq/gen-math -p 64
// Manual edit with caution.
//
// Tick math for concentrated liquidity.
// square price is an u128 used as a fixed point number.
// Precision indicates how many bits are after decimal point.
// There are three optiosn for precision:
// - 64: only lower 96 bits of the u128 is used, decimal point is at index 64 of the u128 from the most significant bit.
// - 96: all the bits of the u128 is used, decimal point is at index 32 of the u128 from the most significant bit.
module aux::concliq_math {
    use aux::int32::{Self, Int32};
    use aux::int128::{Self, Int128};
    use aux::more_math_u256;
    use aux::more_math_u128;

    /**********************/
    /* Errors             */
    /**********************/

    const E_TICK_TOO_BIG: u64 = 1001;
    const E_TICK_TOO_SMALL: u64 = 1002;
    const E_Y_OUTSIDE_1_2: u64 = 1003;
    const E_ZERO_FOR_LOG_2: u64 = 1004;
    const E_Y_LESS_THAN_ONE: u64 = 1004;

    /**********************/
    /* constants          */
    /**********************/

    /// Precision used in the operation.
    const PRECISION: u8 = 64;
    const PRECISION_PLUS_32: u8 = 64 + 32;

    // ONE_X is 1 in fixed point number with 64 digits after decimal point.
    const ONE_X: u128 = 1 << 64;
    // TWO_X is 2 in fixed point number with 64 digits after decimal point.
    const TWO_X: u128 = 1 << (64 + 1);
    // ONE_X_256 is 1 in fixed point number with 64 digits after decimal point.
    const ONE_X_256: u256 = 1 << 64;
    // TWO_X_256 is 2 in fixed point number with 64 digits after decimal point.
    const TWO_X_256: u256 = 1 << (64 + 1);
    // ONE_X_TWICE_SHIFTED_256 is 1 in fixed point number with 2*64 digits after decimal point. It is generally acting as numerator for division.
    const ONE_X_TWICE_SHIFTED_256: u256 = (1 << 64) << 64;
    // ONE_32 is 1 << 32;
    const ONE_32: u256 = 1 << 32;

    /// sqrt(1.0001) in fixed point 64
    const SQUARE_PRICE: u128 = 18447666387855959850;
    /// log_2 sqrt(1.0001) in fixed point 64
    const SQUARE_PRICE_LOG_2: u128 = 2535295485638337043275291122165;
    /// 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG: u256 = 18445821805675392311;
    /// log_2 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG_LOG_2_ABS: u256 = 2535306915274580562721192034936;

    /// get sqrt(1.0001)^i
    public fun get_square_price_from_tick(i: Int32): u128 {
        if (int32::is_negative(i)) {
            get_square_price_from_tick_negative(int32::abs(i))
        } else {
            get_square_price_from_tick_positive(int32::raw_value(i))
        }
    }

    /// get sqrt(1.0001)^i, where i >= 0
    public fun get_square_price_from_tick_positive(i: u32): u128 {
        assert!(i <= 443636, E_TICK_TOO_BIG);
        let r = ONE_X_256;

        // check for 2^0
        if (i & 1 > 0) {
            r = r * 18447666387855959850;
            r = r >> PRECISION;
        };

        // check for 2^1
        if (i & 2 > 0) {
            r = r * 18448588748116922571;
            r = r >> PRECISION;
        };

        // check for 2^2
        if (i & 4 > 0) {
            r = r * 18450433606991734263;
            r = r >> PRECISION;
        };

        // check for 2^3
        if (i & 8 > 0) {
            r = r * 18454123878217468680;
            r = r >> PRECISION;
        };

        // check for 2^4
        if (i & 16 > 0) {
            r = r * 18461506635090006701;
            r = r >> PRECISION;
        };

        // check for 2^5
        if (i & 32 > 0) {
            r = r * 18476281010653910144;
            r = r >> PRECISION;
        };

        // check for 2^6
        if (i & 64 > 0) {
            r = r * 18505865242158250041;
            r = r >> PRECISION;
        };

        // check for 2^7
        if (i & 128 > 0) {
            r = r * 18565175891880433522;
            r = r >> PRECISION;
        };

        // check for 2^8
        if (i & 256 > 0) {
            r = r * 18684368066214940582;
            r = r >> PRECISION;
        };

        // check for 2^9
        if (i & 512 > 0) {
            r = r * 18925053041275764671;
            r = r >> PRECISION;
        };

        // check for 2^10
        if (i & 1024 > 0) {
            r = r * 19415764168677886926;
            r = r >> PRECISION;
        };

        // check for 2^11
        if (i & 2048 > 0) {
            r = r * 20435687552633177494;
            r = r >> PRECISION;
        };

        // check for 2^12
        if (i & 4096 > 0) {
            r = r * 22639080592224303007;
            r = r >> PRECISION;
        };

        // check for 2^13
        if (i & 8192 > 0) {
            r = r * 27784196929998399742;
            r = r >> PRECISION;
        };

        // check for 2^14
        if (i & 16384 > 0) {
            r = r * 41848122137994986128;
            r = r >> PRECISION;
        };

        // check for 2^15
        if (i & 32768 > 0) {
            r = r * 94936283578220370716;
            r = r >> PRECISION;
        };

        // check for 2^16
        if (i & 65536 > 0) {
            r = r * 488590176327622479860;
            r = r >> PRECISION;
        };

        // check for 2^17
        if (i & 131072 > 0) {
            r = r * 12941056668319229769860;
            r = r >> PRECISION;
        };

        // check for 2^18
        if (i & 262144 > 0) {
            r = r * 9078618265828848800676189;
            r = r >> PRECISION;
        };

        ((r >> 32) as u128)
    }

    /// get sqrt(1.0001)^(-i), where i >= 0
    public fun get_square_price_from_tick_negative(i: u32): u128 {
        assert!(i <= 443636, E_TICK_TOO_BIG);
        let r = (ONE_X as u256);
        if (i & 1 > 0) {
            r = r * 18445821805675392311;
            r = r >> PRECISION;
        };
        if (i & 2 > 0) {
            r = r * 18444899583751176498;
            r = r >> PRECISION;
        };
        if (i & 4 > 0) {
            r = r * 18443055278223354162;
            r = r >> PRECISION;
        };
        if (i & 8 > 0) {
            r = r * 18439367220385604838;
            r = r >> PRECISION;
        };
        if (i & 16 > 0) {
            r = r * 18431993317065449817;
            r = r >> PRECISION;
        };
        if (i & 32 > 0) {
            r = r * 18417254355718160513;
            r = r >> PRECISION;
        };
        if (i & 64 > 0) {
            r = r * 18387811781193591352;
            r = r >> PRECISION;
        };
        if (i & 128 > 0) {
            r = r * 18329067761203520168;
            r = r >> PRECISION;
        };
        if (i & 256 > 0) {
            r = r * 18212142134806087854;
            r = r >> PRECISION;
        };
        if (i & 512 > 0) {
            r = r * 17980523815641551639;
            r = r >> PRECISION;
        };
        if (i & 1024 > 0) {
            r = r * 17526086738831147013;
            r = r >> PRECISION;
        };
        if (i & 2048 > 0) {
            r = r * 16651378430235024244;
            r = r >> PRECISION;
        };
        if (i & 4096 > 0) {
            r = r * 15030750278693429944;
            r = r >> PRECISION;
        };
        if (i & 8192 > 0) {
            r = r * 12247334978882834399;
            r = r >> PRECISION;
        };
        if (i & 16384 > 0) {
            r = r * 8131365268884726200;
            r = r >> PRECISION;
        };
        if (i & 32768 > 0) {
            r = r * 3584323654723342297;
            r = r >> PRECISION;
        };
        if (i & 65536 > 0) {
            r = r * 696457651847595233;
            r = r >> PRECISION;
        };
        if (i & 131072 > 0) {
            r = r * 26294789957452057;
            r = r >> PRECISION;
        };
        if (i & 262144 > 0) {
            r = r * 37481735321082;
            r = r >> PRECISION;
        };

        ((r >> 32) as u128)
    }

    /// log_2 for log_{sqrt{1.0001}} y
    public fun log_2(y: u128): Int128 {
        assert!(y != 0, E_ZERO_FOR_LOG_2);
        let leading_zeros = more_math_u128::leading_zeros(y);
        if (y == ONE_X) {
            int128::zero()
        } else if (y > ONE_X) {
            let n_0: u8 = 128 - PRECISION - leading_zeros - 1;
            let r = (n_0 as u128) << PRECISION;
            let d = (more_math_u256::log_2((y as u256) >> n_0, PRECISION) as u128);
            int128::new(r + d, false)
        } else {
            let n_0: u8 = leading_zeros - (128 - PRECISION - 1);
            let r = (n_0 as u128) << PRECISION;
            let intpart = int128::new(r, true);
            let d = (more_math_u256::log_2((y as u256) << n_0, PRECISION) as u128);
            int128::add(int128::new(d, false), intpart)
        }
    }

    /// get the tick from sqrt price
    public fun get_tick(sqrt_p: u128): Int32 {
        let log_2_y = log_2(sqrt_p);
        let is_neg = int128::is_negative(log_2_y);
        let log_2_y = int128::abs(log_2_y);
        let ratio = if (is_neg) {
            let r = log_2_y / SQUARE_PRICE_NEG_LOG_2_ABS;
            if (r * SQUARE_PRICE_NEG_LOG_2_ABS < log_2_y) {
                r + 1
            } else {
                r
            }
        } else {
            log_2_y / SQUARE_PRICE_LOG_2
        };
        int32::new((ratio as u32), is_neg)
    }

    /// price
    public fun get_price(x: u64, y: u64): u256 {
        let x = (x as u256) << PRECISION;
        let y = (y as u256);
        x / y
    }

    /// get the sqrt price sqrt(x/y)
    public fun get_sqrt_price(x: u64, y: u64): u128 {
        let x = ((x as u256) << PRECISION) << PRECISION;
        let y = (y as u256);
        (more_math_u256::sqrt(x / y) as u128)
    }

    /// get sqrt price for a fixed point price with the same precision.
    public fun get_sqrt_price_from_price(price: u128): u128 {
        let price = (price as u256);
        price = price << PRECISION;
        let sqrt_price = more_math_u256::sqrt(price);
        (sqrt_price as u128)
    }

    /// check if this is a valid tick
    public fun is_valid_tick(tick: Int32, spacing: u32): bool {
        let abs_tick = int32::abs(tick);
        (abs_tick % spacing) == 0
    }

    /// making sure the tick spacing is between 1 and 256 inclusive.
    public fun is_valid_tick_spacing(tick_spacing: u32): bool {
        tick_spacing > 0 && tick_spacing <= 256
    }

    /// inverse returns 1/x
    public fun inverse(x: u128, round_up: bool): u128 {
        let x = (x as u256);
        let r = ONE_X_TWICE_SHIFTED_256 / x;
        if (round_up && (r * x < ONE_X_TWICE_SHIFTED_256)) {
            ((r + 1) as u128)
        } else {
            (r as u128)
        }
    }

    /// divide the fixed point number.
    public fun divide(numerator: u128, denominator: u128, round_up: bool): u128 {
        let numerator = (numerator as u256) << PRECISION;
        let denominator = (denominator as u256);
        let r = numerator / denominator;
        if (round_up && (r * denominator < numerator)) {
            ((r + 1) as u128)
        } else {
            (r as u128)
        }
    }

    #[test_only]
    public fun get_square_price_from_2_n_positive(i: u8): u128 {
        if (i == 0) {
            18447666387855959850
        } else if (i == 1) {
            18448588748116922571
        } else if (i == 2) {
            18450433606991734263
        } else if (i == 3) {
            18454123878217468680
        } else if (i == 4) {
            18461506635090006701
        } else if (i == 5) {
            18476281010653910144
        } else if (i == 6) {
            18505865242158250041
        } else if (i == 7) {
            18565175891880433522
        } else if (i == 8) {
            18684368066214940582
        } else if (i == 9) {
            18925053041275764671
        } else if (i == 10) {
            19415764168677886926
        } else if (i == 11) {
            20435687552633177494
        } else if (i == 12) {
            22639080592224303007
        } else if (i == 13) {
            27784196929998399742
        } else if (i == 14) {
            41848122137994986128
        } else if (i == 15) {
            94936283578220370716
        } else if (i == 16) {
            488590176327622479860
        } else if (i == 17) {
            12941056668319229769860
        } else if (i == 18) {
            9078618265828848800676189
        } else {
            abort((i as u64))
        }
    }

    #[test_only]
    public fun get_square_price_from_2_n_negative(i: u8): u128 {
        if (i == 0) {
            18445821805675392311
        } else if (i == 1) {
            18444899583751176498
        } else if (i == 2) {
            18443055278223354162
        } else if (i == 3) {
            18439367220385604838
        } else if (i == 4) {
            18431993317065449817
        } else if (i == 5) {
            18417254355718160513
        } else if (i == 6) {
            18387811781193591352
        } else if (i == 7) {
            18329067761203520168
        } else if (i == 8) {
            18212142134806087854
        } else if (i == 9) {
            17980523815641551639
        } else if (i == 10) {
            17526086738831147013
        } else if (i == 11) {
            16651378430235024244
        } else if (i == 12) {
            15030750278693429944
        } else if (i == 13) {
            12247334978882834399
        } else if (i == 14) {
            8131365268884726200
        } else if (i == 15) {
            3584323654723342297
        } else if (i == 16) {
            696457651847595233
        } else if (i == 17) {
            26294789957452057
        } else if (i == 18) {
            37481735321082
        } else {
            abort((i as u64))
        }
    }

    #[test]
    fun test_log_2_y() {
        assert!(int128::is_zero(log_2(ONE_X)), 1);

        // check positive side
        let square_price_0 = 18447666387855959850u128;
        let ratio_0 = get_tick(square_price_0);
        let abs_ratio_0 = int32::abs(ratio_0);
        assert!(abs_ratio_0 == 1, (abs_ratio_0 as u64)); // positive

        // check positive side
        let square_price_1 = 18448588748116922571u128;
        let ratio_1 = get_tick(square_price_1);
        let abs_ratio_1 = int32::abs(ratio_1);
        assert!(abs_ratio_1 == 2, (abs_ratio_1 as u64)); // positive

        // check positive side
        let square_price_2 = 18450433606991734263u128;
        let ratio_2 = get_tick(square_price_2);
        let abs_ratio_2 = int32::abs(ratio_2);
        assert!(abs_ratio_2 == 4, (abs_ratio_2 as u64)); // positive

        // check positive side
        let square_price_3 = 18454123878217468680u128;
        let ratio_3 = get_tick(square_price_3);
        let abs_ratio_3 = int32::abs(ratio_3);
        assert!(abs_ratio_3 == 8, (abs_ratio_3 as u64)); // positive

        // check positive side
        let square_price_4 = 18461506635090006701u128;
        let ratio_4 = get_tick(square_price_4);
        let abs_ratio_4 = int32::abs(ratio_4);
        assert!(abs_ratio_4 == 16, (abs_ratio_4 as u64)); // positive

        // check positive side
        let square_price_5 = 18476281010653910144u128;
        let ratio_5 = get_tick(square_price_5);
        let abs_ratio_5 = int32::abs(ratio_5);
        assert!(abs_ratio_5 == 32, (abs_ratio_5 as u64)); // positive

        // check positive side
        let square_price_6 = 18505865242158250041u128;
        let ratio_6 = get_tick(square_price_6);
        let abs_ratio_6 = int32::abs(ratio_6);
        assert!(abs_ratio_6 == 64, (abs_ratio_6 as u64)); // positive

        // check positive side
        let square_price_7 = 18565175891880433522u128;
        let ratio_7 = get_tick(square_price_7);
        let abs_ratio_7 = int32::abs(ratio_7);
        assert!(abs_ratio_7 == 128, (abs_ratio_7 as u64)); // positive

        // check positive side
        let square_price_8 = 18684368066214940582u128;
        let ratio_8 = get_tick(square_price_8);
        let abs_ratio_8 = int32::abs(ratio_8);
        assert!(abs_ratio_8 == 256, (abs_ratio_8 as u64)); // positive

        // check positive side
        let square_price_9 = 18925053041275764671u128;
        let ratio_9 = get_tick(square_price_9);
        let abs_ratio_9 = int32::abs(ratio_9);
        assert!(abs_ratio_9 == 512, (abs_ratio_9 as u64)); // positive

        // check positive side
        let square_price_10 = 19415764168677886926u128;
        let ratio_10 = get_tick(square_price_10);
        let abs_ratio_10 = int32::abs(ratio_10);
        assert!(abs_ratio_10 == 1024, (abs_ratio_10 as u64)); // positive

        // check positive side
        let square_price_11 = 20435687552633177494u128;
        let ratio_11 = get_tick(square_price_11);
        let abs_ratio_11 = int32::abs(ratio_11);
        assert!(abs_ratio_11 == 2048, (abs_ratio_11 as u64)); // positive

        // check positive side
        let square_price_12 = 22639080592224303007u128;
        let ratio_12 = get_tick(square_price_12);
        let abs_ratio_12 = int32::abs(ratio_12);
        assert!(abs_ratio_12 == 4096, (abs_ratio_12 as u64)); // positive

        // check positive side
        let square_price_13 = 27784196929998399742u128;
        let ratio_13 = get_tick(square_price_13);
        let abs_ratio_13 = int32::abs(ratio_13);
        assert!(abs_ratio_13 == 8192, (abs_ratio_13 as u64)); // positive

        // check positive side
        let square_price_14 = 41848122137994986128u128;
        let ratio_14 = get_tick(square_price_14);
        let abs_ratio_14 = int32::abs(ratio_14);
        assert!(abs_ratio_14 == 16384, (abs_ratio_14 as u64)); // positive

        // check positive side
        let square_price_15 = 94936283578220370716u128;
        let ratio_15 = get_tick(square_price_15);
        let abs_ratio_15 = int32::abs(ratio_15);
        assert!(abs_ratio_15 == 32768, (abs_ratio_15 as u64)); // positive

        // check positive side
        let square_price_16 = 488590176327622479860u128;
        let ratio_16 = get_tick(square_price_16);
        let abs_ratio_16 = int32::abs(ratio_16);
        assert!(abs_ratio_16 == 65536, (abs_ratio_16 as u64)); // positive

        // check positive side
        let square_price_17 = 12941056668319229769860u128;
        let ratio_17 = get_tick(square_price_17);
        let abs_ratio_17 = int32::abs(ratio_17);
        assert!(abs_ratio_17 == 131072, (abs_ratio_17 as u64)); // positive

        // check positive side
        let square_price_18 = 9078618265828848800676189u128;
        let ratio_18 = get_tick(square_price_18);
        let abs_ratio_18 = int32::abs(ratio_18);
        assert!(abs_ratio_18 == 262144, (abs_ratio_18 as u64)); // positive

        // check negative side
        let square_price_0 = 18445821805675392311u128;
        let ratio_0 = get_tick(square_price_0);
        let abs_ratio_0 = int32::abs(ratio_0);
        assert!(abs_ratio_0 == 1, (abs_ratio_0 as u64)); // negative

        // check negative side
        let square_price_1 = 18444899583751176498u128;
        let ratio_1 = get_tick(square_price_1);
        let abs_ratio_1 = int32::abs(ratio_1);
        assert!(abs_ratio_1 == 2, (abs_ratio_1 as u64)); // negative

        // check negative side
        let square_price_2 = 18443055278223354162u128;
        let ratio_2 = get_tick(square_price_2);
        let abs_ratio_2 = int32::abs(ratio_2);
        assert!(abs_ratio_2 == 4, (abs_ratio_2 as u64)); // negative

        // check negative side
        let square_price_3 = 18439367220385604838u128;
        let ratio_3 = get_tick(square_price_3);
        let abs_ratio_3 = int32::abs(ratio_3);
        assert!(abs_ratio_3 == 8, (abs_ratio_3 as u64)); // negative

        // check negative side
        let square_price_4 = 18431993317065449817u128;
        let ratio_4 = get_tick(square_price_4);
        let abs_ratio_4 = int32::abs(ratio_4);
        assert!(abs_ratio_4 == 16, (abs_ratio_4 as u64)); // negative

        // check negative side
        let square_price_5 = 18417254355718160513u128;
        let ratio_5 = get_tick(square_price_5);
        let abs_ratio_5 = int32::abs(ratio_5);
        assert!(abs_ratio_5 == 32, (abs_ratio_5 as u64)); // negative

        // check negative side
        let square_price_6 = 18387811781193591352u128;
        let ratio_6 = get_tick(square_price_6);
        let abs_ratio_6 = int32::abs(ratio_6);
        assert!(abs_ratio_6 == 64, (abs_ratio_6 as u64)); // negative

        // check negative side
        let square_price_7 = 18329067761203520168u128;
        let ratio_7 = get_tick(square_price_7);
        let abs_ratio_7 = int32::abs(ratio_7);
        assert!(abs_ratio_7 == 128, (abs_ratio_7 as u64)); // negative

        // check negative side
        let square_price_8 = 18212142134806087854u128;
        let ratio_8 = get_tick(square_price_8);
        let abs_ratio_8 = int32::abs(ratio_8);
        assert!(abs_ratio_8 == 256, (abs_ratio_8 as u64)); // negative

        // check negative side
        let square_price_9 = 17980523815641551639u128;
        let ratio_9 = get_tick(square_price_9);
        let abs_ratio_9 = int32::abs(ratio_9);
        assert!(abs_ratio_9 == 512, (abs_ratio_9 as u64)); // negative

        // check negative side
        let square_price_10 = 17526086738831147013u128;
        let ratio_10 = get_tick(square_price_10);
        let abs_ratio_10 = int32::abs(ratio_10);
        assert!(abs_ratio_10 == 1024, (abs_ratio_10 as u64)); // negative

        // check negative side
        let square_price_11 = 16651378430235024244u128;
        let ratio_11 = get_tick(square_price_11);
        let abs_ratio_11 = int32::abs(ratio_11);
        assert!(abs_ratio_11 == 2048, (abs_ratio_11 as u64)); // negative

        // check negative side
        let square_price_12 = 15030750278693429944u128;
        let ratio_12 = get_tick(square_price_12);
        let abs_ratio_12 = int32::abs(ratio_12);
        assert!(abs_ratio_12 == 4096, (abs_ratio_12 as u64)); // negative

        // check negative side
        let square_price_13 = 12247334978882834399u128;
        let ratio_13 = get_tick(square_price_13);
        let abs_ratio_13 = int32::abs(ratio_13);
        assert!(abs_ratio_13 == 8192, (abs_ratio_13 as u64)); // negative

        // check negative side
        let square_price_14 = 8131365268884726200u128;
        let ratio_14 = get_tick(square_price_14);
        let abs_ratio_14 = int32::abs(ratio_14);
        assert!(abs_ratio_14 == 16384, (abs_ratio_14 as u64)); // negative

        // check negative side
        let square_price_15 = 3584323654723342297u128;
        let ratio_15 = get_tick(square_price_15);
        let abs_ratio_15 = int32::abs(ratio_15);
        assert!(abs_ratio_15 == 32768, (abs_ratio_15 as u64)); // negative

        // check negative side
        let square_price_16 = 696457651847595233u128;
        let ratio_16 = get_tick(square_price_16);
        let abs_ratio_16 = int32::abs(ratio_16);
        assert!(abs_ratio_16 == 65536, (abs_ratio_16 as u64)); // negative

        // check negative side
        let square_price_17 = 26294789957452057u128;
        let ratio_17 = get_tick(square_price_17);
        let abs_ratio_17 = int32::abs(ratio_17);
        assert!(abs_ratio_17 == 131072, (abs_ratio_17 as u64)); // negative

        // check negative side
        let square_price_18 = 37481735321082u128;
        let ratio_18 = get_tick(square_price_18);
        let abs_ratio_18 = int32::abs(ratio_18);
        assert!(abs_ratio_18 == 262144, (abs_ratio_18 as u64)); // negative
    }

    #[test]
    fun test_inverse() {
        // check if the inverse can match back

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_0 = get_square_price_from_2_n_positive(0);
        let p_neg_0 = get_square_price_from_2_n_negative(0);
        let p_0_inverse = inverse(p_0, false);
        let diff_0 = int128::unsigned_subtract(p_0_inverse, p_neg_0);
        if (!int128::is_zero(diff_0)) {
            std::debug::print(&0);
            std::debug::print(&p_neg_0);
            std::debug::print(&p_0_inverse);
            std::debug::print(&diff_0);
        };
        let diff_0 = int128::abs(diff_0);
        assert!(diff_0 <= 1, (diff_0 as u64)); // positive index inverse

        let p_neg_0_inverse = inverse(p_neg_0, false);
        let diff_0 = int128::unsigned_subtract(p_neg_0_inverse, p_0);
        if (!int128::is_zero(diff_0)) {
            std::debug::print(&0);
            std::debug::print(&p_0);
            std::debug::print(&p_neg_0_inverse);
            std::debug::print(&diff_0);
        };
        let diff_0 = int128::abs(diff_0);
        assert!(diff_0 <= 1, (diff_0 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_1 = get_square_price_from_2_n_positive(1);
        let p_neg_1 = get_square_price_from_2_n_negative(1);
        let p_1_inverse = inverse(p_1, false);
        let diff_1 = int128::unsigned_subtract(p_1_inverse, p_neg_1);
        if (!int128::is_zero(diff_1)) {
            std::debug::print(&1);
            std::debug::print(&p_neg_1);
            std::debug::print(&p_1_inverse);
            std::debug::print(&diff_1);
        };
        let diff_1 = int128::abs(diff_1);
        assert!(diff_1 <= 1, (diff_1 as u64)); // positive index inverse

        let p_neg_1_inverse = inverse(p_neg_1, false);
        let diff_1 = int128::unsigned_subtract(p_neg_1_inverse, p_1);
        if (!int128::is_zero(diff_1)) {
            std::debug::print(&1);
            std::debug::print(&p_1);
            std::debug::print(&p_neg_1_inverse);
            std::debug::print(&diff_1);
        };
        let diff_1 = int128::abs(diff_1);
        assert!(diff_1 <= 1, (diff_1 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_2 = get_square_price_from_2_n_positive(2);
        let p_neg_2 = get_square_price_from_2_n_negative(2);
        let p_2_inverse = inverse(p_2, false);
        let diff_2 = int128::unsigned_subtract(p_2_inverse, p_neg_2);
        if (!int128::is_zero(diff_2)) {
            std::debug::print(&2);
            std::debug::print(&p_neg_2);
            std::debug::print(&p_2_inverse);
            std::debug::print(&diff_2);
        };
        let diff_2 = int128::abs(diff_2);
        assert!(diff_2 <= 1, (diff_2 as u64)); // positive index inverse

        let p_neg_2_inverse = inverse(p_neg_2, false);
        let diff_2 = int128::unsigned_subtract(p_neg_2_inverse, p_2);
        if (!int128::is_zero(diff_2)) {
            std::debug::print(&2);
            std::debug::print(&p_2);
            std::debug::print(&p_neg_2_inverse);
            std::debug::print(&diff_2);
        };
        let diff_2 = int128::abs(diff_2);
        assert!(diff_2 <= 1, (diff_2 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_3 = get_square_price_from_2_n_positive(3);
        let p_neg_3 = get_square_price_from_2_n_negative(3);
        let p_3_inverse = inverse(p_3, false);
        let diff_3 = int128::unsigned_subtract(p_3_inverse, p_neg_3);
        if (!int128::is_zero(diff_3)) {
            std::debug::print(&3);
            std::debug::print(&p_neg_3);
            std::debug::print(&p_3_inverse);
            std::debug::print(&diff_3);
        };
        let diff_3 = int128::abs(diff_3);
        assert!(diff_3 <= 1, (diff_3 as u64)); // positive index inverse

        let p_neg_3_inverse = inverse(p_neg_3, false);
        let diff_3 = int128::unsigned_subtract(p_neg_3_inverse, p_3);
        if (!int128::is_zero(diff_3)) {
            std::debug::print(&3);
            std::debug::print(&p_3);
            std::debug::print(&p_neg_3_inverse);
            std::debug::print(&diff_3);
        };
        let diff_3 = int128::abs(diff_3);
        assert!(diff_3 <= 1, (diff_3 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_4 = get_square_price_from_2_n_positive(4);
        let p_neg_4 = get_square_price_from_2_n_negative(4);
        let p_4_inverse = inverse(p_4, false);
        let diff_4 = int128::unsigned_subtract(p_4_inverse, p_neg_4);
        if (!int128::is_zero(diff_4)) {
            std::debug::print(&4);
            std::debug::print(&p_neg_4);
            std::debug::print(&p_4_inverse);
            std::debug::print(&diff_4);
        };
        let diff_4 = int128::abs(diff_4);
        assert!(diff_4 <= 1, (diff_4 as u64)); // positive index inverse

        let p_neg_4_inverse = inverse(p_neg_4, false);
        let diff_4 = int128::unsigned_subtract(p_neg_4_inverse, p_4);
        if (!int128::is_zero(diff_4)) {
            std::debug::print(&4);
            std::debug::print(&p_4);
            std::debug::print(&p_neg_4_inverse);
            std::debug::print(&diff_4);
        };
        let diff_4 = int128::abs(diff_4);
        assert!(diff_4 <= 1, (diff_4 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_5 = get_square_price_from_2_n_positive(5);
        let p_neg_5 = get_square_price_from_2_n_negative(5);
        let p_5_inverse = inverse(p_5, false);
        let diff_5 = int128::unsigned_subtract(p_5_inverse, p_neg_5);
        if (!int128::is_zero(diff_5)) {
            std::debug::print(&5);
            std::debug::print(&p_neg_5);
            std::debug::print(&p_5_inverse);
            std::debug::print(&diff_5);
        };
        let diff_5 = int128::abs(diff_5);
        assert!(diff_5 <= 1, (diff_5 as u64)); // positive index inverse

        let p_neg_5_inverse = inverse(p_neg_5, false);
        let diff_5 = int128::unsigned_subtract(p_neg_5_inverse, p_5);
        if (!int128::is_zero(diff_5)) {
            std::debug::print(&5);
            std::debug::print(&p_5);
            std::debug::print(&p_neg_5_inverse);
            std::debug::print(&diff_5);
        };
        let diff_5 = int128::abs(diff_5);
        assert!(diff_5 <= 1, (diff_5 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_6 = get_square_price_from_2_n_positive(6);
        let p_neg_6 = get_square_price_from_2_n_negative(6);
        let p_6_inverse = inverse(p_6, false);
        let diff_6 = int128::unsigned_subtract(p_6_inverse, p_neg_6);
        if (!int128::is_zero(diff_6)) {
            std::debug::print(&6);
            std::debug::print(&p_neg_6);
            std::debug::print(&p_6_inverse);
            std::debug::print(&diff_6);
        };
        let diff_6 = int128::abs(diff_6);
        assert!(diff_6 <= 1, (diff_6 as u64)); // positive index inverse

        let p_neg_6_inverse = inverse(p_neg_6, false);
        let diff_6 = int128::unsigned_subtract(p_neg_6_inverse, p_6);
        if (!int128::is_zero(diff_6)) {
            std::debug::print(&6);
            std::debug::print(&p_6);
            std::debug::print(&p_neg_6_inverse);
            std::debug::print(&diff_6);
        };
        let diff_6 = int128::abs(diff_6);
        assert!(diff_6 <= 1, (diff_6 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_7 = get_square_price_from_2_n_positive(7);
        let p_neg_7 = get_square_price_from_2_n_negative(7);
        let p_7_inverse = inverse(p_7, false);
        let diff_7 = int128::unsigned_subtract(p_7_inverse, p_neg_7);
        if (!int128::is_zero(diff_7)) {
            std::debug::print(&7);
            std::debug::print(&p_neg_7);
            std::debug::print(&p_7_inverse);
            std::debug::print(&diff_7);
        };
        let diff_7 = int128::abs(diff_7);
        assert!(diff_7 <= 1, (diff_7 as u64)); // positive index inverse

        let p_neg_7_inverse = inverse(p_neg_7, false);
        let diff_7 = int128::unsigned_subtract(p_neg_7_inverse, p_7);
        if (!int128::is_zero(diff_7)) {
            std::debug::print(&7);
            std::debug::print(&p_7);
            std::debug::print(&p_neg_7_inverse);
            std::debug::print(&diff_7);
        };
        let diff_7 = int128::abs(diff_7);
        assert!(diff_7 <= 1, (diff_7 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_8 = get_square_price_from_2_n_positive(8);
        let p_neg_8 = get_square_price_from_2_n_negative(8);
        let p_8_inverse = inverse(p_8, false);
        let diff_8 = int128::unsigned_subtract(p_8_inverse, p_neg_8);
        if (!int128::is_zero(diff_8)) {
            std::debug::print(&8);
            std::debug::print(&p_neg_8);
            std::debug::print(&p_8_inverse);
            std::debug::print(&diff_8);
        };
        let diff_8 = int128::abs(diff_8);
        assert!(diff_8 <= 1, (diff_8 as u64)); // positive index inverse

        let p_neg_8_inverse = inverse(p_neg_8, false);
        let diff_8 = int128::unsigned_subtract(p_neg_8_inverse, p_8);
        if (!int128::is_zero(diff_8)) {
            std::debug::print(&8);
            std::debug::print(&p_8);
            std::debug::print(&p_neg_8_inverse);
            std::debug::print(&diff_8);
        };
        let diff_8 = int128::abs(diff_8);
        assert!(diff_8 <= 1, (diff_8 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_9 = get_square_price_from_2_n_positive(9);
        let p_neg_9 = get_square_price_from_2_n_negative(9);
        let p_9_inverse = inverse(p_9, false);
        let diff_9 = int128::unsigned_subtract(p_9_inverse, p_neg_9);
        if (!int128::is_zero(diff_9)) {
            std::debug::print(&9);
            std::debug::print(&p_neg_9);
            std::debug::print(&p_9_inverse);
            std::debug::print(&diff_9);
        };
        let diff_9 = int128::abs(diff_9);
        assert!(diff_9 <= 1, (diff_9 as u64)); // positive index inverse

        let p_neg_9_inverse = inverse(p_neg_9, false);
        let diff_9 = int128::unsigned_subtract(p_neg_9_inverse, p_9);
        if (!int128::is_zero(diff_9)) {
            std::debug::print(&9);
            std::debug::print(&p_9);
            std::debug::print(&p_neg_9_inverse);
            std::debug::print(&diff_9);
        };
        let diff_9 = int128::abs(diff_9);
        assert!(diff_9 <= 1, (diff_9 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_10 = get_square_price_from_2_n_positive(10);
        let p_neg_10 = get_square_price_from_2_n_negative(10);
        let p_10_inverse = inverse(p_10, false);
        let diff_10 = int128::unsigned_subtract(p_10_inverse, p_neg_10);
        if (!int128::is_zero(diff_10)) {
            std::debug::print(&10);
            std::debug::print(&p_neg_10);
            std::debug::print(&p_10_inverse);
            std::debug::print(&diff_10);
        };
        let diff_10 = int128::abs(diff_10);
        assert!(diff_10 <= 1, (diff_10 as u64)); // positive index inverse

        let p_neg_10_inverse = inverse(p_neg_10, false);
        let diff_10 = int128::unsigned_subtract(p_neg_10_inverse, p_10);
        if (!int128::is_zero(diff_10)) {
            std::debug::print(&10);
            std::debug::print(&p_10);
            std::debug::print(&p_neg_10_inverse);
            std::debug::print(&diff_10);
        };
        let diff_10 = int128::abs(diff_10);
        assert!(diff_10 <= 1, (diff_10 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_11 = get_square_price_from_2_n_positive(11);
        let p_neg_11 = get_square_price_from_2_n_negative(11);
        let p_11_inverse = inverse(p_11, false);
        let diff_11 = int128::unsigned_subtract(p_11_inverse, p_neg_11);
        if (!int128::is_zero(diff_11)) {
            std::debug::print(&11);
            std::debug::print(&p_neg_11);
            std::debug::print(&p_11_inverse);
            std::debug::print(&diff_11);
        };
        let diff_11 = int128::abs(diff_11);
        assert!(diff_11 <= 1, (diff_11 as u64)); // positive index inverse

        let p_neg_11_inverse = inverse(p_neg_11, false);
        let diff_11 = int128::unsigned_subtract(p_neg_11_inverse, p_11);
        if (!int128::is_zero(diff_11)) {
            std::debug::print(&11);
            std::debug::print(&p_11);
            std::debug::print(&p_neg_11_inverse);
            std::debug::print(&diff_11);
        };
        let diff_11 = int128::abs(diff_11);
        assert!(diff_11 <= 1, (diff_11 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_12 = get_square_price_from_2_n_positive(12);
        let p_neg_12 = get_square_price_from_2_n_negative(12);
        let p_12_inverse = inverse(p_12, false);
        let diff_12 = int128::unsigned_subtract(p_12_inverse, p_neg_12);
        if (!int128::is_zero(diff_12)) {
            std::debug::print(&12);
            std::debug::print(&p_neg_12);
            std::debug::print(&p_12_inverse);
            std::debug::print(&diff_12);
        };
        let diff_12 = int128::abs(diff_12);
        assert!(diff_12 <= 1, (diff_12 as u64)); // positive index inverse

        let p_neg_12_inverse = inverse(p_neg_12, false);
        let diff_12 = int128::unsigned_subtract(p_neg_12_inverse, p_12);
        if (!int128::is_zero(diff_12)) {
            std::debug::print(&12);
            std::debug::print(&p_12);
            std::debug::print(&p_neg_12_inverse);
            std::debug::print(&diff_12);
        };
        let diff_12 = int128::abs(diff_12);
        assert!(diff_12 <= 1, (diff_12 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_13 = get_square_price_from_2_n_positive(13);
        let p_neg_13 = get_square_price_from_2_n_negative(13);
        let p_13_inverse = inverse(p_13, false);
        let diff_13 = int128::unsigned_subtract(p_13_inverse, p_neg_13);
        if (!int128::is_zero(diff_13)) {
            std::debug::print(&13);
            std::debug::print(&p_neg_13);
            std::debug::print(&p_13_inverse);
            std::debug::print(&diff_13);
        };
        let diff_13 = int128::abs(diff_13);
        assert!(diff_13 <= 1, (diff_13 as u64)); // positive index inverse

        let p_neg_13_inverse = inverse(p_neg_13, false);
        let diff_13 = int128::unsigned_subtract(p_neg_13_inverse, p_13);
        if (!int128::is_zero(diff_13)) {
            std::debug::print(&13);
            std::debug::print(&p_13);
            std::debug::print(&p_neg_13_inverse);
            std::debug::print(&diff_13);
        };
        let diff_13 = int128::abs(diff_13);
        assert!(diff_13 <= 1, (diff_13 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_14 = get_square_price_from_2_n_positive(14);
        let p_neg_14 = get_square_price_from_2_n_negative(14);
        let p_14_inverse = inverse(p_14, false);
        let diff_14 = int128::unsigned_subtract(p_14_inverse, p_neg_14);
        if (!int128::is_zero(diff_14)) {
            std::debug::print(&14);
            std::debug::print(&p_neg_14);
            std::debug::print(&p_14_inverse);
            std::debug::print(&diff_14);
        };
        let diff_14 = int128::abs(diff_14);
        assert!(diff_14 <= 1, (diff_14 as u64)); // positive index inverse

        let p_neg_14_inverse = inverse(p_neg_14, false);
        let diff_14 = int128::unsigned_subtract(p_neg_14_inverse, p_14);
        if (!int128::is_zero(diff_14)) {
            std::debug::print(&14);
            std::debug::print(&p_14);
            std::debug::print(&p_neg_14_inverse);
            std::debug::print(&diff_14);
        };
        let diff_14 = int128::abs(diff_14);
        assert!(diff_14 <= 1, (diff_14 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_15 = get_square_price_from_2_n_positive(15);
        let p_neg_15 = get_square_price_from_2_n_negative(15);
        let p_15_inverse = inverse(p_15, false);
        let diff_15 = int128::unsigned_subtract(p_15_inverse, p_neg_15);
        if (!int128::is_zero(diff_15)) {
            std::debug::print(&15);
            std::debug::print(&p_neg_15);
            std::debug::print(&p_15_inverse);
            std::debug::print(&diff_15);
        };
        let diff_15 = int128::abs(diff_15);
        assert!(diff_15 <= 1, (diff_15 as u64)); // positive index inverse

        let p_neg_15_inverse = inverse(p_neg_15, false);
        let diff_15 = int128::unsigned_subtract(p_neg_15_inverse, p_15);
        if (!int128::is_zero(diff_15)) {
            std::debug::print(&15);
            std::debug::print(&p_15);
            std::debug::print(&p_neg_15_inverse);
            std::debug::print(&diff_15);
        };
        let diff_15 = int128::abs(diff_15);
        assert!(diff_15 <= 1, (diff_15 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_16 = get_square_price_from_2_n_positive(16);
        let p_neg_16 = get_square_price_from_2_n_negative(16);
        let p_16_inverse = inverse(p_16, false);
        let diff_16 = int128::unsigned_subtract(p_16_inverse, p_neg_16);
        if (!int128::is_zero(diff_16)) {
            std::debug::print(&16);
            std::debug::print(&p_neg_16);
            std::debug::print(&p_16_inverse);
            std::debug::print(&diff_16);
        };
        let diff_16 = int128::abs(diff_16);
        assert!(diff_16 <= 1, (diff_16 as u64)); // positive index inverse

        let p_neg_16_inverse = inverse(p_neg_16, false);
        let diff_16 = int128::unsigned_subtract(p_neg_16_inverse, p_16);
        if (!int128::is_zero(diff_16)) {
            std::debug::print(&16);
            std::debug::print(&p_16);
            std::debug::print(&p_neg_16_inverse);
            std::debug::print(&diff_16);
        };
        let diff_16 = int128::abs(diff_16);
        assert!(diff_16 <= 1, (diff_16 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_17 = get_square_price_from_2_n_positive(17);
        let p_neg_17 = get_square_price_from_2_n_negative(17);
        let p_17_inverse = inverse(p_17, false);
        let diff_17 = int128::unsigned_subtract(p_17_inverse, p_neg_17);
        if (!int128::is_zero(diff_17)) {
            std::debug::print(&17);
            std::debug::print(&p_neg_17);
            std::debug::print(&p_17_inverse);
            std::debug::print(&diff_17);
        };
        let diff_17 = int128::abs(diff_17);
        assert!(diff_17 <= 1, (diff_17 as u64)); // positive index inverse

        let p_neg_17_inverse = inverse(p_neg_17, false);
        let diff_17 = int128::unsigned_subtract(p_neg_17_inverse, p_17);
        if (!int128::is_zero(diff_17)) {
            std::debug::print(&17);
            std::debug::print(&p_17);
            std::debug::print(&p_neg_17_inverse);
            std::debug::print(&diff_17);
        };
        let diff_17 = int128::abs(diff_17);
        assert!(diff_17 <= 1, (diff_17 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_18 = get_square_price_from_2_n_positive(18);
        let p_neg_18 = get_square_price_from_2_n_negative(18);
        let p_18_inverse = inverse(p_18, false);
        let diff_18 = int128::unsigned_subtract(p_18_inverse, p_neg_18);
        if (!int128::is_zero(diff_18)) {
            std::debug::print(&18);
            std::debug::print(&p_neg_18);
            std::debug::print(&p_18_inverse);
            std::debug::print(&diff_18);
        };
        let diff_18 = int128::abs(diff_18);
        assert!(diff_18 <= 1, (diff_18 as u64)); // positive index inverse

        let p_neg_18_inverse = inverse(p_neg_18, false);
        let diff_18 = int128::unsigned_subtract(p_neg_18_inverse, p_18);
        if (!int128::is_zero(diff_18)) {
            std::debug::print(&18);
            std::debug::print(&p_18);
            std::debug::print(&p_neg_18_inverse);
            std::debug::print(&diff_18);
        };
        let diff_18 = int128::abs(diff_18);
        assert!(diff_18 <= 1, (diff_18 as u64)); // negative index inverse
    }
}
